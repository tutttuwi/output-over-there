<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>Spring徹底入門 | OUTPUT*OVER-THERE</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#264A2E">
    
    
    <meta name="keywords" content="教科書">
    <meta name="description" content="Spring徹底入門 目次  第1章　Spring Frameworkとは 第2章　Spring Core（DI×AOP） 第3章　データアクセス（Tx、JDBC） 第4章　Spring MVC 第5章　Webアプリケーションの開発 第6章　RESTful Webサービスの開発 第7章　Spring MVC の応用 第8章　Spring Test 第9章　Spring Security 第10章">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring徹底入門">
<meta property="og:url" content="http://yoursite.com/JAVA/2020-05_Spring%E5%BE%B9%E5%BA%95%E5%85%A5%E9%96%80/index.html">
<meta property="og:site_name" content="OUTPUT*OVER-THERE">
<meta property="og:description" content="Spring徹底入門 目次  第1章　Spring Frameworkとは 第2章　Spring Core（DI×AOP） 第3章　データアクセス（Tx、JDBC） 第4章　Spring MVC 第5章　Webアプリケーションの開発 第6章　RESTful Webサービスの開発 第7章　Spring MVC の応用 第8章　Spring Test 第9章　Spring Security 第10章">
<meta property="og:locale" content="ja_JP">
<meta property="article:published_time" content="2020-04-30T15:00:00.000Z">
<meta property="article:modified_time" content="2020-05-29T16:24:02.674Z">
<meta property="article:author" content="t-tsutsui">
<meta property="article:tag" content="教科書">
<meta name="twitter:card" content="summary">
    
        <link rel="alternate" type="application/atom+xml" title="OUTPUT*OVER-THERE" href="https://tutttuwi.github.io/output-over-there/atom.xml">
    
    <link rel="shortcut icon" href="https://tutttuwi.github.io/output-over-there/favicon.ico">
    <link rel="stylesheet" href="https://tutttuwi.github.io/output-over-there/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(https://tutttuwi.github.io/output-over-there/img/brand.png)">
      <div class="brand">
        <a href="https://tutttuwi.github.io/output-over-there/" target="_blank" rel="noopener" class="avatar waves-effect waves-circle waves-light">
          <img src="https://tutttuwi.github.io/output-over-there/img/avatar.png">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">t-tsutsui</h5>
          <a href="mailto:t.tsutsui9117@gmail.com" title="t.tsutsui9117@gmail.com" class="mail">t.tsutsui9117@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="https://tutttuwi.github.io/output-over-there/" target="_blank" rel="noopener"  >
                <i class="icon icon-lg icon-home"></i>
                Home
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://tutttuwi.github.io/output-over-there/about" target="_blank" rel="noopener"  >
                <i class="icon icon-lg icon-link"></i>
                About
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://tutttuwi.github.io/output-over-there/archives" target="_blank" rel="noopener"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://tutttuwi.github.io/output-over-there/tags" target="_blank" rel="noopener"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://tutttuwi.github.io/output-over-there/categories" target="_blank" rel="noopener"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Spring徹底入門</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="検索">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Spring徹底入門</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-04-30T15:00:00.000Z" itemprop="datePublished" class="page-time">
  2020-05-01
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="https://tutttuwi.github.io/output-over-there/categories/JAVA/" target="_blank" rel="noopener">JAVA</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Spring徹底入門"><span class="post-toc-number">1.</span> <span class="post-toc-text">Spring徹底入門</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#第1章-Spring-Frameworkとは"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">第1章　Spring Frameworkとは</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#第2章-Spring-Core（DI×AOP）"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">第2章　Spring Core（DI×AOP）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-1-6-コンポーネントスキャン"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">2.1.6 コンポーネントスキャン</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-1-7-Beanのスコープ"><span class="post-toc-number">1.2.2.</span> <span class="post-toc-text">2.1.7 Beanのスコープ</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-1-8-Beanのライフサイクル"><span class="post-toc-number">1.2.3.</span> <span class="post-toc-text">2.1.8 Beanのライフサイクル</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-1-9-Configurationの分割"><span class="post-toc-number">1.2.4.</span> <span class="post-toc-text">2.1.9 Configurationの分割</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-1-10-Configurationのプロファイル化"><span class="post-toc-number">1.2.5.</span> <span class="post-toc-text">2.1.10 Configurationのプロファイル化</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-1-11-JSR-330-Dependency-Injection-for-Java"><span class="post-toc-number">1.2.6.</span> <span class="post-toc-text">2.1.11 JSR 330: Dependency Injection for Java</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-2-AOP"><span class="post-toc-number">1.2.7.</span> <span class="post-toc-text">2.2 AOP</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-2-1-AOPの概要"><span class="post-toc-number">1.2.8.</span> <span class="post-toc-text">2.2.1 AOPの概要</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-2-2-Spring-AOP"><span class="post-toc-number">1.2.9.</span> <span class="post-toc-text">2.2.2 Spring AOP</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-2-3-Adviceの実装方法"><span class="post-toc-number">1.2.10.</span> <span class="post-toc-text">2.2.3 Adviceの実装方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-2-4-XMLでAdviceの実装"><span class="post-toc-number">1.2.11.</span> <span class="post-toc-text">2.2.4 XMLでAdviceの実装</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-2-5-Pointcut式"><span class="post-toc-number">1.2.12.</span> <span class="post-toc-text">2.2.5 Pointcut式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-2-6-Springプロジェクトで利用されているAOP"><span class="post-toc-number">1.2.13.</span> <span class="post-toc-text">2.2.6 Springプロジェクトで利用されているAOP</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-3-データバインディングと型変換"><span class="post-toc-number">1.2.14.</span> <span class="post-toc-text">2.3 データバインディングと型変換</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-3-1-Springのデータバインディング"><span class="post-toc-number">1.2.15.</span> <span class="post-toc-text">2.3.1 Springのデータバインディング</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-3-2-Springの型変換"><span class="post-toc-number">1.2.16.</span> <span class="post-toc-text">2.3.2 Springの型変換</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-4-プロパティ管理"><span class="post-toc-number">1.2.17.</span> <span class="post-toc-text">2.4 プロパティ管理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-5-Spring-Expression-Language-SpEL"><span class="post-toc-number">1.2.18.</span> <span class="post-toc-text">2.5 Spring Expression Language(SpEL)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-5-1-SpELのセットアップ"><span class="post-toc-number">1.2.19.</span> <span class="post-toc-text">2.5.1 SpELのセットアップ</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-5-2-SpEl-APIの利用"><span class="post-toc-number">1.2.20.</span> <span class="post-toc-text">2.5.2 SpEl APIの利用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-5-3-Bean定義でのSpELの利用"><span class="post-toc-number">1.2.21.</span> <span class="post-toc-text">2.5.3 Bean定義でのSpELの利用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-5-4-SpELで使用可能な式の表現"><span class="post-toc-number">1.2.22.</span> <span class="post-toc-text">2.5.4 SpELで使用可能な式の表現</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-6-リソースの抽象化"><span class="post-toc-number">1.2.23.</span> <span class="post-toc-text">2.6 リソースの抽象化</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-6-1-Resourceインターフェースと実装クラス"><span class="post-toc-number">1.2.24.</span> <span class="post-toc-text">2.6.1 Resourceインターフェースと実装クラス</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-6-2-ResourceLoaderインターフェース"><span class="post-toc-number">1.2.25.</span> <span class="post-toc-text">2.6.2 ResourceLoaderインターフェース</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-6-3-Resourceインターフェースを利用したリソースアクセス"><span class="post-toc-number">1.2.26.</span> <span class="post-toc-text">2.6.3 Resourceインターフェースを利用したリソースアクセス</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-6-4-XMLファイル上でのリソースの指定"><span class="post-toc-number">1.2.27.</span> <span class="post-toc-text">2.6.4 XMLファイル上でのリソースの指定</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-7-メッセージ管理"><span class="post-toc-number">1.2.28.</span> <span class="post-toc-text">2.7 メッセージ管理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-7-1-MessageSourceインターフェースと実装クラス"><span class="post-toc-number">1.2.29.</span> <span class="post-toc-text">2.7.1 MessageSourceインターフェースと実装クラス</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-7-2-MessageSourceの利用"><span class="post-toc-number">1.2.30.</span> <span class="post-toc-text">2.7.2 MessageSourceの利用</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#第3章-データアクセス（Tx、JDBC）"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">第3章　データアクセス（Tx、JDBC）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-1-Springによるデータアクセス"><span class="post-toc-number">1.3.1.</span> <span class="post-toc-text">3.1 Springによるデータアクセス</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-1-1-データソースについて"><span class="post-toc-number">1.3.2.</span> <span class="post-toc-text">3.1.1 データソースについて</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-1-2-データソースのコンフィギュレーション"><span class="post-toc-number">1.3.3.</span> <span class="post-toc-text">3.1.2 データソースのコンフィギュレーション</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-2-Spring-JDBC"><span class="post-toc-number">1.3.4.</span> <span class="post-toc-text">3.2 Spring JDBC</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-2-1-Spring-JDBCとは"><span class="post-toc-number">1.3.5.</span> <span class="post-toc-text">3.2.1 Spring JDBCとは</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-2-2-JdbcTempleteクラスを利用したCRUD操作"><span class="post-toc-number">1.3.6.</span> <span class="post-toc-text">3.2.2 JdbcTempleteクラスを利用したCRUD操作</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-2-3-取得結果の変換処理"><span class="post-toc-number">1.3.7.</span> <span class="post-toc-text">3.2.3 取得結果の変換処理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-2-4-応用的なCRUD操作"><span class="post-toc-number">1.3.8.</span> <span class="post-toc-text">3.2.4 応用的なCRUD操作</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-3-トランザクション管理"><span class="post-toc-number">1.3.9.</span> <span class="post-toc-text">3.3 トランザクション管理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-3-1-トランザクションマネージャ"><span class="post-toc-number">1.3.10.</span> <span class="post-toc-text">3.3.1 トランザクションマネージャ</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-3-2-宣言的トランザクション"><span class="post-toc-number">1.3.11.</span> <span class="post-toc-text">3.3.2 宣言的トランザクション</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-3-3-明示的トランザクション"><span class="post-toc-number">1.3.12.</span> <span class="post-toc-text">3.3.3 明示的トランザクション</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-3-4-トランザクションの分離レベルと伝播レベル"><span class="post-toc-number">1.3.13.</span> <span class="post-toc-text">3.3.4 トランザクションの分離レベルと伝播レベル</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-4-データアクセスエラーのハンドリング"><span class="post-toc-number">1.3.14.</span> <span class="post-toc-text">3.4 データアクセスエラーのハンドリング</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-4-1-Springが提供するデータアクセス例外"><span class="post-toc-number">1.3.15.</span> <span class="post-toc-text">3.4.1 Springが提供するデータアクセス例外</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-4-2-データアクセス例外のハンドリング"><span class="post-toc-number">1.3.16.</span> <span class="post-toc-text">3.4.2 データアクセス例外のハンドリング</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-4-3-データアクセス例外の変換ルールのカスタマイズ"><span class="post-toc-number">1.3.17.</span> <span class="post-toc-text">3.4.3 データアクセス例外の変換ルールのカスタマイズ</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#第4章-Spring-MVC"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">第4章　Spring MVC</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-1-Spring-MVC-とは"><span class="post-toc-number">1.4.1.</span> <span class="post-toc-text">4.1 Spring MVC とは</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-1-1-Webアプリケーション開発における特徴"><span class="post-toc-number">1.4.2.</span> <span class="post-toc-text">4.1.1 Webアプリケーション開発における特徴</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-1-2-MVCフレームワークとしての特徴"><span class="post-toc-number">1.4.3.</span> <span class="post-toc-text">4.1.2 MVCフレームワークとしての特徴</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-2-はじめてのSpring-MVCアプリケーション"><span class="post-toc-number">1.4.4.</span> <span class="post-toc-text">4.2 はじめてのSpring MVCアプリケーション</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-2-1-開発プロジェクトの作成"><span class="post-toc-number">1.4.5.</span> <span class="post-toc-text">4.2.1 開発プロジェクトの作成</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-2-2-Spring-MVCの適用"><span class="post-toc-number">1.4.6.</span> <span class="post-toc-text">4.2.2 Spring MVCの適用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-2-3-トップ画面表示処理の実装"><span class="post-toc-number">1.4.7.</span> <span class="post-toc-text">4.2.3 トップ画面表示処理の実装</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-2-4-入力画面表示処理の実装"><span class="post-toc-number">1.4.8.</span> <span class="post-toc-text">4.2.4 入力画面表示処理の実装</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-2-5-送信処理の実装"><span class="post-toc-number">1.4.9.</span> <span class="post-toc-text">4.2.5 送信処理の実装</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-2-6-入力チェック処理の実装"><span class="post-toc-number">1.4.10.</span> <span class="post-toc-text">4.2.6 入力チェック処理の実装</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-2-7-XMLファイルを使用したBean定義"><span class="post-toc-number">1.4.11.</span> <span class="post-toc-text">4.2.7 XMLファイルを使用したBean定義</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-3-Spring-MVCのアーキテクチャ"><span class="post-toc-number">1.4.12.</span> <span class="post-toc-text">4.3 Spring MVCのアーキテクチャ</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-3-1-フレームワークのアーキテクチャ"><span class="post-toc-number">1.4.13.</span> <span class="post-toc-text">4.3.1 フレームワークのアーキテクチャ</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#第5章-Webアプリケーションの開発"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">第5章　Webアプリケーションの開発</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-1-Webアプリケーションの種類"><span class="post-toc-number">1.5.1.</span> <span class="post-toc-text">5.1 Webアプリケーションの種類</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-3-5-Handlerメソッドの戻り値"><span class="post-toc-number">1.5.1.1.</span> <span class="post-toc-text">5.3.5 Handlerメソッドの戻り値</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-3-6-View-Controllerの利用"><span class="post-toc-number">1.5.1.2.</span> <span class="post-toc-text">5.3.6 View Controllerの利用</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-4-リクエストマッピング"><span class="post-toc-number">1.5.2.</span> <span class="post-toc-text">5.4 リクエストマッピング</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-5-リクエストデータの取得"><span class="post-toc-number">1.5.3.</span> <span class="post-toc-text">5.5 リクエストデータの取得</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-5-4-コンパイルオプションの注意点"><span class="post-toc-number">1.5.3.1.</span> <span class="post-toc-text">5.5.4 コンパイルオプションの注意点</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-5-7-アノテーションを使用したフォーマットの指定"><span class="post-toc-number">1.5.3.2.</span> <span class="post-toc-text">5.5.7 アノテーションを使用したフォーマットの指定</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-6-フォームクラスの実装"><span class="post-toc-number">1.5.4.</span> <span class="post-toc-text">5.6 フォームクラスの実装</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-6-1-フォームオブジェクトのスコープ"><span class="post-toc-number">1.5.4.1.</span> <span class="post-toc-text">5.6.1 フォームオブジェクトのスコープ</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-6-2-フォームクラスの作成"><span class="post-toc-number">1.5.4.2.</span> <span class="post-toc-text">5.6.2 フォームクラスの作成</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-7-入力チェック"><span class="post-toc-number">1.5.5.</span> <span class="post-toc-text">5.7 入力チェック</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-7-1-入力チェックの有効化"><span class="post-toc-number">1.5.5.1.</span> <span class="post-toc-text">5.7.1 入力チェックの有効化</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-7-2-入力チェック結果の判定"><span class="post-toc-number">1.5.5.2.</span> <span class="post-toc-text">5.7.2 入力チェック結果の判定</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-7-3-未入力の扱い"><span class="post-toc-number">1.5.5.3.</span> <span class="post-toc-text">5.7.3 未入力の扱い</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-7-5-ネスト下JavaBeansの入力チェック"><span class="post-toc-number">1.5.5.4.</span> <span class="post-toc-text">5.7.5 ネスト下JavaBeansの入力チェック</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-7-6-入力チェックルールの追加"><span class="post-toc-number">1.5.5.5.</span> <span class="post-toc-text">5.7.6 入力チェックルールの追加</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-7-7-入力チェックツールの切り替え"><span class="post-toc-number">1.5.5.6.</span> <span class="post-toc-text">5.7.7 入力チェックツールの切り替え</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-7-8-エラー情報の表示"><span class="post-toc-number">1.5.5.7.</span> <span class="post-toc-text">5.7.8 エラー情報の表示</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-7-9-エラーメッセージの解決"><span class="post-toc-number">1.5.5.8.</span> <span class="post-toc-text">5.7.9 エラーメッセージの解決</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-7-10-BeanValidationのカスタマイズ"><span class="post-toc-number">1.5.5.9.</span> <span class="post-toc-text">5.7.10 BeanValidationのカスタマイズ</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-7-11-Spring-Validatorの利用"><span class="post-toc-number">1.5.5.10.</span> <span class="post-toc-text">5.7.11 Spring Validatorの利用</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-8-画面遷移"><span class="post-toc-number">1.5.6.</span> <span class="post-toc-text">5.8 画面遷移</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-8-1-遷移先の指定方法"><span class="post-toc-number">1.5.6.1.</span> <span class="post-toc-text">5.8.1 遷移先の指定方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-8-2-リクエストパスへのリダイレクト"><span class="post-toc-number">1.5.6.2.</span> <span class="post-toc-text">5.8.2 リクエストパスへのリダイレクト</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-8-3-リクエストパスへのフォワード"><span class="post-toc-number">1.5.6.3.</span> <span class="post-toc-text">5.8.3 リクエストパスへのフォワード</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-8-4-Viewとのデータ連携"><span class="post-toc-number">1.5.6.4.</span> <span class="post-toc-text">5.8.4 Viewとのデータ連携</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-8-5-リダイレクト先とのデータ連携"><span class="post-toc-number">1.5.6.5.</span> <span class="post-toc-text">5.8.5 リダイレクト先とのデータ連携</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-9-Viewの解決"><span class="post-toc-number">1.5.7.</span> <span class="post-toc-text">5.9 Viewの解決</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-10-JSPの実装"><span class="post-toc-number">1.5.8.</span> <span class="post-toc-text">5.10 JSPの実装</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-11-SpringのHTMLフォーム用タグライブラリの利用"><span class="post-toc-number">1.5.9.</span> <span class="post-toc-text">5.11 SpringのHTMLフォーム用タグライブラリの利用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-12-Springの汎用タグライブラリの利用"><span class="post-toc-number">1.5.10.</span> <span class="post-toc-text">5.12 Springの汎用タグライブラリの利用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-13-例外ハンドリング"><span class="post-toc-number">1.5.11.</span> <span class="post-toc-text">5.13 例外ハンドリング</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-13-1-例外の種類"><span class="post-toc-number">1.5.11.1.</span> <span class="post-toc-text">5.13.1 例外の種類</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-13-2-例外の発生箇所とハンドリング方法"><span class="post-toc-number">1.5.11.2.</span> <span class="post-toc-text">5.13.2 例外の発生箇所とハンドリング方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-13-3-サーブレットコンテナのエラーページ機能を利用"><span class="post-toc-number">1.5.11.3.</span> <span class="post-toc-text">5.13.3 サーブレットコンテナのエラーページ機能を利用</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-13-5-ExceprtionHandlerメソッドの利用"><span class="post-toc-number">1.5.11.4.</span> <span class="post-toc-text">5.13.5 @ExceprtionHandlerメソッドの利用</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-13-6-ResponseStatusを指定した例外クラスの利用"><span class="post-toc-number">1.5.11.5.</span> <span class="post-toc-text">5.13.6 @ResponseStatusを指定した例外クラスの利用</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#第6章-RESTful-Webサービスの開発"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">第6章　RESTful Webサービスの開発</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-1-REST-APIのアーキテクチャ"><span class="post-toc-number">1.6.1.</span> <span class="post-toc-text">6.1 REST APIのアーキテクチャ</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#6-1-1-Resouce-Oriented-Architecture-ROA"><span class="post-toc-number">1.6.1.1.</span> <span class="post-toc-text">6.1.1 Resouce Oriented Architecture (ROA)</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#6-1-2-フレームワークのアーキテクチャ"><span class="post-toc-number">1.6.1.2.</span> <span class="post-toc-text">6.1.2 フレームワークのアーキテクチャ</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-2-アプリケーションの設定"><span class="post-toc-number">1.6.2.</span> <span class="post-toc-text">6.2 アプリケーションの設定</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#6-2-1-ライブラリのセットアップ"><span class="post-toc-number">1.6.2.1.</span> <span class="post-toc-text">6.2.1 ライブラリのセットアップ</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#6-2-2-サーブレットコンテナの設定"><span class="post-toc-number">1.6.2.2.</span> <span class="post-toc-text">6.2.2 サーブレットコンテナの設定</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-3-RestControllerの実装"><span class="post-toc-number">1.6.3.</span> <span class="post-toc-text">6.3 @RestControllerの実装</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#第7章-Spring-MVC-の応用"><span class="post-toc-number">1.7.</span> <span class="post-toc-text">第7章　Spring MVC の応用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-1-HTTPセッションの利用"><span class="post-toc-number">1.7.1.</span> <span class="post-toc-text">7.1 HTTPセッションの利用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7-1-1-セッション属性（-SessionAttributes）"><span class="post-toc-number">1.7.1.1.</span> <span class="post-toc-text">7.1.1 セッション属性（@SessionAttributes）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7-1-2-セッションスコープBean"><span class="post-toc-number">1.7.1.2.</span> <span class="post-toc-text">7.1.2 セッションスコープBean</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-2-ファイルアップロード"><span class="post-toc-number">1.7.2.</span> <span class="post-toc-text">7.2 ファイルアップロード</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7-2-2-ファイルアップロード機能のセットアップ"><span class="post-toc-number">1.7.2.1.</span> <span class="post-toc-text">7.2.2 ファイルアップロード機能のセットアップ</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7-2-3-アップロードデータの取得"><span class="post-toc-number">1.7.2.2.</span> <span class="post-toc-text">7.2.3 アップロードデータの取得</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-3-非同期リクエスト"><span class="post-toc-number">1.7.3.</span> <span class="post-toc-text">7.3 非同期リクエスト</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7-3-1-非同期リクエストの仕組み"><span class="post-toc-number">1.7.3.1.</span> <span class="post-toc-text">7.3.1 非同期リクエストの仕組み</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7-3-2-非同期実行を有効にするための設定"><span class="post-toc-number">1.7.3.2.</span> <span class="post-toc-text">7.3.2 非同期実行を有効にするための設定</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7-3-3-非同期処理の実装"><span class="post-toc-number">1.7.3.3.</span> <span class="post-toc-text">7.3.3 非同期処理の実装</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7-3-4-非同期実行の例外ハンドリング"><span class="post-toc-number">1.7.3.4.</span> <span class="post-toc-text">7.3.4 非同期実行の例外ハンドリング</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7-3-5-非同期実行に対する共通処理の実装"><span class="post-toc-number">1.7.3.5.</span> <span class="post-toc-text">7.3.5 非同期実行に対する共通処理の実装</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-4-共通処理の実装"><span class="post-toc-number">1.7.4.</span> <span class="post-toc-text">7.4 共通処理の実装</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7-4-1-サーブレットフィルタの利用"><span class="post-toc-number">1.7.4.1.</span> <span class="post-toc-text">7.4.1 サーブレットフィルタの利用</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7-4-2-HandlerInterceptorの利用"><span class="post-toc-number">1.7.4.2.</span> <span class="post-toc-text">7.4.2 HandlerInterceptorの利用</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7-4-3-ControllerAdviceの利用"><span class="post-toc-number">1.7.4.3.</span> <span class="post-toc-text">7.4.3 @ControllerAdviceの利用</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7-4-4-HandlerMethodArgumentResolverの利用"><span class="post-toc-number">1.7.4.4.</span> <span class="post-toc-text">7.4.4 HandlerMethodArgumentResolverの利用</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-5-静的リソース"><span class="post-toc-number">1.7.5.</span> <span class="post-toc-text">7.5 静的リソース</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7-5-1-デフォルトサーブレットとDispatcherServletの共存"><span class="post-toc-number">1.7.5.1.</span> <span class="post-toc-text">7.5.1 デフォルトサーブレットとDispatcherServletの共存</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7-5-2-SpringMVC独自の静的リソース解決の仕組み"><span class="post-toc-number">1.7.5.2.</span> <span class="post-toc-text">7.5.2 SpringMVC独自の静的リソース解決の仕組み</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-6-国際化"><span class="post-toc-number">1.7.6.</span> <span class="post-toc-text">7.6 国際化</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7-6-1-ロケールの解決"><span class="post-toc-number">1.7.6.1.</span> <span class="post-toc-text">7.6.1 ロケールの解決</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7-6-2-ロケールの利用"><span class="post-toc-number">1.7.6.2.</span> <span class="post-toc-text">7.6.2 ロケールの利用</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7-6-3-UIを使用したロケールの切り替え"><span class="post-toc-number">1.7.6.3.</span> <span class="post-toc-text">7.6.3 UIを使用したロケールの切り替え</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#第8章-Spring-Test"><span class="post-toc-number">1.8.</span> <span class="post-toc-text">第8章　Spring Test</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8-1-Spring-Testとは"><span class="post-toc-number">1.8.1.</span> <span class="post-toc-text">8.1 Spring Testとは</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8-2-DIコンテナ管理のBeanに対するテスト"><span class="post-toc-number">1.8.2.</span> <span class="post-toc-text">8.2 DIコンテナ管理のBeanに対するテスト</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#8-2-1-Beanの単体テスト"><span class="post-toc-number">1.8.2.1.</span> <span class="post-toc-text">8.2.1 Beanの単体テスト</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#8-2-2-DIコンテナ内のBeanに対する結合テスト"><span class="post-toc-number">1.8.2.2.</span> <span class="post-toc-text">8.2.2 DIコンテナ内のBeanに対する結合テスト</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#8-2-3-Spring-Testcontext-Framework"><span class="post-toc-number">1.8.2.3.</span> <span class="post-toc-text">8.2.3 Spring Testcontext Framework</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#8-2-4-DIコンテナのコンフィギュレーション"><span class="post-toc-number">1.8.2.4.</span> <span class="post-toc-text">8.2.4 DIコンテナのコンフィギュレーション</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#8-2-5-DIコンテナのライフサイクル制御"><span class="post-toc-number">1.8.2.5.</span> <span class="post-toc-text">8.2.5 DIコンテナのライフサイクル制御</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#8-2-6-プロファイルの指定"><span class="post-toc-number">1.8.2.6.</span> <span class="post-toc-text">8.2.6 プロファイルの指定</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#8-2-7-テスト用のプロパティ値の指定"><span class="post-toc-number">1.8.2.7.</span> <span class="post-toc-text">8.2.7 テスト用のプロパティ値の指定</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8-3-データベースアクセスを伴う処理のテスト"><span class="post-toc-number">1.8.3.</span> <span class="post-toc-text">8.3 データベースアクセスを伴う処理のテスト</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#8-3-1-テスト用のデータソースの設定"><span class="post-toc-number">1.8.3.1.</span> <span class="post-toc-text">8.3.1 テスト用のデータソースの設定</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#8-3-2-テストデータのセットアップ"><span class="post-toc-number">1.8.3.2.</span> <span class="post-toc-text">8.3.2 テストデータのセットアップ</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#8-3-3-テストケース用のトランザクション制御"><span class="post-toc-number">1.8.3.3.</span> <span class="post-toc-text">8.3.3 テストケース用のトランザクション制御</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#8-3-4-テーブルの中身の検証"><span class="post-toc-number">1.8.3.4.</span> <span class="post-toc-text">8.3.4 テーブルの中身の検証</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8-4-Spring-MVC-のテスト"><span class="post-toc-number">1.8.4.</span> <span class="post-toc-text">8.4 Spring MVC のテスト</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#8-4-1-MockMvcとは"><span class="post-toc-number">1.8.4.1.</span> <span class="post-toc-text">8.4.1 MockMvcとは</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#8-4-2-MockMvcのセットアップ"><span class="post-toc-number">1.8.4.2.</span> <span class="post-toc-text">8.4.2 MockMvcのセットアップ</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#8-4-3-テストの実行"><span class="post-toc-number">1.8.4.3.</span> <span class="post-toc-text">8.4.3 テストの実行</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#8-4-4-リクエストデータのセットアップ"><span class="post-toc-number">1.8.4.4.</span> <span class="post-toc-text">8.4.4 リクエストデータのセットアップ</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#8-4-5-実行結果の検証"><span class="post-toc-number">1.8.4.5.</span> <span class="post-toc-text">8.4.5 実行結果の検証</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#8-4-6-実行結果の出力"><span class="post-toc-number">1.8.4.6.</span> <span class="post-toc-text">8.4.6 実行結果の出力</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#第9章-Spring-Security"><span class="post-toc-number">1.9.</span> <span class="post-toc-text">第9章　Spring Security</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#9-1-SpringSecurityとは"><span class="post-toc-number">1.9.1.</span> <span class="post-toc-text">9.1 SpringSecurityとは</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-1-1-SpringSecurityの特徴"><span class="post-toc-number">1.9.1.1.</span> <span class="post-toc-text">9.1.1 SpringSecurityの特徴</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-1-2-基本機能"><span class="post-toc-number">1.9.1.2.</span> <span class="post-toc-text">9.1.2 基本機能</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-1-3-強化機能"><span class="post-toc-number">1.9.1.3.</span> <span class="post-toc-text">9.1.3 強化機能</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#9-2-Spring-Securityのセットアップ"><span class="post-toc-number">1.9.2.</span> <span class="post-toc-text">9.2 Spring Securityのセットアップ</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-2-1-ライブラリのセットアップ"><span class="post-toc-number">1.9.2.1.</span> <span class="post-toc-text">9.2.1 ライブラリのセットアップ</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-2-2-SpringSecurityのBean定義"><span class="post-toc-number">1.9.2.2.</span> <span class="post-toc-text">9.2.2 SpringSecurityのBean定義</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-2-3-サーブレットフィルタの設定"><span class="post-toc-number">1.9.2.3.</span> <span class="post-toc-text">9.2.3 サーブレットフィルタの設定</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#9-3-Spring-Security-のアーキテクチャ"><span class="post-toc-number">1.9.3.</span> <span class="post-toc-text">9.3 Spring Security のアーキテクチャ</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-3-1-Spring-Securityのモジュール構成"><span class="post-toc-number">1.9.3.1.</span> <span class="post-toc-text">9.3.1 Spring Securityのモジュール構成</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-3-2-フレームワークのアーキテクチャ"><span class="post-toc-number">1.9.3.2.</span> <span class="post-toc-text">9.3.2 フレームワークのアーキテクチャ</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#9-4-認証処理の適用"><span class="post-toc-number">1.9.4.</span> <span class="post-toc-text">9.4 認証処理の適用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-4-1-認証処理の仕組み"><span class="post-toc-number">1.9.4.1.</span> <span class="post-toc-text">9.4.1 認証処理の仕組み</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-4-2-フォーム認証"><span class="post-toc-number">1.9.4.2.</span> <span class="post-toc-text">9.4.2 フォーム認証</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-4-3-認証成功時のレスポンス"><span class="post-toc-number">1.9.4.3.</span> <span class="post-toc-text">9.4.3 認証成功時のレスポンス</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-4-5-データベース認証"><span class="post-toc-number">1.9.4.4.</span> <span class="post-toc-text">9.4.5 データベース認証</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-4-6-パスワードのハッシュ化"><span class="post-toc-number">1.9.4.5.</span> <span class="post-toc-text">9.4.6 パスワードのハッシュ化</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-4-7-認証イベントのハンドリング"><span class="post-toc-number">1.9.4.6.</span> <span class="post-toc-text">9.4.7 認証イベントのハンドリング</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-4-8-ログアウト"><span class="post-toc-number">1.9.4.7.</span> <span class="post-toc-text">9.4.8 ログアウト</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-4-10-認証情報へのアクセス"><span class="post-toc-number">1.9.4.8.</span> <span class="post-toc-text">9.4.10 認証情報へのアクセス</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-4-11-認証処理とSpringMVCの連携"><span class="post-toc-number">1.9.4.9.</span> <span class="post-toc-text">9.4.11 認証処理とSpringMVCの連携</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-4-12-エラーメッセージ"><span class="post-toc-number">1.9.4.10.</span> <span class="post-toc-text">9.4.12 エラーメッセージ</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#9-5-認可処理"><span class="post-toc-number">1.9.5.</span> <span class="post-toc-text">9.5 認可処理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-5-1-認可処理の仕組み"><span class="post-toc-number">1.9.5.1.</span> <span class="post-toc-text">9.5.1 認可処理の仕組み</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-5-2-アクセスポリシーの記述方法"><span class="post-toc-number">1.9.5.2.</span> <span class="post-toc-text">9.5.2 アクセスポリシーの記述方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-5-3-Webリソースへの認可（JavaConfig編）"><span class="post-toc-number">1.9.5.3.</span> <span class="post-toc-text">9.5.3 Webリソースへの認可（JavaConfig編）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-5-4-Webリソースへの認可（XMLファイル編）"><span class="post-toc-number">1.9.5.4.</span> <span class="post-toc-text">9.5.4 Webリソースへの認可（XMLファイル編）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-5-5-メソッドへの認可"><span class="post-toc-number">1.9.5.5.</span> <span class="post-toc-text">9.5.5 メソッドへの認可</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-5-6-JSPの画面項目への認可"><span class="post-toc-number">1.9.5.6.</span> <span class="post-toc-text">9.5.6 JSPの画面項目への認可</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-5-7-認可エラー時のレスポンス"><span class="post-toc-number">1.9.5.7.</span> <span class="post-toc-text">9.5.7 認可エラー時のレスポンス</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#9-6-CSRF対策"><span class="post-toc-number">1.9.6.</span> <span class="post-toc-text">9.6 CSRF対策</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-6-1-Spring-SecurityのCSRF対策"><span class="post-toc-number">1.9.6.1.</span> <span class="post-toc-text">9.6.1 Spring SecurityのCSRF対策</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-6-2-CSRF対策機能の適用"><span class="post-toc-number">1.9.6.2.</span> <span class="post-toc-text">9.6.2 CSRF対策機能の適用</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-6-3-トークンチェックエラー時のレスポンス"><span class="post-toc-number">1.9.6.3.</span> <span class="post-toc-text">9.6.3 トークンチェックエラー時のレスポンス</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-6-4-CSRF対策機能とSpringMVCとの連携"><span class="post-toc-number">1.9.6.4.</span> <span class="post-toc-text">9.6.4 CSRF対策機能とSpringMVCとの連携</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#9-7-セッション管理"><span class="post-toc-number">1.9.7.</span> <span class="post-toc-text">9.7 セッション管理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-7-1-セッション管理機能の適用"><span class="post-toc-number">1.9.7.1.</span> <span class="post-toc-text">9.7.1 セッション管理機能の適用</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-7-2-URL-Rewriting抑止機能"><span class="post-toc-number">1.9.7.2.</span> <span class="post-toc-text">9.7.2 URL Rewriting抑止機能</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-7-3-セッション固定攻撃対策機能"><span class="post-toc-number">1.9.7.3.</span> <span class="post-toc-text">9.7.3 セッション固定攻撃対策機能</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-7-4-多重ログインの制御"><span class="post-toc-number">1.9.7.4.</span> <span class="post-toc-text">9.7.4 多重ログインの制御</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-7-5-無効なセッションを使ったリクエストの検知"><span class="post-toc-number">1.9.7.5.</span> <span class="post-toc-text">9.7.5 無効なセッションを使ったリクエストの検知</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#9-8-ブラウザのセキュリティ対策機能との連携"><span class="post-toc-number">1.9.8.</span> <span class="post-toc-text">9.8 ブラウザのセキュリティ対策機能との連携</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-8-1-セキュリティヘッダー出力機能の適用"><span class="post-toc-number">1.9.8.1.</span> <span class="post-toc-text">9.8.1 セキュリティヘッダー出力機能の適用</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-8-2-デフォルトでサポートしているセキュリティヘッダー"><span class="post-toc-number">1.9.8.2.</span> <span class="post-toc-text">9.8.2 デフォルトでサポートしているセキュリティヘッダー</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-8-3-セキュリティヘッダーの選択"><span class="post-toc-number">1.9.8.3.</span> <span class="post-toc-text">9.8.3 セキュリティヘッダーの選択</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#9-9-Spring-Securityのテスト"><span class="post-toc-number">1.9.9.</span> <span class="post-toc-text">9.9 Spring Securityのテスト</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-9-1-Spring-Security-Testのセットアップ"><span class="post-toc-number">1.9.9.1.</span> <span class="post-toc-text">9.9.1 Spring Security Testのセットアップ</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#第10章-Spring-Data-JPA"><span class="post-toc-number">1.10.</span> <span class="post-toc-text">第10章　Spring Data JPA</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#10-6-Repositoryの作成と利用"><span class="post-toc-number">1.10.1.</span> <span class="post-toc-text">10.6 Repositoryの作成と利用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#10-6-4-ページネーション"><span class="post-toc-number">1.10.1.1.</span> <span class="post-toc-text">10.6.4 ページネーション</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#10-6-6-監査情報の付与"><span class="post-toc-number">1.10.1.2.</span> <span class="post-toc-text">10.6.6 監査情報の付与</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#第11章-Spring-＋-MyBatis"><span class="post-toc-number">1.11.</span> <span class="post-toc-text">第11章　Spring ＋ MyBatis</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#第12章-Spring＋Thymeleaf"><span class="post-toc-number">1.12.</span> <span class="post-toc-text">第12章　Spring＋Thymeleaf</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#12-1-Thymeleafとは"><span class="post-toc-number">1.12.1.</span> <span class="post-toc-text">12.1 Thymeleafとは</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#12-1-1-Thymeleafのテンプレート"><span class="post-toc-number">1.12.1.1.</span> <span class="post-toc-text">12.1.1 Thymeleafのテンプレート</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#12-1-2-ThymeleafとSpringの連携"><span class="post-toc-number">1.12.1.2.</span> <span class="post-toc-text">12.1.2 ThymeleafとSpringの連携</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#12-2-Spring-Thymeleafのセットアップ"><span class="post-toc-number">1.12.2.</span> <span class="post-toc-text">12.2 Spring + Thymeleafのセットアップ</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#12-2-1-ライブラリのセットアップ"><span class="post-toc-number">1.12.2.1.</span> <span class="post-toc-text">12.2.1 ライブラリのセットアップ</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#12-2-2-SpringとThymeleafを連携するための設定"><span class="post-toc-number">1.12.2.2.</span> <span class="post-toc-text">12.2.2 SpringとThymeleafを連携するための設定</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#12-3-Thymeleafを利用したViewの実装"><span class="post-toc-number">1.12.3.</span> <span class="post-toc-text">12.3 Thymeleafを利用したViewの実装</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#12-3-1-はじめてのThymeleaf"><span class="post-toc-number">1.12.3.1.</span> <span class="post-toc-text">12.3.1 はじめてのThymeleaf</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#12-3-2-テキストの出力"><span class="post-toc-number">1.12.3.2.</span> <span class="post-toc-text">12.3.2 テキストの出力</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#12-3-3-式の構文"><span class="post-toc-number">1.12.3.3.</span> <span class="post-toc-text">12.3.3 式の構文</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#12-3-4-th属性による属性値の設定"><span class="post-toc-number">1.12.3.4.</span> <span class="post-toc-text">12.3.4 th属性による属性値の設定</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#12-3-5-HTML要素の出力制御"><span class="post-toc-number">1.12.3.5.</span> <span class="post-toc-text">12.3.5 HTML要素の出力制御</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#12-3-6-インライン記述"><span class="post-toc-number">1.12.3.6.</span> <span class="post-toc-text">12.3.6 インライン記述</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#12-3-7-コメント"><span class="post-toc-number">1.12.3.7.</span> <span class="post-toc-text">12.3.7 コメント</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#12-3-8-Springとの連携"><span class="post-toc-number">1.12.3.8.</span> <span class="post-toc-text">12.3.8 Springとの連携</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#12-3-9-テンプレートの共通化"><span class="post-toc-number">1.12.3.9.</span> <span class="post-toc-text">12.3.9 テンプレートの共通化</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#12-3-10-SpringSecurityとの連携"><span class="post-toc-number">1.12.3.10.</span> <span class="post-toc-text">12.3.10 SpringSecurityとの連携</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#12-3-11-JSR-310-Date-and-Time-APIの利用"><span class="post-toc-number">1.12.3.11.</span> <span class="post-toc-text">12.3.11 JSR 310: Date and Time APIの利用</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#第13章-Spring-Boot"><span class="post-toc-number">1.13.</span> <span class="post-toc-text">第13章　Spring Boot</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#13-1-SpringBootとは"><span class="post-toc-number">1.13.1.</span> <span class="post-toc-text">13.1 SpringBootとは</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#13-1-1-SpringBootで作るHello-Worldアプリケーション"><span class="post-toc-number">1.13.1.1.</span> <span class="post-toc-text">13.1.1 SpringBootで作るHello Worldアプリケーション</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#13-1-2-AutoConfigureに夜自動設定"><span class="post-toc-number">1.13.1.2.</span> <span class="post-toc-text">13.1.2 AutoConfigureに夜自動設定</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#13-1-3-Starterによる依存ライブラリの解決"><span class="post-toc-number">1.13.1.3.</span> <span class="post-toc-text">13.1.3 Starterによる依存ライブラリの解決</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#13-1-4-実行可能jarの作成"><span class="post-toc-number">1.13.1.4.</span> <span class="post-toc-text">13.1.4 実行可能jarの作成</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#13-2-SpringBootでSpringMVC"><span class="post-toc-number">1.13.2.</span> <span class="post-toc-text">13.2 SpringBootでSpringMVC</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#13-2-1-RESTful-Webサービスの作成"><span class="post-toc-number">1.13.2.1.</span> <span class="post-toc-text">13.2.1 RESTful Webサービスの作成</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#13-2-2-画面遷移型アプリケーションの作成"><span class="post-toc-number">1.13.2.2.</span> <span class="post-toc-text">13.2.2 画面遷移型アプリケーションの作成</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#13-3-SpringBootでデータアクセス"><span class="post-toc-number">1.13.3.</span> <span class="post-toc-text">13.3 SpringBootでデータアクセス</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#13-3-1-SpringJDBC"><span class="post-toc-number">1.13.3.1.</span> <span class="post-toc-text">13.3.1 SpringJDBC</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#13-3-2-Spring-Data-JPA"><span class="post-toc-number">1.13.3.2.</span> <span class="post-toc-text">13.3.2 Spring Data JPA</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#13-3-3-MyBatis"><span class="post-toc-number">1.13.3.3.</span> <span class="post-toc-text">13.3.3 MyBatis</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#13-3-4-コネクションプールライブラリの変更"><span class="post-toc-number">1.13.3.4.</span> <span class="post-toc-text">13.3.4 コネクションプールライブラリの変更</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#13-4-SpringBootでSpring-Security"><span class="post-toc-number">1.13.4.</span> <span class="post-toc-text">13.4 SpringBootでSpring Security</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#13-4-1-Basic認証"><span class="post-toc-number">1.13.4.1.</span> <span class="post-toc-text">13.4.1 Basic認証</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#13-4-2-認証・認可のカスタマイズ"><span class="post-toc-number">1.13.4.2.</span> <span class="post-toc-text">13.4.2 認証・認可のカスタマイズ</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#13-5-Spring-Bootで型安全なプロパティ設定"><span class="post-toc-number">1.13.5.</span> <span class="post-toc-text">13.5 Spring Bootで型安全なプロパティ設定</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#13-5-1-ConfigurationPropertiesを用いたプロパティの設定"><span class="post-toc-number">1.13.5.1.</span> <span class="post-toc-text">13.5.1 @ConfigurationPropertiesを用いたプロパティの設定</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#13-5-2-Bean-Validationに夜プロパティ値のチェック"><span class="post-toc-number">1.13.5.2.</span> <span class="post-toc-text">13.5.2 Bean Validationに夜プロパティ値のチェック</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#13-5-3-IDEによるプロパティの補完"><span class="post-toc-number">1.13.5.3.</span> <span class="post-toc-text">13.5.3 IDEによるプロパティの補完</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#13-6-SpringBootAcruatorで運用機能強化"><span class="post-toc-number">1.13.6.</span> <span class="post-toc-text">13.6 SpringBootAcruatorで運用機能強化</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#13-6-1-HTTPエンドポイントの追加"><span class="post-toc-number">1.13.6.1.</span> <span class="post-toc-text">13.6.1 HTTPエンドポイントの追加</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#13-6-2-ヘルスチェック"><span class="post-toc-number">1.13.6.2.</span> <span class="post-toc-text">13.6.2 ヘルスチェック</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#13-6-3-メトリクス"><span class="post-toc-number">1.13.6.3.</span> <span class="post-toc-text">13.6.3 メトリクス</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#第14章-チュートリアル"><span class="post-toc-number">1.14.</span> <span class="post-toc-text">第14章　チュートリアル</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-2020-05_Spring徹底入門"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Spring徹底入門</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-05-01 00:00:00" datetime="2020-04-30T15:00:00.000Z"  itemprop="datePublished">2020-05-01</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="https://tutttuwi.github.io/output-over-there/categories/JAVA/" target="_blank" rel="noopener">JAVA</a></li></ul>



            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="Spring徹底入門"><a href="#Spring徹底入門" class="headerlink" title="Spring徹底入門"></a>Spring徹底入門</h1><ul>
<li><p>目次</p>
<ul>
<li>第1章　Spring Frameworkとは</li>
<li>第2章　Spring Core（DI×AOP）</li>
<li>第3章　データアクセス（Tx、JDBC）</li>
<li>第4章　Spring MVC</li>
<li>第5章　Webアプリケーションの開発</li>
<li>第6章　RESTful Webサービスの開発</li>
<li>第7章　Spring MVC の応用</li>
<li>第8章　Spring Test</li>
<li>第9章　Spring Security</li>
<li>第10章　Spring Data JPA</li>
<li>第11章　Spring ＋ MyBatis</li>
<li>第12章　Spring＋Thymeleaf</li>
<li>第13章　Spring Boot</li>
<li>第14章　チュートリアル</li>
</ul>
</li>
<li><p>形式：書籍</p>
</li>
<li><p>発売日：2016年07月20日</p>
</li>
<li><p>ISBN：9784798142470</p>
</li>
<li><p>価格：本体4,000円＋税</p>
</li>
<li><p>仕様：B5変・744ページ</p>
</li>
</ul>
<h2 id="第1章-Spring-Frameworkとは"><a href="#第1章-Spring-Frameworkとは" class="headerlink" title="第1章　Spring Frameworkとは"></a>第1章　Spring Frameworkとは</h2><ul>
<li><p>Spring Frameworkの概要</p>
<ul>
<li>「Spring Frameworkは、開発当初より古いインフラ環境上でも新しいインフラ環境上でも、最新のプログラミング思想で開発出来ることを設計思想にしている」</li>
</ul>
</li>
<li><p>Spring Frameworkの歴史</p>
<ul>
<li>2003年：Interface21 Framework → Spring Frameworkへと変更になった (Expert One-one-One: J2EE Design and Development)</li>
<li>2004年：EJBを使わずにSpringFramework1.0で開発する方法</li>
<li>2005年：SpringFramework1.2 の機能をカバーした書籍が刊行 SpringをStruts,Hibernateと組み合わせて使う（SSH）</li>
<li>2006年：SpringFramework2.0がリリース</li>
<li>2007年：SpringFramework2.5 アノテーションベースのDIやMVC<ul>
<li>米国に拠点を移す SpringToolSuiteなど統合開発環境の提供が始まる</li>
</ul>
</li>
<li>2009年：SpringFramework3.0がリリース JSR330に対応</li>
<li>2013年：SpringFramework4.0がリリース WebsocketやWebメソッドなどをサポート<ul>
<li>Pivotalという新しい会社にスピンオフ</li>
</ul>
</li>
<li>2014年：昨今注目されているSpringBootやSpringIOPlatformプロジェクトが始まる</li>
</ul>
</li>
<li><p>Springの各種プロジェクトについて</p>
<ul>
<li>SpringMVC: Webアプリケーションを開発するためのフレームワークであり、MVCパターンを利用している<ul>
<li>MVCパターンには、「アクションベースフレームワーク」と「コンポーネントベースフレームワーク」の２パターンある<ul>
<li>アクションベースフレームワーク<ul>
<li>リクエストによって実行する処理（アクション）を決定し、処理の結果としてレスポンスを返すフレームワーク</li>
</ul>
</li>
<li>コンポーネントベースフレームワーク<ul>
<li>リクエストやレスポンスを抽象化（隠蔽）し、画面を構成するコンポーネントをベースにWebアプリケーションを開発するフレームワーク</li>
<li>JSFはコンポーネントベースのフレームワーク<ul>
<li>MEMO: JavaEE徹底入門読んで理解した！</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>各種サードパーティとの連携機能もある<ul>
<li>Jackson</li>
<li>ApacheTiles</li>
<li>FreeMarker</li>
<li>Rome</li>
<li>JasperReports<ul>
<li>また、Thymeleafなど、サードパーティ自体がSpringMVCをサポートしているケースも有る</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Spring Security</p>
<ul>
<li>Authentication(認証)</li>
<li>Authorization(認可)などのセキュリテイ要件を用意に実現するためのフレームワーク<ul>
<li>非常に多くの認証方式に対応している<ul>
<li>Basic認証</li>
<li>ダイジェスト認証</li>
<li>X.509クライアント証明証</li>
<li>LDAP</li>
<li>OpenID</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Spring Data</p>
<ul>
<li>Spring Dataはリレーショナル・データベースやNoSQL、Key-Valueストアなど様々なデータストアへのデータアクセスを用意にするためのもの<ul>
<li>Spring Data Commons</li>
<li>Spring Data JPA</li>
<li>Spring Data MongoDB, Spring Data Redis, Spring Data Solr, etc…</li>
</ul>
</li>
</ul>
</li>
<li><p>Spring Batch</p>
<ul>
<li>バッチアプリケーション向けの軽量フレームワーク</li>
<li>大容量のデータ処理に必要な共通機能を提供している</li>
<li>もともと、Accentureが開発したバッチアプリケーション向けのフレームワークをベースとしており、2008年にSpringBatchとしてバージョン1.0がリリース</li>
</ul>
</li>
<li><p>Spring Integration</p>
<ul>
<li>Enterprise Integration Patterns(EIP)としてよく知られているさまざまなシステム間を連携させるアーキテクチャパターンに基づく開発をサポートするフレームワーク</li>
<li>同様の機能を実現するOSSとして、ApacheCamelが有名です。</li>
</ul>
</li>
<li><p>Spring Cloud</p>
<ul>
<li>分散環境でCloud Nativeなアプリケーションを開発するためのフレームワーク及びツール群<ul>
<li>SpringCloudConfig</li>
<li>SpringCloudBus</li>
<li>SpringCloudConnectors</li>
<li>SpringCloudNetflix</li>
</ul>
</li>
</ul>
</li>
<li><p>Spring tool Suite</p>
<ul>
<li>Eclipseベースの統合開発環境</li>
</ul>
</li>
<li><p>Spring IO Platform</p>
<ul>
<li>依存関係を管理するためのライブラリー</li>
</ul>
</li>
<li><p>Spring Boot</p>
<ul>
<li>最小限の設定でプロダクションレベルのSpringアプリケーションを容易に開発するためのSpringプロジェクト</li>
</ul>
</li>
<li><p>JavaEEとの関係</p>
<ul>
<li>差は縮まっている</li>
<li>Springのほうが新しい技術を取り込むサイクルが早い</li>
</ul>
</li>
</ul>
<h2 id="第2章-Spring-Core（DI×AOP）"><a href="#第2章-Spring-Core（DI×AOP）" class="headerlink" title="第2章　Spring Core（DI×AOP）"></a>第2章　Spring Core（DI×AOP）</h2><ul>
<li><p>DIコンテナメリット</p>
<ul>
<li>インスタンスのスコープを制御できる</li>
<li>インスタンスのライフサイクルを制御できる</li>
<li>共通機能を組み込める</li>
<li>コンポーネント間が疎結合になるため、単体テストがしやすい</li>
</ul>
</li>
<li><p>SpringFramework以外の有名なDIコンテナのフレームワーク</p>
<ul>
<li>CDI(Contexts&amp;DependencyInjection) ：JavaEE6で導入されたコンテキストに対応したDIの仕様</li>
<li>Google Guice</li>
<li>Dagger</li>
</ul>
</li>
<li><p>ApplicationContextとBean定義</p>
<ul>
<li>SpringFrameworkではApplicationContextがDIコンテナの役割を担う<ul>
<li>DIコンテナに登録するコンポーネントのことを「Bean」</li>
<li>Configurationのことを「Bean定義」</li>
<li>DIコンテナからBeanを取得することを「ルックアップ」という</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UserService userService = context.getBean(UserService.class);</span><br><span class="line">UserService userService = context.getBean(<span class="string">"userService"</span>,UserService.class);</span><br><span class="line">UserService userService = (UserService)context.getBean(<span class="string">"userService"</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>代表的なBean定義の方法</p>
<ul>
<li>JavaベースConfiguration</li>
<li>XMLベースConfiguration</li>
<li>アノテーションベースConfiguration</li>
</ul>
</li>
<li><p>それぞれ１つだけを使用して実装もできるが、通常は</p>
<ul>
<li>JavaベースConfigurationとアノテーションベースConfigurationの組み合わせ、または</li>
<li>XMLベースConfigurationとアノテーションベースConfigurationの組み合わせを用いてBean定義を行う</li>
</ul>
</li>
<li><p>Configuration方法</p>
</li>
<li><p>javaベース、XMLベース、アノテーションベースの説明</p>
</li>
<li><p>インジェクションの種類</p>
<ul>
<li>セッターインジェクション</li>
<li>コンストラクタインジェクション</li>
<li>フィールドインジェクション</li>
</ul>
</li>
<li><p>オートワイヤリング</p>
<ul>
<li><code>@Bean</code>メソッドや<code>&lt;bean&gt;</code>要素で明示的にBean定義しなくても自動的にＤＩコンテナにインジェクションさせる仕組み</li>
<li>解決方法は２つ<ul>
<li>型によるもの（by Type）</li>
<li>名前によるもの（by Name）</li>
</ul>
</li>
</ul>
</li>
<li><p>型による解決</p>
<ul>
<li>デフォルトでインジェクションされる事が必須</li>
<li>対象の型を持つ<code>Bean</code>が１つも登録されていないと<code>org.springframework.beans.factory.NoSuchBeanDefinitionException</code>が発生</li>
</ul>
</li>
</ul>
<p>required &#x3D; false を指定するか</p>
<ul>
<li><p>Spring4からは、<code>required = false</code>の代わりに、JavaSE8から導入された、<code>java.util.Optional</code>を使用することが出来る</p>
<ul>
<li>MEMO: <code>Optional&lt;T&gt;</code>で実装できる！絶対こっちのほうがいい　関数型プログラミングの本で知った。</li>
</ul>
</li>
<li><p>名前による解決</p>
<ul>
<li>同じ親クラスを持つ２つの実装クラスに<code>Bean</code>定義をして、インジェクションする場合</li>
<li><code>@Qualifier</code>で名前を指定してあげないといけない</li>
<li><code>@Primary</code>を使えば、名前を指定しなかった時にインジェクションされるデフォルトを指定できる</li>
<li>名前には、実装クラス名を記載するべきではない。呼び出し側で実装を特定してしまうとDIの意味がなくなる。用途名を指定するべき。</li>
<li>用途は文字列ではなく、アノテーションでも指定できる。</li>
</ul>
</li>
<li><p><input disabled="" type="checkbox"> 
用途を指定するためのアノテーション作成してみたい</p>
</li>
<li><p><input disabled="" type="checkbox"> 
独自アノテーションを作成してみる</p>
</li>
<li><p>名前によるオートワイヤリング</p>
<ul>
<li><code>@Resource</code>を付与</li>
<li>フィールド名がBean名に一致するパターン</li>
<li>プロパティ名がBean名に一致するパターン</li>
</ul>
</li>
<li><p>コレクションやmap型によるオートワイヤリング</p>
</li>
</ul>
<h3 id="2-1-6-コンポーネントスキャン"><a href="#2-1-6-コンポーネントスキャン" class="headerlink" title="2.1.6 コンポーネントスキャン"></a>2.1.6 コンポーネントスキャン</h3><ul>
<li><p>デフォルトのコンポーネントスキャン</p>
<ul>
<li>以下のアノテーションが付いたクラスがＤＩコンテナに登録される<ul>
<li><code>@org.springfrwamework.stereotype.Component</code></li>
<li><code>@org.springfrwamework.stereotype.Controller</code></li>
<li><code>@org.springfrwamework.stereotype.Service</code></li>
<li><code>@org.springfrwamework.stereotype.Repository</code></li>
<li><code>@org.springfrwamework.context.annotation.Configuration</code></li>
<li><code>@org.springfrwamework.web.bind.annotation.RestController</code></li>
<li><code>@org.springfrwamework.web.bind.annotation.ControllerAdvice</code></li>
<li><code>@javax.annotation.ManagedBean</code></li>
<li><code>@javax.inject.Named</code></li>
</ul>
</li>
</ul>
</li>
<li><p>コンポーネントスキャンは広範囲な程処理が遅くなるので不適切</p>
<ul>
<li><code>@ComponentScan(basePackages = &quot;com&quot;)</code></li>
<li><code>@ComponentScan(basePackages = &quot;com.example&quot;)</code></li>
</ul>
</li>
<li><p>対象のアプリケーションのトップレベル、あるいはもう１階層下をスキャン対象にすべき</p>
<ul>
<li><code>@ComponentScan(basePackages = &quot;com.example.demo&quot;)</code></li>
<li><code>@ComponentScan(basePackages = &quot;com.example.demo.app&quot;)</code></li>
</ul>
</li>
<li><p>value属性は basePackages属性の別名であり、どちらを使用しても構いません。この属性を省略した場合、コンフィグレーションクラスと同じパッケージ配下をスキャンすることに注意する事</p>
</li>
<li><p>スキャン対象のアノテーションとしては以下の４種類がよく使われる</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>アノテーション</th>
<th>説明</th>
</tr>
</thead>
<tbody><tr>
<td>@Controller</td>
<td>MVCパターンのC(Controller)の役割を担うコンポーネントであることを示すアノテーション。このアノテーションを付与したコンポーネントでは、クライアントからのリクエストとクライアントへのレスポンスに関わる処理を実装する。ビジネスロジックは、<code>@Service</code>を付与したコンポーネントで行う</td>
</tr>
<tr>
<td>@Service</td>
<td>ビジネスロジック（ビジネスルール）を提供するコンポーネントであることを示すアノテーション。このアノテーションを付与したコンポーネントでは、ビジネスルールが関わる処理を実装する。データの永続化に関わる処理は<code>@Repository</code>を付与したコンポーネントで行う。</td>
</tr>
<tr>
<td>@Repository</td>
<td>データの永続化に悪化÷処理を提供するコンポーネントであることを示すアノテーション。このアノテーションを付与したコンポーネントでは、ORM(Object-Relational Mapper)などの永続化ライブラリ等を使用して、データのCRUD処理を実装する</td>
</tr>
<tr>
<td>@Component</td>
<td>上記３に当てはまらないコンポーネント（ユーティリティクラスやサポートクラスなど）に付与するアノテーション</td>
</tr>
</tbody></table>
<ul>
<li><p>フィルタを明示したコンポーネントスキャン</p>
<ul>
<li>アノテーションによるフィルタ</li>
<li>代入可能な型によるフィルタ</li>
<li>正規表現によるフィルタ</li>
<li>AspectJパターンによるフィルタ</li>
</ul>
</li>
<li><p><input disabled="" type="checkbox"> 
フィルタを駆使するパターンについてメリットがあまり分からないため飛ばす.. あとで調べる</p>
</li>
</ul>
<h3 id="2-1-7-Beanのスコープ"><a href="#2-1-7-Beanのスコープ" class="headerlink" title="2.1.7 Beanのスコープ"></a>2.1.7 Beanのスコープ</h3><ul>
<li>DIコンテナを使用するメリット<ul>
<li>Beanのスコープ（生存期間）の管理をコンテナに任せる事が出来ること</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>スコープ</th>
<th>説明</th>
</tr>
</thead>
<tbody><tr>
<td>singleton</td>
<td>DIコンテナの起動時にBeanのインスタンスを生成し、同一のインスタンスを共有して利用する。デフォルトの設定であり、スコープを設定しない場合はsingletonとして扱われる</td>
</tr>
<tr>
<td>prototype</td>
<td></td>
</tr>
<tr>
<td>session</td>
<td></td>
</tr>
<tr>
<td>request</td>
<td></td>
</tr>
<tr>
<td>globalSession</td>
<td></td>
</tr>
<tr>
<td>application</td>
<td></td>
</tr>
<tr>
<td>カスタムスコープ(独自の命名)</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>覚書<ul>
<li><code>@Bean</code>アノテーションの使いどころ<ul>
<li><code>@Configuration</code>クラスの中に定義しているメソッドに付与して使う</li>
<li>DIコンテナに登録され、デフォルトではsingletonで参照出来る</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-1-8-Beanのライフサイクル"><a href="#2-1-8-Beanのライフサイクル" class="headerlink" title="2.1.8 Beanのライフサイクル"></a>2.1.8 Beanのライフサイクル</h3><ol>
<li>初期化フェーズ</li>
<li>利用フェーズ</li>
<li>終了フェーズ</li>
</ol>
<h3 id="2-1-9-Configurationの分割"><a href="#2-1-9-Configurationの分割" class="headerlink" title="2.1.9 Configurationの分割"></a>2.1.9 Configurationの分割</h3><ul>
<li><p>DIコンテナで管理するBeanが多くなるとConfigurationも肥大化してしまう</p>
</li>
<li><p>Configurationの範囲を明確にし、可読性を上げるために、必要に応じてConfigurationの分割を行う</p>
</li>
<li><p><code>@import</code>を使えば複数のConfigurationクラスに分割ができる</p>
<ul>
<li>MEMO: importでまとめなくても、<code>@Configuration</code>でコンポーネントスキャンされるので関係ないと思う</li>
<li>Contextから取得してわざわざアクセスしていた際に有用な方法だったと考える</li>
</ul>
</li>
</ul>
<h3 id="2-1-10-Configurationのプロファイル化"><a href="#2-1-10-Configurationのプロファイル化" class="headerlink" title="2.1.10 Configurationのプロファイル化"></a>2.1.10 Configurationのプロファイル化</h3><ul>
<li><p>Springでは異なる環境や目的ごとにConfigurationをグループ化することができる</p>
</li>
<li><p>このグループを「プロファイル」といいます。</p>
</li>
<li><p>例えば、環境ごとに「developmentプロファイル」「testプロファイル」などを作成することが考えられる</p>
</li>
</ul>
<p><code>@Profile</code>アノテーションを使用して指定する</p>
<ul>
<li><p>使用するプロファイルの選択方法</p>
<ul>
<li>JVM引数 <code>-Dspring.profiles.acrive=production</code></li>
<li>環境変数 <code>export SPRING_PROFILES_ACTIVE=production</code></li>
<li>WEB.xmlに記載することもできる（割愛）</li>
<li><code>application.yml</code> に指定することもできる（割愛）</li>
</ul>
</li>
<li><p>MEMO: 環境ごとの情報を定義するためのJavaクラスにアノテーションを付与して実現するのは微妙だと思うので、</p>
<ul>
<li><code>application.yml</code>で管理するのが良いだろうと思う</li>
</ul>
</li>
</ul>
<h3 id="2-1-11-JSR-330-Dependency-Injection-for-Java"><a href="#2-1-11-JSR-330-Dependency-Injection-for-Java" class="headerlink" title="2.1.11 JSR 330: Dependency Injection for Java"></a>2.1.11 JSR 330: Dependency Injection for Java</h3><ul>
<li>Springで、Java標準のJSR330で定められたAPI（主にアノテーション）を使用することができる</li>
</ul>
<table>
<thead>
<tr>
<th>Spring</th>
<th>JSR</th>
<th>説明</th>
</tr>
</thead>
<tbody><tr>
<td><code>@Autowired</code></td>
<td><code>@Inject</code></td>
<td><code>@Inject</code>には必須チェック（required属性）がない</td>
</tr>
<tr>
<td><code>@Component</code></td>
<td><code>@Named</code></td>
<td>Springの場合はデフォルトでSingletonスコープであるが、JSR330の場合はデフォルトでprototypeスコープである</td>
</tr>
<tr>
<td><code>@Qualifier</code></td>
<td><code>@Named</code></td>
<td><code>@Named</code>が兼用される</td>
</tr>
<tr>
<td><code>@Scope</code></td>
<td><code>@Scope</code></td>
<td>JSR330の<code>@Scope</code>はスコープを定義するカスタムアノテーションを作るためのメタアノテーション</td>
</tr>
</tbody></table>
<ul>
<li>Springを使うのであれば、特にこだわりがなければ、Springのアノテーションを使うのがいいでしょう</li>
</ul>
<h3 id="2-2-AOP"><a href="#2-2-AOP" class="headerlink" title="2.2 AOP"></a>2.2 AOP</h3><ul>
<li><p>ロギング処理、キャッシュ処理など本質的ではない処理がいろいろなロジック中に散在するようになる</p>
</li>
<li><p>複数のモジュールにまたがって存在する処理は、「横断的関心事（Cross-Cutting Concern）」と呼ばれる</p>
</li>
<li><p>代表的なものとしては以下</p>
<ul>
<li>セキュリティ</li>
<li>ログ出力</li>
<li>トランザクション</li>
<li>モニタリング</li>
<li>キャッシュ</li>
<li>例外ハンドリング</li>
</ul>
</li>
<li><p>プログラムの中から横断的関心事を取り除き、一箇所に集めることを「横断的関心事の分離（Separation Of Cross-Cutting Concerns）」と呼び</p>
</li>
<li><p>これを実現する手法をアスペクト指向プログラミングといいます</p>
</li>
</ul>
<h3 id="2-2-1-AOPの概要"><a href="#2-2-1-AOPの概要" class="headerlink" title="2.2.1 AOPの概要"></a>2.2.1 AOPの概要</h3><ul>
<li><p>AOPはDIと並ぶSpringFrameworkの重要な機能</p>
</li>
<li><p>AOPのコンセプト</p>
<ul>
<li>Aspect<ul>
<li>AOPの単位となる横断的な関心事を示すモジュールそのもの</li>
</ul>
</li>
<li>Join Point<ul>
<li>横断的な関心事を実行するポイント（メソッド実行時や例外スロー時など）</li>
<li>Join PointはAOPライブラリーによって使用が決められている</li>
<li>SpringのAOPでは、Join Pointはメソッドの実行時</li>
</ul>
</li>
<li>Advice<ul>
<li>特定のJoin Pointで実行されるコードのことで、横断的な関心事を実装する箇所</li>
<li>Adviceには、Around,Before,Afterなど複数の種類が存在する</li>
</ul>
</li>
<li>PointCut<ul>
<li>実行対象のJoin Pointを選択する表現式のこと</li>
<li>SpringAOPではBean定義ファイルやアノテーションを利用してPointCutを定義</li>
</ul>
</li>
<li>Weaving<ul>
<li>アプリケーションコードの適切なポイントにAspectを入れ込む処理のこと</li>
<li>AOPライブラリにはWeavingをコンパイル時に行うもの、クラスロード時に行うもの、実行時に行うものがあり、SpringAOPは実行時にWeavingを行う</li>
</ul>
</li>
<li>Target<ul>
<li>AOP処理によって、処理フローが変更されたオブジェクトのこと</li>
<li>TargetオブジェクトはAdvisedオブジェクトと呼ばれることもある</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-2-2-Spring-AOP"><a href="#2-2-2-Spring-AOP" class="headerlink" title="2.2.2 Spring AOP"></a>2.2.2 Spring AOP</h3><ul>
<li>SpringAOP は現場で広く使われているAOPフレームワークであるAspectJを利用している</li>
</ul>
<h3 id="2-2-3-Adviceの実装方法"><a href="#2-2-3-Adviceの実装方法" class="headerlink" title="2.2.3 Adviceの実装方法"></a>2.2.3 Adviceの実装方法</h3><ul>
<li>Before</li>
<li>After Returning</li>
<li>After Throwing など記載していく</li>
<li>括弧にPointCut式を記載する</li>
</ul>
<h3 id="2-2-4-XMLでAdviceの実装"><a href="#2-2-4-XMLでAdviceの実装" class="headerlink" title="2.2.4 XMLでAdviceの実装"></a>2.2.4 XMLでAdviceの実装</h3><p>XMLに記載する方法について</p>
<h3 id="2-2-5-Pointcut式"><a href="#2-2-5-Pointcut式" class="headerlink" title="2.2.5 Pointcut式"></a>2.2.5 Pointcut式</h3><p>Joint Pointを指すPointCutとして<code>execution(* *..*ServiceImple.*(..))</code>という式を使ってきたがその打ち合わけを記載</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">                                                ↓メソッド</span><br><span class="line"><span class="meta">@After</span>(execution(* com.example.domain.*Service.find*(..)))</span><br><span class="line">                 ↑戻り値　↑パッケージ   ↑型、クラス     ↑引数</span><br></pre></td></tr></table></figure>

<ul>
<li><p>PointCut式で利用可能なワイルドカード</p>
<ul>
<li><code>*</code></li>
<li><code>..</code></li>
<li><code>+</code></li>
</ul>
</li>
<li><p>名前付きポイントカットの書き方</p>
</li>
</ul>
<h3 id="2-2-6-Springプロジェクトで利用されているAOP"><a href="#2-2-6-Springプロジェクトで利用されているAOP" class="headerlink" title="2.2.6 Springプロジェクトで利用されているAOP"></a>2.2.6 Springプロジェクトで利用されているAOP</h3><ul>
<li>トランザクション管理処理：メソッドに<code>@Transaction</code>アノテーションを付与</li>
<li>認可処理：<code>@PreAuthorize</code>アノテーションを付与</li>
<li>キャッシュ処理：<code>@Cacheable(&quot;key&quot;)</code>ですでにキャッシュがある場合はメソッドを実行せずにキャッシュされた値を返す</li>
<li>非同期処理：<code>@Async</code>をメソッドに付与、指定された戻り値（<code>CompletableFuture&lt;Result&gt;</code>）を指定することで非同期実行ができる</li>
<li>リトライ処理：<code>@Retryable(maxAttempts=3)</code>をメソッドに付与。信頼性をコントロールできない外部接続先の呼び出しなどで有用</li>
</ul>
<h3 id="2-3-データバインディングと型変換"><a href="#2-3-データバインディングと型変換" class="headerlink" title="2.3 データバインディングと型変換"></a>2.3 データバインディングと型変換</h3><ul>
<li>本来であれば、<code>HttpServletRequestクラス</code>からパラメータをgetしてBeanに１つ１つ設定しなければ行けないが、</li>
<li>型変換しなければ行けない場面もあり面倒でミスが起きやすい</li>
<li>Springのデータバインディングを利用するとこれらの問題を解消できる</li>
</ul>
<h3 id="2-3-1-Springのデータバインディング"><a href="#2-3-1-Springのデータバインディング" class="headerlink" title="2.3.1 Springのデータバインディング"></a>2.3.1 Springのデータバインディング</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EmployeeForm form = <span class="keyword">new</span> EmployeeForm();</span><br><span class="line">ServletRequestDataBinder dataBinder = <span class="keyword">new</span> ServletRequestDataBinder(form);</span><br><span class="line">dataBinder.bind(request);</span><br></pre></td></tr></table></figure>

<ul>
<li>これを記載することで、３行でデータバインディングができる</li>
<li>また、SpringMVCの機能を使えば１行で済む （恐らく、<code>@ModelAttribute</code>を付与することを言っているのだと思う）</li>
</ul>
<h3 id="2-3-2-Springの型変換"><a href="#2-3-2-Springの型変換" class="headerlink" title="2.3.2 Springの型変換"></a>2.3.2 Springの型変換</h3><ul>
<li>型変換を行うための仕組みとして以下の３つを提供している<ul>
<li>PropertyEditor</li>
<li>Type Conversion</li>
<li>Field Formatting</li>
</ul>
</li>
</ul>
<h3 id="2-4-プロパティ管理"><a href="#2-4-プロパティ管理" class="headerlink" title="2.4 プロパティ管理"></a>2.4 プロパティ管理</h3><ul>
<li><p>ハードコーディングを避けるためにプロパティから値を読み込む仕組みがある</p>
</li>
<li><p>Strutsを使用していたときはプロパティファイルの値取得はResourceBundleでUtilクラス経由で取得していたのに対して、</p>
</li>
<li><p>SpringのDIであれば、<code>@Value(xxxx)</code>を引数やフィールドに指定するだけで取得できる</p>
</li>
<li><p>MEMO: これは必ず使用する</p>
<ul>
<li>:で区切って記載すればデフォルト値も指定できる！</li>
<li><code>@Value(xxxx:5)</code>などのように</li>
</ul>
</li>
</ul>
<h3 id="2-5-Spring-Expression-Language-SpEL"><a href="#2-5-Spring-Expression-Language-SpEL" class="headerlink" title="2.5 Spring Expression Language(SpEL)"></a>2.5 Spring Expression Language(SpEL)</h3><ul>
<li><p>Spring Expression Language (SpEL)は、SpringFrameworkが提供しているExpression Language</p>
</li>
<li><p>MEMO: 使用しないことにする</p>
</li>
</ul>
<h3 id="2-5-1-SpELのセットアップ"><a href="#2-5-1-SpELのセットアップ" class="headerlink" title="2.5.1 SpELのセットアップ"></a>2.5.1 SpELのセットアップ</h3><ul>
<li>pom.xmlの例</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-expression<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-5-2-SpEl-APIの利用"><a href="#2-5-2-SpEl-APIの利用" class="headerlink" title="2.5.2 SpEl APIの利用"></a>2.5.2 SpEl APIの利用</h3><ul>
<li>直接APIを使用するケースはないと思うが、SpELの仕組みを理解するために使用方法を説明</li>
</ul>
<h3 id="2-5-3-Bean定義でのSpELの利用"><a href="#2-5-3-Bean定義でのSpELの利用" class="headerlink" title="2.5.3 Bean定義でのSpELの利用"></a>2.5.3 Bean定義でのSpELの利用</h3><ul>
<li><p>SpELで定義した値をコンストラクタの引数に渡す方法の説明</p>
</li>
<li><p>アノテーションの場合は、<code>@Value(&quot;#{T(java.util.UUID).randomUUID().toString()}&quot;) String id</code>のような形で定義する</p>
</li>
<li><p>SpELは様々なアノテーションの中で利用することができる</p>
<ul>
<li><code>@EventListener</code></li>
<li><code>@TransactionalEventListener</code></li>
<li><code>@Cacheable</code></li>
<li><code>@CachePut</code></li>
<li>TODO:後で調べる</li>
</ul>
</li>
</ul>
<h3 id="2-5-4-SpELで使用可能な式の表現"><a href="#2-5-4-SpELで使用可能な式の表現" class="headerlink" title="2.5.4 SpELで使用可能な式の表現"></a>2.5.4 SpELで使用可能な式の表現</h3><ul>
<li><p>リテラル値</p>
</li>
<li><p>オブエジェクトの生成</p>
</li>
<li><p>プロパティへの参照</p>
</li>
<li><p>メソッドの呼び出し</p>
</li>
<li><p>型の解決</p>
</li>
<li><p>変数の参照</p>
</li>
<li><p>Beanの参照</p>
</li>
<li><p>演算子</p>
</li>
<li><p>テンプレート</p>
</li>
<li><p>コレクションの操作</p>
</li>
<li><p>MEMO:テンプレートエンジン使うなら、SpELいらないのは説</p>
</li>
</ul>
<h3 id="2-6-リソースの抽象化"><a href="#2-6-リソースの抽象化" class="headerlink" title="2.6 リソースの抽象化"></a>2.6 リソースの抽象化</h3><ul>
<li>アプリケーションは様々なリソースにアクセスする必要がある</li>
<li>これらのリソースが格納されている場所は<ul>
<li>ファイルシステム上のディレクトリ</li>
<li>クラスパス上のディレクトリ</li>
<li>サーブレットコンテナ上のwarファイル</li>
<li>jarファイル</li>
<li>別のWebサーバー<ul>
<li>など多岐に渡る</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-6-1-Resourceインターフェースと実装クラス"><a href="#2-6-1-Resourceインターフェースと実装クラス" class="headerlink" title="2.6.1 Resourceインターフェースと実装クラス"></a>2.6.1 Resourceインターフェースと実装クラス</h3><ul>
<li><p>Resourceインターフェース実装クラス</p>
<ul>
<li>ClassPathResource</li>
<li>FileSystemResource</li>
<li>PathResource</li>
<li>UrlResource</li>
<li>ServletContextResource</li>
</ul>
</li>
<li><p>TODO: Resourceインターフェースを実装しているクラスをいくつか紹介してくれているが、</p>
<ul>
<li>実際にこれらのクラスを使ってみる必要あり</li>
</ul>
</li>
</ul>
<h3 id="2-6-2-ResourceLoaderインターフェース"><a href="#2-6-2-ResourceLoaderインターフェース" class="headerlink" title="2.6.2 ResourceLoaderインターフェース"></a>2.6.2 ResourceLoaderインターフェース</h3><ul>
<li>MEMO: ResourceLoaderインターフェースと上記のつながりが理解できてないので再確認<ul>
<li>ResourceLoader経由のほうがよい？</li>
<li>上記の実装クラスを使わなくて済むならこっちのほうがよいと考える</li>
</ul>
</li>
</ul>
<h3 id="2-6-3-Resourceインターフェースを利用したリソースアクセス"><a href="#2-6-3-Resourceインターフェースを利用したリソースアクセス" class="headerlink" title="2.6.3 Resourceインターフェースを利用したリソースアクセス"></a>2.6.3 Resourceインターフェースを利用したリソースアクセス</h3><ul>
<li>TODO: 実際に使ってみる必要あり</li>
</ul>
<h3 id="2-6-4-XMLファイル上でのリソースの指定"><a href="#2-6-4-XMLファイル上でのリソースの指定" class="headerlink" title="2.6.4 XMLファイル上でのリソースの指定"></a>2.6.4 XMLファイル上でのリソースの指定</h3><ul>
<li><p>割愛</p>
</li>
<li><p>MEMO: リソース取得先の指定はプロパティファイルにまとめるべき！</p>
<ul>
<li>すべて<code>@Value()</code>で記載すればよい</li>
</ul>
</li>
</ul>
<h3 id="2-7-メッセージ管理"><a href="#2-7-メッセージ管理" class="headerlink" title="2.7 メッセージ管理"></a>2.7 メッセージ管理</h3><ul>
<li>説明文や項目名などの固定文言</li>
<li>処理結果に通知するメッセージ</li>
<li>エラーメッセージなどを表示する際に</li>
<li>プロパティファイルなどの外部定義から取得することが求められるケースも多いはず</li>
<li>メッセージの外部化のメリット<ul>
<li>多言語サポートする要件を満たす</li>
<li>一箇所で一元管理する</li>
</ul>
</li>
</ul>
<h3 id="2-7-1-MessageSourceインターフェースと実装クラス"><a href="#2-7-1-MessageSourceインターフェースと実装クラス" class="headerlink" title="2.7.1 MessageSourceインターフェースと実装クラス"></a>2.7.1 MessageSourceインターフェースと実装クラス</h3><ul>
<li><p>MessageSource</p>
<ul>
<li>メッセージの格納先を抽象化するためのインターフェース</li>
</ul>
</li>
<li><p>MessageSourceResolvable</p>
<ul>
<li>メッセージ解決に必要な値（code,args,defaultMessage）を保持していることを示すインターフェース</li>
</ul>
</li>
<li><p>MessageSourceの実装クラス</p>
<ul>
<li>ResourceBundleMessageSource</li>
<li>ReloadableResourceBundleMessageSource</li>
</ul>
</li>
</ul>
<h3 id="2-7-2-MessageSourceの利用"><a href="#2-7-2-MessageSourceの利用" class="headerlink" title="2.7.2 MessageSourceの利用"></a>2.7.2 MessageSourceの利用</h3><ul>
<li>MessageSourceのBean定義</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageSource <span class="title">messageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ResourceBundleMessageSource messageSource = <span class="keyword">new</span> ResourceBundleMessageSource();</span><br><span class="line">  messageSource.setBeannames(<span class="string">"messages"</span>); <span class="comment">// クラスパス上に格納されているプロパティファイル（拡張子は除く）を指定する</span></span><br><span class="line">  <span class="keyword">return</span> messageSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>メッセージの定義ファイルを作成</p>
</li>
<li><p>MessageSourceのAPI利用</p>
<ul>
<li>DIコンテナに登録したMessageSourceをインジェクションして<code>getMessage</code>メソッドを呼び出す</li>
</ul>
</li>
<li><p>MEMO: 感じたこと</p>
<ul>
<li>標準のクラスをDIコンテナで管理したい場合<code>@Bean</code>をメソッドにつけているのかなと思った</li>
<li>独自のクラスを作るのであれば、<code>@Component</code>でよいのではと</li>
</ul>
</li>
<li><p>MessageSourceResolvableの利用</p>
<ul>
<li>メッセージ引数もメッセージ定義で管理したい場合に利用するみたい</li>
</ul>
</li>
</ul>
<h2 id="第3章-データアクセス（Tx、JDBC）"><a href="#第3章-データアクセス（Tx、JDBC）" class="headerlink" title="第3章　データアクセス（Tx、JDBC）"></a>第3章　データアクセス（Tx、JDBC）</h2><ul>
<li>データアクセス機能について解説<ul>
<li>JDBC関連の機能</li>
<li>トランザクション管理機能</li>
<li>データアクセスエラーのハンドリング機能</li>
<li>その他ライブラリの機能（JPA、Hivernate、MyBatisといったORM）は以降の章で解説</li>
</ul>
</li>
</ul>
<h3 id="3-1-Springによるデータアクセス"><a href="#3-1-Springによるデータアクセス" class="headerlink" title="3.1 Springによるデータアクセス"></a>3.1 Springによるデータアクセス</h3><ul>
<li>まずはSpringが扱うことができるデータソースの種類について</li>
</ul>
<h3 id="3-1-1-データソースについて"><a href="#3-1-1-データソースについて" class="headerlink" title="3.1.1 データソースについて"></a>3.1.1 データソースについて</h3><p>データソースは、データベースにアクセスするためのコネクションをアプリケーションに提供する役割を担う</p>
<ul>
<li><p>Springが提供するデータベースアクセス機能では、以下に示す３つのデータソースを利用することができる</p>
<ul>
<li>アプリケーション内に定義したデータソース<ul>
<li>アプリ内にユーザや接続情報などを記載するパターン</li>
</ul>
</li>
<li>アプリケーションサーバーに定義したデータソース<ul>
<li>APサーバーに定義されたデータソースを利用するパターン<ul>
<li>MEMO: JavaEE徹底入門ではこのパターンでサンプル実装されていた</li>
</ul>
</li>
</ul>
</li>
<li>組み込みデータベースのデータソース<ul>
<li>HSQLDB、H2、Apache Derbyといった組み込みデータベースをデータソースとして利用する</li>
</ul>
</li>
</ul>
</li>
<li><p>MEMO: Commons DBCP はコネクションプール機能付きのデータソースを提供するライブラリー</p>
<ul>
<li>実際に定義を作成していく際に、コネクションプール設定方法について確認しておく</li>
</ul>
</li>
</ul>
<h3 id="3-1-2-データソースのコンフィギュレーション"><a href="#3-1-2-データソースのコンフィギュレーション" class="headerlink" title="3.1.2 データソースのコンフィギュレーション"></a>3.1.2 データソースのコンフィギュレーション</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>アプリケーション定義のデータソース</p>
<ul>
<li>アノテーション定義の例（詳細略）</li>
<li>XML定義の例（詳細略）</li>
</ul>
</li>
<li><p>アプリケーションサーバー定義のデータソース</p>
<ul>
<li>Jndiを指定して参照する（詳細略）</li>
</ul>
</li>
<li><p>組み込みデータソース</p>
<ul>
<li>（詳細略）</li>
</ul>
</li>
<li><p>TODO: 実際に上記の３種類で接続をしてみる必要がある</p>
</li>
</ul>
<h3 id="3-2-Spring-JDBC"><a href="#3-2-Spring-JDBC" class="headerlink" title="3.2 Spring JDBC"></a>3.2 Spring JDBC</h3><ul>
<li>前節ではSpring JDBCを使用するために必要となるデータソースのBean定義方法を紹介した</li>
<li>データアクセス処理を記述するための中心的な役割を持つJdbcTempleteクラスの使用方法を紹介<ul>
<li>SQLを実行する方法</li>
<li>SQLへ値をバインドする方法</li>
<li>SQLの実行結果からデータを取得する方法</li>
</ul>
</li>
</ul>
<h3 id="3-2-1-Spring-JDBCとは"><a href="#3-2-1-Spring-JDBCとは" class="headerlink" title="3.2.1 Spring JDBCとは"></a>3.2.1 Spring JDBCとは</h3><p>SQLの内容にかかわらす共通に行われる定型的なJDBCの処理をSpringが代替する機能</p>
<ul>
<li>定型的な処理<ul>
<li>コネクションのオープンやクローズ</li>
<li>SQLステートメントの実行</li>
<li>処理結果行の繰り返し処理</li>
<li>例外ハンドリング</li>
</ul>
</li>
<li>SpringJDBCを利用することで、実装範囲を以下のような重要な処理に限定できる<ul>
<li>SQLの定義</li>
<li>パラメータの設定</li>
<li>ResultSetの取得結果において、各レコードに対して実行したい処理</li>
</ul>
</li>
</ul>
<h3 id="3-2-2-JdbcTempleteクラスを利用したCRUD操作"><a href="#3-2-2-JdbcTempleteクラスを利用したCRUD操作" class="headerlink" title="3.2.2 JdbcTempleteクラスを利用したCRUD操作"></a>3.2.2 JdbcTempleteクラスを利用したCRUD操作</h3><ul>
<li>JdbcTempleteクラスを用いたCRUD操作の説明</li>
<li>MEMO: ORMを使用したほうが効率が良さそう<ul>
<li>念の為読んでおく程度で、覚えておかなくても良いと考える</li>
</ul>
</li>
</ul>
<h3 id="3-2-3-取得結果の変換処理"><a href="#3-2-3-取得結果の変換処理" class="headerlink" title="3.2.3 取得結果の変換処理"></a>3.2.3 取得結果の変換処理</h3><ul>
<li><p>SpringJDBCでは取得結果を変換できる３つのインターフェースを用意している</p>
<ul>
<li><code>RowMapper</code><ul>
<li>ResultSetの１行を特定のPOJOインスタンスに変換する</li>
</ul>
</li>
<li><code>ResultSetExtractor</code><ul>
<li>複数行から１つのインスタンスを生成できる</li>
</ul>
</li>
<li><code>RowCallbackHandler</code><ul>
<li>ResultSetを参照してなんらかの処理を行うためのインターフェース</li>
<li>戻り値を返さない。取得結果のファイル出力や、データのチェックなどを行う場合に利用します。</li>
</ul>
</li>
</ul>
</li>
<li><p>RowMapperの実装方法</p>
<ul>
<li>RowMapperインターフェースを実装したクラスにメソッドを作成して使用する</li>
<li>BeanPropertyRowMapperクラスを利用することもできる<ul>
<li>制約はありルールに沿ってBean定義すればかんたんにResultSetを設定可能</li>
</ul>
</li>
</ul>
</li>
<li><p>ResultSetExtractorの実装</p>
<ul>
<li>割愛</li>
</ul>
</li>
<li><p>RowCallbackHandlerの実装</p>
<ul>
<li>割愛</li>
</ul>
</li>
</ul>
<h3 id="3-2-4-応用的なCRUD操作"><a href="#3-2-4-応用的なCRUD操作" class="headerlink" title="3.2.4 応用的なCRUD操作"></a>3.2.4 応用的なCRUD操作</h3><ul>
<li>SQLのバッチ実行<ul>
<li><code>batchUpdate()</code>メソッドを利用する</li>
</ul>
</li>
<li>ストアドプロシージャの呼び出し<ul>
<li><code>JdbcTemplate</code>の<code>call</code>メソッドや<code>execute</code>メソッドを利用することで呼び出すことができる</li>
<li>TODO: ストアド・プロシージャ使ってみる。使ったことないので。。</li>
</ul>
</li>
</ul>
<h3 id="3-3-トランザクション管理"><a href="#3-3-トランザクション管理" class="headerlink" title="3.3 トランザクション管理"></a>3.3 トランザクション管理</h3><ul>
<li>アノテーションを用いたトランザクション管理方法</li>
<li>プログラム内に直接commitメソッドやrollbackメソッドを記述する明示的なトランザクション管理について説明</li>
</ul>
<h3 id="3-3-1-トランザクションマネージャ"><a href="#3-3-1-トランザクションマネージャ" class="headerlink" title="3.3.1 トランザクションマネージャ"></a>3.3.1 トランザクションマネージャ</h3><ul>
<li><p><code>PlatformTransactionManager</code>: Springのトランザクション管理の中心となるインターフェース</p>
</li>
<li><p>トランザクションマネージャの定義</p>
<ul>
<li><code>PlatformTransactionManager</code>のBeanを定義する</li>
<li>トランザクション対象とするメソッドを定義する</li>
</ul>
</li>
<li><p>ローカルトランザクションを利用する場合</p>
<ul>
<li>単一データベースに対する複数の操作</li>
<li>XMLにTransactionManagerの定義を記載する方法を紹介</li>
<li>BeanIDは<code>transactionManager</code>を指定することを推奨</li>
</ul>
</li>
<li><p>グローバルトランザクションを利用する場合</p>
<ul>
<li>異なるデータベースに対する複数の操作</li>
<li>グローバルトランザクションの仕組みはJTAというJavaEEの仕様として標準化されておりアプリケーション・サーバーからJTAの仕組みが提供されている</li>
<li>実装クラスとして<code>JtaTransactionManager</code>を使用する</li>
<li>ただし、製品ごとの<code>JtaTransactionManager</code>が提供されているのでそちらを使う 自動的に最適なクラスを使う仕組みが用意されているらしい</li>
</ul>
</li>
</ul>
<h3 id="3-3-2-宣言的トランザクション"><a href="#3-3-2-宣言的トランザクション" class="headerlink" title="3.3.2 宣言的トランザクション"></a>3.3.2 宣言的トランザクション</h3><ul>
<li><p>宣言的トランザクションとは</p>
<ul>
<li>事前に宣言されたルールに従い、トランザクションを制御する方法のこと</li>
<li>メリット<ul>
<li>トランザクションの開始やコミット、ロールバックなどの典型的な処理をビジネスロジックの中に記述する必要がなくなる</li>
</ul>
</li>
<li>利用方法<ul>
<li><code>@Transactional</code></li>
<li>XMLコンフィギュレーション</li>
</ul>
</li>
</ul>
</li>
<li><p><code>@Transactional</code>を利用した宣言的トランザクション</p>
</li>
<li><p>トランザクション制御で必要となる情報</p>
<ul>
<li>アノテーションの引数について説明（割愛）</li>
<li>クラスに付与するかメソッドに付与するか</li>
</ul>
</li>
<li><p>コンフィギュレーションクラスに定義する方法も紹介している</p>
</li>
<li><p>XMLコンフィギュレーションによる宣言的トランザクション</p>
<ul>
<li>割愛</li>
</ul>
</li>
</ul>
<h3 id="3-3-3-明示的トランザクション"><a href="#3-3-3-明示的トランザクション" class="headerlink" title="3.3.3 明示的トランザクション"></a>3.3.3 明示的トランザクション</h3><ul>
<li><p>明示的トランザクションとは</p>
<ul>
<li>コミットやロールバックといったトランザクション制御に関する処理をソースコードに明示的に記述する方法</li>
</ul>
</li>
<li><p><code>PlatformTransactionManager</code>を利用した明示的トランザクション制御</p>
<ul>
<li>commit(),rollback()などを直接書く</li>
</ul>
</li>
<li><p><code>TransactionTemplete</code>を利用した明示的トランザクション制御</p>
<ul>
<li>@ConfigurationクラスにBean定義する際にトランザクションを設定</li>
</ul>
</li>
<li><p>MEMO: 明示的トランザクションはどちらも使いにくいような印象</p>
</li>
</ul>
<h3 id="3-3-4-トランザクションの分離レベルと伝播レベル"><a href="#3-3-4-トランザクションの分離レベルと伝播レベル" class="headerlink" title="3.3.4 トランザクションの分離レベルと伝播レベル"></a>3.3.4 トランザクションの分離レベルと伝播レベル</h3><ul>
<li>TODO: ★見返して実装に組み込む</li>
<li>トランザクション分離レベル<ul>
<li>TODO: トランザクション分離レベルについて復習すべし</li>
</ul>
</li>
<li>トランザクション伝播レベル<ul>
<li>MEMO: 伝播レベルについて意識したことはなかった</li>
<li>トランザクション処理が入れ子になったときに初めて意識することになる。</li>
<li>通常の処理の場合はデフォルトの<code>Required</code>で問題ないような気がする。</li>
<li>TODO: 逆に入れ子にするパターンってどのような要件が考えられるか確認する<ul>
<li>→本書に解説があった。<ul>
<li>業務ロジックのトランザクションとは別に、ログ出力用の処理でDBアクセスがある場合</li>
<li>業務ロジックでロールバックが発生すると、ログ出力用のデータもロールバックされてしまう。</li>
<li>こうならないように、ログ出力用のトランザクションは<code>REQUIRES_NEW</code>で生成しておく必要があるとのこと</li>
<li>そもそもDBにログを貯める仕様が良くないのではと思う</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-4-データアクセスエラーのハンドリング"><a href="#3-4-データアクセスエラーのハンドリング" class="headerlink" title="3.4 データアクセスエラーのハンドリング"></a>3.4 データアクセスエラーのハンドリング</h3><ul>
<li>データアクセス処理でエラーが発生した際のハンドリング処理を実装しておく必要がある</li>
<li>Springにおけるデータアクセス例外の抽象化の考えかたを理解した上で、エラーハンドリング処理の実装方法や抽象化のカスタマイズ方法を紹介</li>
</ul>
<h3 id="3-4-1-Springが提供するデータアクセス例外"><a href="#3-4-1-Springが提供するデータアクセス例外" class="headerlink" title="3.4.1 Springが提供するデータアクセス例外"></a>3.4.1 Springが提供するデータアクセス例外</h3><ul>
<li><p>DataAccessExceptionを親クラスとするデータアクセス例外の階層構造</p>
<ul>
<li>MEMO: かなり多くの種類のエラーが、<code>DataAccessException</code>から切られていることを確認した</li>
</ul>
</li>
<li><p>非検査例外によるDataAccessExceptionの実装</p>
<ul>
<li>DataAccessExceptionはRuntimeExceptionが親クラスなので、例外ハンドリングが強制されてませんよという説明</li>
</ul>
</li>
<li><p>実装を隠蔽したデータアクセス例外</p>
<ul>
<li>DBごとに例外コードが異なるが、Springのデータアクセス機能で共通の例外クラスに変換している</li>
<li>MEMO: これは画期的ですごい便利だと感じた→当たり前でもあるか..</li>
</ul>
</li>
</ul>
<h3 id="3-4-2-データアクセス例外のハンドリング"><a href="#3-4-2-データアクセス例外のハンドリング" class="headerlink" title="3.4.2 データアクセス例外のハンドリング"></a>3.4.2 データアクセス例外のハンドリング</h3><ul>
<li><p>非検査例外のため、ハンドリングを行いたい場所だけcatchする、行いたくない場所は何もする必要が無い</p>
</li>
<li><p>データアクセス例外のハンドリングを行う実装例</p>
<ul>
<li>Springが提供している例外でcatchできるようにtry-catchで囲む</li>
<li>catch後は、プロジェクトの例外を再throwする</li>
</ul>
</li>
</ul>
<h3 id="3-4-3-データアクセス例外の変換ルールのカスタマイズ"><a href="#3-4-3-データアクセス例外の変換ルールのカスタマイズ" class="headerlink" title="3.4.3 データアクセス例外の変換ルールのカスタマイズ"></a>3.4.3 データアクセス例外の変換ルールのカスタマイズ</h3><ul>
<li>各データベースのエラーコードとデータアクセス例外の対応はspring-jdbc-xxx.jarに含まれるsql-error-codes.xmlに定義されているが、クラスパス直下にsql-error-codes.xmlを配置することでこの定義をカスタマイズすることができる</li>
</ul>
<h2 id="第4章-Spring-MVC"><a href="#第4章-Spring-MVC" class="headerlink" title="第4章　Spring MVC"></a>第4章　Spring MVC</h2><ul>
<li><p>第三章までで得た知識で開発できるのは、データベースにアクセスするスタンドアロンアプリケーション</p>
</li>
<li><p>本章から７章までにかけて、SpringMVCの機能を利用したWebアプリケーションの開発方法について解説</p>
</li>
<li><p>本章</p>
<ul>
<li>SpringMVCの特徴を簡単に説明</li>
<li>シンプルなサンプルアプリケーションを作成しながらSpringMVCの基礎を学ぶ</li>
<li>SpringMVCのアーキテクチャについて説明</li>
</ul>
</li>
</ul>
<h3 id="4-1-Spring-MVC-とは"><a href="#4-1-Spring-MVC-とは" class="headerlink" title="4.1 Spring MVC とは"></a>4.1 Spring MVC とは</h3><ul>
<li>フレームワークのアーキテクチャとしてMVCパターンを採用している<ul>
<li>TODO: MVC以外のアーキテクチャについて理解を深める</li>
</ul>
</li>
<li>Springは正確に言うと、フロントコントローラパターンを採用しているらしい詳細は4.3SpringMVCのアーキテクチャで解説</li>
</ul>
<h3 id="4-1-1-Webアプリケーション開発における特徴"><a href="#4-1-1-Webアプリケーション開発における特徴" class="headerlink" title="4.1.1 Webアプリケーション開発における特徴"></a>4.1.1 Webアプリケーション開発における特徴</h3><ul>
<li><p>SpringMVCはWebアプリケーションをストレスなく快適に開発することができるフレームワークで、次のような特徴がある</p>
<ul>
<li>POJO（Plain Old Java Object）での実装<ul>
<li>フレームワーク独自のインターフェースを実装する必要が無いため、作成するクラスの単体テストのテスタビリティを確保</li>
</ul>
</li>
<li>アノテーションを使用した定義情報の指定</li>
<li>柔軟なメソッドシグネチャの定義<ul>
<li>Controllerに渡す引数や戻り値も様々な形がサポートされている</li>
</ul>
</li>
<li>ServletAPIの抽象化<ul>
<li>ServletAPI（HttpServletRequest,HttpServletResponse,HttpSessionなどのAPI）を抽象化する仕組みを提供</li>
<li>テスタビリティを確保</li>
</ul>
</li>
<li>Viewの実装技術の抽象化<ul>
<li>コントローラはView名（Viewの論理名）を返却し、SpringMVCのフレームワーク処理が呼び出すViewを決定</li>
<li>ControllerはViewの実装技術（Thymeleaf,ServletAPI,FreeMarkerなど）を意識する必要がなくなる</li>
</ul>
</li>
<li>SpringのDIコンテナとの連携<ul>
<li>SpringMVCはSpringのDIコンテナ上で動作するフレームワーク</li>
<li>DIやAOPなどの仕組みを活用できる</li>
</ul>
</li>
</ul>
</li>
<li><p>MEMO: この辺は開発で感触をつかめているのですんなり理解できた</p>
</li>
</ul>
<h3 id="4-1-2-MVCフレームワークとしての特徴"><a href="#4-1-2-MVCフレームワークとしての特徴" class="headerlink" title="4.1.2 MVCフレームワークとしての特徴"></a>4.1.2 MVCフレームワークとしての特徴</h3><ul>
<li><p>豊富な拡張ポイントの提供</p>
<ul>
<li>処理の役割に応じてインターフェースを定義している</li>
</ul>
</li>
<li><p>エンタープライズアプリケーション向けの機能の提供</p>
<ul>
<li>メッセージ管理</li>
<li>セッション管理</li>
<li>国際化</li>
<li>ファイルアップロードといったエンタープライズアプリケーション向けのWebアプリケーションを開発する際に必要となる機能も提供</li>
</ul>
</li>
<li><p>サードパーティのライブラリとの連携部品の提供</p>
<ul>
<li>★Jackson(JSON&#x2F;XML操作) → JSON操作は他に、org.jsonがあるみたいだが、Jacksonの方が良さそう</li>
<li>Apache Tiles(レイアウトエンジン) → レイアウトを組める。Thymeleafのincludeで十分なので使わない</li>
<li>FreeMarker(テンプレートエンジン) → 変数を持つ定型文言を作成しておき（*.ftlファイル）</li>
<li>★Rome(RSS&#x2F;Feed操作) → 他に、Informaというのがあるらしい。</li>
<li>★JsperReports(帳票出力) → 他にも色々なライブラリがあるみたいだが、一旦これを使用したい<ul>
<li><a href="https://weblabo.oscasierra.net/java-pdf-lib-2017/" target="_blank" rel="noopener">https://weblabo.oscasierra.net/java-pdf-lib-2017/</a></li>
</ul>
</li>
<li>★Apache POI(Excel操作)</li>
<li>★Hibernate Validator(Bean Validation)</li>
<li>Joda Time(日付操作) → Java7時代の日付操作</li>
<li>など</li>
<li>サードパーティ自体がSpringMVCとの連携部品を提供しているケースもある。<ul>
<li>Thymeleaf(テンプレートエンジン)</li>
<li>★HDIV(セキュリティ強化)</li>
</ul>
</li>
</ul>
</li>
<li><p>TODO: ★つけたライブラリーは使用したい</p>
</li>
</ul>
<h3 id="4-2-はじめてのSpring-MVCアプリケーション"><a href="#4-2-はじめてのSpring-MVCアプリケーション" class="headerlink" title="4.2 はじめてのSpring MVCアプリケーション"></a>4.2 はじめてのSpring MVCアプリケーション</h3><h3 id="4-2-1-開発プロジェクトの作成"><a href="#4-2-1-開発プロジェクトの作成" class="headerlink" title="4.2.1 開発プロジェクトの作成"></a>4.2.1 開発プロジェクトの作成</h3><ul>
<li><p>InteliJ IDEA でプロジェクトを作成することにした</p>
</li>
<li><p>mavenプロジェクトをstartarのアーキタイプで作成</p>
</li>
<li><p>pom.xmlをサンプルアプリに合わせる</p>
<ul>
<li>mavenがうまく動かない不具合発生</li>
<li>原因: urlがmavenレポジトリを向いていなかったため<ul>
<li>結果: 解消しなかった</li>
</ul>
</li>
</ul>
</li>
<li><p>Intelijだとうまくいかないと判断し、Eclipseで実施</p>
</li>
<li><p>Eclipseでサンプルプログラムを配置</p>
</li>
<li><p>mavenの設定をサンプルに合わせる</p>
</li>
<li><p>javaeeのモジュールがデフォルトで読み込めなくなったみたいなので、pomに定義を入れる</p>
</li>
<li><p>tomcat9サーバーを立ち上げる</p>
</li>
<li><p>context-pathはデフォルトでプロジェクト名？になるみたいなので、<code>http://localhost:8080/firstapp4-2</code>でアクセスするとうまく行った</p>
</li>
<li><p>Web.xmlに<code>jsp-config</code>というものを定義すると、すべてのjspに対してデフォルトでincludeさせることができるみたい</p>
</li>
<li><p>TODO: spring bootで生成したプロジェクトだと、web.xmlが必要ない？ そのあたりの仕組みが理解できていない</p>
</li>
</ul>
<h3 id="4-2-2-Spring-MVCの適用"><a href="#4-2-2-Spring-MVCの適用" class="headerlink" title="4.2.2 Spring MVCの適用"></a>4.2.2 Spring MVCの適用</h3><h3 id="4-2-3-トップ画面表示処理の実装"><a href="#4-2-3-トップ画面表示処理の実装" class="headerlink" title="4.2.3 トップ画面表示処理の実装"></a>4.2.3 トップ画面表示処理の実装</h3><h3 id="4-2-4-入力画面表示処理の実装"><a href="#4-2-4-入力画面表示処理の実装" class="headerlink" title="4.2.4 入力画面表示処理の実装"></a>4.2.4 入力画面表示処理の実装</h3><h3 id="4-2-5-送信処理の実装"><a href="#4-2-5-送信処理の実装" class="headerlink" title="4.2.5 送信処理の実装"></a>4.2.5 送信処理の実装</h3><h3 id="4-2-6-入力チェック処理の実装"><a href="#4-2-6-入力チェック処理の実装" class="headerlink" title="4.2.6 入力チェック処理の実装"></a>4.2.6 入力チェック処理の実装</h3><ul>
<li><p>ここまででサンプルアプリケーションの説明終了</p>
<ul>
<li>Controllerクラス</li>
<li>フォームクラス</li>
<li>View(JSPなどのテンプレートファイル)</li>
</ul>
</li>
<li><p>本来であれば、JSPではなくThymeleafとかを使うべきだと思うので、詳細な実装はサラッと流し読み</p>
</li>
</ul>
<h3 id="4-2-7-XMLファイルを使用したBean定義"><a href="#4-2-7-XMLファイルを使用したBean定義" class="headerlink" title="4.2.7 XMLファイルを使用したBean定義"></a>4.2.7 XMLファイルを使用したBean定義</h3><ul>
<li>割愛</li>
</ul>
<h3 id="4-3-Spring-MVCのアーキテクチャ"><a href="#4-3-Spring-MVCのアーキテクチャ" class="headerlink" title="4.3 Spring MVCのアーキテクチャ"></a>4.3 Spring MVCのアーキテクチャ</h3><h3 id="4-3-1-フレームワークのアーキテクチャ"><a href="#4-3-1-フレームワークのアーキテクチャ" class="headerlink" title="4.3.1 フレームワークのアーキテクチャ"></a>4.3.1 フレームワークのアーキテクチャ</h3><ul>
<li><p>Spring MVCは「フロントコントローラパターン」と呼ばれるアーキテクチャを採用している</p>
<ul>
<li>クライアントからのリクエストをフロントコントローラと呼ばれるコンポーネントが受け取り、リクエストの内容に応じて実行するHandler(Controller)を選択するアーキテクチャ</li>
</ul>
</li>
<li><p>フロントコントローラが担う処理</p>
<ul>
<li>クライアントからのリクエストの受付</li>
<li>リクエストデータのJavaオブジェクトへの変換</li>
<li>入力チェックの実行（Bean Validation）</li>
<li>Handlerの呼び出し</li>
<li>Viewの解決</li>
<li>クライアントへのレスポンスデータの応答</li>
<li>例外ハンドリング</li>
</ul>
</li>
<li><p>TODO: Springフレームワークの全体を把握したときにもう一度見直す</p>
</li>
</ul>
<h2 id="第5章-Webアプリケーションの開発"><a href="#第5章-Webアプリケーションの開発" class="headerlink" title="第5章　Webアプリケーションの開発"></a>第5章　Webアプリケーションの開発</h2><h3 id="5-1-Webアプリケーションの種類"><a href="#5-1-Webアプリケーションの種類" class="headerlink" title="5.1 Webアプリケーションの種類"></a>5.1 Webアプリケーションの種類</h3><ul>
<li><p>SpringMVCは大きく分けて以下の２種類のアプリケーションを作成するための機能を提供</p>
<ul>
<li>画面を応答するアプリケーション</li>
<li>データのみを応答するアプリケーション（RESTful Webサービス）</li>
</ul>
</li>
<li><p>メモ</p>
<ul>
<li>SpringMVCの仕組みは使用していないが、Spring4.0よりWebSocketの連携モジュールが提供されている</li>
<li>フロントとサーバーサイドの双方向通信用</li>
<li>TODO: 使ってみる</li>
</ul>
</li>
<li><p>Hamdlerメソッド作成</p>
<ul>
<li><code>@RequestMapping()</code>は使用せずに、<code>@GetMapping()</code>を使用する</li>
</ul>
</li>
<li><p>Handlerメソッドの引数に指定可能な型、アノテーションを紹介</p>
<ul>
<li>TODO: 再度確認する</li>
</ul>
</li>
<li><p>暗黙的な引数の解決！覚えておく</p>
<ul>
<li>引数の型がStringやIntegerといったシンプル型の場合、引数名に一致するリクエストパラメータの値を取得</li>
<li>引数の方がJavaBeansだった場合、デフォルトの属性名に一致するオブジェクトをModelから取得する<ul>
<li>該当するオブジェクトがModelに存在しない場合、デフォルトコンストラクタを呼び出して新しいオブジェクトを生成</li>
</ul>
</li>
</ul>
</li>
<li><p>ServletAPI(HttpServletRequest,HttpServletResponse,HttpSession,Partなど)や低レベルのJavaAPI(InputStream,Reader,OutputStream, Writer,Map)なども指定できるが、これらのAPIを自由に使うとメンテナンス性を低下させる可能性があるので、使用しないようにする必要がある</p>
</li>
<li><p>TODO: コーディング規約として利用を制限していくべき！</p>
</li>
</ul>
<h4 id="5-3-5-Handlerメソッドの戻り値"><a href="#5-3-5-Handlerメソッドの戻り値" class="headerlink" title="5.3.5 Handlerメソッドの戻り値"></a>5.3.5 Handlerメソッドの戻り値</h4><ul>
<li><p>Handlerメソッドは戻り値として様々なオブジェクトを返却できる</p>
</li>
<li><p>メモ</p>
<ul>
<li>返却できるオブジェクトは<code>org.springframework.web.method.support.HandlerMethodReturnValueHandler</code>インターフェースの実装クラスを作成することで拡張できる</li>
</ul>
</li>
<li><p>SpringMVCがサポートしている主な型</p>
<ul>
<li><code>java.lang.String</code></li>
<li>Model</li>
<li>ModelAndView</li>
<li>void</li>
<li>ResponseEntity&lt;?&gt;</li>
<li>HttpHeaders</li>
</ul>
</li>
</ul>
<h4 id="5-3-6-View-Controllerの利用"><a href="#5-3-6-View-Controllerの利用" class="headerlink" title="5.3.6 View Controllerの利用"></a>5.3.6 View Controllerの利用</h4><ul>
<li>Viewを呼び出すだけであれば、SpringMVCが提供しているViewControllerの仕組みを利用することができる</li>
</ul>
<h3 id="5-4-リクエストマッピング"><a href="#5-4-リクエストマッピング" class="headerlink" title="5.4 リクエストマッピング"></a>5.4 リクエストマッピング</h3><ul>
<li><p><code>@RequestMapping</code>の属性値を使ってリクエストマッピングの条件を指定する</p>
</li>
<li><p>指定可能な属性</p>
<ul>
<li>value</li>
<li>path</li>
<li>method</li>
<li>params</li>
<li>headers: リクエストヘッダー</li>
<li>consumes: Content-Typeヘッダー</li>
<li>produces: Acceptヘッダー</li>
<li>name</li>
</ul>
</li>
<li><p>value,pathは複数指定することができる</p>
<ul>
<li>or条件として扱われる</li>
</ul>
</li>
<li><p>パスパターンの使用</p>
<ul>
<li>URIテンプレート形式のパスパターン</li>
<li>正規表現も使える</li>
<li>Antスタイルのパスパターン</li>
</ul>
</li>
<li><p>paramsはメソッドが実行される条件としてパラメータの有無も入る</p>
</li>
</ul>
<h3 id="5-5-リクエストデータの取得"><a href="#5-5-リクエストデータの取得" class="headerlink" title="5.5 リクエストデータの取得"></a>5.5 リクエストデータの取得</h3><ul>
<li>種類<ul>
<li><code>@PathVariable</code></li>
<li><code>@RequestParam</code></li>
<li><code>@RequestHeader</code></li>
<li>リクエストパラメータ値の一括取得</li>
</ul>
</li>
</ul>
<h4 id="5-5-4-コンパイルオプションの注意点"><a href="#5-5-4-コンパイルオプションの注意点" class="headerlink" title="5.5.4 コンパイルオプションの注意点"></a>5.5.4 コンパイルオプションの注意点</h4><ul>
<li><code>@PathVariable</code>,<code>@RequestParam</code>,<code>@RequestHeader</code>,<code>@CookieValue</code>のvalue属性を省略する場合、</li>
<li><code>-g</code>オプションまたはJavaSE8から追加された<code>-parameters</code>オプションのどちらかのコンパイルオプションを有効にしておく必要がある<ul>
<li>TODO: バインドされないとき確認</li>
</ul>
</li>
</ul>
<h4 id="5-5-7-アノテーションを使用したフォーマットの指定"><a href="#5-5-7-アノテーションを使用したフォーマットの指定" class="headerlink" title="5.5.7 アノテーションを使用したフォーマットの指定"></a>5.5.7 アノテーションを使用したフォーマットの指定</h4><ul>
<li><p><code>@org.springframework.format.annotation.DateTimeFormat</code></p>
</li>
<li><p><code>@org.springframework.format.annotation.NumberFormat</code></p>
</li>
<li><p>JSR354 : Money and Currency APIというものがあるらしい</p>
<ul>
<li>TODO: 後で確認する</li>
</ul>
</li>
</ul>
<h3 id="5-6-フォームクラスの実装"><a href="#5-6-フォームクラスの実装" class="headerlink" title="5.6 フォームクラスの実装"></a>5.6 フォームクラスの実装</h3><h4 id="5-6-1-フォームオブジェクトのスコープ"><a href="#5-6-1-フォームオブジェクトのスコープ" class="headerlink" title="5.6.1 フォームオブジェクトのスコープ"></a>5.6.1 フォームオブジェクトのスコープ</h4><ul>
<li><p>スコープの種類</p>
<ul>
<li>リクエストスコープ</li>
<li>フラッシュスコープ：PRGパターンのリクエスト間でオブジェクトを共有するためのスコープ</li>
<li>セッションスコープ：HttpSessionに格納され、明示的に破棄するまで残り続ける</li>
</ul>
</li>
<li><p>フラッシュスコープ</p>
<ul>
<li><code>RedirectAttributes</code>の<code>addFlashAttribute()</code>メソッドを使用して詰める</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"create"</span>, method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  @Validated AccountCreateForm form, BindingResult result,</span></span></span><br><span class="line"><span class="function"><span class="params">  RedirectAttributes redirectAttributes)</span> </span>&#123;</span><br><span class="line">    redirectAttributes.addFlashAttribute(form);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:/account/create?complete"</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-6-2-フォームクラスの作成"><a href="#5-6-2-フォームクラスの作成" class="headerlink" title="5.6.2 フォームクラスの作成"></a>5.6.2 フォームクラスの作成</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginFormRequestDto</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Serializableインターフェスを実装しておく。これが必要なのはオブジェクトをセッションスコープで管理する場合だが、スコープに関係なく定義しておくのが無難</li>
</ul>
<h3 id="5-7-入力チェック"><a href="#5-7-入力チェック" class="headerlink" title="5.7 入力チェック"></a>5.7 入力チェック</h3><ul>
<li>SpringMVCではBeanValidationの仕組みを利用して、リクエストパラメータ値がバインドされたフォームクラス（またはコマンドクラス）に対して入力チェックを行う</li>
</ul>
<h4 id="5-7-1-入力チェックの有効化"><a href="#5-7-1-入力チェックの有効化" class="headerlink" title="5.7.1 入力チェックの有効化"></a>5.7.1 入力チェックの有効化</h4><ul>
<li>入力チェックを行う場合、<ul>
<li>入力チェックを行うメソッドの引数にフォームクラスを定義して、<ul>
<li><code>@org.springframework.validation.annotation.Validated</code>または</li>
<li><code>@org.springframework.validation.annotation.Valid</code> を指定する<ul>
<li><code>@Validated</code>を使用すると、BeanValidationのバリデーショングループの仕組みが使用できるらしい</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="5-7-2-入力チェック結果の判定"><a href="#5-7-2-入力チェック結果の判定" class="headerlink" title="5.7.2 入力チェック結果の判定"></a>5.7.2 入力チェック結果の判定</h4><ul>
<li>BindingResultで処理する</li>
</ul>
<h4 id="5-7-3-未入力の扱い"><a href="#5-7-3-未入力の扱い" class="headerlink" title="5.7.3 未入力の扱い"></a>5.7.3 未入力の扱い</h4><ul>
<li><p>未入力は許容するが、入力された場合は６文字移譲であること</p>
<ul>
<li>という要件をBeanValidation標準アノテーションを使用して満たすことができない</li>
</ul>
</li>
<li><p>この場合は、Springが提供している<code>org.springframework.beans.propertyeditors.StringTrimerEditor</code>を使用することを検討</p>
</li>
<li><p>TODO: 普通に独自アノテーションを作成した方がシンプルなような気がする</p>
</li>
</ul>
<h4 id="5-7-5-ネスト下JavaBeansの入力チェック"><a href="#5-7-5-ネスト下JavaBeansの入力チェック" class="headerlink" title="5.7.5 ネスト下JavaBeansの入力チェック"></a>5.7.5 ネスト下JavaBeansの入力チェック</h4><ul>
<li><p>ネストしたJavaBeansやコレクション内のJavaBeansに定義したプロパティに対して入力チェックを行いたい場合は、<code>@Valid</code>を指定する</p>
<ul>
<li>チェック対象とすることを明示する必要がある</li>
</ul>
</li>
<li><p><code>@Valid</code>と<code>@Validated</code>の違い  </p>
<ul>
<li><a href="http://moondream.hatenablog.com/entry/20131006/1381031027" target="_blank" rel="noopener">http://moondream.hatenablog.com/entry/20131006/1381031027</a></li>
</ul>
</li>
</ul>
<h4 id="5-7-6-入力チェックルールの追加"><a href="#5-7-6-入力チェックルールの追加" class="headerlink" title="5.7.6 入力チェックルールの追加"></a>5.7.6 入力チェックルールの追加</h4><ul>
<li><p>独自の入力チェックツール追加方法２つ</p>
<ul>
<li>既成ルールを合成して作成する方法</li>
<li>独自のバリデータを実装して作成する方法</li>
</ul>
</li>
<li><p>既成ルールを合成して作成する方法</p>
<ul>
<li>→こっちは使った方がよい</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.RetentionPolicy.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.Constraint;</span><br><span class="line"><span class="keyword">import</span> javax.validation.Payload;</span><br><span class="line"><span class="keyword">import</span> javax.validation.ReportAsSingleViolation;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint</span>(validatedBy = &#123;&#125;)</span><br><span class="line"><span class="meta">@Target</span>(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER &#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RUNTIME)</span><br><span class="line"><span class="meta">@ReportAsSingleViolation</span></span><br><span class="line"><span class="meta">@Pattern</span>(regexp = <span class="string">"[a-zA-Z0-9]*"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AlphaNumeric &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "</span>&#123;validation.AlphaNumeric.message&#125;<span class="string">";</span></span><br><span class="line"><span class="string">  Class&lt;?&gt;[] groups() default &#123;&#125;;</span></span><br><span class="line"><span class="string">  Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  @Target(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER &#125;)</span></span><br><span class="line"><span class="string">  @Retention(RUNTIME)</span></span><br><span class="line"><span class="string">  @Documented</span></span><br><span class="line"><span class="string">  public @interface List &#123;</span></span><br><span class="line"><span class="string">    AlphaNumeric[] value();</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>メモ TODO: 覚えておく</p>
<ul>
<li>上の例では１つしか既成ルールを使用していないが、既成ルールを複数まとめた合成アノテーションを作成することもできる<ul>
<li>なお、既成ルールをまとめた合成アノテーションを作成する場合、<code>@ReportAsSingleViolation</code>も付与するのが一般的で、付与すると、message属性で指定したメッセージが利用される用になる。付与しない場合は、既成ルールに指定したメッセージが利用される</li>
</ul>
</li>
</ul>
</li>
<li><p>独自のバリデータを実装して作成する方法</p>
<ul>
<li>→冗長になりがちだと思うので作成しないほうが良いのでは？<ul>
<li>相関チェックも実装できそうだが、<code>@AssertTrue</code>を使用したほうがシンプル</li>
</ul>
</li>
</ul>
</li>
<li><p><code>@AssertTrue</code>の使用方法</p>
<ul>
<li><a href="https://qiita.com/t-iguchi/items/ea3dd8691d52d7abe695" target="_blank" rel="noopener">https://qiita.com/t-iguchi/items/ea3dd8691d52d7abe695</a></li>
</ul>
</li>
</ul>
<h4 id="5-7-7-入力チェックツールの切り替え"><a href="#5-7-7-入力チェックツールの切り替え" class="headerlink" title="5.7.7 入力チェックツールの切り替え"></a>5.7.7 入力チェックツールの切り替え</h4><ul>
<li>コントローラーのメソッドでパラメータ指定して、呼び出すメソッドを変更することで実現する例を記載している</li>
</ul>
<h4 id="5-7-8-エラー情報の表示"><a href="#5-7-8-エラー情報の表示" class="headerlink" title="5.7.8 エラー情報の表示"></a>5.7.8 エラー情報の表示</h4><ul>
<li><p><code>&lt;form:errors path=&quot;name&quot;&gt;</code></p>
<ul>
<li>このように記載することでエラー情報取れますよという説明がある</li>
</ul>
</li>
<li><p>エラーメッセージ要素の構成案</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"error-message d-none"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form:errors</span> <span class="attr">path</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">".error-message"</span>).forEach(<span class="function"><span class="params">el</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(el.innerText) el.classList.remove(<span class="string">"d-none"</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>みたいな感じにすればいいのではなかろうかと</li>
</ul>
<h4 id="5-7-9-エラーメッセージの解決"><a href="#5-7-9-エラーメッセージの解決" class="headerlink" title="5.7.9 エラーメッセージの解決"></a>5.7.9 エラーメッセージの解決</h4><ul>
<li><p>エラーメッセージの定義方法</p>
<ul>
<li>Springが提供するMessageSourceで読み込んだプロパティファイルにメッセージを定義する</li>
<li>BeanValidation管理のプロパティファイルにメッセージを定義する</li>
<li>制約アノテーションのmessage属性に直接メッセージを定義する</li>
</ul>
</li>
<li><p>Spring管理プロパティファイル</p>
<ul>
<li>制約アノテーションのクラス名＋「.」＋フォームオブジェクトの属性名＋「.」＋プロパティ名</li>
<li>制約アノテーションのクラス名＋「.」＋フォームオブジェクトの属性名</li>
<li>制約アノテーションのクラス名＋「.」＋プロパティ名</li>
<li>制約アノテーションのクラス名＋「.」＋プロパティの型名（FQCN）</li>
<li>制約アノテーションのクラス名</li>
</ul>
</li>
<li><p>BeanValidation管理のプロパティファイルにエラーメッセージを定義</p>
<ul>
<li>クラスパス直下のValidationMessages.propertiesにメッセージを定義する<ul>
<li>→あまり使用する機会無いのではと思う</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="5-7-10-BeanValidationのカスタマイズ"><a href="#5-7-10-BeanValidationのカスタマイズ" class="headerlink" title="5.7.10 BeanValidationのカスタマイズ"></a>5.7.10 BeanValidationのカスタマイズ</h4><ul>
<li>java configに設定<ul>
<li>→あまりメリットが理解できなかったのでスキップ</li>
</ul>
</li>
</ul>
<h4 id="5-7-11-Spring-Validatorの利用"><a href="#5-7-11-Spring-Validatorの利用" class="headerlink" title="5.7.11 Spring Validatorの利用"></a>5.7.11 Spring Validatorの利用</h4><ul>
<li>割愛</li>
</ul>
<h3 id="5-8-画面遷移"><a href="#5-8-画面遷移" class="headerlink" title="5.8 画面遷移"></a>5.8 画面遷移</h3><h4 id="5-8-1-遷移先の指定方法"><a href="#5-8-1-遷移先の指定方法" class="headerlink" title="5.8.1 遷移先の指定方法"></a>5.8.1 遷移先の指定方法</h4><ul>
<li>View名をHandlerメソッドの戻り値として返却することで実現</li>
</ul>
<h4 id="5-8-2-リクエストパスへのリダイレクト"><a href="#5-8-2-リクエストパスへのリダイレクト" class="headerlink" title="5.8.2 リクエストパスへのリダイレクト"></a>5.8.2 リクエストパスへのリダイレクト</h4><ul>
<li>View名に「redirect: + リダイレクト先のリクエストパス」</li>
<li>RedirectAttributesを使用してパラメータを設定する</li>
<li>パス変数を指定することもできる</li>
</ul>
<h4 id="5-8-3-リクエストパスへのフォワード"><a href="#5-8-3-リクエストパスへのフォワード" class="headerlink" title="5.8.3 リクエストパスへのフォワード"></a>5.8.3 リクエストパスへのフォワード</h4><ul>
<li>「forward: + 転送先のリクエストパス」</li>
<li><code>return &quot;forward:/auth/authenticate&quot;;</code></li>
<li>MEMO: 使い所が知りたい</li>
</ul>
<h4 id="5-8-4-Viewとのデータ連携"><a href="#5-8-4-Viewとのデータ連携" class="headerlink" title="5.8.4 Viewとのデータ連携"></a>5.8.4 Viewとのデータ連携</h4><ul>
<li>JavaオブジェクトをModelに格納する方法は、以下の２つがある<ul>
<li>ModelのAPIを直接呼び出す</li>
<li>ModelAttributeアノテーションを付与したメソッドを用意する</li>
</ul>
</li>
</ul>
<h4 id="5-8-5-リダイレクト先とのデータ連携"><a href="#5-8-5-リダイレクト先とのデータ連携" class="headerlink" title="5.8.5 リダイレクト先とのデータ連携"></a>5.8.5 リダイレクト先とのデータ連携</h4><ul>
<li>RedirectAttributesのフラッシュスコープの説明</li>
</ul>
<h3 id="5-9-Viewの解決"><a href="#5-9-Viewの解決" class="headerlink" title="5.9 Viewの解決"></a>5.9 Viewの解決</h3><ul>
<li>jspとかいろいろ使えるよ</li>
<li>JSP使うなら、ViewResolverRegistryに登録する必要があるよっていう説明</li>
</ul>
<h3 id="5-10-JSPの実装"><a href="#5-10-JSPの実装" class="headerlink" title="5.10 JSPの実装"></a>5.10 JSPの実装</h3><ul>
<li>JSP使用しないため割愛</li>
</ul>
<h3 id="5-11-SpringのHTMLフォーム用タグライブラリの利用"><a href="#5-11-SpringのHTMLフォーム用タグライブラリの利用" class="headerlink" title="5.11 SpringのHTMLフォーム用タグライブラリの利用"></a>5.11 SpringのHTMLフォーム用タグライブラリの利用</h3><ul>
<li>JSP使用しないため割愛</li>
</ul>
<h3 id="5-12-Springの汎用タグライブラリの利用"><a href="#5-12-Springの汎用タグライブラリの利用" class="headerlink" title="5.12 Springの汎用タグライブラリの利用"></a>5.12 Springの汎用タグライブラリの利用</h3><ul>
<li>Springで使用できるタグについて説明<ul>
<li>MEMO: 必要であれば読み返す</li>
<li>できるだけthymeleafだけの方が良いのではと思う</li>
</ul>
</li>
</ul>
<h3 id="5-13-例外ハンドリング"><a href="#5-13-例外ハンドリング" class="headerlink" title="5.13 例外ハンドリング"></a>5.13 例外ハンドリング</h3><h4 id="5-13-1-例外の種類"><a href="#5-13-1-例外の種類" class="headerlink" title="5.13.1 例外の種類"></a>5.13.1 例外の種類</h4><ul>
<li>Webアプリケーションで発生する例外は大きく３つある<ul>
<li>システム例外:処理を継続することができない例外<ul>
<li>アプリケーション自体のバグ</li>
<li>依存ライブラリのバグ</li>
<li>ミドルウェアやハードウェアの故障</li>
<li>システムリソースの枯渇</li>
<li>ネットワーク障害</li>
</ul>
</li>
<li>リクエスト不正を通知する例外：リクエストの内容が不正なときに発生する例外<ul>
<li>存在しないパスへのリクエスト</li>
<li>バインディングエラー</li>
<li>入力チェックエラー</li>
</ul>
</li>
<li>アプリケーション例外：ビジネスルールに違反したときに発生する例外<ul>
<li>ユーザー登録時のIDの重複エラー</li>
<li>排他エラー</li>
<li>在庫数の不足エラー</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="5-13-2-例外の発生箇所とハンドリング方法"><a href="#5-13-2-例外の発生箇所とハンドリング方法" class="headerlink" title="5.13.2 例外の発生箇所とハンドリング方法"></a>5.13.2 例外の発生箇所とハンドリング方法</h4><ul>
<li>以下の箇所で例外が発生する可能性があり、それぞれ例外ハンドリングの方法も異なる<ul>
<li><ol>
<li>Servlet Fileter</li>
</ol>
<ul>
<li>サーブレットコンテナへのエラーページ機能（web.xmlの<code>&lt;error-page&gt;</code>要素）を使用してエラー処理を実装する</li>
</ul>
</li>
<li><ol start="2">
<li>DispatcherServlet: SpringMVCが提供する例外ハンドリングの仕組み（HandlerExceptionResolver）</li>
</ol>
</li>
<li><ol start="3">
<li>アプリケーション(Controller, Service, Repositoryなど)：SpringMVCが提供する例外ハンドリングの仕組み（HandlerExceptionResolver）</li>
</ol>
</li>
<li><ol start="4">
<li>View（JSPなど）</li>
</ol>
<ul>
<li>Viewの中で発生した例外は、サーブレットコンテナのエラーページ機能を使用して絵r-あ処理を実装</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="5-13-3-サーブレットコンテナのエラーページ機能を利用"><a href="#5-13-3-サーブレットコンテナのエラーページ機能を利用" class="headerlink" title="5.13.3 サーブレットコンテナのエラーページ機能を利用"></a>5.13.3 サーブレットコンテナのエラーページ機能を利用</h4><ul>
<li><code>web.xml</code>に<code>error-page</code>を記載する方法を紹介</li>
</ul>
<h4 id="5-13-5-ExceprtionHandlerメソッドの利用"><a href="#5-13-5-ExceprtionHandlerメソッドの利用" class="headerlink" title="5.13.5 @ExceprtionHandlerメソッドの利用"></a>5.13.5 @ExceprtionHandlerメソッドの利用</h4><ul>
<li><p>複数のController間で共通の処理</p>
<ul>
<li><code>@ControllerAdvice</code>を用いる</li>
<li><a href="https://terasolunaorg.github.io/guideline/5.0.1.RELEASE/ja/ImplementationAtEachLayer/ApplicationLayer.html#id160" target="_blank" rel="noopener">https://terasolunaorg.github.io/guideline/5.0.1.RELEASE/ja/ImplementationAtEachLayer/ApplicationLayer.html#id160</a></li>
</ul>
</li>
<li><p><code>@ExceptionHandler</code>メソッドの引数</p>
<ul>
<li>Exception</li>
<li>HandlerMethod</li>
<li>java.util.Locale</li>
<li>java.util.Timezone</li>
<li>java.time.ZoneId</li>
<li>java.security.Principal</li>
</ul>
</li>
<li><p>戻り値について</p>
<ul>
<li>String</li>
<li>ModelAndView</li>
<li>void</li>
<li>ResponseEntity&lt;?&gt;</li>
</ul>
</li>
</ul>
<h4 id="5-13-6-ResponseStatusを指定した例外クラスの利用"><a href="#5-13-6-ResponseStatusを指定した例外クラスの利用" class="headerlink" title="5.13.6 @ResponseStatusを指定した例外クラスの利用"></a>5.13.6 @ResponseStatusを指定した例外クラスの利用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseStatus</span>(HttpStatus.NOT_FOUND)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceNotFoundException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">  <span class="comment">// *****</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>TODO: 独自Exceptionを作成していくべきかどうか</li>
</ul>
<h2 id="第6章-RESTful-Webサービスの開発"><a href="#第6章-RESTful-Webサービスの開発" class="headerlink" title="第6章　RESTful Webサービスの開発"></a>第6章　RESTful Webサービスの開発</h2><h3 id="6-1-REST-APIのアーキテクチャ"><a href="#6-1-REST-APIのアーキテクチャ" class="headerlink" title="6.1 REST APIのアーキテクチャ"></a>6.1 REST APIのアーキテクチャ</h3><ul>
<li>RESTは「REpresentational State Transfer」の略で、クライアントとサーバー間でデータをやり取りするアプリケーションを構築するためのアーキテクチャスタイルの１つ</li>
<li>最も重要なのは「リソース」という概念</li>
<li>REST APIはデータベースなどで管理している情報の中から、クライアントに提供する情報を「リソース」として抽出</li>
<li>抽出したリソースはWeb上に公開し、リソースにアクセスするための手段としてRESTAPIを用意します</li>
</ul>
<h4 id="6-1-1-Resouce-Oriented-Architecture-ROA"><a href="#6-1-1-Resouce-Oriented-Architecture-ROA" class="headerlink" title="6.1.1 Resouce Oriented Architecture (ROA)"></a>6.1.1 Resouce Oriented Architecture (ROA)</h4><h4 id="6-1-2-フレームワークのアーキテクチャ"><a href="#6-1-2-フレームワークのアーキテクチャ" class="headerlink" title="6.1.2 フレームワークのアーキテクチャ"></a>6.1.2 フレームワークのアーキテクチャ</h4><ul>
<li>割愛 TODO: 詳細を知りたくなったら読む</li>
</ul>
<h3 id="6-2-アプリケーションの設定"><a href="#6-2-アプリケーションの設定" class="headerlink" title="6.2 アプリケーションの設定"></a>6.2 アプリケーションの設定</h3><h4 id="6-2-1-ライブラリのセットアップ"><a href="#6-2-1-ライブラリのセットアップ" class="headerlink" title="6.2.1 ライブラリのセットアップ"></a>6.2.1 ライブラリのセットアップ</h4><ul>
<li>リソース形式としてJSONを使用する際に利用する「FasterXML Jackson Databind」を依存ライブラリに追加する<ul>
<li>MEMO: SpringBootだと不要みたい</li>
</ul>
</li>
</ul>
<h4 id="6-2-2-サーブレットコンテナの設定"><a href="#6-2-2-サーブレットコンテナの設定" class="headerlink" title="6.2.2 サーブレットコンテナの設定"></a>6.2.2 サーブレットコンテナの設定</h4><ul>
<li><p>HiddenHttpMethodFilterの適用</p>
<ul>
<li>RESTAPIを提供する場合、HTTPメソッドとして、PUT、PATCH、DELETEなども使用するが、</li>
<li>Webブラウザなどクライアントの実装によっては、GETとPOSTしか使用できなかったりする</li>
<li>そこをサポートするために<code>org.springframework.web.filter.HiddenHttpMethodFileter</code>クラスを利用する<ul>
<li><code>_method=put</code>というパラメータでリクエストが送られると、サーブレットコンテナ内で行われる処理はPUTメソッドでアクセスしたときとおなじになる</li>
</ul>
</li>
</ul>
</li>
<li><p>HttpMessageConverterのカスタマイズ</p>
<ul>
<li>MEMO: Converterの設定をしているが、SpringBootだと不要だと思うので飛ばす</li>
</ul>
</li>
</ul>
<h3 id="6-3-RestControllerの実装"><a href="#6-3-RestControllerの実装" class="headerlink" title="6.3 @RestControllerの実装"></a>6.3 @RestControllerの実装</h3><ul>
<li><p>大きく２つ種類がある</p>
<ul>
<li>メソッドシグネチャを参照してフロントコントローラが処理を行う「宣言型」の処理</li>
<li>Controllerクラスのメソッド内に処理を実装する「プログラミング型」の処理</li>
</ul>
</li>
<li><p>MEMO: クライアントへ返却するオブジェクトは共通で作成しているもの（クラス）を使用するのが良いと思った</p>
</li>
<li><p>以下、割愛</p>
</li>
</ul>
<h2 id="第7章-Spring-MVC-の応用"><a href="#第7章-Spring-MVC-の応用" class="headerlink" title="第7章　Spring MVC の応用"></a>第7章　Spring MVC の応用</h2><ul>
<li>SpringMVCの機能を利用したWebアプリケーションの開発方法を学びましたが、</li>
<li>典型的なWebアプリケーションの開発では、<ul>
<li>セッションの利用</li>
<li>ファイルアップロード</li>
<li>画面やメッセージの国際化</li>
<li>共通処理の適用</li>
<li>静的リソースのキャッシュ制御　などへの考慮も必要になる</li>
<li>非同期処理（SSE(Server-Sent Events)）</li>
</ul>
</li>
</ul>
<h3 id="7-1-HTTPセッションの利用"><a href="#7-1-HTTPセッションの利用" class="headerlink" title="7.1 HTTPセッションの利用"></a>7.1 HTTPセッションの利用</h3><ul>
<li>セッション管理する方法３つある<ul>
<li>セッション属性（@SessionAttributes）の使用</li>
<li>セッションスコープのBeanの利用</li>
<li>HttpSessionのAPIの利用</li>
</ul>
</li>
</ul>
<h4 id="7-1-1-セッション属性（-SessionAttributes）"><a href="#7-1-1-セッション属性（-SessionAttributes）" class="headerlink" title="7.1.1 セッション属性（@SessionAttributes）"></a>7.1.1 セッション属性（@SessionAttributes）</h4><ul>
<li>１つのController内で扱う複数のリクエスト間でデータを共有する場合に有効な方法<ul>
<li>入力画面が複数のページで構成される場合や、複雑な画面遷移を伴う場合は<code>@SessionAttributes</code>を使用することを検討</li>
</ul>
</li>
<li>シンプルな画面構成の場合（入力画面→確認画面→完了画面とかの場合）は、HTMLフォームのHiddenで値を持ち回る方法を検討すること</li>
</ul>
<h4 id="7-1-2-セッションスコープBean"><a href="#7-1-2-セッションスコープBean" class="headerlink" title="7.1.2 セッションスコープBean"></a>7.1.2 セッションスコープBean</h4><ul>
<li>複数のControllerをまたぐ画面遷移において、Controller間でデータを共有する場合に有効な方法</li>
</ul>
<h3 id="7-2-ファイルアップロード"><a href="#7-2-ファイルアップロード" class="headerlink" title="7.2 ファイルアップロード"></a>7.2 ファイルアップロード</h3><ul>
<li>SpringMVCでファイルをアップロードする場合は、以下のいずれかの方法を利用する<ul>
<li>Servlet標準のアップロード機能</li>
<li>ApacheCommonsFileUploadのアップロード機能</li>
</ul>
</li>
</ul>
<h4 id="7-2-2-ファイルアップロード機能のセットアップ"><a href="#7-2-2-ファイルアップロード機能のセットアップ" class="headerlink" title="7.2.2 ファイルアップロード機能のセットアップ"></a>7.2.2 ファイルアップロード機能のセットアップ</h4><ul>
<li><p>web.xmlに<code>&lt;multipart-config /&gt;</code>を追加するとのこと</p>
</li>
<li><p>Servlet標準のファイルアップロード機能をデフォルトのまま利用するとアップロードできるファイルのサイズに上限がないため、上限を設けたい場合は、ファイル単位の最大サイズ、アップロード時のリクエスト全体の最大サイズ、一時ファイル出力有無の閾値サイズの３つを指定する必要がある</p>
</li>
<li><p>上限に引っかかると、<code>MultipartException</code>が発生するので、Handlerでハンドリングすること</p>
</li>
<li><p>メモ</p>
<ul>
<li>SpringMVCのDispatcherServletより前にリクエストパラメータにアクセスする処理があると、MultipartExceptionが発生しない可能性がある</li>
<li>SpringWEBから提供されているフィルターを利用すると制御できるとのこと<ul>
<li>TODO: SpringBootだとどのように記載するか確認</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="7-2-3-アップロードデータの取得"><a href="#7-2-3-アップロードデータの取得" class="headerlink" title="7.2.3 アップロードデータの取得"></a>7.2.3 アップロードデータの取得</h4><ul>
<li><p>Formクラスの作成</p>
<ul>
<li>普通にFormクラスの作成 <code>MultipartFile</code>型で変数定義する</li>
</ul>
</li>
<li><p>Viewの作成</p>
<ul>
<li>input type&#x3D;”file”で作成して送るだけ</li>
</ul>
</li>
<li><p>Controller</p>
<ul>
<li>ファイルを取得して永続化操作</li>
</ul>
</li>
<li><p>Validation</p>
<ul>
<li>ファイルサイズや、コンテンツタイプ、ファイル名などをチェックする場合は、Validatorを作成してチェック</li>
</ul>
</li>
<li><p>TODO: 実際にアイコン画像などをDBで保持できる永続化ロジックまで書く</p>
</li>
</ul>
<h3 id="7-3-非同期リクエスト"><a href="#7-3-非同期リクエスト" class="headerlink" title="7.3 非同期リクエスト"></a>7.3 非同期リクエスト</h3><h4 id="7-3-1-非同期リクエストの仕組み"><a href="#7-3-1-非同期リクエストの仕組み" class="headerlink" title="7.3.1 非同期リクエストの仕組み"></a>7.3.1 非同期リクエストの仕組み</h4><ul>
<li><p>非同期実行が終了してからHTTPレスポンスを開始</p>
<ul>
<li>勘違いしやすいのが、HTTPレスポンスは非同期実行している処理が終了したあとに行うため、クライアント側から見ると、同期処理と同じ動作になる</li>
</ul>
</li>
<li><p>SpringMVCはこのパターンの非同期処理をサポートするために以下の２つの方法を提供</p>
<ul>
<li>SpringMVC管理のスレッドを使用した非同期処理</li>
<li>SpringMVC管理外のスレッドを使用した非同期処理</li>
</ul>
</li>
<li><p>非同期実行の処理中にHTTPレスポンスを開始</p>
<ul>
<li>ロングポーリングを使用した非同期処理</li>
<li>SSE（Server-Sent Events）に準拠した非同期処理</li>
</ul>
</li>
</ul>
<h4 id="7-3-2-非同期実行を有効にするための設定"><a href="#7-3-2-非同期実行を有効にするための設定" class="headerlink" title="7.3.2 非同期実行を有効にするための設定"></a>7.3.2 非同期実行を有効にするための設定</h4><ul>
<li>web.xmlに設定追記</li>
<li>java configにBean定義追加</li>
</ul>
<h4 id="7-3-3-非同期処理の実装"><a href="#7-3-3-非同期処理の実装" class="headerlink" title="7.3.3 非同期処理の実装"></a>7.3.3 非同期処理の実装</h4><ul>
<li><p>以下の２つの非同期処理の実装方法を紹介</p>
<ul>
<li>CompletableFutureを使用した非同期処理</li>
<li>SseEmitterを使用したPush型の非同期処理</li>
</ul>
</li>
<li><p><code>@Async</code>の利用</p>
<ul>
<li>本書で説明する非同期処理は、どちらもSpringMVC管理外のスレッドを使用した非同期処理</li>
<li>SpringFrameworkは、特定のメソッドを別スレッドで実行する仕組みを提供しており、別スレッドで実行したいメソッドに、<code>org.springframework.scheduling.annotation.Async</code>を付与するだけ</li>
</ul>
</li>
<li><p>MEMO: SpringBootでの利用に参考</p>
<ul>
<li><a href="https://qiita.com/mitsuya/items/c21907ab10919111e773" target="_blank" rel="noopener">https://qiita.com/mitsuya/items/c21907ab10919111e773</a></li>
</ul>
</li>
<li><p>CompletableFutureを使用した非同期処理の実装</p>
<ul>
<li><code>CoompletableFuture&lt;String&gt;</code>を返却する</li>
</ul>
</li>
<li><p>SseEmitterを使用したPush型の非同期処理の実装</p>
<ul>
<li><code>new SseEmitter();</code>でイベント処理を行う<ul>
<li>具体的な使用方法について説明なし</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="7-3-4-非同期実行の例外ハンドリング"><a href="#7-3-4-非同期実行の例外ハンドリング" class="headerlink" title="7.3.4 非同期実行の例外ハンドリング"></a>7.3.4 非同期実行の例外ハンドリング</h4><ul>
<li><code>DeferredResult</code>を使用して結果を設定する</li>
<li>TODO: 結果を非同期で画面に通知する方法確認</li>
</ul>
<h4 id="7-3-5-非同期実行に対する共通処理の実装"><a href="#7-3-5-非同期実行に対する共通処理の実装" class="headerlink" title="7.3.5 非同期実行に対する共通処理の実装"></a>7.3.5 非同期実行に対する共通処理の実装</h4><ul>
<li><p>CallableProcessingInterceptorもしくはDeferredResultProcessingInterceptorのAdopterを実装したクラスを作成</p>
</li>
<li><p>現在は、interfaceにデフォルトメソッドが定義できるようになったので、Adopterではなくて、interfaceの方を使用すべきとのことで、<code>@Deprecated</code>になっている</p>
</li>
<li><p><code>CallableProcessingInterceptor</code>インターフェース</p>
</li>
</ul>
<h3 id="7-4-共通処理の実装"><a href="#7-4-共通処理の実装" class="headerlink" title="7.4 共通処理の実装"></a>7.4 共通処理の実装</h3><p>ControllerのHandlerメソッドの呼び出し前後に共通処理を実行する方法について説明します。</p>
<h4 id="7-4-1-サーブレットフィルタの利用"><a href="#7-4-1-サーブレットフィルタの利用" class="headerlink" title="7.4.1 サーブレットフィルタの利用"></a>7.4.1 サーブレットフィルタの利用</h4><ul>
<li><p>SpringMVCの呼び出し前後に共通する処理を実行するには、<code>javax.servlet.Filter</code>インターフェースの実装クラスを作成する</p>
</li>
<li><p>Filterクラスを直接実装してもよいが、ここではSpringが提供しているサポートクラスを利用する方法を紹介</p>
</li>
<li><p>サポートクラス</p>
<ul>
<li><code>GenericFilterBean</code>クラス</li>
<li><code>OncePerRequestFilter</code>クラス</li>
</ul>
</li>
<li><p>DIコンテナで管理しているBeanのインジェクション方法</p>
<ul>
<li>サーブレットフィルター内の処理でDIコンテナ管理しているBeanを利用したい場合は、サーブレットフィルタをDIコンテナに登録し、DelegatingFilterProxy経由でサーブレットフィルタの処理を実行する</li>
<li>DelegatingFilterProxyは、SpringのDIコンテナに登録されているサーブレットフィルターに処理を移譲するサーブレットフィルタクラス</li>
</ul>
</li>
</ul>
<h4 id="7-4-2-HandlerInterceptorの利用"><a href="#7-4-2-HandlerInterceptorの利用" class="headerlink" title="7.4.2 HandlerInterceptorの利用"></a>7.4.2 HandlerInterceptorの利用</h4><ul>
<li><p>Controllerでハンドリングする処理に対してだけ共通処理を実行したい場合は、</p>
<ul>
<li><code>org.springframework.web.servlet.HndlerInterceptor</code>インターフェースの実装クラスを作成する</li>
</ul>
</li>
<li><p>メソッド</p>
<ul>
<li>preHandle：実行前</li>
<li>postHandle：例外時は呼び出されない</li>
<li>afterCompletion：実行後</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandler</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">      ModelAndView modelAndView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (log.isInfoEnabled()) &#123;</span><br><span class="line">      HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br><span class="line">      Method method = ((HandlerMethod) handler).getMethod();</span><br><span class="line">      log.info(<span class="string">"[SUCCESS CONTROLLER] &#123;&#125;.&#123;&#125;"</span>, method.getDeclaringClass().getSimpleName(), method.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">    registry.addInterceptor(<span class="keyword">new</span> LoggingInterceptor())</span><br><span class="line">            .addPathPatterns(<span class="string">"/**"</span>)</span><br><span class="line">            .excludePathPatterns(<span class="string">"/resources/**"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-4-3-ControllerAdviceの利用"><a href="#7-4-3-ControllerAdviceの利用" class="headerlink" title="7.4.3 @ControllerAdviceの利用"></a>7.4.3 @ControllerAdviceの利用</h4><ul>
<li>Controllerクラスには、Handlerメソッドとは別に、Controller専用の特殊なメソッド（<code>@InitBinder</code>メソッド、<code>@ModelAttribute</code>メソッド、<code>@ExceptionHandler</code>メソッド）を実装することができる</li>
<li>これらのメソッドを複数のControllerクラスで共有するには、<code>@ControllerAdvice</code>を付与したクラスを作成する</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping</span>(<span class="string">"/error"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">handleError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@ExceptionHandler</span>(Throwable.class)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">handleThrowable</span><span class="params">(Throwable exception, Model model)</span> </span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@ExceptionHandler</span>(Exception.class)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">handleException</span><span class="params">(Exception exception, Model model)</span> </span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@ExceptionHandler</span>(IOException.class)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">handleIOException</span><span class="params">(IOException exception, Model model)</span> </span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-4-4-HandlerMethodArgumentResolverの利用"><a href="#7-4-4-HandlerMethodArgumentResolverの利用" class="headerlink" title="7.4.4 HandlerMethodArgumentResolverの利用"></a>7.4.4 HandlerMethodArgumentResolverの利用</h4><ul>
<li>SpringMVCのデフォルトでサポートされていないオブジェクトをControllerのHandlerメソッドの引数に渡したい場合は、<code>org.springframework.web.method.support.HandlerMethodArgumentResolver</code>インターフェースの実装クラスを作成します。</li>
<li>あまり利用するシーンがわからないため割愛する</li>
</ul>
<h3 id="7-5-静的リソース"><a href="#7-5-静的リソース" class="headerlink" title="7.5 静的リソース"></a>7.5 静的リソース</h3><ul>
<li>ルートから任意のディレクトリに配置した静的リソースにアクセスできますという説明</li>
</ul>
<h4 id="7-5-1-デフォルトサーブレットとDispatcherServletの共存"><a href="#7-5-1-デフォルトサーブレットとDispatcherServletの共存" class="headerlink" title="7.5.1 デフォルトサーブレットとDispatcherServletの共存"></a>7.5.1 デフォルトサーブレットとDispatcherServletの共存</h4><ul>
<li>Servletの使用では、ルートパス（）にマッピングされたサーブレットのことを「デフォルトサーブレット」と呼び、デフォルトサーブレット経由でWebアプリケーションのドキュメントルート配下のファイルにアクセスすることができる</li>
<li>SpringMVCアプリケーションでは、DispatcherServletをルートパスにマッピングするスタイルを採用することがよくあるが、DispatcherServletをルートパスにマッピングすると、Webアプリケーションのドキュメントルート配下のファイルにアクセスできなくなってしまいます。</li>
<li>この動作を変更するには、SpringMVCが提供している「DispatcherServletで受けたリクエストをデフォルトサーブレットへ転送する機能」を有効化する必要がある</li>
</ul>
<h4 id="7-5-2-SpringMVC独自の静的リソース解決の仕組み"><a href="#7-5-2-SpringMVC独自の静的リソース解決の仕組み" class="headerlink" title="7.5.2 SpringMVC独自の静的リソース解決の仕組み"></a>7.5.2 SpringMVC独自の静的リソース解決の仕組み</h4><ul>
<li><p>HTTPのキャッシュ制御</p>
</li>
<li><p>ResourceResolverとResouceTransformerの利用</p>
<ul>
<li>ResourceHttpRequestHandlerには<ul>
<li>バージョン付き公開パスを使用した静的リソースへのアクセス</li>
<li>Gzip化された静的リソースへのアクセス</li>
<li>WebJars内の静的リソースのバージョン番号の隠蔽<ul>
<li>を行う機能がある</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>ResourceResolverインターフェース</p>
<ul>
<li>静的リソースにアクセスするための公開パス</li>
<li>サーバー上の物理的な静的リソースを相互に解決するためのメソッドを提供</li>
</ul>
</li>
<li><p>ResourceTransformerインターフェース</p>
<ul>
<li>静的リソースのコンテンツデータを書き換えるためのメソッドを提供</li>
</ul>
</li>
<li><p>バージョン付きの公開パスを使用した静的リソースへのアクセス</p>
</li>
<li><p>Thymeleafでのアクセス方法について確認する</p>
<ul>
<li>ここで紹介されていた<a href="https://ksoichiro.blogspot.com/2015/04/spring-boot_14.html" target="_blank" rel="noopener">https://ksoichiro.blogspot.com/2015/04/spring-boot_14.html</a></li>
<li><code>th:href=&quot;@{/css/main.css}&quot;</code>などと記載する</li>
</ul>
</li>
</ul>
<h3 id="7-6-国際化"><a href="#7-6-国際化" class="headerlink" title="7.6 国際化"></a>7.6 国際化</h3><h4 id="7-6-1-ロケールの解決"><a href="#7-6-1-ロケールの解決" class="headerlink" title="7.6.1 ロケールの解決"></a>7.6.1 ロケールの解決</h4><ul>
<li><p>アプリケーション内で扱うロケール解決には、<code>org.springframework.web.servlet.LocaleResolver</code>インターフェースを使用する</p>
</li>
<li><p>SpringMVCは、ロケールの保存場所に応じて以下の実装クラスを提供しており、デフォルトではAcceptHeaderLocaleResolverが有効になっている</p>
</li>
<li><p>提供されているLocaleResolverの実装クラス</p>
<ul>
<li>AcceptHeaderLocaleResolver</li>
<li>SessionLocaleResolver</li>
<li>CookieLocaleResolver</li>
<li>FixedLocaleResolver</li>
</ul>
</li>
<li><p>クライアントからロケールの指定がない場合、デフォルトロケールが利用され、</p>
<ul>
<li>LocaleResolverに指定したデフォルトロケール</li>
<li>JVMに指定したロケール</li>
<li>OSに指定したロケール<ul>
<li>の順番で解決されます。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="7-6-2-ロケールの利用"><a href="#7-6-2-ロケールの利用" class="headerlink" title="7.6.2 ロケールの利用"></a>7.6.2 ロケールの利用</h4><ul>
<li>VIEWからロケールにアクセスするときはSpringのタグを使用する</li>
<li>Handlerメソッドからロケールにアクセスするときは引数にLocaleを指定する</li>
<li>Handler以外の場所からロケールにアクセスするときは、RequestContextUtilsのgetLocaleメソッドを使用する</li>
</ul>
<h4 id="7-6-3-UIを使用したロケールの切り替え"><a href="#7-6-3-UIを使用したロケールの切り替え" class="headerlink" title="7.6.3 UIを使用したロケールの切り替え"></a>7.6.3 UIを使用したロケールの切り替え</h4><ul>
<li><p>画面などのUIを使用してロケールを切り替える方法について説明</p>
</li>
<li><p>ロケールの切り替えは、<code>org.springframework.web.servlet.i18n.LocaleChangeInterceptor</code>を利用することで簡単に行うことができる</p>
</li>
<li><p>LocaleResolverのBean定義</p>
</li>
<li><p>LocaleChangeInterceptorのBean定義</p>
</li>
<li><p>ロケール切り替え用の画面要素の表示</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"?locale=en"</span>&gt;</span>English<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"?locale=ja"</span>&gt;</span>Japanese<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>このリンクをクリクすると、LocaleChangeInterceptorが呼び出され、<br>リクエストパラメータで指定されたロケールがSpringMVCアプリケーションに反映される</p>
<h2 id="第8章-Spring-Test"><a href="#第8章-Spring-Test" class="headerlink" title="第8章　Spring Test"></a>第8章　Spring Test</h2><ul>
<li><p>本章では、SpringFrameworkが提供するテスト支援モジュールを利用して、Springアプリケーションに対してテストを行う方法について解説していく</p>
</li>
<li><p>紹介を行うテスト</p>
<ul>
<li>DIコンテナに登録したBeanへのテスト</li>
<li>データベースアクセスを伴う処理へのテスト</li>
<li>SpringMVC上で動くControllerへのテスト</li>
</ul>
</li>
<li><p>第９章では、SpringSecurityの機能を利用した処理へのテストを紹介</p>
</li>
</ul>
<h3 id="8-1-Spring-Testとは"><a href="#8-1-Spring-Testとは" class="headerlink" title="8.1 Spring Testとは"></a>8.1 Spring Testとは</h3><ul>
<li><p>Spring Testとは</p>
<ul>
<li>Spring Framework上で動かすために作成したクラスのテストを支援するモジュール</li>
</ul>
</li>
<li><p>単体テスト</p>
<ul>
<li>テスト対象のクラス内で実装しているロジックのみをテスト</li>
<li>単体テストを行う際には、テスト対象のクラスの中で依存している他のコンポーネントはモックやスタブを使用し、実行結果が他のコンポーネントの実装内容に左右されないようにする</li>
</ul>
</li>
<li><p>結合テスト</p>
<ul>
<li>基本的にモックやスタブは使わず、プロダクション環境で使用するクラスを結合してテストを行います。</li>
<li>ポイントは、システムやアプリケーション全体が正しく動作するかを検証するのではなく、開発者が作成したクラスがSpringのフレームワーク上で正しく動作するかをテストするという点</li>
</ul>
</li>
<li><p>提供されている機能</p>
<ul>
<li>JUnitやTestNGといったテスティングフレームワーク上でのSpringのDIコンテナを動かす機能</li>
<li>トランザクション制御をテスト向けに最適化する機能</li>
<li>アプリケーションサーバーを使わずにSpringMVCの動作を再現する機能</li>
<li>テストデータをセットアップするためのSQLを実行する機能</li>
<li>RestTemplateを使用したHTTP通信に対してモックレスポンスを返却する機能</li>
</ul>
</li>
</ul>
<h3 id="8-2-DIコンテナ管理のBeanに対するテスト"><a href="#8-2-DIコンテナ管理のBeanに対するテスト" class="headerlink" title="8.2 DIコンテナ管理のBeanに対するテスト"></a>8.2 DIコンテナ管理のBeanに対するテスト</h3><ul>
<li>junitを使用する前提で説明</li>
</ul>
<h4 id="8-2-1-Beanの単体テスト"><a href="#8-2-1-Beanの単体テスト" class="headerlink" title="8.2.1 Beanの単体テスト"></a>8.2.1 Beanの単体テスト</h4><ul>
<li><p>Serviceクラスをテスト</p>
</li>
<li><p>依存しているコンポーネントはできるだけモック化することを検討する</p>
<ul>
<li>外部ファイル参照サービスやDBアクセスなど</li>
</ul>
</li>
</ul>
<h4 id="8-2-2-DIコンテナ内のBeanに対する結合テスト"><a href="#8-2-2-DIコンテナ内のBeanに対する結合テスト" class="headerlink" title="8.2.2 DIコンテナ内のBeanに対する結合テスト"></a>8.2.2 DIコンテナ内のBeanに対する結合テスト</h4><ul>
<li>Springの機能を使用して、DIコンテナ内のリソースを取得してテストを行う</li>
<li>単体テストは本当にクラス単体の観点なのに対して、結合テストはプロジェクト内のリソースを結合したテストとみなしている</li>
</ul>
<h4 id="8-2-3-Spring-Testcontext-Framework"><a href="#8-2-3-Spring-Testcontext-Framework" class="headerlink" title="8.2.3 Spring Testcontext Framework"></a>8.2.3 Spring Testcontext Framework</h4><ul>
<li>他のランナーとSpringを併用したい場合は、<code>@ClassRule</code>と<code>@Rule</code>を使用すれば実現できるという説明</li>
<li>TODO: 使用するランナーによって何が違うのかを後で確認する必要ある</li>
</ul>
<h4 id="8-2-4-DIコンテナのコンフィギュレーション"><a href="#8-2-4-DIコンテナのコンフィギュレーション" class="headerlink" title="8.2.4 DIコンテナのコンフィギュレーション"></a>8.2.4 DIコンテナのコンフィギュレーション</h4><p>DIコンテナを作成するには、<br><code>@org.springframework.test.context.ContextConfiguration</code>をテストクラスケースに付与する</p>
<ul>
<li><p>デフォルトのBean定義ファ入りう</p>
</li>
<li><p>Webアプリケーション向けのDIコンテナのコンフィギュレーション</p>
<ul>
<li><code>@WebApplicationConfiguration</code>付与について説明<ul>
<li>Webアプリケーション向けのDIコンテナに加えて、</li>
<li>ServletAPIに依存する各種モックオブジェクトなどをテストケースクラスにインジェクションできる</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="8-2-5-DIコンテナのライフサイクル制御"><a href="#8-2-5-DIコンテナのライフサイクル制御" class="headerlink" title="8.2.5 DIコンテナのライフサイクル制御"></a>8.2.5 DIコンテナのライフサイクル制御</h4><ul>
<li><p>Spring TestContext Framework上に生成されたDIコンテナは、テスト実行時のJavaVMが終了するまでキャッシュされ、必要に応じてテストケース間で共有される仕組みになっています。</p>
</li>
<li><p>DIコンテナのキャッシュ</p>
<ul>
<li>デフォルトの動作では、同一テストケースクラスのテストメソッドで同じDIコンテナが使われる</li>
<li>さらにテストケースクラスが別の場合でも、<code>@ContextConfiguration</code>などに指定した属性値が同じであれば、キャッシュ済みのDIコンテナが利用される</li>
</ul>
</li>
<li><p>DIコンテナの破棄</p>
<ul>
<li>割愛…TODO: 実際のテストケースの組み方について調査する必要あり</li>
</ul>
</li>
</ul>
<h4 id="8-2-6-プロファイルの指定"><a href="#8-2-6-プロファイルの指定" class="headerlink" title="8.2.6 プロファイルの指定"></a>8.2.6 プロファイルの指定</h4><ul>
<li>Springのプロファイル機能を使用しているアプリケーションに対してテストを行う場合は、<code>@org.springframework.test.context.ActiveProfiles</code>を使う</li>
</ul>
<h4 id="8-2-7-テスト用のプロパティ値の指定"><a href="#8-2-7-テスト用のプロパティ値の指定" class="headerlink" title="8.2.7 テスト用のプロパティ値の指定"></a>8.2.7 テスト用のプロパティ値の指定</h4><ul>
<li><p>テスト用のプロパティ値を設定できる</p>
<ul>
<li><code>@org.springframework.test.context.TestPropertySource</code>を使う</li>
</ul>
</li>
<li><p>プロパティ値の指定には２つの方法がある</p>
<ul>
<li>アノテーションに直接指定する</li>
<li>プロパティファイルに指定する</li>
</ul>
</li>
</ul>
<h3 id="8-3-データベースアクセスを伴う処理のテスト"><a href="#8-3-データベースアクセスを伴う処理のテスト" class="headerlink" title="8.3 データベースアクセスを伴う処理のテスト"></a>8.3 データベースアクセスを伴う処理のテスト</h3><ul>
<li>データベースへアクセスするBeanに対するテスト方法について説明</li>
<li>データベースにアクセスするBeanに対してテストを行う場合、以下の作業が必要になる<ul>
<li>テスト用のデータソースの設定</li>
<li>テストデータのセットアップ</li>
<li>テストケース用のトランザクション制御</li>
<li>テーブルの中身の検証</li>
</ul>
</li>
</ul>
<h4 id="8-3-1-テスト用のデータソースの設定"><a href="#8-3-1-テスト用のデータソースの設定" class="headerlink" title="8.3.1 テスト用のデータソースの設定"></a>8.3.1 テスト用のデータソースの設定</h4><ul>
<li>Test用のConfigクラスを作成して、既存のコンフィグクラスを上書きする説明</li>
</ul>
<h4 id="8-3-2-テストデータのセットアップ"><a href="#8-3-2-テストデータのセットアップ" class="headerlink" title="8.3.2 テストデータのセットアップ"></a>8.3.2 テストデータのセットアップ</h4><ul>
<li><code>@Sql</code>を使用すると、テストケース・メソッドの呼び出し前に任意のSLQを実行できる</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sqlを付与することで、テストメソッド実行前に任意のSQL文を実行することができる</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Sql</span>(&#123; <span class="string">"/account-delete.sql"</span>, <span class="string">"/account-insert-data.sql"</span> &#125;)</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">testFindOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Account account = accountRepositry.findOne(<span class="string">"001"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>メモ<ul>
<li><code>@Sql</code>にはJavaSE8で追加された<code>@Repeatable</code>が付与されているため、JavaSE8以降を使う場合は同じ箇所に複数指定できる<ul>
<li>JavaSE7以前のJavaでも、<code>@org.springframework.test.context.jdbc.SqlGroup</code>を使うことで、複数のSQLを指定できる</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="8-3-3-テストケース用のトランザクション制御"><a href="#8-3-3-テストケース用のトランザクション制御" class="headerlink" title="8.3.3 テストケース用のトランザクション制御"></a>8.3.3 テストケース用のトランザクション制御</h4><ul>
<li><p>デフォルトではテストデータをセットアップする際に使用するトランザクションと、</p>
</li>
<li><p>テスト対象のデータアクセス処理で使用するトランザクションは別々になってしまう</p>
</li>
<li><p>テストが途中で失敗して、レコードが更新されてしまったり、データの状態が変わってしまうため注意が必要</p>
</li>
<li><p>このような事故を防ぐには、JUnit専用のデータベースを用意しておくと確実</p>
</li>
<li><p>ローカルなんかも優位だと思う</p>
</li>
<li><p>あるいは、SpringTestが提供しているテスト用のトランザクション制御の仕組みを利用して防ぐこともできる</p>
</li>
<li><p>トランザクション境界の移動</p>
<ul>
<li>SpringTestでは、、JUnit実行時のトランザクション境界を、テストケースメソッドの呼び出し前に移動する仕組みを提供している。</li>
<li>この仕組を利用すると、<code>@Sql</code>で指定したSQLファイルの実行とテストを同一のトランザクション内で行うことができる</li>
<li><code>@Transactional</code>をクラス、メソッドに指定する</li>
</ul>
</li>
<li><p>トランザクション境界でのロールバック&#x2F;コミットの制御</p>
<ul>
<li>処理が完了したあと、ロールバックするのではなくコミットしたい場合、<code>@Commit</code>を付与すれば実現できる</li>
</ul>
</li>
<li><p>永続コンテキストをフラッシュ</p>
<ul>
<li>JPAやHibernateがEntityへの更新操作を永続コンテキストと呼ばれるインメモリ領域に蓄積しておき、トランザクションのコミット時にSQLを発行する仕組みになっているため、明示的にSQLが発行されるようにフラッシュする必要がある</li>
</ul>
</li>
</ul>
<h4 id="8-3-4-テーブルの中身の検証"><a href="#8-3-4-テーブルの中身の検証" class="headerlink" title="8.3.4 テーブルの中身の検証"></a>8.3.4 テーブルの中身の検証</h4><ul>
<li>JdbcTemplateを使用して検証する</li>
<li>DIコンテナに入っている同じオブジェクトを使用すること</li>
</ul>
<h3 id="8-4-Spring-MVC-のテスト"><a href="#8-4-Spring-MVC-のテスト" class="headerlink" title="8.4 Spring MVC のテスト"></a>8.4 Spring MVC のテスト</h3><ul>
<li><p>SpringMVC上で動くControllerに対するテスト方法について説明</p>
</li>
<li><p>Controllerに対するテストの話をするときにいつも出てくる話題がある</p>
<ul>
<li>→「Controllerに対する単体テストは必要か？」という話題</li>
</ul>
</li>
<li><p>Controllerの主な役割は、</p>
<ul>
<li>リクエストマッピング</li>
<li>入力チェック</li>
<li>リクエストデータの取得</li>
<li>ビジネスロジックの呼び出し</li>
<li>遷移先の制御</li>
</ul>
</li>
<li><p>これらは、SpringMVCのフレームワークと結合しないと妥当性を検証することができないので、単体テストではなく、結合テストとして行ったほうがよい</p>
</li>
<li><p>では、SpringMVCのフレームワーク機能と結合した状態でControllerをテストするにはどうすればよいのでしょうか？</p>
</li>
<li><p>最もオーソドックスな選択肢は、Webアプリケーションをアプリケーションサーバーにデプロイし、E2E（End to End）テストとして実施する方法</p>
</li>
<li><p>E2Eテストとして実施すると、Viewが生成したレスポンスデータの妥当性を検証できるのがメリット</p>
</li>
<li><p>一方、以下のようなデメリットがある</p>
<ul>
<li>アプリケーションサーバーやデータベースの起動が必須となる</li>
<li>トランザクションがコミットされるため、テスト実施前の状態に戻すことができない</li>
<li>回帰テストを実行するために、Seleniumなどを利用したテストケースの実装が必要になる</li>
<li>Seleniumを使うと、テストの実行時間が長くなる</li>
</ul>
</li>
<li><p>SpringTestはE2Eテストのデメリットを解消しつつ、SpringMVCのフレームワーク機能と結合した状態でControllerをテストするためのプラットフォームとして、<code>org.springframework.test.web.servlet.MockMvc</code>というクラスを提供している</p>
</li>
</ul>
<h4 id="8-4-1-MockMvcとは"><a href="#8-4-1-MockMvcとは" class="headerlink" title="8.4.1 MockMvcとは"></a>8.4.1 MockMvcとは</h4><ul>
<li><p>アプリケーションサーバー上にデプロイせず、SpringMVCの動作を再現する仕組みを提供するクラス</p>
</li>
<li><p>流れ</p>
<ol>
<li>テストケース・メソッドは、DispatcherServletにリクエストするデータ（リクエストパスやリクエストパラメータなど）をセットアップする</li>
<li>MockMvcは、DispatcherServletに対して擬似的なリクエストを行う。実際に使われるDispatcherServletは、テスト用に拡張されている、<code>org.springframework.test.web.servlet.TestDipacherSevlet</code>となる</li>
<li>DispatcherServletは、リクエスト内容に一致するHandlerのメソッドを呼び出す</li>
<li>テストケースメソッドは、MockMvcが返却する実行結果を受け取り、実行結果の妥当性を検証する</li>
</ol>
</li>
<li><p>動作モードには２つある</p>
<ul>
<li>ユーザー指定のDIコンテナと連携するモード</li>
<li>スタンドアロンモード</li>
</ul>
</li>
<li><p>SpringMVCのコンフィギュレーションも含めてテストしたい場合、ユーザー指定のDIコンテナと連携するモードを利用すること</p>
</li>
<li><p>メモ</p>
<ul>
<li>本書では扱わないが、SpringTestは、MockMvcとHtmlUnitを連携する機能も提供している</li>
<li>HtmlUnitと連携することで、テンプレートエンジンが生成したHTMLを検証することができる</li>
<li>さらに、SeleniumWebDriverやGebと連携すると、Page Object Patternを活用した可読性および再利用性の高いテストケースを記載することも可能</li>
<li>TODO: あとで確認してみる</li>
</ul>
</li>
</ul>
<h4 id="8-4-2-MockMvcのセットアップ"><a href="#8-4-2-MockMvcのセットアップ" class="headerlink" title="8.4.2 MockMvcのセットアップ"></a>8.4.2 MockMvcのセットアップ</h4><ul>
<li><p>ユーザー指定のDIコンテナと連携するモード</p>
</li>
<li><p>スタンドアロンモード</p>
<ul>
<li>SpringMVCのコンフィギュレーションはSpringTest側が行い、SpringTestが生成したDIコンテナを使用してSpringMVCの動作を再現</li>
</ul>
</li>
<li><p>サーブレットフィルタの追加</p>
<ul>
<li>MockMvcには、サーブレットフィルタを追加することができる</li>
</ul>
</li>
<li><p>staticメソッドのインポート</p>
<ul>
<li>テストを書く前に、MockMvcを使用したテストをサポートしてくれるstaticメソッドをインポートします。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// よく使用するstaticメソッド</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultHandlers.*;</span><br></pre></td></tr></table></figure>

<h4 id="8-4-3-テストの実行"><a href="#8-4-3-テストの実行" class="headerlink" title="8.4.3 テストの実行"></a>8.4.3 テストの実行</h4><ul>
<li>テストを実行する際は、Controllerを呼び出すために必要なリクエストデータをセットアップし、MockMvcにリクエストの実行依頼を行います。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHome</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  mockMvc.perform(get(<span class="string">"/"</span>))</span><br><span class="line">      .andExpect(status().isOk())</span><br><span class="line">      .andExpect(forwardedUrl(<span class="string">"/WEB-INF/index.jsp"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-4-4-リクエストデータのセットアップ"><a href="#8-4-4-リクエストデータのセットアップ" class="headerlink" title="8.4.4 リクエストデータのセットアップ"></a>8.4.4 リクエストデータのセットアップ</h4><ul>
<li>リクエストデータのセットアップは、<ul>
<li><code>org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder</code></li>
<li><code>org.springframework.test.web.servlet.request.MockMultipartHttpServletRequestBuilder</code></li>
<li>のファクトリメソッドを使用して行います。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBooks</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  mockMvc.perform(get(<span class="string">"/books"</span>)</span><br><span class="line">      .param(<span class="string">"name"</span>, <span class="string">"Spring"</span>)</span><br><span class="line">      .accept(MediaType.APPLICATION_JSON)</span><br><span class="line">      .header(<span class="string">"X-Track-Id"</span>, UUID.randomUUID().toString()))</span><br><span class="line">      .andExpect(status().isOk());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-4-5-実行結果の検証"><a href="#8-4-5-実行結果の検証" class="headerlink" title="8.4.5 実行結果の検証"></a>8.4.5 実行結果の検証</h4><ul>
<li><p>MockMvcResultMathcersの主なメソッド</p>
<ul>
<li>status</li>
<li>header</li>
<li>cookie</li>
<li>content</li>
<li>view</li>
<li>forwardedUrl</li>
<li>redirectedUrl</li>
<li>model</li>
<li>flash</li>
<li>request</li>
</ul>
</li>
<li><p>メモ</p>
<ul>
<li>ResultMatcherでサポートされていない検証を行いたい場合は、以下のいずれかの方法で検証ロジックを実装する<ul>
<li>独自のResultMatcherを作成する</li>
<li>ResultActionsのandReturnメソッドを呼び出して、MvcResultを取得し、テストケース内で検証ロジックを実装する</li>
</ul>
</li>
<li>MEMO: 検証ロジックを複数のテストケースで共有したい場合は、ResultMatcherを作成すること</li>
</ul>
</li>
</ul>
<h4 id="8-4-6-実行結果の出力"><a href="#8-4-6-実行結果の出力" class="headerlink" title="8.4.6 実行結果の出力"></a>8.4.6 実行結果の出力</h4><ul>
<li>実行結果をログなどに出力する場合は、<code>org.springframework.test.web.servlet.ResultActions</code>の<code>andDo</code>メソッドを使用する</li>
<li>andDoメソッドの引数には、実行結果に対して、任意の処理を行う<code>org.springframewok.test.web.servlet.ResultHandler</code>を指定する</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(get(<span class="string">"/books"</span>))</span><br><span class="line">    .andExpect(status().isOk())</span><br><span class="line">    .andDo(log());</span><br></pre></td></tr></table></figure>

<ul>
<li>log: 実行結果をデバッグレベルでログ出力する</li>
<li>pring: 実行結果を任意の出力先に出力する</li>
</ul>
<h2 id="第9章-Spring-Security"><a href="#第9章-Spring-Security" class="headerlink" title="第9章　Spring Security"></a>第9章　Spring Security</h2><ul>
<li><p>SpringSecurityの「セットアップ方法」と「アーキテクチャ」について説明したあと、</p>
</li>
<li><p>セキュリティ対策の基本となる</p>
<ul>
<li>「認証」と「認可」、</li>
</ul>
</li>
<li><p>さらにセキュリティを強化するために必要となる</p>
<ul>
<li>「CSRF対策」</li>
<li>「セッション管理」</li>
<li>「ブラウザのセキュリティ対策機能との連携（セキュリティヘッダーの出力）」について説明</li>
</ul>
</li>
<li><p>最後に、SpringSecurityが提供する支援モジュールを使用して、セキュリティ対策が正しく適用されているかをテストする方法についても紹介</p>
</li>
</ul>
<h3 id="9-1-SpringSecurityとは"><a href="#9-1-SpringSecurityとは" class="headerlink" title="9.1 SpringSecurityとは"></a>9.1 SpringSecurityとは</h3><ul>
<li>アプリケーションにセキュリティ対策機能を実装する際に使用するフレームワーク</li>
</ul>
<h4 id="9-1-1-SpringSecurityの特徴"><a href="#9-1-1-SpringSecurityの特徴" class="headerlink" title="9.1.1 SpringSecurityの特徴"></a>9.1.1 SpringSecurityの特徴</h4><ul>
<li>豊富なオプションの提供<ul>
<li>SpringSecurityのデフォルト実装の動作をカスタマイズするためのオプションが豊富に提供されている</li>
<li>このため、デフォルトの動作がセキュリティ要件に合致しない場合であっても、オプションの値を変更することで要件にあった動作に変更できるケースがある</li>
</ul>
</li>
<li>豊富な拡張ポイントの提供<ul>
<li>SpringSecurityは動作をカスタマイズするための拡張ポイントを豊富に提供します。</li>
<li>SpringSecurityのデフォルト実装を使って要件を満たせない場合は、拡張クラスを作成することで要件にあった動作にカスタマイズすることができます。</li>
</ul>
</li>
</ul>
<h4 id="9-1-2-基本機能"><a href="#9-1-2-基本機能" class="headerlink" title="9.1.2 基本機能"></a>9.1.2 基本機能</h4><ul>
<li><p>セキュリティ対策の基本機能として「認証機能」と「認可機能」の２つを提供しています。</p>
</li>
<li><p>認証機能：アプリケーションを利用するユーザーの正当性を確認する機能を提供する</p>
</li>
<li><p>認可機能：アプリケーションが提供するリソースや処理に対するアクセスを制御する機能を提供する</p>
</li>
</ul>
<h4 id="9-1-3-強化機能"><a href="#9-1-3-強化機能" class="headerlink" title="9.1.3 強化機能"></a>9.1.3 強化機能</h4><ul>
<li><p>SpringSecurityでは認証と認可という基本機能に加え、</p>
</li>
<li><p>Webアプリケーションのセキュリティを強化するための機能をいくつか提供している</p>
</li>
<li><p>セキュリティ対策の強化機能</p>
<ul>
<li>セッション管理機能</li>
<li>CSRF対策機能</li>
<li>ブラウザのセキュリティ対策機能との連携機能</li>
<li>※他にある！TODO: 他のセキュリティ機能も確認しておく</li>
</ul>
</li>
</ul>
<h3 id="9-2-Spring-Securityのセットアップ"><a href="#9-2-Spring-Securityのセットアップ" class="headerlink" title="9.2 Spring Securityのセットアップ"></a>9.2 Spring Securityのセットアップ</h3><h4 id="9-2-1-ライブラリのセットアップ"><a href="#9-2-1-ライブラリのセットアップ" class="headerlink" title="9.2.1 ライブラリのセットアップ"></a>9.2.1 ライブラリのセットアップ</h4><ul>
<li>pom.xmlに設定を追加する手順の説明</li>
</ul>
<h4 id="9-2-2-SpringSecurityのBean定義"><a href="#9-2-2-SpringSecurityのBean定義" class="headerlink" title="9.2.2 SpringSecurityのBean定義"></a>9.2.2 SpringSecurityのBean定義</h4><p>SpringSecurityのコンポーネントをBean定義します</p>
<ul>
<li>コンフィギュレーションクラスの作成</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SpringSecurityが提供しているコンフィギュレーションクラスがインポートされ、SpringSecurityを利用するために必要となるコンポーネントのBean定義が自動で行われる仕組み</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123; <span class="comment">// 継承すると、デフォルトで適用されるBean定義を簡単にカスタマイズすることができる</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// セキュリティ対策が不要なリソースがある場合、SpringSecurityの処理を適用しないようにする</span></span><br><span class="line">    web.ignoring().antMatchers(<span class="string">"/resources/**"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>web.xmlへの設定追加方法説明<ul>
<li>TODO: SpringBootだと必要？</li>
</ul>
</li>
</ul>
<h4 id="9-2-3-サーブレットフィルタの設定"><a href="#9-2-3-サーブレットフィルタの設定" class="headerlink" title="9.2.3 サーブレットフィルタの設定"></a>9.2.3 サーブレットフィルタの設定</h4><ul>
<li><p>最後に、SpringSecurityが提供しているサーブレットフィルタクラス（FilterChainProxy）をサーブレットコンテナに登録する</p>
</li>
<li><p>TODO: SpringBootだとConfigでフィルター追加する</p>
<ul>
<li><a href="https://qiita.com/R-STYLE/items/61a3b6a678cb0ff00edf" target="_blank" rel="noopener">https://qiita.com/R-STYLE/items/61a3b6a678cb0ff00edf</a></li>
<li><a href="https://qiita.com/opengl-8080/items/c105152c9ca48509bd0c" target="_blank" rel="noopener">https://qiita.com/opengl-8080/items/c105152c9ca48509bd0c</a></li>
</ul>
</li>
<li><p>メモ</p>
<ul>
<li>Sevlet3.0以降のサーブレットコンテナでは、サーブレットコンテナの初期化処理をJavaのコードで行うことができる</li>
<li>SpringSecurityでは、サーブレットコンテナの初期化処理をJavaを使って行うためのサポートクラス説いて、</li>
<li><code>AbstractSecurityWebApplicationInitializer</code>という抽象クラスを提供しています</li>
<li>以下の初期化処理を自動で行ってくれる<ul>
<li>ContextLoaderListenerをサーブレットコンテナに登録する処理</li>
<li>SpringSecurityのサーブレットフィルタクラスをサーブレットコンテナに登録する処理</li>
<li>参考：<a href="https://qiita.com/opengl-8080/items/c105152c9ca48509bd0c" target="_blank" rel="noopener">https://qiita.com/opengl-8080/items/c105152c9ca48509bd0c</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="9-3-Spring-Security-のアーキテクチャ"><a href="#9-3-Spring-Security-のアーキテクチャ" class="headerlink" title="9.3 Spring Security のアーキテクチャ"></a>9.3 Spring Security のアーキテクチャ</h3><ul>
<li><p>各機能の詳細な説明を行う前に、SpringSecurityのアーキテクチャ概要とSpringSecurityを構成する主要なコンポーネントの役割を見ていく</p>
</li>
<li><p>メモ</p>
<ul>
<li>ここで紹介する内容は、SpringSecurityが提供するデフォルトの動作をそのまま利用する場合や、</li>
<li>SpringSecurityのコンフィギュレーションをサポートする仕組みを利用する場合は、開発者が直接意識する必要ない</li>
<li>そのため、まず各機能の使い方を知りたい場合は、本説を読み飛ばしてOK</li>
<li>カスタマイズする際に必要になってくるので、アーキテクトを目指す方は一読しておくことをおすすめします。</li>
</ul>
</li>
</ul>
<h4 id="9-3-1-Spring-Securityのモジュール構成"><a href="#9-3-1-Spring-Securityのモジュール構成" class="headerlink" title="9.3.1 Spring Securityのモジュール構成"></a>9.3.1 Spring Securityのモジュール構成</h4><ul>
<li><p>提供しているモジュールを紹介</p>
</li>
<li><p>コンポーネントの役割などに応じてモジュール分割されており、標準的なWebアプリケーションに対してセキュリティ対策を講じる際に必要となるモジュールは以下の４つになる</p>
<ul>
<li><code>spring-security-core</code>: 認証と認可機能を実現するためのコアなコンポーネントが格納されている</li>
<li><code>spring-security-web</code>: Webアプリケーションのセキュリティ対策を実現するためのコンポーネントが格納されている</li>
<li><code>spring-security-config</code>: 各モジュールから提供されているコンポーネントのセットアップをサポートするためのコンポーネント（Java ConfigをサポートするクラスやXMLネームスペースを解析するクラスなど）が格納されている</li>
<li><code>spring-security-taglibs</code>: 認証情報や認可機能にアクセスするためのJSPタグライブラリが格納されている</li>
</ul>
</li>
<li><p>本書で使い方を紹介しないが、上記以外にも以下のようなモジュールがある</p>
<ul>
<li>一般的に利用される認証方法（LDAP、OpenID、CASなど）をサポートするためのモジュール</li>
<li>ACL（AccessControlList）を使用したドメインオブジェクトの認可制御を行うモジュール</li>
<li>SpringのWebSocket機能に対してセキュリティ対策を追加するためのモジュール</li>
<li>SpringSecurityの機能を用いる処理に対するテストを支援するためのモジュール</li>
</ul>
</li>
<li><p>メモ</p>
<ul>
<li>SpringSecurityのモジュールではないが、OAuth2.0の仕組みを使用してAPIの認可を実現するためのモジュール（spring-security-oauth2）などが姉妹ライブラリとして提供されている</li>
</ul>
</li>
</ul>
<h4 id="9-3-2-フレームワークのアーキテクチャ"><a href="#9-3-2-フレームワークのアーキテクチャ" class="headerlink" title="9.3.2 フレームワークのアーキテクチャ"></a>9.3.2 フレームワークのアーキテクチャ</h4><ul>
<li><p>処理の流れ</p>
<ol>
<li>クライアントはWebアプリケーションに対してリクエストを送る</li>
<li>SpringSecurityのFilterChainProxyクラスがリクエストを受け取り、HttpFirewallインターフェースのメソッドを呼び出して、HttpServletRequestとHttpServletResponseに対してファイアウォール機能を組み込む</li>
<li>FilterChainProxyクラスはSecurityFilterChainに設定されているセキュリティ対策用のSecurityFilterクラスに処理を移譲する</li>
<li>SecurityFilterChainには複数のSecurityFilterが設定されており、SecurityFilterの処理が正常に終了すると皇族のSecurityFilterが呼び出される</li>
<li>最後のSecurityFilterの処理が正常に終了した場合、後続処理を呼び出し、Webアプリケーション内のリソースへアクセスする</li>
<li>FilterChainProxyクラスは、Webアプリケーションから返却されたリソースをクライアントに返却する</li>
</ol>
</li>
<li><p>FilterChainProxy</p>
<ul>
<li>FilterChainProxyクラスは、フレームワーク処理のエントリーポイントとなるサーブレットフィルタクラス</li>
<li>このクラスはフレームワーク処理の全体の流れを制御し、具体的なセキュリティ対策処理はSecurityFilterに移譲するスタイルとなっている</li>
</ul>
</li>
<li><p>HttpFirewall</p>
<ul>
<li>HttpFirewallインターフェースは、HttpServletRequestとHttpServletResponseに対して、ファイアウォール機能を組み込むためのインターフェースです。デフォルトでは、DefaultHttpFirewallクラスが使用され、ディレクトリトラバーサル攻撃や、不正なリダイレクト先の指定によるHTTPレスポンス分割攻撃に対するチェックなどが実装されている</li>
</ul>
</li>
<li><p>SecurityFilterChain</p>
<ul>
<li>SecurityFilterChainインターフェースは、FilterChainProxyが受け取ったリクエストに対して適用する「SecurityFilterリスト」を管理するためのインターフェース</li>
<li>デフォルトではDefaultSecurityFilterChainクラスが使用され、以下のようなBean定義を行うと、指定したパスパターンごとに異なるセキュリティ対策が適用できます。</li>
</ul>
</li>
<li><p>Security Filter</p>
<ul>
<li>SecurityFilterクラスは、フレームワーク機能やセキュリティ対策機能を提供するサーブレットフィルタクラスです。</li>
<li>SpringSecurityは、複数のSecurityFilterを連鎖させることで、Webアプリケーションのセキュリティ対策を行う仕組みになっています。</li>
</ul>
</li>
<li><p>コアなSecurityFilter</p>
<ul>
<li>SecurityContextPersistenceFilter</li>
<li>UsernamePasswordAuthenticationFilter</li>
<li>LogoutFilter</li>
<li>FilterSecurityInterceptor</li>
<li>ExceptionTranslationFilter</li>
</ul>
</li>
</ul>
<h3 id="9-4-認証処理の適用"><a href="#9-4-認証処理の適用" class="headerlink" title="9.4 認証処理の適用"></a>9.4 認証処理の適用</h3><ul>
<li><p>認証処理は、アプリケーションを利用するユーザーの正当性を確認するための処理</p>
</li>
<li><p>最も標準的な方法はアプリケーションを使用できるユーザーをデータストアに登録しておいて、利用者が入力した認証情報と照合する方法</p>
</li>
<li><p>利用者に認証情報を入力してもらう方式もいくつかあり、</p>
<ul>
<li>HTMLの入力フォームを使う方式</li>
<li>RFCで定められているHTTP標準の認証方式（BASIC認証やDigest認証など）を利用するのが一般的</li>
<li>OpenID認証、シングルサインオン認証などの認証方式を利用するケースもある</li>
</ul>
</li>
<li><p>本節では、HTMLの入力フォームで入力した認証情報とリレーショナルデータベースに格納されているユーザー情報を照合して認証処理を行う実装例を紹介しながら、SpringSecurityの認証機能を解説</p>
</li>
</ul>
<h4 id="9-4-1-認証処理の仕組み"><a href="#9-4-1-認証処理の仕組み" class="headerlink" title="9.4.1 認証処理の仕組み"></a>9.4.1 認証処理の仕組み</h4><ul>
<li><p>認証処理の流れ</p>
<ol>
<li>クライントは認証処理を行うパスに対して資格情報（ユーザー名とパスワード）を指定してリクエストを送信する</li>
<li>Authentication Filterはリクエストから資格情報を取得し、AuthenticationManagerクラスの認証処理を呼び出す</li>
<li>ProviderManager（デフォルトで使用されるAuthenticationManagerの実装クラス）は、実際の認証処理をAuthenticationProviderインターフェースの実装クラスに移譲する</li>
</ol>
</li>
<li><p>メモ</p>
<ul>
<li>Authentication FilterとAuthenticationProviderの実装クラスは複数用意されており、要件に合わせて使用するクラスを選択する仕組みになっている</li>
<li>TODO: 選択できるクラスについて確認</li>
</ul>
</li>
<li><p>Authentication Filter</p>
<ul>
<li>認証方式に対する実装を提供するサーブレットフィルタ</li>
<li>本書では、フォーム認証用のサーブレットフィルタクラス（UsernamePasswordAuthenticationFilter）をシヨすうる前提で説明しますが、SpringSecurityはBasic認証、Digest認証、Remember Me 認証用のサーブレットフィルタクラスも提供しています</li>
</ul>
</li>
<li><p>AuthenticationManager</p>
<ul>
<li>認証処理を実行するためのインターフェース</li>
<li>SpringSecurityが提供するデフォルトの実装（ProviderManager）では、実際の認証処理はAuthenticationProviderに移譲し、AuthenticationProviderで行われた認証処理結果をハンドリングする仕組みになっています。</li>
</ul>
</li>
<li><p>AuthenticationProvider</p>
<ul>
<li>認証処理の実装をて依拠するためのインターフェース</li>
<li>本書では、データストアに登録しているユーザーの資格情報とユーザーの状態をチェックして認証処理を行う実装クラス（DaoAuthenticationProvider）を使用する前提で説明しますが、SpringSecurityは認証方法別の実装クラスも提供している。<ul>
<li>※DBだけでなく他の認証方式にも対応しているという意味だと理解</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="9-4-2-フォーム認証"><a href="#9-4-2-フォーム認証" class="headerlink" title="9.4.2 フォーム認証"></a>9.4.2 フォーム認証</h4><ul>
<li><p>SpringSecurityは以下のような流れでフォーム認証を行う</p>
<ol>
<li>クライアントは、フォーム認証を行うパスに対して資格情報（ユーザー名とパスワード）をリクエストパラメータとして送信する</li>
<li>UsernamePasswordAuthenticationFilterクラスは、リクエストパラメータから資格情報を取得して、AuthenticationManagerの認証処理を呼び出す</li>
<li>UsernamePasswordAuthenticationFilterクラスは、AuthenticationManagerから返却された認証結果をハンドリングする。認証処理が成功した場合は、AuthenticationSuccessHandlerのメソッドを、認証処理が失敗した場合は、AuthenticationFailureHandlerのメソッドを呼び出し、画面遷移を行う</li>
</ol>
</li>
<li><p>フォーム認証の適用</p>
<ul>
<li>Bean定義</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SpringSecurityが提供しているコンフィギュレーションクラスがインポートされ、SpringSecurityを利用するために必要となるコンポーネントのBean定義が自動で行われる仕組み</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123; <span class="comment">// 継承すると、デフォルトで適用されるBean定義を簡単にカスタマイズすることができる</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// セキュリティ対策が不要なリソースがある場合、SpringSecurityの処理を適用しないようにする</span></span><br><span class="line">    web.ignoring().antMatchers(<span class="string">"/resources/**"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ★追加！！</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.formLogin();</span><br><span class="line">    <span class="comment">// formLoginメソッドを呼び出すと、フォーム認証が有効になり、FormLoginConfigurerのインスタンスが返却される。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>デフォルトの動作</p>
<ul>
<li>SpringSecurityのデフォルトの動作では、<code>/login</code>に対して、GETメソッドでアクセスするとSpringSecurityが用意しているデフォルトのログインフォームが表示され、ログインボタンを謳歌すると<code>/login</code>に対してPOSTメソッドでアクセスして認証処理を行います。</li>
</ul>
</li>
<li><p>ログインフォームの作成</p>
<ul>
<li>SpringSecurityは、フォーム認証用のログインフォームをデフォルトで提供しているが、そのまま利用するケースは殆どないと思う</li>
<li>ここでは、自身で作成したログインフォームをSpringSecurityに適用する方法を紹介する</li>
<li>まず、ログインフォームを表示するためのJSPを作成</li>
<li>ここでは、SpringMVCのViewResolverに指定しているベースパス（src&#x2F;main&#x2F;webapp&#x2F;views&#x2F;）の直下にJSPを配置し、SpringMVC経由でログインフォームを表示する前提で説明</li>
</ul>
</li>
<li><p>ログインフォームをSpringSecurityに適用するために以下のようなBean定義を行う</p>
<ol>
<li>loginPageメソッドを呼び出し、ログインフォームを表示するためのパスを指定する<ul>
<li>匿名のユーザーが認証を必要するリソースにアクセスした場合、ここで指定したパスにリダイレクトしてログインフォームを表示する仕組みになっている。loginPageメソッドに与えられた引数によって、認証パス（loginProcessingUrl）も連動して変わる</li>
</ul>
</li>
<li>permitAll()メソッドを呼び出して、すべてのユーザーに対してログインフォームへのアクセス件を付与する</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">//    http.addFilter(this.preAuthenticatedProcessingFilter());</span></span><br><span class="line">  <span class="comment">//    http.formLogin();</span></span><br><span class="line">  http.formLogin()</span><br><span class="line">      .loginPage(<span class="string">"/login"</span>) <span class="comment">// 認証を必要とするURLに遷移した場合、このURLにリダイレクトしてログインフォームを表示する仕組み</span></span><br><span class="line">      .permitAll(); <span class="comment">// すべてのユーザーに対してログインフォームへのアクセス件を付与する</span></span><br><span class="line">  http.authorizeRequests()</span><br><span class="line">      .anyRequest()</span><br><span class="line">      .authenticated();</span><br><span class="line">  <span class="comment">// formLoginメソッドを呼び出すと、フォーム認証が有効になり、FormLoginConfigurerのインスタンスが返却される。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>デフォルト動作のカスタマイズ<ul>
<li>フォーム認証処理のカスタマイズポイントとして<ul>
<li>認証パス</li>
<li>資格情報を送るリクエストパラメータ名の変更方法を紹介</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http.formLogin()</span><br><span class="line">    <span class="comment">//.loginPage("/login")</span></span><br><span class="line">    .loginProcessingUrl(<span class="string">"authenticate"</span>)</span><br><span class="line">    .usernameParameter(<span class="string">"uid"</span>)</span><br><span class="line">    .passwordParameter(<span class="string">"pwd"</span>)</span><br><span class="line">    .permitAll();</span><br></pre></td></tr></table></figure>

<ul>
<li>loginPageもloginProcessingUrlもやっていることは同じらしい<ul>
<li><a href="http://www.ne.jp/asahi/hishidama/home/tech/java/spring/boot/web/form-auth.html" target="_blank" rel="noopener">http://www.ne.jp/asahi/hishidama/home/tech/java/spring/boot/web/form-auth.html</a></li>
</ul>
</li>
</ul>
<h4 id="9-4-3-認証成功時のレスポンス"><a href="#9-4-3-認証成功時のレスポンス" class="headerlink" title="9.4.3 認証成功時のレスポンス"></a>9.4.3 認証成功時のレスポンス</h4><ul>
<li><p>SpringSecurityは、認証成功時のレスポンスを制御するためのコンポーネントとして、AuthenticationSuccessHandlerというインターフェースと実装クラスを提供している</p>
</li>
<li><p>AuthenticationSuccessHandlerの実装クラス</p>
<ul>
<li>SavedRequestAwareAuthenticationSuccessHanlder: 認証前にアクセスを試みたURLにリダイレクト（デフォルト）</li>
<li>SimpleUrlAuthenticastionSuccessHandler: コンストラクタに指定したURLにリダイレクトまたはフォワードする</li>
</ul>
</li>
<li><p>デフォルトの動作</p>
<ul>
<li>認証前にアクセスを拒否したリクエストをHTTPセッションに保存しておいて、認証が成功した際にアクセスを拒否したリクエストを復元してリダイレクトする仕組みになっている</li>
</ul>
</li>
<li><p>デフォルト動作のカスタマイズ</p>
<ul>
<li>認証成功時のレスポンスのカスタマイズポイントとして、認証成功時に遷移するデフォルトのパスの変更方法を紹介</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http.formLogin()</span><br><span class="line">    .loginPage(<span class="string">"/login"</span>) <span class="comment">// 認証を必要とするURLに遷移した場合、このURLにリダイレクトしてログインフォームを表示する仕組み</span></span><br><span class="line">    .defaultSuccessUrl(<span class="string">"/menu"</span>) <span class="comment">// 認証成功時のデフォルトアクセスはルート。カスタマイズするために記載</span></span><br><span class="line">    .permitAll(); <span class="comment">// すべてのユーザーに対してログインフォームへのアクセス件を付与する</span></span><br></pre></td></tr></table></figure>

<h4 id="9-4-5-データベース認証"><a href="#9-4-5-データベース認証" class="headerlink" title="9.4.5 データベース認証"></a>9.4.5 データベース認証</h4><ul>
<li><p>データベース認証の仕組み</p>
<ul>
<li>SpringSecurityはクライアントからの認証依頼を受け、DaoAuthenticationProviderの認証処理を呼び出す</li>
<li>DaoAuthenticationProviderは、UserDetailsServiceのユーザー情報取得処理を呼び出す</li>
<li>UserDetailsServiceの実装クラスは、データストアからユーザー情報を取得する</li>
<li>UserDetailsServiceの実装クラスは、データストアから取得したユーザー情報からUserDetailsを生成する</li>
<li>DaoAuthenticationProviderは、UserDetailsServiceから返却されたUserDetailsとクライアントが指定した認証情報との照合を行い、クライアントが指定したユーザーの正当性をチェックする。クライアントが指定したユーザーが正当なユーザーでない場合は、認証例外をスローする</li>
</ul>
</li>
<li><p>メモ</p>
<ul>
<li>SpringSecurityはユーザー情報をリレーショナルデータベースからJDBC経由で取得するための実装クラスを提供しているが、最低限の認証処理しか行わないため、そのまま利用できるケースは少ないと思われる</li>
<li>そのため本書では、UserDetailsとUserDetailsServiceの実装クラスを作成する方法を紹介します。</li>
</ul>
</li>
<li><p>UserDetailsの作成</p>
<ul>
<li>MEMO:※細かいのでソースを確認 後で追記</li>
</ul>
</li>
<li><p>認証処理の適用</p>
</li>
</ul>
<h4 id="9-4-6-パスワードのハッシュ化"><a href="#9-4-6-パスワードのハッシュ化" class="headerlink" title="9.4.6 パスワードのハッシュ化"></a>9.4.6 パスワードのハッシュ化</h4><ul>
<li>いくつか、パスワードを扱う実装クラスが提供されている</li>
<li>MEMO:※細かいのでソースを確認 後で追記</li>
</ul>
<h4 id="9-4-7-認証イベントのハンドリング"><a href="#9-4-7-認証イベントのハンドリング" class="headerlink" title="9.4.7 認証イベントのハンドリング"></a>9.4.7 認証イベントのハンドリング</h4><ul>
<li><p>SpringSecurityは、SpringFrameworkが提供しているイベント通知の仕組みを利用して、</p>
</li>
<li><p>認証処理の結果を他のコンポーネントへ連携する仕組みを提供しています</p>
</li>
<li><p>この仕組を利用すると以下のようなセキュリティ要件をSpringSecurityの認証機能に組み込むことができます</p>
<ul>
<li>認証成功、失敗などの認証履歴をデータベースやログに保存したい</li>
<li>パスワードを連続して誤った場合にアカウントをロックしたい</li>
</ul>
</li>
<li><p>認証イベントの通知は以下のような仕組みで行われる</p>
</li>
<li><p>認証イベントの通知の流れ</p>
<ol>
<li>SpringSecurityの認証機能は、認証結果をAuthenticationEventPublisherに渡して認証イベントの通知依頼を行う</li>
<li>AuthenticationEventPublisherインターフェースのデフォルトの実装クラスは、認証結果に対応する認証イベントクラスのインスタンスを生成し、ApplicationEventPublisherに渡してイベントの通知依頼を行う</li>
<li>ApplicationEventPublisherインターフェースの実測クラスは、ApplicationListenerインターフェースの実装クラスにイベントを通知する</li>
<li>ApplicationListenerの実装クラスの１つであるApplicationListenerMethodAdaptorは、<code>@org.springframework.context.event.EventLintener</code>が付与されているメソッドを呼び出してイベントを通知する</li>
</ol>
</li>
<li><p>メモ</p>
<ul>
<li>Spring4.1まではApplicationListenerインターフェースの実装クラスを作成して、イベントを受け取る必要があった</li>
<li>Spring4.2からは、POJOに<code>@EventListener</code>を付与したメソッドを実装するだけでイベントを受け取ることができる</li>
<li>Spring4.2以降も、従来と同じ用にApplicationListenerインターフェースの実装クラスを作成してイベントを受け取ることができる</li>
</ul>
</li>
<li><p>認証成功イベント</p>
<ul>
<li>認証が成功したときにSpringSecurityが通知する主なイベントは以下の３つです。</li>
<li>この３つのイベントは途中でエラーが発生しなければ、以下の順番ですべて通知されます<ul>
<li>AuthenticationSuccessEvent<ul>
<li>AuthenticationProviderによる認証処理が成功したことを通知する。</li>
<li>このイベントをハンドリングすると、クライアントが正しい認証情報を指定したことを検知することができるが、後続の認証処理でエラーになる可能性がある</li>
</ul>
</li>
<li>SessionFixationProtectionEvent<ul>
<li>セッション固定攻撃対策の処理（セッションIDの変更処理）が成功したことを通知する。このイベントをハンドリングすると、変更後のセッションIDを検知することができる</li>
</ul>
</li>
<li>InteractiveAuthenticationSuccessEvent<ul>
<li>認証処理がすべて成功したことを通知する。このイベントをハンドリングすると、画面遷移を除くすべての認証処理が成功したことを検知することができる</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>認証失敗イベント</p>
<ul>
<li>認証が失敗したときにSpringSecurityが通知する主なイベントは以下の通り</li>
<li>認証に失敗した場合は、以下のいずれか１つのイベントが通知される<ul>
<li>AuthenticationFailureBadCredentialsEvent</li>
<li>AuthenticationFailureDisabledEvent</li>
<li>AuthenticationFailureLockedEvent</li>
<li>AuthenticationFailureExpiredEvent</li>
<li>AuthenticationFailureCredentialsExpiredEvent</li>
<li>AuthenticationFailureServiceExceptionEvent</li>
</ul>
</li>
</ul>
</li>
<li><p>イベントリスナの作成</p>
<ul>
<li>認証イベントの通知を受け取って処理を行いたい場合、<code>@EventListener</code>を付与したメソッドを実装したクラスを作成し、DIコンテナに登録するだけ</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * - 認証イベントの通知の流れ</span></span><br><span class="line"><span class="comment"> *    1. SpringSecurityの認証機能は、認証結果をAuthenticationEventPublisherに渡して認証イベントの通知依頼を行う</span></span><br><span class="line"><span class="comment"> *    2. AuthenticationEventPublisherインターフェースのデフォルトの実装クラスは、認証結果に対応する認証イベントクラスのインスタンスを生成し、ApplicationEventPublisherに渡してイベントの通知依頼を行う</span></span><br><span class="line"><span class="comment"> *    3. ApplicationEventPublisherインターフェースの実測クラスは、ApplicationListenerインターフェースの実装クラスにイベントを通知する</span></span><br><span class="line"><span class="comment"> *    4. ApplicationListenerの実装クラスの１つであるApplicationListenerMethodAdaptorは、`<span class="doctag">@org</span>.springframework.context.event.EventLintener`が付与されているメソッドを呼び出してイベントを通知する</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - `<span class="doctag">@EventLitener</span>`を付与したメソッドを実装するだけで認証成功/失敗時の処理を実装できる仕組み</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Tomo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppSecurityEventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ==============================</span></span><br><span class="line">  <span class="comment">//  SUCCESS EVENT HANDLERS</span></span><br><span class="line">  <span class="comment">// ==============================</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * AuthenticationProviderによる認証処理が成功したことを通知する。</span></span><br><span class="line"><span class="comment">   * このイベントをハンドリングすると、クライアントが正しい認証情報を指定したことを検知することができるが、</span></span><br><span class="line"><span class="comment">   * 後続の認証処理でエラーになる可能性がある。</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@EventListener</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleAuthenticationSuccess</span><span class="params">(AuthenticationSuccessEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * セッション固定攻撃対策の処理（セッションIDの変更処理）が成功したことを通知する。</span></span><br><span class="line"><span class="comment">   * このイベントをハンドリングすると、変更後のセッションIDを検知することができる。</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@EventListener</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleSessionFixationProtection</span><span class="params">(SessionFixationProtectionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 認証処理がすべて成功したことを通知する。</span></span><br><span class="line"><span class="comment">   * このイベントをハンドリングすると、画面遷移を除くすべての認証処理が成功したことを検知することができる。</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@EventListener</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleInteractiveAuthenticationSuccess</span><span class="params">(InteractiveAuthenticationSuccessEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ==============================</span></span><br><span class="line">  <span class="comment">//  FAILURE EVENT HANDLERS</span></span><br><span class="line">  <span class="comment">// ==============================</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@EventListener</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleBadCredentials</span><span class="params">(AuthenticationFailureBadCredentialsEvent event)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"BAD Credentials is detected. username : &#123;&#125;"</span>, event.getAuthentication().getName());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@EventListener</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDisabled</span><span class="params">(AuthenticationFailureDisabledEvent event)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"Disabled user is detected. username : &#123;&#125;"</span>, event.getAuthentication().getName());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@EventListener</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleLocked</span><span class="params">(AuthenticationFailureLockedEvent event)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"Locked user is detected. username : &#123;&#125;"</span>, event.getAuthentication().getName());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@EventListener</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleExpired</span><span class="params">(AuthenticationFailureExpiredEvent event)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"Expired user is detected. username : &#123;&#125;"</span>, event.getAuthentication().getName());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@EventListener</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleCredentialsExpired</span><span class="params">(AuthenticationFailureCredentialsExpiredEvent event)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"CredentialsExpired is detected. username : &#123;&#125;"</span>, event.getAuthentication().getName());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@EventListener</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleServiceException</span><span class="params">(AuthenticationFailureServiceExceptionEvent event)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"ServiceException is detected. username : &#123;&#125;"</span>, event.getAuthentication().getName());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-4-8-ログアウト"><a href="#9-4-8-ログアウト" class="headerlink" title="9.4.8 ログアウト"></a>9.4.8 ログアウト</h4><ul>
<li><p>SpringSecurityは以下のような流れでログアウト処理を行う</p>
<ol>
<li>クライアントは、ログアウト処理を行うためのパスにリクエストを送信する</li>
<li>LogoutFilterは、LogoutHandlerのメソッドを呼び出してログアウト処理を行う</li>
<li>LogoutFilterは、LogoutSuccessHandlerのメソッドを呼び出して画面遷移を行う</li>
</ol>
</li>
<li><p>LogoutHandlerの実装クラス</p>
<ul>
<li>SecurityContextLogoutHandler: 認証情報のクリアとセッションの破棄を行う</li>
<li>CookieClearingLogoutHandler: 指定したクッキーの削除するためのレスポンスを行う</li>
<li>CsrfLogoutHandler: CSRF対策用のトークンの破棄を行う</li>
</ul>
</li>
<li><p>こららのLogoutHandlerは、SpringSecurityが提供しているBean定義をサポートするクラスが自動でLogoutFilterに設定する仕組みになっているので、基本的にはアプリケーションの開発者が直接意識する必要はない</p>
</li>
<li><p>ログアウト処理の適用</p>
<ul>
<li>ログアウト処理を適用するには、以下のようなBean定義を行う必要がある</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">http.authorizeRequests()</span><br><span class="line">    .antMatchers(<span class="string">"/"</span>, <span class="string">"/find"</span>, <span class="string">"/login"</span>, <span class="string">"/signup"</span>, <span class="string">"/error"</span>, <span class="string">"/login-error"</span>).permitAll()</span><br><span class="line">    .anyRequest().authenticated()</span><br><span class="line">    .and()</span><br><span class="line">    <span class="comment">// Login処理</span></span><br><span class="line">    .formLogin()</span><br><span class="line">    .loginPage(<span class="string">"/login"</span>) <span class="comment">// 認証を必要とするURLに遷移した場合、このURLにリダイレクトしてログインフォームを表示する仕組み</span></span><br><span class="line">    .defaultSuccessUrl(<span class="string">"/menu"</span>) <span class="comment">// 認証成功時のデフォルトアクセスはルート。カスタマイズするために記載</span></span><br><span class="line">    .failureUrl(<span class="string">"/login"</span>) <span class="comment">// 認証失敗時ログイン画面に戻す</span></span><br><span class="line">    .usernameParameter(<span class="string">"id"</span>)</span><br><span class="line">    .passwordParameter(<span class="string">"password"</span>)</span><br><span class="line">    .and()</span><br><span class="line">    <span class="comment">// Logout処理</span></span><br><span class="line">    .logout()</span><br><span class="line">    .logoutRequestMatcher(<span class="keyword">new</span> AntPathRequestMatcher(<span class="string">"logout**"</span>))</span><br><span class="line">    .logoutSuccessUrl(<span class="string">"/login"</span>)</span><br><span class="line">    .permitAll(); <span class="comment">// すべてのユーザーに対してログインフォームへのアクセス件を付与する</span></span><br></pre></td></tr></table></figure>

<ul>
<li>デフォルトの動作のカスタマイズ<ul>
<li>遷移先を変える <code>logoutSuccessUrl</code>の引数を変えてあげる</li>
</ul>
</li>
</ul>
<h4 id="9-4-10-認証情報へのアクセス"><a href="#9-4-10-認証情報へのアクセス" class="headerlink" title="9.4.10 認証情報へのアクセス"></a>9.4.10 認証情報へのアクセス</h4><ul>
<li><p>認証済みのユーザーの認証情報は、SpringSecurityのデフォルト実装では、セッションに格納される</p>
</li>
<li><p>セッションに格納された認証情報は、リクエストごとにSecurityContextPersistenceFilterクラスによって</p>
</li>
<li><p>SecurityContextHolderというクラスに格納され、同一スレッド内であればどこからでもアクセスすることができる用になる</p>
</li>
<li><p>Javaからのアクセス</p>
<ul>
<li>一般的な業務アプリケーションでは、「いつ」「誰が」「どのデータに」「どのようなアクセスをしたか」を</li>
<li>記録する監査ログを取得することがある。この要件を実現する際の、「誰が」は、認証情報から取得できる</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 認証情報（Authenticationオブジェクト）を取得する</span></span><br><span class="line">Authentication authentication =</span><br><span class="line">    SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line"></span><br><span class="line">String userUuid = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// Authentication#getPrincipal()メソッドを呼び出して、UserDetailsオブジェクトを取得する</span></span><br><span class="line"><span class="comment">// 認証済みでない場合は、匿名ユーザーを表す文字列が返却されるので注意</span></span><br><span class="line"><span class="keyword">if</span> (authentication.getPrincipal() <span class="keyword">instanceof</span> AccountUserDetails) &#123;</span><br><span class="line">    AccountUserDetails userDetails = AccountUserDetails.class.cast(authentication.getPrincipal());</span><br><span class="line">    <span class="comment">// UserDetailsから処理に必要な情報を取得する</span></span><br><span class="line">    userUuid = userDetails.getAccount().getUserUuid();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>アノテーションでアクセスした方が良さそう</p>
<ul>
<li><a href="https://qiita.com/Hyuga-Tsukui/items/81990938e43c7dff35cf" target="_blank" rel="noopener">https://qiita.com/Hyuga-Tsukui/items/81990938e43c7dff35cf</a></li>
</ul>
</li>
<li><p>JSPからのアクセス</p>
<ul>
<li>一般的なWebアプリケーションでは、ログインユーザーのユーザー情報などを画面に表示することがある。</li>
</ul>
</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;% taglib prefix=<span class="string">"sec"</span> uri=<span class="string">"http://www.springframework.org/security/tags"</span> %&gt;</span><br><span class="line">&lt;%-- ... --%&gt;</span><br><span class="line">ようこそ</span><br><span class="line">&lt;sec:authentication property=<span class="string">"principal.account.lastName"</span> /&gt;</span><br><span class="line">さん。</span><br></pre></td></tr></table></figure>

<ul>
<li>追記：thymeleafからのアクセス</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:sec</span>=<span class="string">"http://www.thymeleaf.org/thymeleaf-extras-springsecurity4"</span>&gt;</span> <span class="comment">&lt;!-- これを追加してThymeleafからSpringSecurityを利用 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 省略 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>こんにちは、<span class="tag">&lt;<span class="name">span</span> <span class="attr">sec:authentication</span>=<span class="string">"principal.userId"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>さん<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> <span class="comment">&lt;!-- principal.メンバ変数名　で参照できる　--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="9-4-11-認証処理とSpringMVCの連携"><a href="#9-4-11-認証処理とSpringMVCの連携" class="headerlink" title="9.4.11 認証処理とSpringMVCの連携"></a>9.4.11 認証処理とSpringMVCの連携</h4><ul>
<li>SpringSecurityは、SpringMVCと連携するためのコンポーネントをいくつか提供している</li>
<li>ここでは、認証処理と連携するためのコンポーネントの使い方を紹介</li>
<li>SpringSecurityは認証情報（UserDetails）をSpringMVCのコントローラーのメソッドに引き渡すためのコンポーネントとして、AuthenticationPrincipalArgumentResolverというクラスを提供している</li>
<li>これを使用すると、コントローラーのメソッド引数として、UserDetailsインターフェースまたはその実装クラスのインスタンスを受け取ることができる</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">index</span><span class="params">(@AuthenticationPrincipal UserDetailsImpl userDetails)</span> </span>&#123;</span><br><span class="line">        System.out.println(userDetails.getUserId) <span class="comment">// userId</span></span><br><span class="line">        System.out.println(userDetails.getPassword) <span class="comment">//password</span></span><br><span class="line">        System.out.println(userDetails.getHoge) <span class="comment">//hoge</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-4-12-エラーメッセージ"><a href="#9-4-12-エラーメッセージ" class="headerlink" title="9.4.12 エラーメッセージ"></a>9.4.12 エラーメッセージ</h4><ul>
<li><p>認証に失敗した場合、SpringSecurityが用意しているエラーメッセージが表示されます</p>
</li>
<li><p>このエラーメッセージは内容を変更したり、表示しないようにすることができます。</p>
</li>
<li><p>エラーメッセージの変更</p>
<ul>
<li>認証失敗時に表示されるエラーメッセージを変更したい場合は、MessageSourceで読み込んでいるプロパティファイルに</li>
<li>SpringSecurityが用意しているメッセージの定義を追加してください</li>
</ul>
</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">AbstractUserDetailsAuthenticationProvider.badCredentials</span> = <span class="string">入力した認証情報に誤りがあります。</span></span><br><span class="line"><span class="meta">AbstractUserDetailsAuthenticationProvider.credentialsExpired</span> = <span class="string">認証情報の利用期限が切れています。</span></span><br><span class="line"><span class="meta">AbstractUserDetailsAuthenticationProvider.disabled</span> = <span class="string">無効なアカウントです。</span></span><br><span class="line"><span class="meta">AbstractUserDetailsAuthenticationProvider.expired</span> = <span class="string">アカウントの期限が切れています。</span></span><br><span class="line"><span class="meta">AbstractUserDetailsAuthenticationProvider.locked</span> = <span class="string">アカウントがロックされています。</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>この他にも多数のメッセージが用意されている</p>
</li>
<li><p>種類を確認するには、<code>spring-security-core</code>モジュールのjarファイルの中の<code>org/springframework/security/message.properties</code>ファイルを確認してください</p>
</li>
<li><p>メッセージ定義定数クラスは自動生成するべきな件</p>
<ul>
<li><a href="https://terasolunaorg.github.io/guideline/1.0.x/ja/ArchitectureInDetail/MessageManagement.html" target="_blank" rel="noopener">https://terasolunaorg.github.io/guideline/1.0.x/ja/ArchitectureInDetail/MessageManagement.html</a></li>
</ul>
</li>
<li><p>メモ</p>
<ul>
<li>MessageSourceの中でプロパティファイルをISO 8859-1(デフォルト)で読み込んでいる場合は、マルチバイト文字は</li>
<li>Unicodeコード（\udddd表記）形式に変換する必要がある。</li>
<li>なお、プロパティファイルを任意の文字コードで読み込む場合は、MessageSourceのdefaultEncodingプロパティに文字コードを指定してください。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageSource <span class="title">messageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ResourceBundleMessageSource messageSource = <span class="keyword">new</span> ResourceBundleMessageSource();</span><br><span class="line">  messageSource.setBasenames(<span class="string">"i18n/messages"</span>); <span class="comment">// クラスパス上に格納されているプロパティファイル（拡張子は除く）を指定する</span></span><br><span class="line">  messageSource.setDefaultEncoding(<span class="string">"UTF-8"</span>); <span class="comment">// ★ここのこと！</span></span><br><span class="line">  <span class="keyword">return</span> messageSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>システムエラー時のメッセージ</p>
<ul>
<li>認証処理の中で予期しないエラー（システムエラーなど）が発生した場合、InternalAuthenticationServiceExceptionという例外が発生する。InteractiveAuthenticationServiceExceptionが保持するメッセージには、</li>
<li>原因例外のメッセージが設定されるため画面にそのまま表示するのは好ましくない</li>
<li>システムエラーの例外メッセージを画面に表示しない用にするには、ExceptionMappingAuthenticationFailureHandlerやDelegatingAuthenticationFailureHandlerを使用して、InternalAuthenticationServiceExceptionが発生したときの遷移先をシステムエラー画面にするのが良いでしょう。</li>
</ul>
</li>
<li><p>TODO: この辺見て実装する</p>
<ul>
<li><a href="https://qiita.com/rubytomato@github/items/6c6318c948398fa62275" target="_blank" rel="noopener">https://qiita.com/rubytomato@github/items/6c6318c948398fa62275</a></li>
</ul>
</li>
</ul>
<h3 id="9-5-認可処理"><a href="#9-5-認可処理" class="headerlink" title="9.5 認可処理"></a>9.5 認可処理</h3><ul>
<li>認可処理は、アプリケーションの利用者がアクセスできるリソースを制御するための処理</li>
<li>最も標準的な方法は、リソース毎にアクセスポリシーを定義しておいて、利用者がリソースにアクセスしようとしたときにアクセスポリシーを調べて制御する方法</li>
<li>アクセスポリシーには、どのリソースにどのユーザーからのアクセスを許可するかを定義します</li>
<li>SpringSecurityでは、Webリソース、Javaメソッド、ドメインオブジェクトに対してアクセスポリシーを定義できる</li>
</ul>
<p>※ドメインオブジェクトに関する認可処理は本書では扱わない<br>興味がある場合は、下記参照<br><a href="http://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#domain-acls" target="_blank" rel="noopener">http://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#domain-acls</a></p>
<h4 id="9-5-1-認可処理の仕組み"><a href="#9-5-1-認可処理の仕組み" class="headerlink" title="9.5.1 認可処理の仕組み"></a>9.5.1 認可処理の仕組み</h4><ul>
<li><p>SpringSecrityが提供する認証処理の仕組みを理解しましょう</p>
</li>
<li><p>以下のような流れで認可処理を行います</p>
<ol>
<li>クライアントが任意のリソースにアクセスする</li>
<li>FilterSecurityInterceptorクラスは、AccessDecisionManagerインターフェースのメソッドを呼び出し、リソースへのアクセス権の有無をチェックする</li>
<li>AffirmativeBasedクラス（デフォルトで使用されるAccessDecisionManagerの実装クラス）は、AccessDecisionVoterインターフェースのメソッドを呼び出し、アクセス件の有無を投票してもらう</li>
<li>FilterSecurityInterceptorは、AccessDecisionManagerによってアクセス権が付与された場合に限り、リソースへアクセスする</li>
</ol>
</li>
<li><p>ExceptionTranslationFilter</p>
<ul>
<li>認可処理（AccessDecisionManager）で発生した例外をハンドリングし、</li>
<li>クライアントに適切なレスポンスを行うためのサーブレットフィルタ</li>
<li>デフォルトの実装では、未認証ユーザーからのアクセスの場合は、認証を促すレスポンス、認証済みユーザーからのアクセスの場合は、認可エラーを通知するレスポンスを返却する</li>
</ul>
</li>
<li><p>FilterSecurityInterceptor</p>
<ul>
<li>HTTPリクエストに対して認可処理を適用するためのサーブレットフィルタで、実際の認可処理はAccessDecisionManagerに移譲しています。</li>
<li>AccessDecisionManagerインターフェースのメソッドを呼び出す際には、クライアントがアクセスしようとしたWebリソースに指定されているアクセスポリシーを連携します。</li>
</ul>
</li>
<li><p>AccessDecisionManager</p>
<ul>
<li>アクセスしようとしたリソースに対してアクセス権があるかチェックを行うためのインターフェース</li>
<li>SpringSecurityが提供する実装クラスでは、このあと紹介するAccessDecisionVoterというインターフェースのメソッドを呼び出してアクセス権を付与するか否かを投票するしくみになっており、デフォルトで適用されるクラスはAffirmativeBasedクラスです。AffirmativeBasedクラスは、いずれかのAccessDecisionVoterが付与を投票した場合にアクセス権を与える実装クラス</li>
</ul>
</li>
<li><p>AccessDecisionVoter</p>
<ul>
<li>アクセスしようとしたリソースに指定されているアクセスポリシーを参照し、アクセス権を付与するか否かを投票する（付与、拒否、棄権）するためのインターフェース</li>
<li>SpringSecurityではいくつかの実装クラスを提供しているが、4.0からデフォルトで適用されるクラスは、<code>WebExpressionVoter</code>に統一されている</li>
<li>WebExpressionVoterはSpring Expression Languageを使用して、利用者が持つ、権限情報とリクエスト情報を参照して投票を行う実装クラス</li>
</ul>
</li>
</ul>
<h4 id="9-5-2-アクセスポリシーの記述方法"><a href="#9-5-2-アクセスポリシーの記述方法" class="headerlink" title="9.5.2 アクセスポリシーの記述方法"></a>9.5.2 アクセスポリシーの記述方法</h4><ul>
<li><p>SpringSecurityは、アクセスポリシーを指定する記述方法として、SpringExpressionLanguage（SpEL）をサポート</p>
</li>
<li><p>SpELを使わない方法もあるが、本書では、Expressionを使ってアクセスポリシーを指定する方法で解説する</p>
</li>
<li><p>CommonExpressions</p>
<ul>
<li>※割愛</li>
</ul>
</li>
</ul>
<h4 id="9-5-3-Webリソースへの認可（JavaConfig編）"><a href="#9-5-3-Webリソースへの認可（JavaConfig編）" class="headerlink" title="9.5.3 Webリソースへの認可（JavaConfig編）"></a>9.5.3 Webリソースへの認可（JavaConfig編）</h4><ul>
<li><p>JavaConfigを使用して、Webリソースに対してアクセスポリシーを定義する方法について説明</p>
</li>
<li><p>アクセスポリシーを適用するWebリソースの指定</p>
<ul>
<li>まずは、アクセスポリシーを適用するリソースを指定</li>
<li>アクセスポリシーを適用するリソースの指定は、ExpressionInterceptUrlRegistryクラスの以下のメソッドを呼び出して行います。<ul>
<li>antMatchers</li>
<li>regexMatchers</li>
<li>requestMatchers</li>
<li>anyRequests</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">//    http.addFilter(this.preAuthenticatedProcessingFilter());</span></span><br><span class="line">  <span class="comment">//    http.formLogin();</span></span><br><span class="line">  http.authorizeRequests()</span><br><span class="line">      .antMatchers(<span class="string">"/"</span>, <span class="string">"/find"</span>, <span class="string">"/login"</span>, <span class="string">"/signup"</span>, <span class="string">"/error"</span>, <span class="string">"/login-error"</span>).permitAll()</span><br><span class="line">      <span class="comment">// ★記載順には気をつける必要がある</span></span><br><span class="line">      .antMatchers(<span class="string">"/admin/accounts/***"</span>).hasRole(<span class="string">"ACCOUNT_MANAGER"</span>)</span><br><span class="line">      .antMatchers(<span class="string">"/admin/***"</span>).hasRole(<span class="string">"ADMIN"</span>)</span><br><span class="line">      .anyRequest().authenticated()</span><br></pre></td></tr></table></figure>

<ul>
<li>アクセスポリシーの指定<ul>
<li>次に、アクセスポリシーを指定します。</li>
<li>アクセスポリシーの指定は、AuthorizedUrlクラスのメソッドを使用して行います。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http.authorizeRequests()</span><br><span class="line">    .antMatchers(<span class="string">"/"</span>, <span class="string">"/find"</span>, <span class="string">"/login"</span>, <span class="string">"/signup"</span>, <span class="string">"/error"</span>, <span class="string">"/login-error"</span>).permitAll()</span><br><span class="line">    <span class="comment">//        .antMatchers("/admin/accounts/***").hasRole("ACCOUNT_MANAGER")</span></span><br><span class="line">    <span class="comment">//        .antMatchers("/admin/***").hasRole("ADMIN")</span></span><br><span class="line">    .antMatchers(<span class="string">"/admin/***"</span>).access(<span class="string">"hasIpAddress('127.0.0.1') and hasRole('CONFIGURATION_MANAGER')"</span>)</span><br><span class="line">    .antMatchers(<span class="string">"/admin/***"</span>).hasRole(<span class="string">"ADMIN"</span>)</span><br><span class="line">    .anyRequest().authenticated()</span><br></pre></td></tr></table></figure>

<h4 id="9-5-4-Webリソースへの認可（XMLファイル編）"><a href="#9-5-4-Webリソースへの認可（XMLファイル編）" class="headerlink" title="9.5.4 Webリソースへの認可（XMLファイル編）"></a>9.5.4 Webリソースへの認可（XMLファイル編）</h4><ul>
<li>割愛</li>
</ul>
<h4 id="9-5-5-メソッドへの認可"><a href="#9-5-5-メソッドへの認可" class="headerlink" title="9.5.5 メソッドへの認可"></a>9.5.5 メソッドへの認可</h4><ul>
<li><p>SpringSecurityは、SpringAOPの仕組みを利用して、アプリケーションコンテキスト内で管理しているBeanのメソッド呼び出しに対して認可処理を行う仕組みを提供しています。</p>
<ul>
<li>メソッドに対応する認可処理を使用すると、メソッドの引数や戻り値のオブジェクトの状態を参照できるため、よりきめ細かいアクセスポリシーの定義が行える</li>
<li>メソッドへの認可を使用する場合は、メソッド呼び出しに対して認可処理を行うためのコンポーネント（AOP）を有効にしてから、アクセスポリシーをクラスやメソッドのアノテーションに定義します。<ul>
<li>つまり<ul>
<li>AOP有効化</li>
<li>メソッドにアノテーション定義</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>SpringSecurityがサポートしているアノテーションは以下</p>
<ul>
<li>@PreAuthorize,@PostAuthorize,@PreFilter,@PostFilter: SpringSecurityのアノテーション</li>
<li>@Secured: SpringSecurityのアノテーション</li>
<li>JSR250(javax.annotation.securityパッケージ)のアノテーション（@RolesAllowedなど）</li>
</ul>
</li>
<li><p>本書では、アクセスポリシーの指定にExpressionを使用することができる <code>@PreAuthorize</code>と<code>@PostAuthorize</code>を紹介する</p>
</li>
<li><p>メソッド認可の有効化</p>
<ul>
<li>まず、メソッドに対して認可処理を行うAOPを有効化します</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="keyword">true</span>) <span class="comment">// メソッドに対して認可処理を行うAOPを有効化 prePostEnabled属性にtrueを指定すると、Expressionを使用してアクセスポリシーを定義することができるアノテーションが有効になる</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>メソッド実行前に適用するアクセスポリシーの指定<ul>
<li>メソッドの実行前に適用するアクセスポリシーを指定する場合は<code>@PreAuthorize</code>を使用する</li>
<li><code>@PreAuthorize</code>のvalue属性に指定したExpressionの結果がtrueになるとメソッドの実行が許可される</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管理者以外の人間が他人のアカウント情報にアクセスできないように定義している</span></span><br><span class="line"><span class="meta">@PreAuthorize</span>(<span class="string">"hasRole('ADMIN') or (#username == principal.username)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Account <span class="title">findOne</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> accountRepository.findOne(username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>ここでポイントになるのが、Expressionの中からメソッドの引数にアクセスしている部分</p>
</li>
<li><p>具体的には、#usernameの部分が引数にアクセスしている部分になる</p>
</li>
<li><p>Expression内で「# + 引数名」形式のExpressionを指定するとメソッドの引数にアクセスすることができる</p>
</li>
<li><p>メモ</p>
<ul>
<li>SpringSecurityは、クラスに出力されているデバッグ情報から引数名を解決する仕組みになっているが、</li>
<li>アノテーション（<code>@P</code>）を使用して明示的に引数名を指定することもできる</li>
<li>以下の場合は、明示的に引数名を指定してあげる必要がある<ul>
<li>引数のデバッグ情報を出力しない</li>
<li>Expressionの中から実際の引数名とは別の名前を使ってアクセスする（例：短縮した名前）</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize</span>(<span class="string">"hasRole('ADMIN') or (#username == principal.username)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Account <span class="title">findOne</span><span class="params">(@P(<span class="string">"username"</span>)</span> String username) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> accountRepository.findOne(username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>JavaSE8から追加されたコンパイルオプション（-parameters）を使用すると、メソッドパラメータにリフレクション用のメタデータが生成されるため、アノテーションを指定しなくても引数名を解決してくれる</p>
</li>
<li><p>メソッド実行後に適用するアクセスポリシーの指定</p>
<ul>
<li><code>@PostAuthorize</code>を使用する</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize</span>(<span class="string">"hasRole('DEPARTMENT_MANAGER')"</span>)</span><br><span class="line"><span class="meta">@PostAuthorize</span>(<span class="string">"(returnObject == null) or (returnObject.departmentCode == principal.account.departmentCode)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Account <span class="title">findOne</span><span class="params">(@P(<span class="string">"username"</span>)</span> String username) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> accountRepository.findOne(username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-5-6-JSPの画面項目への認可"><a href="#9-5-6-JSPの画面項目への認可" class="headerlink" title="9.5.6 JSPの画面項目への認可"></a>9.5.6 JSPの画面項目への認可</h4><p>SpringSecurityはJSPタグライブラリを使用してJSPの画面項目に対して認可処理を適用することができる</p>
<ul>
<li>※管理者の場合、この項目を表示するなどの制御<ul>
<li>このURLへ遷移させるなどの制御</li>
</ul>
</li>
</ul>
<h4 id="9-5-7-認可エラー時のレスポンス"><a href="#9-5-7-認可エラー時のレスポンス" class="headerlink" title="9.5.7 認可エラー時のレスポンス"></a>9.5.7 認可エラー時のレスポンス</h4><ul>
<li><p>SpringSecurityはリソースへのアクセスを拒否した場合、以下のような流れでエラーハンドリング、レスポンスを行う</p>
<ol>
<li>SpringSecurityは、リソースやメソッドへのアクセスを拒否するために、AccessDeniedExceptionをスローする</li>
<li>ExceptionTranslationFilterクラスは、AccessDeniedExceptionを捕捉し、AccessDeniedHandlerまたは、AuthenticationEntryPointインターフェースのメソッドを呼び出してエラー応答を行う</li>
<li>認証済みのユーザーからのアクセスの場合は、AccessDeniedHandlerインターフェースのメソッドを呼び出してエラー応答を行う</li>
<li>未認証ユーザーからのアクセスの場合は、AuthenticationEntryPointインターフェースのメソッドを呼び出してエラー応答を行う</li>
</ol>
</li>
<li><p>AccessDeniedHandler</p>
</li>
<li><p>AuthenticationEntryPoint</p>
</li>
<li><p>認可エラー時の遷移先</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.exceptionHandling().accessDeniedPage(<span class="string">"/accessDeniedError"</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>デフォルト動作のカスタマイズ<ul>
<li>TODO: 認証エラー時にメッセージを出す処理を作るときに記述しないと行けない気がする</li>
</ul>
</li>
</ul>
<h3 id="9-6-CSRF対策"><a href="#9-6-CSRF対策" class="headerlink" title="9.6 CSRF対策"></a>9.6 CSRF対策</h3><h4 id="9-6-1-Spring-SecurityのCSRF対策"><a href="#9-6-1-Spring-SecurityのCSRF対策" class="headerlink" title="9.6.1 Spring SecurityのCSRF対策"></a>9.6.1 Spring SecurityのCSRF対策</h4><ul>
<li>Spring Securityはセッション単位にランダムなトークン値(CSRFトークン)を払い出し、払い出されたCSRFトークンをリクエストパラメータ（HTMLフォームのhidden項目）として送信することで、そのリクエストが正規のWebページからなのか、それとも攻撃者が用意したWebページからなのかを判断する機能がある</li>
<li>SpringSecurityのデフォルト実装では、POST,PUT,DELETE,PATCHのHTTPメソッドを使用したリクエストに対して、CSRFトークンチェックを行います</li>
</ul>
<h4 id="9-6-2-CSRF対策機能の適用"><a href="#9-6-2-CSRF対策機能の適用" class="headerlink" title="9.6.2 CSRF対策機能の適用"></a>9.6.2 CSRF対策機能の適用</h4><ul>
<li>CSRF対策機能はSpring3.2から追加された機能で、SpringSecurity4.0からデフォルトで適用されるようになりました。</li>
<li>そのため、CSRF対策機能を有効にするための特別な定義はありません。</li>
<li>なおCSRF機能を適用したくない場合は、明示的に無効にする必要がある</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  http.csrf().disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>HTMLフォーム使用時のトークン値の連携</p>
<ul>
<li>JSPでの設定を紹介しているため割愛</li>
<li>Thymeleafだとこんな感じ<a href="https://qiita.com/nenokido2000/items/22a97a26a5858ddb164f" target="_blank" rel="noopener">https://qiita.com/nenokido2000/items/22a97a26a5858ddb164f</a></li>
</ul>
</li>
<li><p>Ajax使用時の連携</p>
<ul>
<li>Ajaxを使ってリクエストを送信する場合は、SpringSecurityから提供されている<code>&lt;sec:csrfMetaTag&gt;</code>要素を使用して、HTMLの<code>&lt;meta&gt;</code>要素としてCSRFトークンの情報を出力し<code>&lt;meta&gt;</code>要素から取得したトークン値をAjax通信時のリクエストヘッダーに設定して連携します。</li>
<li>Thymeleafの場合、以下を参考に、Cookieからcsrfトークンを取り出して、詰めて送る<ul>
<li><a href="https://qiita.com/nenokido2000/items/22a97a26a5858ddb164f" target="_blank" rel="noopener">https://qiita.com/nenokido2000/items/22a97a26a5858ddb164f</a></li>
<li>CookieにCSRFトークンを詰める処理は以下で行えるようになっている</li>
<li><code>http.csrf().csrfTokenRepository(new CookieCsrfTokenRepository());</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="9-6-3-トークンチェックエラー時のレスポンス"><a href="#9-6-3-トークンチェックエラー時のレスポンス" class="headerlink" title="9.6.3 トークンチェックエラー時のレスポンス"></a>9.6.3 トークンチェックエラー時のレスポンス</h4><ul>
<li><p>CSRFトークンチェックでエラーが発生した場合、SpringSecurityはAccessDeniedHandlerインターフェースを使用してエラーのレスポンスを行う</p>
</li>
<li><p>CSRFトークンチェックでエラーが発生したときに専用のエラーページに遷移させる場合は、SpringSecurityから提供されているDelegatingAuthenticationFailureHandlerクラスを利用して、それぞれの例外にAccessDeniedHandlerインターフェースの実装クラスを指定してください</p>
</li>
<li><p>CSRFトークンチェックで使用される例外クラス</p>
<ul>
<li>InvalidCsrfTokenException</li>
<li>MissingCsrfTokenException<ul>
<li>TODO: この例外処理を実装する必要がある XMLで記載している例はあるけど、Javaで書いている例がない..</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="9-6-4-CSRF対策機能とSpringMVCとの連携"><a href="#9-6-4-CSRF対策機能とSpringMVCとの連携" class="headerlink" title="9.6.4 CSRF対策機能とSpringMVCとの連携"></a>9.6.4 CSRF対策機能とSpringMVCとの連携</h4><ul>
<li>自動でFormにcsrfトークンが入りますよという説明</li>
</ul>
<h3 id="9-7-セッション管理"><a href="#9-7-セッション管理" class="headerlink" title="9.7 セッション管理"></a>9.7 セッション管理</h3><h4 id="9-7-1-セッション管理機能の適用"><a href="#9-7-1-セッション管理機能の適用" class="headerlink" title="9.7.1 セッション管理機能の適用"></a>9.7.1 セッション管理機能の適用</h4><ul>
<li>セッション管理機能を使用するには、以下のようなBean定義を行う</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  http.sessionManagement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>sessionManagementメソッドを呼び出し、SessionManagementConfigurerのインスタンスを取得する</p>
</li>
<li><p>SessionManagementConfigurerには、セッション管理機能のコンポーネントの動作をカスタマイズするためのメソッドが定義されている。なお、WebSecurityConfigurerAdapterを継承して、コンフィギュレーションクラスを作成している場合は、sessionManagementメソッドは親クラスの処理で呼び出されるため、デフォルトでセッション管理機能が適用されている</p>
</li>
<li><p>RESTAPIなどセッションを使用しない場合は、セッションの作成方式を stateless に変更する必要がある</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br></pre></td></tr></table></figure>

<ul>
<li>セッションの作成方式は以下のオプションから選択することができる<ul>
<li>always</li>
<li>ifRequired (デフォルト)</li>
<li>never</li>
<li>stateless</li>
</ul>
</li>
</ul>
<h4 id="9-7-2-URL-Rewriting抑止機能"><a href="#9-7-2-URL-Rewriting抑止機能" class="headerlink" title="9.7.2 URL Rewriting抑止機能"></a>9.7.2 URL Rewriting抑止機能</h4><p>URL Rewritingが行われると、URL内にセッションIDが露出してしまうため、セッションIDを盗まれるリスクが高くなります。</p>
<p>SpringSecurityでは、URL Rewritingを抑止するための仕組みも提供しており、この機能はSpringSecurity4.0以上ではデフォルトで適用されます。</p>
<ul>
<li>TODO: Cookieを許可しない設定になっているとどのような挙動になる？クエリに埋め込まれない？</li>
</ul>
<h4 id="9-7-3-セッション固定攻撃対策機能"><a href="#9-7-3-セッション固定攻撃対策機能" class="headerlink" title="9.7.3 セッション固定攻撃対策機能"></a>9.7.3 セッション固定攻撃対策機能</h4><ul>
<li><p>セッション管理機能を適用すると、デフォルトでセッション固定攻撃機能が有効になる</p>
</li>
<li><p>セッション固定攻撃対策機能を使用すると、ログイン成功時に新たセッションIDを払い直すため、攻撃者が事前に払い出したセッションIDが使われることはありません。</p>
</li>
<li><p>セッション固定攻撃への対策オプション</p>
<ul>
<li>changeSessionId: Servlet3.1で追加されたHttpServletRequest#changeSessionIdメソッドを使用してセッションIDを変更する（Servlet3.1以上のコンテナでのデフォルト動作）</li>
<li>migrateSession: ログイン前に使用していたセッションを破棄し、新たにセッションを作成する。ログイン前にセッションに格納されていたオブジェクトは新しいセッションに引き継がれる</li>
<li>newSession: migrateSessionと同じ方法でセッションIDを変更するが、ログイン前に格納されていたオブジェクトは新しいセッションには引き継がれない</li>
<li>none: SpringSecurityはセッションIDを変更しない</li>
</ul>
</li>
<li><p>指定方法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">http.sessionManagement().sessionFixation().newSession();</span><br></pre></td></tr></table></figure>

<h4 id="9-7-4-多重ログインの制御"><a href="#9-7-4-多重ログインの制御" class="headerlink" title="9.7.4 多重ログインの制御"></a>9.7.4 多重ログインの制御</h4><ul>
<li><p>SpringSecurityは同じユーザー名（ログインID）を使った多重ログインを制御する機能を提供しているが、</p>
</li>
<li><p>SpringSecurityが提供しているデフォルト実装にはいくつかの制約や注意事項がある</p>
</li>
<li><p>本書では、これらの制約と注意事項について紹介するが、具体的な使い方は扱わない、リファレンス参照</p>
</li>
<li><p>SpringSecurityが提供しているデフォルト実装では、ユーザー毎にセッション情報をアプリケーションサーバーのメモリ内で管理します。</p>
</li>
<li><p>そのため、複数のアプリケーションサーバーを同時に実行するシステムでは利用することができません。</p>
</li>
<li><p>また、アプリケーションサーバーを停止または再起動するとメモリ内で管理していたセッション情報はクリアされます。</p>
</li>
<li><p>使用するアプリケーションサーバーによっては、停止または再起動時のセッション状態を復元する機能を持っているため、実際のセッション状態とSpringSecurityが管理しているセッション情報に不整合が生じる可能性がある</p>
</li>
<li><p>TODO: Redisで管理する方法探る</p>
</li>
</ul>
<h4 id="9-7-5-無効なセッションを使ったリクエストの検知"><a href="#9-7-5-無効なセッションを使ったリクエストの検知" class="headerlink" title="9.7.5 無効なセッションを使ったリクエストの検知"></a>9.7.5 無効なセッションを使ったリクエストの検知</h4><ul>
<li>SpringSecurityは無効なセッションを使ったリクエストを検知する機能を提供している</li>
<li>無効なセッションとして扱われるリクエストの大部分は、セッションタイムアウト後のリクエストです。</li>
<li>以下の例では、無効なセッションを検知した際の遷移先として <code>&quot;/error/invalidSession&quot;</code>を指定することで、この機能を有効化している</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">http.sessionManagement().invalidSessionUrl(<span class="string">"/error/invalidSession"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="9-8-ブラウザのセキュリティ対策機能との連携"><a href="#9-8-ブラウザのセキュリティ対策機能との連携" class="headerlink" title="9.8 ブラウザのセキュリティ対策機能との連携"></a>9.8 ブラウザのセキュリティ対策機能との連携</h3><ul>
<li>ブラウザが提供するセキュリティ対策機能の一部は、サーバー側で、HTTPのレスポンスヘッダーを出力することで動作を制御することができる</li>
</ul>
<h4 id="9-8-1-セキュリティヘッダー出力機能の適用"><a href="#9-8-1-セキュリティヘッダー出力機能の適用" class="headerlink" title="9.8.1 セキュリティヘッダー出力機能の適用"></a>9.8.1 セキュリティヘッダー出力機能の適用</h4><ul>
<li>Spring3.2から追加された機能で、Spring4.0からデフォルトで適用されるようになった</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 無効にする方法</span></span><br><span class="line">    http.headers().disable();</span><br></pre></td></tr></table></figure>

<h4 id="9-8-2-デフォルトでサポートしているセキュリティヘッダー"><a href="#9-8-2-デフォルトでサポートしているセキュリティヘッダー" class="headerlink" title="9.8.2 デフォルトでサポートしているセキュリティヘッダー"></a>9.8.2 デフォルトでサポートしているセキュリティヘッダー</h4><ul>
<li><p>SpringSecurityがデフォルトでサポートしているレスポンスヘッダーは以下の５つ</p>
<ul>
<li>Cache-Control（Pragma, Expires）<ul>
<li>コンテンツのキャッシュ方法を支持するヘッダー</li>
<li>保護されたコンテンツがブラウザにキャッシュされないようにすることで、権限のないユーザーが保護されたコンテンツを閲覧できてしまうリスクを減らすことができる</li>
</ul>
</li>
<li>X-Frame-Options<ul>
<li>フレーム（<code>&lt;frame&gt;</code>または<code>&lt;iframe&gt;</code>要素）内でコンテンツの表示を許可するか否かを支持するためのヘッダー</li>
<li>フレーム内でコンテンツが表示されないようにすることで、クリックジャッキングと呼ばれる攻撃手法を使って機密情報を盗み取られるリスクを無くすことができる</li>
</ul>
</li>
<li>X-Content-Type-Options<ul>
<li>コンテンツの種類の決定方法を指示するためのヘッダー</li>
<li>一部のブラウザでは、Content-Typeヘッダーの値を無視して、コンテンツの内容を見て決定します。</li>
<li>コンテンツの種類を決定する際にコンテンツの内容を見ないようにすることで、クロスサイトスクリプティングを使った攻撃を受ける可能性をへらすことができます。</li>
</ul>
</li>
<li>X-XSS-Protection<ul>
<li>ブラウザのXSSフィルタ機能を使って有害なスクリプトを検知する方法を支持するためのヘッダー</li>
<li>XSSフィルタ機能を有効にして有害なスクリプトを検知するようにすれば、クロスサイトスクリプティングを使った攻撃を受ける可能性をへらすことができる。</li>
</ul>
</li>
<li>Strict-Transport-Security<ul>
<li>HTTPSを使ったアクセスをしたあとに、HTTPを使ってアクセスしようとした際に、HTTPSに置き換えてからアクセスすることを支持するためのヘッダー</li>
<li>HTTPSでアクセスした後に、HTTPが使われないようにすることで、中間者攻撃と呼ばれる攻撃手法を使って悪意のあるサイトに誘導されるリスクをへらすことができる</li>
</ul>
</li>
</ul>
</li>
<li><p>TODO: 攻撃手法と対策について再度整理する必要あり</p>
</li>
</ul>
<h4 id="9-8-3-セキュリティヘッダーの選択"><a href="#9-8-3-セキュリティヘッダーの選択" class="headerlink" title="9.8.3 セキュリティヘッダーの選択"></a>9.8.3 セキュリティヘッダーの選択</h4><ul>
<li>出力するセキュリティヘッダーを選択したい場合は、以下のようなBean定義を行います。</li>
<li>ここではSpringSecurityが提供するすべてのセキュリティヘッダーを出力する例になっていますが、実際は必要なものだけ指定する</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http.headers()</span><br><span class="line">    .defaultsDisabled()</span><br><span class="line">    .cacheControl().and()</span><br><span class="line">    .frameOptions().and()</span><br><span class="line">    .contentTypeOptions().and()</span><br><span class="line">    .xssProtection().and()</span><br><span class="line">    .httpStrictTransportSecurity();</span><br></pre></td></tr></table></figure>

<ul>
<li>不要なものだけ無効化する方法もある</li>
</ul>
<h3 id="9-9-Spring-Securityのテスト"><a href="#9-9-Spring-Securityのテスト" class="headerlink" title="9.9 Spring Securityのテスト"></a>9.9 Spring Securityのテスト</h3><ul>
<li>MockMvcを使用して「認証処理」や「認可処理」などのテストを行うための機能</li>
<li>テスト時に適用する認証情報をアノテーションで指定できる機能</li>
</ul>
<h4 id="9-9-1-Spring-Security-Testのセットアップ"><a href="#9-9-1-Spring-Security-Testのセットアップ" class="headerlink" title="9.9.1 Spring Security Testのセットアップ"></a>9.9.1 Spring Security Testのセットアップ</h4><ul>
<li>依存ライブラリーの追加</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// build.gradle</span></span><br><span class="line">  testImplementation <span class="string">'org.springframework.security:spring-security-test'</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>SpringSecurityのサーブレットフィルタの追加</p>
</li>
<li><p>TODO: テスト環境が作れて無いため一旦スキップする</p>
</li>
</ul>
<h2 id="第10章-Spring-Data-JPA"><a href="#第10章-Spring-Data-JPA" class="headerlink" title="第10章　Spring Data JPA"></a>第10章　Spring Data JPA</h2><h3 id="10-6-Repositoryの作成と利用"><a href="#10-6-Repositoryの作成と利用" class="headerlink" title="10.6 Repositoryの作成と利用"></a>10.6 Repositoryの作成と利用</h3><h4 id="10-6-4-ページネーション"><a href="#10-6-4-ページネーション" class="headerlink" title="10.6.4 ページネーション"></a>10.6.4 ページネーション</h4><ul>
<li>TODO: DOMAにあるかどうか</li>
</ul>
<h4 id="10-6-6-監査情報の付与"><a href="#10-6-6-監査情報の付与" class="headerlink" title="10.6.6 監査情報の付与"></a>10.6.6 監査情報の付与</h4><ul>
<li>TODO: DOMAにあるかどうか</li>
</ul>
<h2 id="第11章-Spring-＋-MyBatis"><a href="#第11章-Spring-＋-MyBatis" class="headerlink" title="第11章　Spring ＋ MyBatis"></a>第11章　Spring ＋ MyBatis</h2><ul>
<li>XMLに記述しないといけないので採用したくない</li>
</ul>
<h2 id="第12章-Spring＋Thymeleaf"><a href="#第12章-Spring＋Thymeleaf" class="headerlink" title="第12章　Spring＋Thymeleaf"></a>第12章　Spring＋Thymeleaf</h2><ul>
<li>SpringBootを始め、ViewにJSPではなくテンプレートエンジンであるThymeleafを使用するケースが増えている</li>
<li>まずはThymeleaf自体や、Springとセットで開発する際に欠かせない連携ライブラリーの概要を紹介</li>
</ul>
<h3 id="12-1-Thymeleafとは"><a href="#12-1-Thymeleafとは" class="headerlink" title="12.1 Thymeleafとは"></a>12.1 Thymeleafとは</h3><ul>
<li><p>Thymeleafは、Webアプリケーションと親和性の高いテンプレートエンジン</p>
</li>
<li><p>テンプレートエンジンとは</p>
<ul>
<li>雛形となるドキュメント（テンプレート）に対して、可変データを埋め込むことで動的にドキュメントを生成する仕組み</li>
<li>この仕組は、MVCフレームワークのModelとViewを分割する考え方と親和性が高く、しばしばMVCフレームワークのVIEWとし利用される</li>
</ul>
</li>
<li><p>特徴</p>
<ul>
<li>XHTMLやHTML5に準拠した形で記述できること</li>
</ul>
</li>
<li><p>JSPはブラウザが認識できないタグライブラリなどが含まれるため、開発中のJSPを直接ブラウザ上で正確に表示させることが難しいという問題があった</p>
</li>
<li><p>一方ThymeleafのテンプレートはHTML5に準拠しているため、テンプレートをブラウザで直接表示させたり。HTMLをデザイナーとプログラマの間で共有することができる</p>
</li>
<li><p>MEMO: パーツをIncludeする際はうまく表示できない問題はあると思う</p>
</li>
</ul>
<h4 id="12-1-1-Thymeleafのテンプレート"><a href="#12-1-1-Thymeleafのテンプレート" class="headerlink" title="12.1.1 Thymeleafのテンプレート"></a>12.1.1 Thymeleafのテンプレート</h4><p>ThymeleafはXHTMLやHTML5などで書かれたテンプレートをDOMに変換してから処理を行う仕組みになっている<br>「処理対象のDOMノード」と「DOMノードに適用する処理」をthネームスペースの属性（th属性）を使用して指定します。</p>
<p>th属性が指定されているDOMノードは「プロセッサ」と呼ばれるコンポーネントによってDOM操作（追加、削除、変更）が行われる。th属性の属性値には、OGNL（Object-Graph Navigation Language）と呼ばれる式言語を指定でき、式の中から、ユーザー定義のオブジェクトやThymeleafが提供する暗黙オブジェクトにアクセスすることができる</p>
<ul>
<li><p>以下３つのことをDialectと呼ぶ</p>
<ul>
<li>DOM操作を行うプロセッサ</li>
<li>th属性の属性値に指定された式を解釈するコンポーネント</li>
<li>暗黙オブジェクトを生成するコンポーネント<ul>
<li>→デフォルトでは、StandardDialectクラスが使用される</li>
</ul>
</li>
</ul>
</li>
<li><p>Dialectは拡張可能な仕組みになっており、本書で紹介するthymeleaf-spring4を使う場合は、StandardDiarectクラスを継承した、SpringStandardDialectクラスが使用される</p>
</li>
</ul>
<h4 id="12-1-2-ThymeleafとSpringの連携"><a href="#12-1-2-ThymeleafとSpringの連携" class="headerlink" title="12.1.2 ThymeleafとSpringの連携"></a>12.1.2 ThymeleafとSpringの連携</h4><ul>
<li><p>連携する場合、Thymeleafが提供するthymeleaf-spring4モジュールを利用</p>
</li>
<li><p>SpringMVCがJSP向けに提供しているタグライブラリと同様の機能を、Thymeleafで利用することができる</p>
</li>
<li><p>実現できる機能</p>
<ul>
<li>Thymeleafが管理するテンプレートをSpringMVCのViewとして扱うことができる</li>
<li>テンプレート内でSpringELを利用することができる</li>
<li>テンプレートと、フォームクラスおよび入力値チェック結果のバインドが可能となる</li>
<li>Springが管理するメッセージリソースを利用し、国際化対応のメッセージを表示することができる</li>
</ul>
</li>
</ul>
<h3 id="12-2-Spring-Thymeleafのセットアップ"><a href="#12-2-Spring-Thymeleafのセットアップ" class="headerlink" title="12.2 Spring + Thymeleafのセットアップ"></a>12.2 Spring + Thymeleafのセットアップ</h3><h4 id="12-2-1-ライブラリのセットアップ"><a href="#12-2-1-ライブラリのセットアップ" class="headerlink" title="12.2.1 ライブラリのセットアップ"></a>12.2.1 ライブラリのセットアップ</h4><ul>
<li>thymeleaf-spring4を入れる</li>
</ul>
<h4 id="12-2-2-SpringとThymeleafを連携するための設定"><a href="#12-2-2-SpringとThymeleafを連携するための設定" class="headerlink" title="12.2.2 SpringとThymeleafを連携するための設定"></a>12.2.2 SpringとThymeleafを連携するための設定</h4><ul>
<li>SringBootだと書かなくても動くっぽいけど明示する意味で</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(ThymeleafConfig.class) <span class="comment">// Thymeleafを使用することを明示</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThymeleafConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ClassLoaderTemplateResolver <span class="title">templateResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ClassLoaderTemplateResolver resolver = <span class="keyword">new</span> ClassLoaderTemplateResolver();</span><br><span class="line">    resolver.setPrefix(<span class="string">"/WEB-INF/templates/"</span>);</span><br><span class="line">    resolver.setSuffix(<span class="string">".html"</span>);</span><br><span class="line">    resolver.setTemplateMode(<span class="string">"HTML5"</span>);</span><br><span class="line">    resolver.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">    <span class="keyword">return</span> resolver;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SpringTemplateEngine <span class="title">templateEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SpringTemplateEngine templateEngine = <span class="keyword">new</span> SpringTemplateEngine();</span><br><span class="line">    templateEngine.setTemplateResolver(templateResolver());</span><br><span class="line">    <span class="keyword">return</span> templateEngine;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ViewResolver <span class="title">viewResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThymeleafViewResolver viewResolver = <span class="keyword">new</span> ThymeleafViewResolver();</span><br><span class="line">    viewResolver.setTemplateEngine(templateEngine());</span><br><span class="line">    viewResolver.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">    <span class="keyword">return</span> viewResolver;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-3-Thymeleafを利用したViewの実装"><a href="#12-3-Thymeleafを利用したViewの実装" class="headerlink" title="12.3 Thymeleafを利用したViewの実装"></a>12.3 Thymeleafを利用したViewの実装</h3><h4 id="12-3-1-はじめてのThymeleaf"><a href="#12-3-1-はじめてのThymeleaf" class="headerlink" title="12.3.1 はじめてのThymeleaf"></a>12.3.1 はじめてのThymeleaf</h4><ul>
<li>Thymeleafを利用したViewへの変更</li>
<li>テンプレートの実装</li>
</ul>
<h4 id="12-3-2-テキストの出力"><a href="#12-3-2-テキストの出力" class="headerlink" title="12.3.2 テキストの出力"></a>12.3.2 テキストの出力</h4><ul>
<li>th:text — 属性値に指定した値をXHTMLサニタイジングして出力する<ul>
<li>ユーザからの入力を表示する際はこちら</li>
</ul>
</li>
<li>th:utext — 属性値に指定した値をXHTMLサニタイジングせずに出力する<ul>
<li>プロパティファイルでHTML要素を使用して意図的に装飾しているような場合は、th:utext属性を使用してXHTMLサニタイジングせずに出力する必要がある</li>
</ul>
</li>
</ul>
<h4 id="12-3-3-式の構文"><a href="#12-3-3-式の構文" class="headerlink" title="12.3.3 式の構文"></a>12.3.3 式の構文</h4><ul>
<li>基本的な式<ul>
<li>変数式</li>
<li>選択変数式</li>
<li>メッセージ式：これは利用しておきたい</li>
<li>リンクURL式</li>
</ul>
</li>
<li>リテラル</li>
<li>基本的な演算子</li>
<li>テキスト演算子</li>
<li>条件演算子</li>
</ul>
<h4 id="12-3-4-th属性による属性値の設定"><a href="#12-3-4-th属性による属性値の設定" class="headerlink" title="12.3.4 th属性による属性値の設定"></a>12.3.4 th属性による属性値の設定</h4><ul>
<li><p>Thymeleafのテンプレートエンジンとしての機能は、th属性に指定された式を解釈し、HTMLの各要素の属性値を設定または上書きすることです。</p>
</li>
<li><p>特定の属性に値を設定する方法</p>
</li>
<li><p>現在の属性値の前後に値を追加する方法</p>
</li>
<li><p>存在有無が重要な属性の出力を制御する方法</p>
</li>
<li><p>複数の属性に同じ値を設定する方法：AltとTitleに同じ値を入れたりとか</p>
</li>
<li><p>任意の属性に値を設定する方法：独自データ属性に値を設定したい場合に使用する</p>
<ul>
<li><code>&lt;button th:attr=&quot;data-product-id=${product.id}&quot;&gt;削除&lt;/button&gt;</code></li>
</ul>
</li>
</ul>
<h4 id="12-3-5-HTML要素の出力制御"><a href="#12-3-5-HTML要素の出力制御" class="headerlink" title="12.3.5 HTML要素の出力制御"></a>12.3.5 HTML要素の出力制御</h4><p>ここまでth属性を使ってHTML属性の属性値を動的に設定する方法を見てきましたが、<br>動的にHTML要素の出力を制御する必要が出てくる場合がある</p>
<ul>
<li><p>例えば、特定の条件下の場合のみメッセージを表示したり、</p>
</li>
<li><p>データの件数だけ行を追加して出力したりする場合などです。</p>
</li>
<li><p>JSPでは、それらの専用タグライブラリが用意されていましたが、Thymeleafでも相当する機能がth属性として提供されている</p>
</li>
<li><p>条件による出力有無の制御</p>
<ul>
<li>th:if</li>
<li>th:unless</li>
<li>th:switch</li>
<li>th:case</li>
</ul>
</li>
<li><p>繰り返し出力の制御</p>
<ul>
<li>th:each<ul>
<li>java.util.Listの実装クラス</li>
<li>java.util.Iterableの実装クラス</li>
<li>java.util.Mapの実装クラス</li>
<li>配列</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="12-3-6-インライン記述"><a href="#12-3-6-インライン記述" class="headerlink" title="12.3.6 インライン記述"></a>12.3.6 インライン記述</h4><p>th属性を利用しない方法であるインライン記述について説明</p>
<ul>
<li><p><code>[[ ${user.name} ]]</code>でかけるよ</p>
</li>
<li><p>インライン記述はデフォルトで無効になっている</p>
</li>
<li><p>有効にするには、 <code>th:inline</code>属性をインライン記述を利用する要素、もしくは親要素に付与する必要がある</p>
</li>
<li><p>インライン記述のでメリット</p>
<ul>
<li>テンプレートファイルをブラウザ上で直接表示した際に、インライン記述のテキストがそのまま表示されてしまう点</li>
<li>th:textの用にサンプルデータを表示することができないため、デザイナーとの分業に支障をきたす可能性がある</li>
</ul>
</li>
<li><p>メモ</p>
<ul>
<li>インライン記述はJavascriptなどのスクリプト内でも利用することができる</li>
<li>これを利用すると、テンプレートをブラウザで静的に表示した場合や、アプリケーションサーバーにデプロイして動的に表示した場合、その両方においてスクリプトを正常に動作させられる。</li>
</ul>
</li>
<li><p>MEMO: 結論（個人的な）</p>
<ul>
<li>インライン記述は原則禁止したほうがよいと思う（コーディング規約などで明記すべき）</li>
</ul>
</li>
</ul>
<h4 id="12-3-7-コメント"><a href="#12-3-7-コメント" class="headerlink" title="12.3.7 コメント"></a>12.3.7 コメント</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">  このブロックはThymeleafの処理後もテンプレートに残ります。</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--/*</span></span><br><span class="line"><span class="comment">  このブロックはThymeleafの処理後に削除される。</span></span><br><span class="line"><span class="comment">*/--&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="12-3-8-Springとの連携"><a href="#12-3-8-Springとの連携" class="headerlink" title="12.3.8 Springとの連携"></a>12.3.8 Springとの連携</h4><p>本項では、thymleaf-springが提供しているSpringとの連携機能に焦点を当てる</p>
<ul>
<li><p>フォームオブジェクトのバインディング</p>
<ul>
<li>th:object属性</li>
<li>th:field属性</li>
</ul>
</li>
<li><p>入力エラーの表示</p>
<ul>
<li>SpringMVCの入力チェック機能で発生したエラーの表示は、<ul>
<li>th:errors属性 — エラーメッセージの出力対象を指定するための属性</li>
<li>th:errorclass属性 — エラー時に適用するCSSを指定するための属性</li>
<li>th:fieldsオブジェクト — エラー情報にアクセスするための便利なメソッドを提供するオブジェクト<ul>
<li>を使用して行う</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>TODO: エラー処理について設計する必要あり</p>
</li>
<li><p>SpELの利用</p>
<ul>
<li>Thymeleafは数式をOGNLとして解釈しますが、thymeleaf-springを利用すると、</li>
<li>変数式はSpELとして解釈されます。</li>
<li>これにより、テンプレート内から、DIコンテナ内に登録されているBeanにアクセスできるようになる</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;@appSettings.passwordValidDays&#125;"</span>&gt;</span>60<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- @Bean名でアクセスできる --&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>ConversionServiceとの連携<ul>
<li>SpringMVCに適用されているConversionServiceと連携して、値の型変換を行うことができる</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppSettings</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Value</span>(<span class="string">"$&#123;vasicPostage:1250&#125;"</span>)</span><br><span class="line">  <span class="meta">@NumberFormat</span>(style = NumberFormat.Style.NUMBER)</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> basicOneDayCost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;@appSettings.basicOneDayCost&#125;"</span>&gt;</span>1300<span class="tag">&lt;/<span class="name">span</span>&gt;</span>円</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;&#123;@appSettings.basicOneDayCost&#125;&#125;"</span>&gt;</span>1300<span class="tag">&lt;/<span class="name">span</span>&gt;</span>円</span><br></pre></td></tr></table></figure>

<h4 id="12-3-9-テンプレートの共通化"><a href="#12-3-9-テンプレートの共通化" class="headerlink" title="12.3.9 テンプレートの共通化"></a>12.3.9 テンプレートの共通化</h4><ul>
<li><p>テンプレートのフラグメント化</p>
<ul>
<li>共通な内容を別ファイルに切り出す</li>
</ul>
</li>
<li><p>テンプレートのレイアウト化</p>
<ul>
<li>複数のテンプレートで同じデザインレイアウトを適用する場合は、通常、共通的なレイアウトを定義して共有することになる。このような場合に有効なライブラリとして、<code>Thymeleaf Layout Dialect</code>がある</li>
</ul>
</li>
<li><p>テンプレートのフラグメント化</p>
<ul>
<li>テンプレートの一部を分割して別ファイルに切り出すことができる</li>
<li>ヘッダー、フッター、メニューがフラグメントとしてよく利用されるが、特定のUIコンポーネントをフラグメントとして切り出すことも可能<ul>
<li>フラグメントの利用方法<ul>
<li>フラグメントの定義と参照という２つの作業が必要になる</li>
<li>定義方法には以下の２つの方法がある<ul>
<li>Thymeleafのth:fragment属性を利用したフラグメント定義　★個人的にこっちがわかりやすくていいと思う</li>
<li>CSSセレクタと同様、id属性を利用したフラグメント定義</li>
</ul>
</li>
<li>定義したフラグメントを読み込む方法として以下の２つ<ul>
<li>Thymeleafのth:include属性を利用したフラグメントのインクルード</li>
<li>Thymeleafのth:replace属性を利用したフラグメントのち缶</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>テンプレートのレイアウト化</p>
<ul>
<li>Thymeleaf Layout Dialectを利用したテンプレートのレイアウト化について説明</li>
</ul>
</li>
<li><p>セットアップ</p>
<ul>
<li><code>thymeleaf-layout-dialect</code>のリポジトリ追加</li>
<li>コンフィギュレーションクラスの実装</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SpringTemplateEngine <span class="title">templateEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  SpringTemplateEngine templateEngine = <span class="keyword">new</span> SpringTemplateEngine();</span><br><span class="line">  templateEngine.setDialect(<span class="keyword">new</span> LayoutDialect());</span><br><span class="line">  templateEngine.setTemplateResolver(templateResolver());</span><br><span class="line">  <span class="keyword">return</span> templateEngine;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Thymeleaf Layout DialectによるViewの実装</p>
<ul>
<li>共通レイアウトとなるテンプレートを「Decorator」</li>
<li>共通レイアウトを適用する側の個別のテンプレートを「Fragment」と呼ぶ</li>
</ul>
</li>
<li><p>MEMO: 画面の全体像がわかりづらくなりやすいので、この方法は採用したくないため割愛</p>
</li>
</ul>
<h4 id="12-3-10-SpringSecurityとの連携"><a href="#12-3-10-SpringSecurityとの連携" class="headerlink" title="12.3.10 SpringSecurityとの連携"></a>12.3.10 SpringSecurityとの連携</h4><ul>
<li><p>SpringSecurityが提供する画面表示に関する機能をThymeleafで利用するためには、</p>
</li>
<li><p>SpringSecurityDialectを利用します。</p>
</li>
<li><p>以下の機能</p>
<ul>
<li>認証情報にアクセスする機能を持つ sec:authentication属性を提供</li>
<li>SpringSecurity expression を利用した認可処理と同等の機能を持つ sec:authorize属性を提供</li>
<li>URLベースの認可処理を行う sec:authorize-ur属性を提供する</li>
<li>ACL(Access Control List)を利用した認可処理を行う sec:authorize-acl属性を提供</li>
<li>CSRFトークンにアクセスする機能を提供</li>
</ul>
</li>
<li><p>SpringSecurityDialectのセットアップ</p>
<ul>
<li><code>thymeleaf-extras-springsecurity4</code></li>
</ul>
</li>
<li><p>認証情報へのアクセス</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:sec</span>=<span class="string">"http://www.thymeleaf.ort/extras/spring-security"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">th:with</span>=<span class="string">"title=トップページ"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">sec:authentication</span>=<span class="string">"principal.username"</span>&gt;</span>テストユーザ名<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>画面項目への認可</p>
<ul>
<li>適用する画面項目とアクセスポリシーの指定<ul>
<li><code>sec:authorize=&quot;hasRole(&#39;ADMIN&#39;)&quot;</code>属性を付与</li>
<li>Trueの場合、HTMLを表示</li>
</ul>
</li>
<li>Webリソースとして指定したアクセスポリシーとの連動<ul>
<li><code>sec:authorize-url=&quot;/admin/accounts&quot;</code>にアクセスできることを条件として表示非表示を設定している</li>
</ul>
</li>
</ul>
</li>
<li><p>CSRFトークンへのアクセス</p>
<ul>
<li>Spring Security Dialectを適用するだけでOK hidden項目としてHTMLに埋め込まれます</li>
<li>ajax通信の際は取得してあげる必要がある<ul>
<li>headerのmeta要素に設定しといて、JSで取得してあげる感じにする<ul>
<li>TODO: 取得してPOSTする処理は実装考えてみる</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="12-3-11-JSR-310-Date-and-Time-APIの利用"><a href="#12-3-11-JSR-310-Date-and-Time-APIの利用" class="headerlink" title="12.3.11 JSR 310: Date and Time APIの利用"></a>12.3.11 JSR 310: Date and Time APIの利用</h4><ul>
<li><p>Thymeleafは、テンプレート内でJSR310:Date and TimeAPIのオブジェクトを操作するための機能を標準ではサポートしておらず、Thymeleafが提供する拡張ライブラリが必要になる</p>
</li>
<li><p>依存ライブラリの追加</p>
<ul>
<li>thymeleaf-extras-java8timeを利用する</li>
<li>なお、thymeleaf-extras-java8timeはSpringIO Platformで管理されていないため、バージョンの指定が必要</li>
</ul>
</li>
<li><p>Bean定義の追加</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SpringTemplateEngine <span class="title">templateEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  SpringTemplateEngine templateEngine = <span class="keyword">new</span> SpringTemplateEngine();</span><br><span class="line">  templateEngine.setDialect(<span class="keyword">new</span> Java8TimeDialect());</span><br><span class="line">  templateEngine.setTemplateResolver(templateResolver());</span><br><span class="line">  <span class="keyword">return</span> templateEngine;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ユーティリティオブジェクト（temporals）を利用</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span> <span class="attr">th:text</span>=<span class="string">"|$&#123;#temporals.format(date, 'yyyy/mm/dd')&#125;の会議室|"</span>&gt;</span>2020/05/19の会議室<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="第13章-Spring-Boot"><a href="#第13章-Spring-Boot" class="headerlink" title="第13章　Spring Boot"></a>第13章　Spring Boot</h2><p>機能が豊富な事による課題がある<br>どう組み合わせていいかわからなかったり、ちょっとしたWebアプリケーションを作成するだけでも、数多くの設定が必要であったりする点です。</p>
<p>SpringBootを利用することでこられの課題を解決することができる</p>
<h3 id="13-1-SpringBootとは"><a href="#13-1-SpringBootとは" class="headerlink" title="13.1 SpringBootとは"></a>13.1 SpringBootとは</h3><ul>
<li><p>SpringBoot</p>
<ul>
<li>２０１３年　　：開発開始</li>
<li>２０１４年４月：1.0リリース</li>
<li>２０１６年６月：1.3.5</li>
<li>２０２０年５月：2.3.0</li>
</ul>
</li>
<li><p>SpringBootを使えば、何も設定しなくてもデフォルトで様々な機能が利用可能</p>
</li>
<li><p>XMLまたはJavaConfigによるBean定義、ログの設定、Servletの設定などが不要になる</p>
</li>
<li><p>アプリケーションサーバーをデプロイする必要もなくなり、Javaのmainメソッドを実行すればアプリケーションを実行できる</p>
</li>
</ul>
<h4 id="13-1-1-SpringBootで作るHello-Worldアプリケーション"><a href="#13-1-1-SpringBootで作るHello-Worldアプリケーション" class="headerlink" title="13.1.1 SpringBootで作るHello Worldアプリケーション"></a>13.1.1 SpringBootで作るHello Worldアプリケーション</h4><h4 id="13-1-2-AutoConfigureに夜自動設定"><a href="#13-1-2-AutoConfigureに夜自動設定" class="headerlink" title="13.1.2 AutoConfigureに夜自動設定"></a>13.1.2 AutoConfigureに夜自動設定</h4><ul>
<li>自動設定の詳細を知りたい場合は、spring-boot-autoconfigureプロジェクトの◯◯AutoConfigurationクラスのソースを読むことをおすすめします。</li>
</ul>
<h4 id="13-1-3-Starterによる依存ライブラリの解決"><a href="#13-1-3-Starterによる依存ライブラリの解決" class="headerlink" title="13.1.3 Starterによる依存ライブラリの解決"></a>13.1.3 Starterによる依存ライブラリの解決</h4><ul>
<li>starterライブラリの説明</li>
</ul>
<h4 id="13-1-4-実行可能jarの作成"><a href="#13-1-4-実行可能jarの作成" class="headerlink" title="13.1.4 実行可能jarの作成"></a>13.1.4 実行可能jarの作成</h4><ul>
<li>実行可能jarとしてパッケージングされる</li>
</ul>
<h3 id="13-2-SpringBootでSpringMVC"><a href="#13-2-SpringBootでSpringMVC" class="headerlink" title="13.2 SpringBootでSpringMVC"></a>13.2 SpringBootでSpringMVC</h3><h4 id="13-2-1-RESTful-Webサービスの作成"><a href="#13-2-1-RESTful-Webサービスの作成" class="headerlink" title="13.2.1 RESTful Webサービスの作成"></a>13.2.1 RESTful Webサービスの作成</h4><h4 id="13-2-2-画面遷移型アプリケーションの作成"><a href="#13-2-2-画面遷移型アプリケーションの作成" class="headerlink" title="13.2.2 画面遷移型アプリケーションの作成"></a>13.2.2 画面遷移型アプリケーションの作成</h4><ul>
<li><p>SpringBootの自動設定では、TemplateResolverがビュー名につけるプレフィックスとサフィックスのデフォルト値は、</p>
</li>
<li><p>それぞれ、<code>classpath:/templates/</code>と<code>.html</code>になる</p>
</li>
<li><p>テンプレートからメッセージを取得する方法</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span> <span class="attr">th:text</span>=<span class="string">"#&#123;app.title&#125;"</span>&gt;</span> <span class="comment">&lt;!-- $&#123;変数名&#125;ではなく#&#123;メッセージキー名&#125;--&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="13-3-SpringBootでデータアクセス"><a href="#13-3-SpringBootでデータアクセス" class="headerlink" title="13.3 SpringBootでデータアクセス"></a>13.3 SpringBootでデータアクセス</h3><h4 id="13-3-1-SpringJDBC"><a href="#13-3-1-SpringJDBC" class="headerlink" title="13.3.1 SpringJDBC"></a>13.3.1 SpringJDBC</h4><ul>
<li><p>これまで必要だったがSpringJDBCでは不要な定義</p>
<ul>
<li>データソースの定義</li>
<li>トランザクションマネージャの定義</li>
<li>JdbcTemplateの定義</li>
</ul>
</li>
<li><p>SpringBootのデフォルトの挙動としてクラスパス直下に<code>schema.sql</code>が存在すると起動時にそのSQLファイルを実行</p>
</li>
</ul>
<h4 id="13-3-2-Spring-Data-JPA"><a href="#13-3-2-Spring-Data-JPA" class="headerlink" title="13.3.2 Spring Data JPA"></a>13.3.2 Spring Data JPA</h4><h4 id="13-3-3-MyBatis"><a href="#13-3-3-MyBatis" class="headerlink" title="13.3.3 MyBatis"></a>13.3.3 MyBatis</h4><h4 id="13-3-4-コネクションプールライブラリの変更"><a href="#13-3-4-コネクションプールライブラリの変更" class="headerlink" title="13.3.4 コネクションプールライブラリの変更"></a>13.3.4 コネクションプールライブラリの変更</h4><ul>
<li><p>SpringBootではDatasourceを定義する必要はなく、自動で生成されます。コネクションプーリングの仕組みも自動で決まり、以下のライブラリのうちクラスパス上にあるものが利用されます。</p>
<ul>
<li>TomcatJDBC</li>
<li>HikariCP</li>
<li>Commons DBCP</li>
<li>Commons DBCP2</li>
</ul>
</li>
<li><p>TODO: HikariCPが一番速いとのこと</p>
</li>
</ul>
<h3 id="13-4-SpringBootでSpring-Security"><a href="#13-4-SpringBootでSpring-Security" class="headerlink" title="13.4 SpringBootでSpring Security"></a>13.4 SpringBootでSpring Security</h3><ul>
<li>Spring Security用のプロジェクトも当然用意されています。</li>
</ul>
<h4 id="13-4-1-Basic認証"><a href="#13-4-1-Basic認証" class="headerlink" title="13.4.1 Basic認証"></a>13.4.1 Basic認証</h4><ul>
<li>デフォルトで有効になるらしい</li>
<li>デフォルトユーザーはuser</li>
<li>パスワードはランダムに設定される</li>
</ul>
<h4 id="13-4-2-認証・認可のカスタマイズ"><a href="#13-4-2-認証・認可のカスタマイズ" class="headerlink" title="13.4.2 認証・認可のカスタマイズ"></a>13.4.2 認証・認可のカスタマイズ</h4><ul>
<li>SpringSecruityの認証・認可の設定は<code>org.springframework.security.config.annotation.web.configuration.WebSecrityConfigurerAdapter</code>を用いて行う</li>
</ul>
<h3 id="13-5-Spring-Bootで型安全なプロパティ設定"><a href="#13-5-Spring-Bootで型安全なプロパティ設定" class="headerlink" title="13.5 Spring Bootで型安全なプロパティ設定"></a>13.5 Spring Bootで型安全なプロパティ設定</h3><p>application.propertiesから値を取得できる</p>
<ul>
<li>TODO: EnumによるConst管理とどっちがいいか<ul>
<li>メッセージのとり方確認</li>
<li>定数管理方法のベストプラクティス</li>
</ul>
</li>
</ul>
<h4 id="13-5-1-ConfigurationPropertiesを用いたプロパティの設定"><a href="#13-5-1-ConfigurationPropertiesを用いたプロパティの設定" class="headerlink" title="13.5.1 @ConfigurationPropertiesを用いたプロパティの設定"></a>13.5.1 @ConfigurationPropertiesを用いたプロパティの設定</h4><ul>
<li><p>プロパティを多用するSpringBootでは、安全にプロパティを扱うための仕組みとして、</p>
</li>
<li><p><code>@ConfigurationProperties</code>アノテーションが用意されている</p>
</li>
<li><p>TODO: プロパティ管理はこれが良さそう</p>
</li>
</ul>
<h4 id="13-5-2-Bean-Validationに夜プロパティ値のチェック"><a href="#13-5-2-Bean-Validationに夜プロパティ値のチェック" class="headerlink" title="13.5.2 Bean Validationに夜プロパティ値のチェック"></a>13.5.2 Bean Validationに夜プロパティ値のチェック</h4><ul>
<li>プロパティ値も、起動時にBindされる際、<code>@NotEmpty</code>などで値の検証ができる</li>
</ul>
<h4 id="13-5-3-IDEによるプロパティの補完"><a href="#13-5-3-IDEによるプロパティの補完" class="headerlink" title="13.5.3 IDEによるプロパティの補完"></a>13.5.3 IDEによるプロパティの補完</h4><ul>
<li><p><code>@ConfigurationProperties</code>を用いて定義したプロパティはIDEで補完が効く</p>
</li>
<li><p>補完させるためにプロパティのメタ情報を生成する必要がある</p>
</li>
<li><p>spring-boot-configuration-processorの説明</p>
</li>
<li><p>SpringBootでプロパティを外部化する際は積極的に使用していくとよい</p>
</li>
</ul>
<h3 id="13-6-SpringBootAcruatorで運用機能強化"><a href="#13-6-SpringBootAcruatorで運用機能強化" class="headerlink" title="13.6 SpringBootAcruatorで運用機能強化"></a>13.6 SpringBootAcruatorで運用機能強化</h3><ul>
<li><p>SpringBootでは開発を容易にする機能が提供されるだけでなく、アプリケーションの運用面を考慮した機能も提供されている</p>
</li>
<li><p>これを提供するのがSpringBootActuator</p>
</li>
<li><p>これだけでアプリケーションの状態を検査するためのエンドポイント（HTTP,JMX,SSH）が追加されたり、ヘルスチェック機能やメトリクス取得機能が有効になる</p>
</li>
<li><p>TODO: 有効にして活用したい</p>
</li>
</ul>
<h4 id="13-6-1-HTTPエンドポイントの追加"><a href="#13-6-1-HTTPエンドポイントの追加" class="headerlink" title="13.6.1 HTTPエンドポイントの追加"></a>13.6.1 HTTPエンドポイントの追加</h4><ul>
<li><p>HTTPエンドポイント</p>
<ul>
<li>&#x2F;autoconfig</li>
<li>&#x2F;beans</li>
<li>&#x2F;env</li>
<li>&#x2F;configprops</li>
<li>&#x2F;dump</li>
<li>&#x2F;health</li>
<li>&#x2F;info</li>
<li>&#x2F;logfile</li>
<li>&#x2F;metrics</li>
<li>&#x2F;mappings</li>
<li>&#x2F;shutdown</li>
<li>&#x2F;trace</li>
<li>&#x2F;flyway</li>
<li>&#x2F;liquibase</li>
</ul>
</li>
<li><p>エンドポイントのコンテキストパスやポート番号などはプロパティを使用して変更できる</p>
</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.context-path</span>=<span class="string">/manage</span></span><br><span class="line"><span class="meta">management.port</span>=<span class="string">8081</span></span><br><span class="line"><span class="meta">management.address</span>=<span class="string">127.0.0.1 # localhostからのみアクセスを許可する</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 個別のエンドポイントの有効無効を次のプロパティで設定</span></span><br><span class="line"><span class="meta">endpoints.shutdown.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">endpoints.mapping.enabled</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">endpoints.trace.enabled</span>=<span class="string">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># エンドポイントはHTTPだけでなくJMXでもアクセスできる これらの無効にもできる</span></span><br><span class="line"><span class="meta">management.port</span>=<span class="string">-1 # HTTPエンドポイントを無効にする</span></span><br><span class="line"><span class="meta">endpoints.jmx.enabled</span>=<span class="string">false # JMXエンドポイントを無効にする</span></span><br></pre></td></tr></table></figure>

<h4 id="13-6-2-ヘルスチェック"><a href="#13-6-2-ヘルスチェック" class="headerlink" title="13.6.2 ヘルスチェック"></a>13.6.2 ヘルスチェック</h4><ul>
<li>SpringBootActuatorはヘルスチェック機能を持っている</li>
</ul>
<h4 id="13-6-3-メトリクス"><a href="#13-6-3-メトリクス" class="headerlink" title="13.6.3 メトリクス"></a>13.6.3 メトリクス</h4><ul>
<li><p>SpringBootActuatorはメトリクス取得機能も備えている</p>
</li>
<li><p>次の２つのメトリクスがサポートされている</p>
<ul>
<li>gauge: 絶対値を記録する</li>
<li>counter: 差分値を記録する</li>
</ul>
</li>
<li><p>TODO: メトリクスは収集して管理できる用にしておく</p>
</li>
</ul>
<h2 id="第14章-チュートリアル"><a href="#第14章-チュートリアル" class="headerlink" title="第14章　チュートリアル"></a>第14章　チュートリアル</h2><ul>
<li>会議室予約システムを作成していく手順を記載</li>
</ul>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最終更新：<time datetime="2020-05-29T16:24:02.674Z" itemprop="dateUpdated">2020-05-30 01:24:02</time>
</span><br>


        
        thank you for your reading my article!!
        
    </div>
    
    <footer>
        <a href="http://yoursite.com">
            <img src="https://tutttuwi.github.io/output-over-there/img/avatar.png" alt="t-tsutsui">
            t-tsutsui
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="https://tutttuwi.github.io/output-over-there/tags/%E6%95%99%E7%A7%91%E6%9B%B8/" target="_blank" rel="tag noopener">教科書</a></li></ul>


            


        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="https://tutttuwi.github.io/output-over-there/JAVA/2020-06_SpringBoot2%E5%BE%B9%E5%BA%95%E6%B4%BB%E7%94%A8/" target="_blank" rel="noopener" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">SpringBoot2徹底活用</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="https://tutttuwi.github.io/output-over-there/JAVA/2020-04_JavaEE7%E5%BE%B9%E5%BA%95%E5%85%A5%E9%96%80/" target="_blank" rel="noopener" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Java EE 7徹底入門 標準Javaフレームワークによる高信頼性Webシステムの構築</h4>
      </a>
    </div>
  
</nav>



    

















</article>



</div>

        <footer class="footer">
    <div class="top">
<!--        

        <p>
            
                <span><a href="https://tutttuwi.github.io/output-over-there/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>このブログの内容物は<a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.ja" target="_blank">クリエイティブ・コモンズ 表示 - 非営利 - 継承 4.0 国際ライセンスの下に提供されています</a></span>
        </p> -->
    </div>
    <div class="bottom">
        <p><span>t-tsutsui &copy; 2015 - 2023</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>


    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: 'https://tutttuwi.github.io/output-over-there/', SHARE: false, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>










</body>
</html>
