{"meta":{"title":"OUTPUT*OVER-THERE","subtitle":null,"description":null,"author":"t-tsutsui","url":"http://yoursite.com"},"pages":[{"title":"OUTPUT*OVER-THERE | 404","date":"2019-01-21T13:23:36.785Z","updated":"2019-01-21T13:23:36.785Z","comments":true,"path":"index.html","permalink":"http://yoursite.com/index.html","excerpt":"","text":""},{"title":"このサイトについて","date":"2019-08-25T03:46:17.711Z","updated":"2019-08-25T03:46:17.711Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"自己紹介 名前：tsutsui 生年：1991年生まれ その他、ポートフォリオをご確認ください。 運用目的 学習した技術情報をアウトプットする場所として使用 日々の成長を残せていけたらと思い作成 環境について 本サイトは Amazon S3 上に静的に配備しています。 構成概要は以下の通り。 ご留意事項 できるだけ正確に、まとまった記載を心がけますが、誤記がある可能性がありますのでご留意頂きますようお願いします。"},{"title":"カテゴリー","date":"2019-01-21T13:20:36.143Z","updated":"2019-01-21T13:20:36.143Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"タグ","date":"2019-01-21T13:20:18.700Z","updated":"2019-01-21T13:20:18.700Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring徹底入門","slug":"2020-05_Spring徹底入門","date":"2020-04-30T15:00:00.000Z","updated":"2020-05-23T03:23:23.720Z","comments":true,"path":"JAVA/2020-05_Spring徹底入門/","link":"","permalink":"http://yoursite.com/JAVA/2020-05_Spring徹底入門/","excerpt":"","text":"Spring徹底入門 目次 第1章 Spring Frameworkとは 第2章 Spring Core（DI×AOP） 第3章 データアクセス（Tx、JDBC） 第4章 Spring MVC 第5章 Webアプリケーションの開発 第6章 RESTful Webサービスの開発 第7章 Spring MVC の応用 第8章 Spring Test 第9章 Spring Security 第10章 Spring Data JPA 第11章 Spring ＋ MyBatis 第12章 Spring＋Thymeleaf 第13章 Spring Boot 第14章 チュートリアル 形式：書籍 発売日：2016年07月20日 ISBN：9784798142470 価格：本体4,000円＋税 仕様：B5変・744ページ 第1章 Spring Frameworkとは Spring Frameworkの概要 「Spring Frameworkは、開発当初より古いインフラ環境上でも新しいインフラ環境上でも、最新のプログラミング思想で開発出来ることを設計思想にしている」 Spring Frameworkの歴史 2003年：Interface21 Framework → Spring Frameworkへと変更になった (Expert One-one-One: J2EE Design and Development) 2004年：EJBを使わずにSpringFramework1.0で開発する方法 2005年：SpringFramework1.2 の機能をカバーした書籍が刊行 SpringをStruts,Hibernateと組み合わせて使う（SSH） 2006年：SpringFramework2.0がリリース 2007年：SpringFramework2.5 アノテーションベースのDIやMVC 米国に拠点を移す SpringToolSuiteなど統合開発環境の提供が始まる 2009年：SpringFramework3.0がリリース JSR330に対応 2013年：SpringFramework4.0がリリース WebsocketやWebメソッドなどをサポート Pivotalという新しい会社にスピンオフ 2014年：昨今注目されているSpringBootやSpringIOPlatformプロジェクトが始まる Springの各種プロジェクトについて SpringMVC: Webアプリケーションを開発するためのフレームワークであり、MVCパターンを利用している MVCパターンには、「アクションベースフレームワーク」と「コンポーネントベースフレームワーク」の２パターンある アクションベースフレームワーク リクエストによって実行する処理（アクション）を決定し、処理の結果としてレスポンスを返すフレームワーク コンポーネントベースフレームワーク リクエストやレスポンスを抽象化（隠蔽）し、画面を構成するコンポーネントをベースにWebアプリケーションを開発するフレームワーク JSFはコンポーネントベースのフレームワーク MEMO: JavaEE徹底入門読んで理解した！ 各種サードパーティとの連携機能もある Jackson ApacheTiles FreeMarker Rome JasperReports また、Thymeleafなど、サードパーティ自体がSpringMVCをサポートしているケースも有る Spring Security Authentication(認証) Authorization(認可)などのセキュリテイ要件を用意に実現するためのフレームワーク 非常に多くの認証方式に対応している Basic認証 ダイジェスト認証 X.509クライアント証明証 LDAP OpenID Spring Data Spring Dataはリレーショナル・データベースやNoSQL、Key-Valueストアなど様々なデータストアへのデータアクセスを用意にするためのもの Spring Data Commons Spring Data JPA Spring Data MongoDB, Spring Data Redis, Spring Data Solr, etc… Spring Batch バッチアプリケーション向けの軽量フレームワーク 大容量のデータ処理に必要な共通機能を提供している もともと、Accentureが開発したバッチアプリケーション向けのフレームワークをベースとしており、2008年にSpringBatchとしてバージョン1.0がリリース Spring Integration Enterprise Integration Patterns(EIP)としてよく知られているさまざまなシステム間を連携させるアーキテクチャパターンに基づく開発をサポートするフレームワーク 同様の機能を実現するOSSとして、ApacheCamelが有名です。 Spring Cloud 分散環境でCloud Nativeなアプリケーションを開発するためのフレームワーク及びツール群 SpringCloudConfig SpringCloudBus SpringCloudConnectors SpringCloudNetflix Spring tool Suite Eclipseベースの統合開発環境 Spring IO Platform 依存関係を管理するためのライブラリー Spring Boot 最小限の設定でプロダクションレベルのSpringアプリケーションを容易に開発するためのSpringプロジェクト JavaEEとの関係 差は縮まっている Springのほうが新しい技術を取り込むサイクルが早い 第2章 Spring Core（DI×AOP） DIコンテナメリット インスタンスのスコープを制御できる インスタンスのライフサイクルを制御できる 共通機能を組み込める コンポーネント間が疎結合になるため、単体テストがしやすい SpringFramework以外の有名なDIコンテナのフレームワーク CDI(Contexts&amp;DependencyInjection) ：JavaEE6で導入されたコンテキストに対応したDIの仕様 Google Guice Dagger ApplicationContextとBean定義 SpringFrameworkではApplicationContextがDIコンテナの役割を担う DIコンテナに登録するコンポーネントのことを「Bean」 Configurationのことを「Bean定義」 DIコンテナからBeanを取得することを「ルックアップ」という 123UserService userService = context.getBean(UserService.class);UserService userService = context.getBean(\"userService\",UserService.class);UserService userService = (UserService)context.getBean(\"userService\"); 代表的なBean定義の方法 JavaベースConfiguration XMLベースConfiguration アノテーションベースConfiguration それぞれ１つだけを使用して実装もできるが、通常は JavaベースConfigurationとアノテーションベースConfigurationの組み合わせ、または XMLベースConfigurationとアノテーションベースConfigurationの組み合わせを用いてBean定義を行う Configuration方法 javaベース、XMLベース、アノテーションベースの説明 インジェクションの種類 セッターインジェクション コンストラクタインジェクション フィールドインジェクション オートワイヤリング @Beanメソッドや&lt;bean&gt;要素で明示的にBean定義しなくても自動的にＤＩコンテナにインジェクションさせる仕組み 解決方法は２つ 型によるもの（by Type） 名前によるもの（by Name） 型による解決 デフォルトでインジェクションされる事が必須 対象の型を持つBeanが１つも登録されていないとorg.springframework.beans.factory.NoSuchBeanDefinitionExceptionが発生 required = false を指定するか Spring4からは、required = falseの代わりに、JavaSE8から導入された、java.util.Optionalを使用することが出来る MEMO: Optional&lt;T&gt;で実装できる！絶対こっちのほうがいい 関数型プログラミングの本で知った。 名前による解決 同じ親クラスを持つ２つの実装クラスにBean定義をして、インジェクションする場合 @Qualifierで名前を指定してあげないといけない @Primaryを使えば、名前を指定しなかった時にインジェクションされるデフォルトを指定できる 名前には、実装クラス名を記載するべきではない。呼び出し側で実装を特定してしまうとDIの意味がなくなる。用途名を指定するべき。 用途は文字列ではなく、アノテーションでも指定できる。 [ ] 用途を指定するためのアノテーション作成してみたい [ ] 独自アノテーションを作成してみる 名前によるオートワイヤリング @Resourceを付与 フィールド名がBean名に一致するパターン プロパティ名がBean名に一致するパターン コレクションやmap型によるオートワイヤリング 2.1.6 コンポーネントスキャン デフォルトのコンポーネントスキャン 以下のアノテーションが付いたクラスがＤＩコンテナに登録される `@org.springfrwamework.stereotype.Component` `@org.springfrwamework.stereotype.Controller` `@org.springfrwamework.stereotype.Service` `@org.springfrwamework.stereotype.Repository` `@org.springfrwamework.context.annotation.Configuration` `@org.springfrwamework.web.bind.annotation.RestController` `@org.springfrwamework.web.bind.annotation.ControllerAdvice` `@javax.annotation.ManagedBean` `@javax.inject.Named` コンポーネントスキャンは広範囲な程処理が遅くなるので不適切 @ComponentScan(basePackages = &quot;com&quot;) @ComponentScan(basePackages = &quot;com.example&quot;) 対象のアプリケーションのトップレベル、あるいはもう１階層下をスキャン対象にすべき @ComponentScan(basePackages = &quot;com.example.demo&quot;) @ComponentScan(basePackages = &quot;com.example.demo.app&quot;) value属性は basePackages属性の別名であり、どちらを使用しても構いません。この属性を省略した場合、コンフィグレーションクラスと同じパッケージ配下をスキャンすることに注意する事 スキャン対象のアノテーションとしては以下の４種類がよく使われる アノテーション 説明 @Controller MVCパターンのC(Controller)の役割を担うコンポーネントであることを示すアノテーション。このアノテーションを付与したコンポーネントでは、クライアントからのリクエストとクライアントへのレスポンスに関わる処理を実装する。ビジネスロジックは、@Serviceを付与したコンポーネントで行う @Service ビジネスロジック（ビジネスルール）を提供するコンポーネントであることを示すアノテーション。このアノテーションを付与したコンポーネントでは、ビジネスルールが関わる処理を実装する。データの永続化に関わる処理は@Repositoryを付与したコンポーネントで行う。 @Repository データの永続化に悪化÷処理を提供するコンポーネントであることを示すアノテーション。このアノテーションを付与したコンポーネントでは、ORM(Object-Relational Mapper)などの永続化ライブラリ等を使用して、データのCRUD処理を実装する @Component 上記３に当てはまらないコンポーネント（ユーティリティクラスやサポートクラスなど）に付与するアノテーション フィルタを明示したコンポーネントスキャン アノテーションによるフィルタ 代入可能な型によるフィルタ 正規表現によるフィルタ AspectJパターンによるフィルタ [ ] フィルタを駆使するパターンについてメリットがあまり分からないため飛ばす.. あとで調べる 2.1.7 Beanのスコープ DIコンテナを使用するメリット Beanのスコープ（生存期間）の管理をコンテナに任せる事が出来ること スコープ 説明 singleton DIコンテナの起動時にBeanのインスタンスを生成し、同一のインスタンスを共有して利用する。デフォルトの設定であり、スコープを設定しない場合はsingletonとして扱われる prototype session request globalSession application カスタムスコープ(独自の命名) 覚書 @Beanアノテーションの使いどころ @Configurationクラスの中に定義しているメソッドに付与して使う DIコンテナに登録され、デフォルトではsingletonで参照出来る 2.1.8 Beanのライフサイクル 初期化フェーズ 利用フェーズ 終了フェーズ 2.1.9 Configurationの分割 DIコンテナで管理するBeanが多くなるとConfigurationも肥大化してしまう Configurationの範囲を明確にし、可読性を上げるために、必要に応じてConfigurationの分割を行う @importを使えば複数のConfigurationクラスに分割ができる MEMO: importでまとめなくても、@Configurationでコンポーネントスキャンされるので関係ないと思う Contextから取得してわざわざアクセスしていた際に有用な方法だったと考える 2.1.10 Configurationのプロファイル化 Springでは異なる環境や目的ごとにConfigurationをグループ化することができる このグループを「プロファイル」といいます。 例えば、環境ごとに「developmentプロファイル」「testプロファイル」などを作成することが考えられる @Profileアノテーションを使用して指定する 使用するプロファイルの選択方法 JVM引数 -Dspring.profiles.acrive=production 環境変数 export SPRING_PROFILES_ACTIVE=production WEB.xmlに記載することもできる（割愛） application.yml に指定することもできる（割愛） MEMO: 環境ごとの情報を定義するためのJavaクラスにアノテーションを付与して実現するのは微妙だと思うので、 application.ymlで管理するのが良いだろうと思う 2.1.11 JSR 330: Dependency Injection for Java Springで、Java標準のJSR330で定められたAPI（主にアノテーション）を使用することができる Spring JSR 説明 @Autowired @Inject @Injectには必須チェック（required属性）がない @Component @Named Springの場合はデフォルトでSingletonスコープであるが、JSR330の場合はデフォルトでprototypeスコープである @Qualifier @Named @Namedが兼用される @Scope @Scope JSR330の@Scopeはスコープを定義するカスタムアノテーションを作るためのメタアノテーション Springを使うのであれば、特にこだわりがなければ、Springのアノテーションを使うのがいいでしょう 2.2 AOP ロギング処理、キャッシュ処理など本質的ではない処理がいろいろなロジック中に散在するようになる 複数のモジュールにまたがって存在する処理は、「横断的関心事（Cross-Cutting Concern）」と呼ばれる 代表的なものとしては以下 セキュリティ ログ出力 トランザクション モニタリング キャッシュ 例外ハンドリング プログラムの中から横断的関心事を取り除き、一箇所に集めることを「横断的関心事の分離（Separation Of Cross-Cutting Concerns）」と呼び これを実現する手法をアスペクト指向プログラミングといいます 2.2.1 AOPの概要 AOPはDIと並ぶSpringFrameworkの重要な機能 AOPのコンセプト Aspect AOPの単位となる横断的な関心事を示すモジュールそのもの Join Point 横断的な関心事を実行するポイント（メソッド実行時や例外スロー時など） Join PointはAOPライブラリーによって使用が決められている SpringのAOPでは、Join Pointはメソッドの実行時 Advice 特定のJoin Pointで実行されるコードのことで、横断的な関心事を実装する箇所 Adviceには、Around,Before,Afterなど複数の種類が存在する PointCut 実行対象のJoin Pointを選択する表現式のこと SpringAOPではBean定義ファイルやアノテーションを利用してPointCutを定義 Weaving アプリケーションコードの適切なポイントにAspectを入れ込む処理のこと AOPライブラリにはWeavingをコンパイル時に行うもの、クラスロード時に行うもの、実行時に行うものがあり、SpringAOPは実行時にWeavingを行う Target AOP処理によって、処理フローが変更されたオブジェクトのこと TargetオブジェクトはAdvisedオブジェクトと呼ばれることもある 2.2.2 Spring AOP SpringAOP は現場で広く使われているAOPフレームワークであるAspectJを利用している 2.2.3 Adviceの実装方法 Before After Returning After Throwing など記載していく 括弧にPointCut式を記載する 2.2.4 XMLでAdviceの実装XMLに記載する方法について 2.2.5 Pointcut式Joint Pointを指すPointCutとしてexecution(* *..*ServiceImple.*(..))という式を使ってきたがその打ち合わけを記載 123 ↓メソッド@After(execution(* com.example.domain.*Service.find*(..))) ↑戻り値 ↑パッケージ ↑型、クラス ↑引数 PointCut式で利用可能なワイルドカード * .. + 名前付きポイントカットの書き方 2.2.6 Springプロジェクトで利用されているAOP トランザクション管理処理：メソッドに@Transactionアノテーションを付与 認可処理：@PreAuthorizeアノテーションを付与 キャッシュ処理：@Cacheable(&quot;key&quot;)ですでにキャッシュがある場合はメソッドを実行せずにキャッシュされた値を返す 非同期処理：@Asyncをメソッドに付与、指定された戻り値（CompletableFuture&lt;Result&gt;）を指定することで非同期実行ができる リトライ処理：@Retryable(maxAttempts=3)をメソッドに付与。信頼性をコントロールできない外部接続先の呼び出しなどで有用 2.3 データバインディングと型変換 本来であれば、HttpServletRequestクラスからパラメータをgetしてBeanに１つ１つ設定しなければ行けないが、 型変換しなければ行けない場面もあり面倒でミスが起きやすい Springのデータバインディングを利用するとこれらの問題を解消できる 2.3.1 Springのデータバインディング123EmployeeForm form = new EmployeeForm();ServletRequestDataBinder dataBinder = new ServletRequestDataBinder(form);dataBinder.bind(request); これを記載することで、３行でデータバインディングができる また、SpringMVCの機能を使えば１行で済む （恐らく、@ModelAttributeを付与することを言っているのだと思う） 2.3.2 Springの型変換 型変換を行うための仕組みとして以下の３つを提供している PropertyEditor Type Conversion Field Formatting 2.4 プロパティ管理 ハードコーディングを避けるためにプロパティから値を読み込む仕組みがある Strutsを使用していたときはプロパティファイルの値取得はResourceBundleでUtilクラス経由で取得していたのに対して、 SpringのDIであれば、@Value(xxxx)を引数やフィールドに指定するだけで取得できる MEMO: これは必ず使用する :で区切って記載すればデフォルト値も指定できる！ @Value(xxxx:5)などのように 2.5 Spring Expression Language(SpEL) Spring Expression Language (SpEL)は、SpringFrameworkが提供しているExpression Language MEMO: 使用しないことにする 2.5.1 SpELのセットアップ pom.xmlの例 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;&lt;/dependency&gt; 2.5.2 SpEl APIの利用 直接APIを使用するケースはないと思うが、SpELの仕組みを理解するために使用方法を説明 2.5.3 Bean定義でのSpELの利用 SpELで定義した値をコンストラクタの引数に渡す方法の説明 アノテーションの場合は、@Value(&quot;#{T(java.util.UUID).randomUUID().toString()}&quot;) String idのような形で定義する SpELは様々なアノテーションの中で利用することができる @EventListener @TransactionalEventListener @Cacheable @CachePut TODO:後で調べる 2.5.4 SpELで使用可能な式の表現 リテラル値 オブエジェクトの生成 プロパティへの参照 メソッドの呼び出し 型の解決 変数の参照 Beanの参照 演算子 テンプレート コレクションの操作 MEMO:テンプレートエンジン使うなら、SpELいらないのは説 2.6 リソースの抽象化 アプリケーションは様々なリソースにアクセスする必要がある これらのリソースが格納されている場所は ファイルシステム上のディレクトリ クラスパス上のディレクトリ サーブレットコンテナ上のwarファイル jarファイル 別のWebサーバー など多岐に渡る 2.6.1 Resourceインターフェースと実装クラス Resourceインターフェース実装クラス ClassPathResource FileSystemResource PathResource UrlResource ServletContextResource TODO: Resourceインターフェースを実装しているクラスをいくつか紹介してくれているが、 実際にこれらのクラスを使ってみる必要あり 2.6.2 ResourceLoaderインターフェース MEMO: ResourceLoaderインターフェースと上記のつながりが理解できてないので再確認 ResourceLoader経由のほうがよい？ 上記の実装クラスを使わなくて済むならこっちのほうがよいと考える 2.6.3 Resourceインターフェースを利用したリソースアクセス TODO: 実際に使ってみる必要あり 2.6.4 XMLファイル上でのリソースの指定 割愛 MEMO: リソース取得先の指定はプロパティファイルにまとめるべき！ すべて@Value()で記載すればよい 2.7 メッセージ管理 説明文や項目名などの固定文言 処理結果に通知するメッセージ エラーメッセージなどを表示する際に プロパティファイルなどの外部定義から取得することが求められるケースも多いはず メッセージの外部化のメリット 多言語サポートする要件を満たす 一箇所で一元管理する 2.7.1 MessageSourceインターフェースと実装クラス MessageSource メッセージの格納先を抽象化するためのインターフェース MessageSourceResolvable メッセージ解決に必要な値（code,args,defaultMessage）を保持していることを示すインターフェース MessageSourceの実装クラス ResourceBundleMessageSource ReloadableResourceBundleMessageSource 2.7.2 MessageSourceの利用 MessageSourceのBean定義 123456@Beanpublic MessageSource messageSource() &#123; ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); messageSource.setBeannames(\"messages\"); // クラスパス上に格納されているプロパティファイル（拡張子は除く）を指定する return messageSource;&#125; メッセージの定義ファイルを作成 MessageSourceのAPI利用 DIコンテナに登録したMessageSourceをインジェクションしてgetMessageメソッドを呼び出す MEMO: 感じたこと 標準のクラスをDIコンテナで管理したい場合@Beanをメソッドにつけているのかなと思った 独自のクラスを作るのであれば、@Componentでよいのではと MessageSourceResolvableの利用 メッセージ引数もメッセージ定義で管理したい場合に利用するみたい 第3章 データアクセス（Tx、JDBC） データアクセス機能について解説 JDBC関連の機能 トランザクション管理機能 データアクセスエラーのハンドリング機能 その他ライブラリの機能（JPA、Hivernate、MyBatisといったORM）は以降の章で解説 3.1 Springによるデータアクセス まずはSpringが扱うことができるデータソースの種類について 3.1.1 データソースについてデータソースは、データベースにアクセスするためのコネクションをアプリケーションに提供する役割を担う Springが提供するデータベースアクセス機能では、以下に示す３つのデータソースを利用することができる アプリケーション内に定義したデータソース アプリ内にユーザや接続情報などを記載するパターン アプリケーションサーバーに定義したデータソース APサーバーに定義されたデータソースを利用するパターン MEMO: JavaEE徹底入門ではこのパターンでサンプル実装されていた 組み込みデータベースのデータソース HSQLDB、H2、Apache Derbyといった組み込みデータベースをデータソースとして利用する MEMO: Commons DBCP はコネクションプール機能付きのデータソースを提供するライブラリー 実際に定義を作成していく際に、コネクションプール設定方法について確認しておく 3.1.2 データソースのコンフィギュレーション123456&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt;&lt;/dependency&gt; アプリケーション定義のデータソース アノテーション定義の例（詳細略） XML定義の例（詳細略） アプリケーションサーバー定義のデータソース Jndiを指定して参照する（詳細略） 組み込みデータソース （詳細略） TODO: 実際に上記の３種類で接続をしてみる必要がある 3.2 Spring JDBC 前節ではSpring JDBCを使用するために必要となるデータソースのBean定義方法を紹介した データアクセス処理を記述するための中心的な役割を持つJdbcTempleteクラスの使用方法を紹介 SQLを実行する方法 SQLへ値をバインドする方法 SQLの実行結果からデータを取得する方法 3.2.1 Spring JDBCとはSQLの内容にかかわらす共通に行われる定型的なJDBCの処理をSpringが代替する機能 定型的な処理 コネクションのオープンやクローズ SQLステートメントの実行 処理結果行の繰り返し処理 例外ハンドリング SpringJDBCを利用することで、実装範囲を以下のような重要な処理に限定できる SQLの定義 パラメータの設定 ResultSetの取得結果において、各レコードに対して実行したい処理 3.2.2 JdbcTempleteクラスを利用したCRUD操作 JdbcTempleteクラスを用いたCRUD操作の説明 MEMO: ORMを使用したほうが効率が良さそう 念の為読んでおく程度で、覚えておかなくても良いと考える 3.2.3 取得結果の変換処理 SpringJDBCでは取得結果を変換できる３つのインターフェースを用意している RowMapper ResultSetの１行を特定のPOJOインスタンスに変換する ResultSetExtractor 複数行から１つのインスタンスを生成できる RowCallbackHandler ResultSetを参照してなんらかの処理を行うためのインターフェース 戻り値を返さない。取得結果のファイル出力や、データのチェックなどを行う場合に利用します。 RowMapperの実装方法 RowMapperインターフェースを実装したクラスにメソッドを作成して使用する BeanPropertyRowMapperクラスを利用することもできる 制約はありルールに沿ってBean定義すればかんたんにResultSetを設定可能 ResultSetExtractorの実装 割愛 RowCallbackHandlerの実装 割愛 3.2.4 応用的なCRUD操作 SQLのバッチ実行 batchUpdate()メソッドを利用する ストアドプロシージャの呼び出し JdbcTemplateのcallメソッドやexecuteメソッドを利用することで呼び出すことができる TODO: ストアド・プロシージャ使ってみる。使ったことないので。。 3.3 トランザクション管理 アノテーションを用いたトランザクション管理方法 プログラム内に直接commitメソッドやrollbackメソッドを記述する明示的なトランザクション管理について説明 3.3.1 トランザクションマネージャ PlatformTransactionManager: Springのトランザクション管理の中心となるインターフェース トランザクションマネージャの定義 PlatformTransactionManagerのBeanを定義する トランザクション対象とするメソッドを定義する ローカルトランザクションを利用する場合 単一データベースに対する複数の操作 XMLにTransactionManagerの定義を記載する方法を紹介 BeanIDはtransactionManagerを指定することを推奨 グローバルトランザクションを利用する場合 異なるデータベースに対する複数の操作 グローバルトランザクションの仕組みはJTAというJavaEEの仕様として標準化されておりアプリケーション・サーバーからJTAの仕組みが提供されている 実装クラスとしてJtaTransactionManagerを使用する ただし、製品ごとのJtaTransactionManagerが提供されているのでそちらを使う 自動的に最適なクラスを使う仕組みが用意されているらしい 3.3.2 宣言的トランザクション 宣言的トランザクションとは 事前に宣言されたルールに従い、トランザクションを制御する方法のこと メリット トランザクションの開始やコミット、ロールバックなどの典型的な処理をビジネスロジックの中に記述する必要がなくなる 利用方法 @Transactional XMLコンフィギュレーション @Transactionalを利用した宣言的トランザクション トランザクション制御で必要となる情報 アノテーションの引数について説明（割愛） クラスに付与するかメソッドに付与するか コンフィギュレーションクラスに定義する方法も紹介している XMLコンフィギュレーションによる宣言的トランザクション 割愛 3.3.3 明示的トランザクション 明示的トランザクションとは コミットやロールバックといったトランザクション制御に関する処理をソースコードに明示的に記述する方法 PlatformTransactionManagerを利用した明示的トランザクション制御 commit(),rollback()などを直接書く TransactionTempleteを利用した明示的トランザクション制御 @ConfigurationクラスにBean定義する際にトランザクションを設定 MEMO: 明示的トランザクションはどちらも使いにくいような印象 3.3.4 トランザクションの分離レベルと伝播レベル TODO: ★見返して実装に組み込む トランザクション分離レベル TODO: トランザクション分離レベルについて復習すべし トランザクション伝播レベル MEMO: 伝播レベルについて意識したことはなかった トランザクション処理が入れ子になったときに初めて意識することになる。 通常の処理の場合はデフォルトのRequiredで問題ないような気がする。 TODO: 逆に入れ子にするパターンってどのような要件が考えられるか確認する →本書に解説があった。 業務ロジックのトランザクションとは別に、ログ出力用の処理でDBアクセスがある場合 業務ロジックでロールバックが発生すると、ログ出力用のデータもロールバックされてしまう。 こうならないように、ログ出力用のトランザクションはREQUIRES_NEWで生成しておく必要があるとのこと そもそもDBにログを貯める仕様が良くないのではと思う 3.4 データアクセスエラーのハンドリング データアクセス処理でエラーが発生した際のハンドリング処理を実装しておく必要がある Springにおけるデータアクセス例外の抽象化の考えかたを理解した上で、エラーハンドリング処理の実装方法や抽象化のカスタマイズ方法を紹介 3.4.1 Springが提供するデータアクセス例外 DataAccessExceptionを親クラスとするデータアクセス例外の階層構造 MEMO: かなり多くの種類のエラーが、DataAccessExceptionから切られていることを確認した 非検査例外によるDataAccessExceptionの実装 DataAccessExceptionはRuntimeExceptionが親クラスなので、例外ハンドリングが強制されてませんよという説明 実装を隠蔽したデータアクセス例外 DBごとに例外コードが異なるが、Springのデータアクセス機能で共通の例外クラスに変換している MEMO: これは画期的ですごい便利だと感じた→当たり前でもあるか.. 3.4.2 データアクセス例外のハンドリング 非検査例外のため、ハンドリングを行いたい場所だけcatchする、行いたくない場所は何もする必要が無い データアクセス例外のハンドリングを行う実装例 Springが提供している例外でcatchできるようにtry-catchで囲む catch後は、プロジェクトの例外を再throwする 3.4.3 データアクセス例外の変換ルールのカスタマイズ 各データベースのエラーコードとデータアクセス例外の対応はspring-jdbc-xxx.jarに含まれるsql-error-codes.xmlに定義されているが、クラスパス直下にsql-error-codes.xmlを配置することでこの定義をカスタマイズすることができる 第4章 Spring MVC 第三章までで得た知識で開発できるのは、データベースにアクセスするスタンドアロンアプリケーション 本章から７章までにかけて、SpringMVCの機能を利用したWebアプリケーションの開発方法について解説 本章 SpringMVCの特徴を簡単に説明 シンプルなサンプルアプリケーションを作成しながらSpringMVCの基礎を学ぶ SpringMVCのアーキテクチャについて説明 4.1 Spring MVC とは フレームワークのアーキテクチャとしてMVCパターンを採用している TODO: MVC以外のアーキテクチャについて理解を深める Springは正確に言うと、フロントコントローラパターンを採用しているらしい詳細は4.3SpringMVCのアーキテクチャで解説 4.1.1 Webアプリケーション開発における特徴 SpringMVCはWebアプリケーションをストレスなく快適に開発することができるフレームワークで、次のような特徴がある POJO（Plain Old Java Object）での実装 フレームワーク独自のインターフェースを実装する必要が無いため、作成するクラスの単体テストのテスタビリティを確保 アノテーションを使用した定義情報の指定 柔軟なメソッドシグネチャの定義 Controllerに渡す引数や戻り値も様々な形がサポートされている ServletAPIの抽象化 ServletAPI（HttpServletRequest,HttpServletResponse,HttpSessionなどのAPI）を抽象化する仕組みを提供 テスタビリティを確保 Viewの実装技術の抽象化 コントローラはView名（Viewの論理名）を返却し、SpringMVCのフレームワーク処理が呼び出すViewを決定 ControllerはViewの実装技術（Thymeleaf,ServletAPI,FreeMarkerなど）を意識する必要がなくなる SpringのDIコンテナとの連携 SpringMVCはSpringのDIコンテナ上で動作するフレームワーク DIやAOPなどの仕組みを活用できる MEMO: この辺は開発で感触をつかめているのですんなり理解できた 4.1.2 MVCフレームワークとしての特徴 豊富な拡張ポイントの提供 処理の役割に応じてインターフェースを定義している エンタープライズアプリケーション向けの機能の提供 メッセージ管理 セッション管理 国際化 ファイルアップロードといったエンタープライズアプリケーション向けのWebアプリケーションを開発する際に必要となる機能も提供 サードパーティのライブラリとの連携部品の提供 ★Jackson(JSON/XML操作) → JSON操作は他に、org.jsonがあるみたいだが、Jacksonの方が良さそう Apache Tiles(レイアウトエンジン) → レイアウトを組める。Thymeleafのincludeで十分なので使わない FreeMarker(テンプレートエンジン) → 変数を持つ定型文言を作成しておき（*.ftlファイル） ★Rome(RSS/Feed操作) → 他に、Informaというのがあるらしい。 ★JsperReports(帳票出力) → 他にも色々なライブラリがあるみたいだが、一旦これを使用したい https://weblabo.oscasierra.net/java-pdf-lib-2017/ ★Apache POI(Excel操作) ★Hibernate Validator(Bean Validation) Joda Time(日付操作) → Java7時代の日付操作 など サードパーティ自体がSpringMVCとの連携部品を提供しているケースもある。 Thymeleaf(テンプレートエンジン) ★HDIV(セキュリティ強化) TODO: ★つけたライブラリーは使用したい 4.2 はじめてのSpring MVCアプリケーション4.2.1 開発プロジェクトの作成 InteliJ IDEA でプロジェクトを作成することにした mavenプロジェクトをstartarのアーキタイプで作成 pom.xmlをサンプルアプリに合わせる mavenがうまく動かない不具合発生 原因: urlがmavenレポジトリを向いていなかったため 結果: 解消しなかった Intelijだとうまくいかないと判断し、Eclipseで実施 Eclipseでサンプルプログラムを配置 mavenの設定をサンプルに合わせる javaeeのモジュールがデフォルトで読み込めなくなったみたいなので、pomに定義を入れる tomcat9サーバーを立ち上げる context-pathはデフォルトでプロジェクト名？になるみたいなので、http://localhost:8080/firstapp4-2でアクセスするとうまく行った Web.xmlにjsp-configというものを定義すると、すべてのjspに対してデフォルトでincludeさせることができるみたい TODO: spring bootで生成したプロジェクトだと、web.xmlが必要ない？ そのあたりの仕組みが理解できていない 4.2.2 Spring MVCの適用4.2.3 トップ画面表示処理の実装4.2.4 入力画面表示処理の実装4.2.5 送信処理の実装4.2.6 入力チェック処理の実装 ここまででサンプルアプリケーションの説明終了 Controllerクラス フォームクラス View(JSPなどのテンプレートファイル) 本来であれば、JSPではなくThymeleafとかを使うべきだと思うので、詳細な実装はサラッと流し読み 4.2.7 XMLファイルを使用したBean定義 割愛 4.3 Spring MVCのアーキテクチャ4.3.1 フレームワークのアーキテクチャ Spring MVCは「フロントコントローラパターン」と呼ばれるアーキテクチャを採用している クライアントからのリクエストをフロントコントローラと呼ばれるコンポーネントが受け取り、リクエストの内容に応じて実行するHandler(Controller)を選択するアーキテクチャ フロントコントローラが担う処理 クライアントからのリクエストの受付 リクエストデータのJavaオブジェクトへの変換 入力チェックの実行（Bean Validation） Handlerの呼び出し Viewの解決 クライアントへのレスポンスデータの応答 例外ハンドリング TODO: Springフレームワークの全体を把握したときにもう一度見直す 第5章 Webアプリケーションの開発5.1 Webアプリケーションの種類 SpringMVCは大きく分けて以下の２種類のアプリケーションを作成するための機能を提供 画面を応答するアプリケーション データのみを応答するアプリケーション（RESTful Webサービス） メモ SpringMVCの仕組みは使用していないが、Spring4.0よりWebSocketの連携モジュールが提供されている フロントとサーバーサイドの双方向通信用 TODO: 使ってみる Hamdlerメソッド作成 @RequestMapping()は使用せずに、@GetMapping()を使用する Handlerメソッドの引数に指定可能な型、アノテーションを紹介 TODO: 再度確認する 暗黙的な引数の解決！覚えておく 引数の型がStringやIntegerといったシンプル型の場合、引数名に一致するリクエストパラメータの値を取得 引数の方がJavaBeansだった場合、デフォルトの属性名に一致するオブジェクトをModelから取得する 該当するオブジェクトがModelに存在しない場合、デフォルトコンストラクタを呼び出して新しいオブジェクトを生成 ServletAPI(HttpServletRequest,HttpServletResponse,HttpSession,Partなど)や低レベルのJavaAPI(InputStream,Reader,OutputStream, Writer,Map)なども指定できるが、これらのAPIを自由に使うとメンテナンス性を低下させる可能性があるので、使用しないようにする必要がある TODO: コーディング規約として利用を制限していくべき！ 5.3.5 Handlerメソッドの戻り値 Handlerメソッドは戻り値として様々なオブジェクトを返却できる メモ 返却できるオブジェクトはorg.springframework.web.method.support.HandlerMethodReturnValueHandlerインターフェースの実装クラスを作成することで拡張できる SpringMVCがサポートしている主な型 java.lang.String Model ModelAndView void ResponseEntity&lt;?&gt; HttpHeaders 5.3.6 View Controllerの利用 Viewを呼び出すだけであれば、SpringMVCが提供しているViewControllerの仕組みを利用することができる 5.4 リクエストマッピング @RequestMappingの属性値を使ってリクエストマッピングの条件を指定する 指定可能な属性 value path method params headers: リクエストヘッダー consumes: Content-Typeヘッダー produces: Acceptヘッダー name value,pathは複数指定することができる or条件として扱われる パスパターンの使用 URIテンプレート形式のパスパターン 正規表現も使える Antスタイルのパスパターン paramsはメソッドが実行される条件としてパラメータの有無も入る 5.5 リクエストデータの取得 種類 @PathVariable @RequestParam @RequestHeader リクエストパラメータ値の一括取得 5.5.4 コンパイルオプションの注意点 @PathVariable,@RequestParam,@RequestHeader,@CookieValueのvalue属性を省略する場合、 -gオプションまたはJavaSE8から追加された-parametersオプションのどちらかのコンパイルオプションを有効にしておく必要がある TODO: バインドされないとき確認 5.5.7 アノテーションを使用したフォーマットの指定 `@org.springframework.format.annotation.DateTimeFormat` `@org.springframework.format.annotation.NumberFormat` JSR354 : Money and Currency APIというものがあるらしい TODO: 後で確認する 5.6 フォームクラスの実装5.6.1 フォームオブジェクトのスコープ スコープの種類 リクエストスコープ フラッシュスコープ：PRGパターンのリクエスト間でオブジェクトを共有するためのスコープ セッションスコープ：HttpSessionに格納され、明示的に破棄するまで残り続ける フラッシュスコープ RedirectAttributesのaddFlashAttribute()メソッドを使用して詰める 1234567@RequestMapping(path = \"create\", method = RequestMethod.POST)public String create( @Validated AccountCreateForm form, BindingResult result, RedirectAttributes redirectAttributes) &#123; redirectAttributes.addFlashAttribute(form); return \"redirect:/account/create?complete\"; &#125; 5.6.2 フォームクラスの作成123456@Datapublic class LoginFormRequestDto implements Serializable &#123; private static final long serialVersionUID = 1L; private String id; private String password;&#125; Serializableインターフェスを実装しておく。これが必要なのはオブジェクトをセッションスコープで管理する場合だが、スコープに関係なく定義しておくのが無難 5.7 入力チェック SpringMVCではBeanValidationの仕組みを利用して、リクエストパラメータ値がバインドされたフォームクラス（またはコマンドクラス）に対して入力チェックを行う 5.7.1 入力チェックの有効化 入力チェックを行う場合、 入力チェックを行うメソッドの引数にフォームクラスを定義して、 `@org.springframework.validation.annotation.Validated`または `@org.springframework.validation.annotation.Valid` を指定する @Validatedを使用すると、BeanValidationのバリデーショングループの仕組みが使用できるらしい 5.7.2 入力チェック結果の判定 BindingResultで処理する 5.7.3 未入力の扱い 未入力は許容するが、入力された場合は６文字移譲であること という要件をBeanValidation標準アノテーションを使用して満たすことができない この場合は、Springが提供しているorg.springframework.beans.propertyeditors.StringTrimerEditorを使用することを検討 TODO: 普通に独自アノテーションを作成した方がシンプルなような気がする 5.7.5 ネスト下JavaBeansの入力チェック ネストしたJavaBeansやコレクション内のJavaBeansに定義したプロパティに対して入力チェックを行いたい場合は、@Validを指定する チェック対象とすることを明示する必要がある @Validと@Validatedの違い http://moondream.hatenablog.com/entry/20131006/1381031027 5.7.6 入力チェックルールの追加 独自の入力チェックツール追加方法２つ 既成ルールを合成して作成する方法 独自のバリデータを実装して作成する方法 既成ルールを合成して作成する方法 →こっちは使った方がよい 1234567891011121314151617181920212223242526272829303132import static java.lang.annotation.ElementType.*;import static java.lang.annotation.RetentionPolicy.*;import java.lang.annotation.Documented;import java.lang.annotation.Retention;import java.lang.annotation.Target;import javax.validation.Constraint;import javax.validation.Payload;import javax.validation.ReportAsSingleViolation;import javax.validation.constraints.Pattern;@Documented@Constraint(validatedBy = &#123;&#125;)@Target(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER &#125;)@Retention(RUNTIME)@ReportAsSingleViolation@Pattern(regexp = \"[a-zA-Z0-9]*\")public @interface AlphaNumeric &#123; String message() default \"&#123;validation.AlphaNumeric.message&#125;\"; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;; @Target(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER &#125;) @Retention(RUNTIME) @Documented public @interface List &#123; AlphaNumeric[] value(); &#125;&#125; メモ TODO: 覚えておく 上の例では１つしか既成ルールを使用していないが、既成ルールを複数まとめた合成アノテーションを作成することもできる なお、既成ルールをまとめた合成アノテーションを作成する場合、@ReportAsSingleViolationも付与するのが一般的で、付与すると、message属性で指定したメッセージが利用される用になる。付与しない場合は、既成ルールに指定したメッセージが利用される 独自のバリデータを実装して作成する方法 →冗長になりがちだと思うので作成しないほうが良いのでは？ 相関チェックも実装できそうだが、@AssertTrueを使用したほうがシンプル @AssertTrueの使用方法 https://qiita.com/t-iguchi/items/ea3dd8691d52d7abe695 5.7.7 入力チェックツールの切り替え コントローラーのメソッドでパラメータ指定して、呼び出すメソッドを変更することで実現する例を記載している 5.7.8 エラー情報の表示 &lt;form:errors path=&quot;name&quot;&gt; このように記載することでエラー情報取れますよという説明がある エラーメッセージ要素の構成案 123&lt;div class=\"error-message d-none\"&gt; &lt;form:errors path=\"name\"&gt;&lt;/div&gt; 123document.querySelectorAll(\".error-message\").forEach(el=&gt;&#123; if(el.innerText) el.classList.remove(\"d-none\");&#125;) みたいな感じにすればいいのではなかろうかと 5.7.9 エラーメッセージの解決 エラーメッセージの定義方法 Springが提供するMessageSourceで読み込んだプロパティファイルにメッセージを定義する BeanValidation管理のプロパティファイルにメッセージを定義する 制約アノテーションのmessage属性に直接メッセージを定義する Spring管理プロパティファイル 制約アノテーションのクラス名＋「.」＋フォームオブジェクトの属性名＋「.」＋プロパティ名 制約アノテーションのクラス名＋「.」＋フォームオブジェクトの属性名 制約アノテーションのクラス名＋「.」＋プロパティ名 制約アノテーションのクラス名＋「.」＋プロパティの型名（FQCN） 制約アノテーションのクラス名 BeanValidation管理のプロパティファイルにエラーメッセージを定義 クラスパス直下のValidationMessages.propertiesにメッセージを定義する →あまり使用する機会無いのではと思う 5.7.10 BeanValidationのカスタマイズ java configに設定 →あまりメリットが理解できなかったのでスキップ 5.7.11 Spring Validatorの利用 割愛 5.8 画面遷移5.8.1 遷移先の指定方法 View名をHandlerメソッドの戻り値として返却することで実現 5.8.2 リクエストパスへのリダイレクト View名に「redirect: + リダイレクト先のリクエストパス」 RedirectAttributesを使用してパラメータを設定する パス変数を指定することもできる 5.8.3 リクエストパスへのフォワード 「forward: + 転送先のリクエストパス」 return &quot;forward:/auth/authenticate&quot;; MEMO: 使い所が知りたい 5.8.4 Viewとのデータ連携 JavaオブジェクトをModelに格納する方法は、以下の２つがある ModelのAPIを直接呼び出す ModelAttributeアノテーションを付与したメソッドを用意する 5.8.5 リダイレクト先とのデータ連携 RedirectAttributesのフラッシュスコープの説明 5.9 Viewの解決 jspとかいろいろ使えるよ JSP使うなら、ViewResolverRegistryに登録する必要があるよっていう説明 5.10 JSPの実装 JSP使用しないため割愛 5.11 SpringのHTMLフォーム用タグライブラリの利用 JSP使用しないため割愛 5.12 Springの汎用タグライブラリの利用 Springで使用できるタグについて説明 MEMO: 必要であれば読み返す できるだけthymeleafだけの方が良いのではと思う 5.13 例外ハンドリング5.13.1 例外の種類 Webアプリケーションで発生する例外は大きく３つある システム例外:処理を継続することができない例外 アプリケーション自体のバグ 依存ライブラリのバグ ミドルウェアやハードウェアの故障 システムリソースの枯渇 ネットワーク障害 リクエスト不正を通知する例外：リクエストの内容が不正なときに発生する例外 存在しないパスへのリクエスト バインディングエラー 入力チェックエラー アプリケーション例外：ビジネスルールに違反したときに発生する例外 ユーザー登録時のIDの重複エラー 排他エラー 在庫数の不足エラー 5.13.2 例外の発生箇所とハンドリング方法 以下の箇所で例外が発生する可能性があり、それぞれ例外ハンドリングの方法も異なる 1) Servlet Fileter サーブレットコンテナへのエラーページ機能（web.xmlの&lt;error-page&gt;要素）を使用してエラー処理を実装する 2) DispatcherServlet: SpringMVCが提供する例外ハンドリングの仕組み（HandlerExceptionResolver） 3) アプリケーション(Controller, Service, Repositoryなど)：SpringMVCが提供する例外ハンドリングの仕組み（HandlerExceptionResolver） 4) View（JSPなど） Viewの中で発生した例外は、サーブレットコンテナのエラーページ機能を使用して絵r-あ処理を実装 5.13.3 サーブレットコンテナのエラーページ機能を利用 web.xmlにerror-pageを記載する方法を紹介 5.13.5 @ExceprtionHandlerメソッドの利用 複数のController間で共通の処理 @ControllerAdviceを用いる https://terasolunaorg.github.io/guideline/5.0.1.RELEASE/ja/ImplementationAtEachLayer/ApplicationLayer.html#id160 @ExceptionHandlerメソッドの引数 Exception HandlerMethod java.util.Locale java.util.Timezone java.time.ZoneId java.security.Principal 戻り値について String ModelAndView void ResponseEntity&lt;?&gt; 5.13.6 @ResponseStatusを指定した例外クラスの利用1234@ResponseStatus(HttpStatus.NOT_FOUND)public class ResourceNotFoundException extends RuntimeException &#123; // *****&#125; TODO: 独自Exceptionを作成していくべきかどうか 第6章 RESTful Webサービスの開発6.1 REST APIのアーキテクチャ RESTは「REpresentational State Transfer」の略で、クライアントとサーバー間でデータをやり取りするアプリケーションを構築するためのアーキテクチャスタイルの１つ 最も重要なのは「リソース」という概念 REST APIはデータベースなどで管理している情報の中から、クライアントに提供する情報を「リソース」として抽出 抽出したリソースはWeb上に公開し、リソースにアクセスするための手段としてRESTAPIを用意します 6.1.1 Resouce Oriented Architecture (ROA)6.1.2 フレームワークのアーキテクチャ 割愛 TODO: 詳細を知りたくなったら読む 6.2 アプリケーションの設定6.2.1 ライブラリのセットアップ リソース形式としてJSONを使用する際に利用する「FasterXML Jackson Databind」を依存ライブラリに追加する MEMO: SpringBootだと不要みたい 6.2.2 サーブレットコンテナの設定 HiddenHttpMethodFilterの適用 RESTAPIを提供する場合、HTTPメソッドとして、PUT、PATCH、DELETEなども使用するが、 Webブラウザなどクライアントの実装によっては、GETとPOSTしか使用できなかったりする そこをサポートするためにorg.springframework.web.filter.HiddenHttpMethodFileterクラスを利用する _method=putというパラメータでリクエストが送られると、サーブレットコンテナ内で行われる処理はPUTメソッドでアクセスしたときとおなじになる HttpMessageConverterのカスタマイズ MEMO: Converterの設定をしているが、SpringBootだと不要だと思うので飛ばす 6.3 @RestControllerの実装 大きく２つ種類がある メソッドシグネチャを参照してフロントコントローラが処理を行う「宣言型」の処理 Controllerクラスのメソッド内に処理を実装する「プログラミング型」の処理 MEMO: クライアントへ返却するオブジェクトは共通で作成しているもの（クラス）を使用するのが良いと思った 以下、割愛 第7章 Spring MVC の応用 SpringMVCの機能を利用したWebアプリケーションの開発方法を学びましたが、 典型的なWebアプリケーションの開発では、 セッションの利用 ファイルアップロード 画面やメッセージの国際化 共通処理の適用 静的リソースのキャッシュ制御 などへの考慮も必要になる 非同期処理（SSE(Server-Sent Events)） 7.1 HTTPセッションの利用 セッション管理する方法３つある セッション属性（@SessionAttributes）の使用 セッションスコープのBeanの利用 HttpSessionのAPIの利用 7.1.1 セッション属性（@SessionAttributes） １つのController内で扱う複数のリクエスト間でデータを共有する場合に有効な方法 入力画面が複数のページで構成される場合や、複雑な画面遷移を伴う場合は@SessionAttributesを使用することを検討 シンプルな画面構成の場合（入力画面→確認画面→完了画面とかの場合）は、HTMLフォームのHiddenで値を持ち回る方法を検討すること 7.1.2 セッションスコープBean 複数のControllerをまたぐ画面遷移において、Controller間でデータを共有する場合に有効な方法 7.2 ファイルアップロード SpringMVCでファイルをアップロードする場合は、以下のいずれかの方法を利用する Servlet標準のアップロード機能 ApacheCommonsFileUploadのアップロード機能 7.2.2 ファイルアップロード機能のセットアップ web.xmlに&lt;multipart-config /&gt;を追加するとのこと Servlet標準のファイルアップロード機能をデフォルトのまま利用するとアップロードできるファイルのサイズに上限がないため、上限を設けたい場合は、ファイル単位の最大サイズ、アップロード時のリクエスト全体の最大サイズ、一時ファイル出力有無の閾値サイズの３つを指定する必要がある 上限に引っかかると、MultipartExceptionが発生するので、Handlerでハンドリングすること メモ SpringMVCのDispatcherServletより前にリクエストパラメータにアクセスする処理があると、MultipartExceptionが発生しない可能性がある SpringWEBから提供されているフィルターを利用すると制御できるとのこと TODO: SpringBootだとどのように記載するか確認 7.2.3 アップロードデータの取得 Formクラスの作成 普通にFormクラスの作成 MultipartFile型で変数定義する Viewの作成 input type=”file”で作成して送るだけ Controller ファイルを取得して永続化操作 Validation ファイルサイズや、コンテンツタイプ、ファイル名などをチェックする場合は、Validatorを作成してチェック TODO: 実際にアイコン画像などをDBで保持できる永続化ロジックまで書く 7.3 非同期リクエスト7.3.1 非同期リクエストの仕組み 非同期実行が終了してからHTTPレスポンスを開始 勘違いしやすいのが、HTTPレスポンスは非同期実行している処理が終了したあとに行うため、クライアント側から見ると、同期処理と同じ動作になる SpringMVCはこのパターンの非同期処理をサポートするために以下の２つの方法を提供 SpringMVC管理のスレッドを使用した非同期処理 SpringMVC管理外のスレッドを使用した非同期処理 非同期実行の処理中にHTTPレスポンスを開始 ロングポーリングを使用した非同期処理 SSE（Server-Sent Events）に準拠した非同期処理 7.3.2 非同期実行を有効にするための設定 web.xmlに設定追記 java configにBean定義追加 7.3.3 非同期処理の実装 以下の２つの非同期処理の実装方法を紹介 CompletableFutureを使用した非同期処理 SseEmitterを使用したPush型の非同期処理 @Asyncの利用 本書で説明する非同期処理は、どちらもSpringMVC管理外のスレッドを使用した非同期処理 SpringFrameworkは、特定のメソッドを別スレッドで実行する仕組みを提供しており、別スレッドで実行したいメソッドに、org.springframework.scheduling.annotation.Asyncを付与するだけ MEMO: SpringBootでの利用に参考 https://qiita.com/mitsuya/items/c21907ab10919111e773 CompletableFutureを使用した非同期処理の実装 CoompletableFuture&lt;String&gt;を返却する SseEmitterを使用したPush型の非同期処理の実装 new SseEmitter();でイベント処理を行う 具体的な使用方法について説明なし 7.3.4 非同期実行の例外ハンドリング DeferredResultを使用して結果を設定する TODO: 結果を非同期で画面に通知する方法確認 7.3.5 非同期実行に対する共通処理の実装 CallableProcessingInterceptorもしくはDeferredResultProcessingInterceptorのAdopterを実装したクラスを作成 現在は、interfaceにデフォルトメソッドが定義できるようになったので、Adopterではなくて、interfaceの方を使用すべきとのことで、@Deprecatedになっている CallableProcessingInterceptorインターフェース 7.4 共通処理の実装ControllerのHandlerメソッドの呼び出し前後に共通処理を実行する方法について説明します。 7.4.1 サーブレットフィルタの利用 SpringMVCの呼び出し前後に共通する処理を実行するには、javax.servlet.Filterインターフェースの実装クラスを作成する Filterクラスを直接実装してもよいが、ここではSpringが提供しているサポートクラスを利用する方法を紹介 サポートクラス GenericFilterBeanクラス OncePerRequestFilterクラス DIコンテナで管理しているBeanのインジェクション方法 サーブレットフィルター内の処理でDIコンテナ管理しているBeanを利用したい場合は、サーブレットフィルタをDIコンテナに登録し、DelegatingFilterProxy経由でサーブレットフィルタの処理を実行する DelegatingFilterProxyは、SpringのDIコンテナに登録されているサーブレットフィルターに処理を移譲するサーブレットフィルタクラス 7.4.2 HandlerInterceptorの利用 Controllerでハンドリングする処理に対してだけ共通処理を実行したい場合は、 org.springframework.web.servlet.HndlerInterceptorインターフェースの実装クラスを作成する メソッド preHandle：実行前 postHandle：例外時は呼び出されない afterCompletion：実行後 12345678910111213@Slf4jpublic class LoggingInterceptor extends HandlerInterceptorAdapter &#123; public void postHandler(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) &#123; if (log.isInfoEnabled()) &#123; HandlerMethod handlerMethod = (HandlerMethod) handler; Method method = ((HandlerMethod) handler).getMethod(); log.info(\"[SUCCESS CONTROLLER] &#123;&#125;.&#123;&#125;\", method.getDeclaringClass().getSimpleName(), method.getName()); &#125; &#125;&#125; 123456@Overridepublic void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoggingInterceptor()) .addPathPatterns(\"/**\") .excludePathPatterns(\"/resources/**\");&#125; 7.4.3 @ControllerAdviceの利用 Controllerクラスには、Handlerメソッドとは別に、Controller専用の特殊なメソッド（@InitBinderメソッド、@ModelAttributeメソッド、@ExceptionHandlerメソッド）を実装することができる これらのメソッドを複数のControllerクラスで共有するには、@ControllerAdviceを付与したクラスを作成する 123456789101112131415161718192021222324252627@Slf4j@ControllerAdvicepublic class ErrorController &#123; @GetMapping(\"/error\") public String handleError() &#123; return \"error\"; &#125; @ExceptionHandler(Throwable.class) public String handleThrowable(Throwable exception, Model model) &#123; model.addAttribute(\"\", \"\"); return \"error\"; &#125; @ExceptionHandler(Exception.class) public String handleException(Exception exception, Model model) &#123; model.addAttribute(\"\", \"\"); return \"error\"; &#125; @ExceptionHandler(IOException.class) public String handleIOException(IOException exception, Model model) &#123; model.addAttribute(\"\", \"\"); return \"error\"; &#125;&#125; 7.4.4 HandlerMethodArgumentResolverの利用 SpringMVCのデフォルトでサポートされていないオブジェクトをControllerのHandlerメソッドの引数に渡したい場合は、org.springframework.web.method.support.HandlerMethodArgumentResolverインターフェースの実装クラスを作成します。 あまり利用するシーンがわからないため割愛する 7.5 静的リソース ルートから任意のディレクトリに配置した静的リソースにアクセスできますという説明 7.5.1 デフォルトサーブレットとDispatcherServletの共存 Servletの使用では、ルートパス（）にマッピングされたサーブレットのことを「デフォルトサーブレット」と呼び、デフォルトサーブレット経由でWebアプリケーションのドキュメントルート配下のファイルにアクセスすることができる SpringMVCアプリケーションでは、DispatcherServletをルートパスにマッピングするスタイルを採用することがよくあるが、DispatcherServletをルートパスにマッピングすると、Webアプリケーションのドキュメントルート配下のファイルにアクセスできなくなってしまいます。 この動作を変更するには、SpringMVCが提供している「DispatcherServletで受けたリクエストをデフォルトサーブレットへ転送する機能」を有効化する必要がある 7.5.2 SpringMVC独自の静的リソース解決の仕組み HTTPのキャッシュ制御 ResourceResolverとResouceTransformerの利用 ResourceHttpRequestHandlerには バージョン付き公開パスを使用した静的リソースへのアクセス Gzip化された静的リソースへのアクセス WebJars内の静的リソースのバージョン番号の隠蔽 を行う機能がある ResourceResolverインターフェース 静的リソースにアクセスするための公開パス サーバー上の物理的な静的リソースを相互に解決するためのメソッドを提供 ResourceTransformerインターフェース 静的リソースのコンテンツデータを書き換えるためのメソッドを提供 バージョン付きの公開パスを使用した静的リソースへのアクセス Thymeleafでのアクセス方法について確認する ここで紹介されていたhttps://ksoichiro.blogspot.com/2015/04/spring-boot_14.html th:href=&quot;@{/css/main.css}&quot;などと記載する 7.6 国際化7.6.1 ロケールの解決 アプリケーション内で扱うロケール解決には、org.springframework.web.servlet.LocaleResolverインターフェースを使用する SpringMVCは、ロケールの保存場所に応じて以下の実装クラスを提供しており、デフォルトではAcceptHeaderLocaleResolverが有効になっている 提供されているLocaleResolverの実装クラス AcceptHeaderLocaleResolver SessionLocaleResolver CookieLocaleResolver FixedLocaleResolver クライアントからロケールの指定がない場合、デフォルトロケールが利用され、 LocaleResolverに指定したデフォルトロケール JVMに指定したロケール OSに指定したロケール の順番で解決されます。 7.6.2 ロケールの利用 VIEWからロケールにアクセスするときはSpringのタグを使用する Handlerメソッドからロケールにアクセスするときは引数にLocaleを指定する Handler以外の場所からロケールにアクセスするときは、RequestContextUtilsのgetLocaleメソッドを使用する 7.6.3 UIを使用したロケールの切り替え 画面などのUIを使用してロケールを切り替える方法について説明 ロケールの切り替えは、org.springframework.web.servlet.i18n.LocaleChangeInterceptorを利用することで簡単に行うことができる LocaleResolverのBean定義 LocaleChangeInterceptorのBean定義 ロケール切り替え用の画面要素の表示 12&lt;a href=\"?locale=en\"&gt;English&lt;/a&gt;&lt;a href=\"?locale=ja\"&gt;Japanese&lt;/a&gt; このリンクをクリクすると、LocaleChangeInterceptorが呼び出され、リクエストパラメータで指定されたロケールがSpringMVCアプリケーションに反映される 第8章 Spring Test 本章では、SpringFrameworkが提供するテスト支援モジュールを利用して、Springアプリケーションに対してテストを行う方法について解説していく 紹介を行うテスト DIコンテナに登録したBeanへのテスト データベースアクセスを伴う処理へのテスト SpringMVC上で動くControllerへのテスト 第９章では、SpringSecurityの機能を利用した処理へのテストを紹介 8.1 Spring Testとは Spring Testとは Spring Framework上で動かすために作成したクラスのテストを支援するモジュール 単体テスト テスト対象のクラス内で実装しているロジックのみをテスト 単体テストを行う際には、テスト対象のクラスの中で依存している他のコンポーネントはモックやスタブを使用し、実行結果が他のコンポーネントの実装内容に左右されないようにする 結合テスト 基本的にモックやスタブは使わず、プロダクション環境で使用するクラスを結合してテストを行います。 ポイントは、システムやアプリケーション全体が正しく動作するかを検証するのではなく、開発者が作成したクラスがSpringのフレームワーク上で正しく動作するかをテストするという点 提供されている機能 JUnitやTestNGといったテスティングフレームワーク上でのSpringのDIコンテナを動かす機能 トランザクション制御をテスト向けに最適化する機能 アプリケーションサーバーを使わずにSpringMVCの動作を再現する機能 テストデータをセットアップするためのSQLを実行する機能 RestTemplateを使用したHTTP通信に対してモックレスポンスを返却する機能 8.2 DIコンテナ管理のBeanに対するテスト junitを使用する前提で説明 8.2.1 Beanの単体テスト Serviceクラスをテスト 依存しているコンポーネントはできるだけモック化することを検討する 外部ファイル参照サービスやDBアクセスなど 8.2.2 DIコンテナ内のBeanに対する結合テスト Springの機能を使用して、DIコンテナ内のリソースを取得してテストを行う 単体テストは本当にクラス単体の観点なのに対して、結合テストはプロジェクト内のリソースを結合したテストとみなしている 8.2.3 Spring Testcontext Framework 他のランナーとSpringを併用したい場合は、@ClassRuleと@Ruleを使用すれば実現できるという説明 TODO: 使用するランナーによって何が違うのかを後で確認する必要ある 8.2.4 DIコンテナのコンフィギュレーションDIコンテナを作成するには、`@org.springframework.test.context.ContextConfiguration`をテストクラスケースに付与する デフォルトのBean定義ファ入りう Webアプリケーション向けのDIコンテナのコンフィギュレーション @WebApplicationConfiguration付与について説明 Webアプリケーション向けのDIコンテナに加えて、 ServletAPIに依存する各種モックオブジェクトなどをテストケースクラスにインジェクションできる 8.2.5 DIコンテナのライフサイクル制御 Spring TestContext Framework上に生成されたDIコンテナは、テスト実行時のJavaVMが終了するまでキャッシュされ、必要に応じてテストケース間で共有される仕組みになっています。 DIコンテナのキャッシュ デフォルトの動作では、同一テストケースクラスのテストメソッドで同じDIコンテナが使われる さらにテストケースクラスが別の場合でも、@ContextConfigurationなどに指定した属性値が同じであれば、キャッシュ済みのDIコンテナが利用される DIコンテナの破棄 割愛…TODO: 実際のテストケースの組み方について調査する必要あり 8.2.6 プロファイルの指定 Springのプロファイル機能を使用しているアプリケーションに対してテストを行う場合は、`@org.springframework.test.context.ActiveProfiles`を使う 8.2.7 テスト用のプロパティ値の指定 テスト用のプロパティ値を設定できる `@org.springframework.test.context.TestPropertySource`を使う プロパティ値の指定には２つの方法がある アノテーションに直接指定する プロパティファイルに指定する 8.3 データベースアクセスを伴う処理のテスト データベースへアクセスするBeanに対するテスト方法について説明 データベースにアクセスするBeanに対してテストを行う場合、以下の作業が必要になる テスト用のデータソースの設定 テストデータのセットアップ テストケース用のトランザクション制御 テーブルの中身の検証 8.3.1 テスト用のデータソースの設定 Test用のConfigクラスを作成して、既存のコンフィグクラスを上書きする説明 8.3.2 テストデータのセットアップ @Sqlを使用すると、テストケース・メソッドの呼び出し前に任意のSLQを実行できる 12345678/** * Sqlを付与することで、テストメソッド実行前に任意のSQL文を実行することができる */@Test@Sql(&#123; \"/account-delete.sql\", \"/account-insert-data.sql\" &#125;)final void testFindOne() &#123; Account account = accountRepositry.findOne(\"001\");&#125; メモ @SqlにはJavaSE8で追加された@Repeatableが付与されているため、JavaSE8以降を使う場合は同じ箇所に複数指定できる JavaSE7以前のJavaでも、`@org.springframework.test.context.jdbc.SqlGroup`を使うことで、複数のSQLを指定できる 8.3.3 テストケース用のトランザクション制御 デフォルトではテストデータをセットアップする際に使用するトランザクションと、 テスト対象のデータアクセス処理で使用するトランザクションは別々になってしまう テストが途中で失敗して、レコードが更新されてしまったり、データの状態が変わってしまうため注意が必要 このような事故を防ぐには、JUnit専用のデータベースを用意しておくと確実 ローカルなんかも優位だと思う あるいは、SpringTestが提供しているテスト用のトランザクション制御の仕組みを利用して防ぐこともできる トランザクション境界の移動 SpringTestでは、、JUnit実行時のトランザクション境界を、テストケースメソッドの呼び出し前に移動する仕組みを提供している。 この仕組を利用すると、@Sqlで指定したSQLファイルの実行とテストを同一のトランザクション内で行うことができる @Transactionalをクラス、メソッドに指定する トランザクション境界でのロールバック/コミットの制御 処理が完了したあと、ロールバックするのではなくコミットしたい場合、@Commitを付与すれば実現できる 永続コンテキストをフラッシュ JPAやHibernateがEntityへの更新操作を永続コンテキストと呼ばれるインメモリ領域に蓄積しておき、トランザクションのコミット時にSQLを発行する仕組みになっているため、明示的にSQLが発行されるようにフラッシュする必要がある 8.3.4 テーブルの中身の検証 JdbcTemplateを使用して検証する DIコンテナに入っている同じオブジェクトを使用すること 8.4 Spring MVC のテスト SpringMVC上で動くControllerに対するテスト方法について説明 Controllerに対するテストの話をするときにいつも出てくる話題がある →「Controllerに対する単体テストは必要か？」という話題 Controllerの主な役割は、 リクエストマッピング 入力チェック リクエストデータの取得 ビジネスロジックの呼び出し 遷移先の制御 これらは、SpringMVCのフレームワークと結合しないと妥当性を検証することができないので、単体テストではなく、結合テストとして行ったほうがよい では、SpringMVCのフレームワーク機能と結合した状態でControllerをテストするにはどうすればよいのでしょうか？ 最もオーソドックスな選択肢は、Webアプリケーションをアプリケーションサーバーにデプロイし、E2E（End to End）テストとして実施する方法 E2Eテストとして実施すると、Viewが生成したレスポンスデータの妥当性を検証できるのがメリット 一方、以下のようなデメリットがある アプリケーションサーバーやデータベースの起動が必須となる トランザクションがコミットされるため、テスト実施前の状態に戻すことができない 回帰テストを実行するために、Seleniumなどを利用したテストケースの実装が必要になる Seleniumを使うと、テストの実行時間が長くなる SpringTestはE2Eテストのデメリットを解消しつつ、SpringMVCのフレームワーク機能と結合した状態でControllerをテストするためのプラットフォームとして、org.springframework.test.web.servlet.MockMvcというクラスを提供している 8.4.1 MockMvcとは アプリケーションサーバー上にデプロイせず、SpringMVCの動作を再現する仕組みを提供するクラス 流れ テストケース・メソッドは、DispatcherServletにリクエストするデータ（リクエストパスやリクエストパラメータなど）をセットアップする MockMvcは、DispatcherServletに対して擬似的なリクエストを行う。実際に使われるDispatcherServletは、テスト用に拡張されている、org.springframework.test.web.servlet.TestDipacherSevletとなる DispatcherServletは、リクエスト内容に一致するHandlerのメソッドを呼び出す テストケースメソッドは、MockMvcが返却する実行結果を受け取り、実行結果の妥当性を検証する 動作モードには２つある ユーザー指定のDIコンテナと連携するモード スタンドアロンモード SpringMVCのコンフィギュレーションも含めてテストしたい場合、ユーザー指定のDIコンテナと連携するモードを利用すること メモ 本書では扱わないが、SpringTestは、MockMvcとHtmlUnitを連携する機能も提供している HtmlUnitと連携することで、テンプレートエンジンが生成したHTMLを検証することができる さらに、SeleniumWebDriverやGebと連携すると、Page Object Patternを活用した可読性および再利用性の高いテストケースを記載することも可能 TODO: あとで確認してみる 8.4.2 MockMvcのセットアップ ユーザー指定のDIコンテナと連携するモード スタンドアロンモード SpringMVCのコンフィギュレーションはSpringTest側が行い、SpringTestが生成したDIコンテナを使用してSpringMVCの動作を再現 サーブレットフィルタの追加 MockMvcには、サーブレットフィルタを追加することができる staticメソッドのインポート テストを書く前に、MockMvcを使用したテストをサポートしてくれるstaticメソッドをインポートします。 1234// よく使用するstaticメソッドimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.*; 8.4.3 テストの実行 テストを実行する際は、Controllerを呼び出すために必要なリクエストデータをセットアップし、MockMvcにリクエストの実行依頼を行います。 12345public void testHome() throws Exception &#123; mockMvc.perform(get(\"/\")) .andExpect(status().isOk()) .andExpect(forwardedUrl(\"/WEB-INF/index.jsp\"));&#125; 8.4.4 リクエストデータのセットアップ リクエストデータのセットアップは、 org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder org.springframework.test.web.servlet.request.MockMultipartHttpServletRequestBuilder のファクトリメソッドを使用して行います。 12345678@Testpublic void testBooks() throws Exception &#123; mockMvc.perform(get(\"/books\") .param(\"name\", \"Spring\") .accept(MediaType.APPLICATION_JSON) .header(\"X-Track-Id\", UUID.randomUUID().toString())) .andExpect(status().isOk());&#125; 8.4.5 実行結果の検証 MockMvcResultMathcersの主なメソッド status header cookie content view forwardedUrl redirectedUrl model flash request メモ ResultMatcherでサポートされていない検証を行いたい場合は、以下のいずれかの方法で検証ロジックを実装する 独自のResultMatcherを作成する ResultActionsのandReturnメソッドを呼び出して、MvcResultを取得し、テストケース内で検証ロジックを実装する MEMO: 検証ロジックを複数のテストケースで共有したい場合は、ResultMatcherを作成すること 8.4.6 実行結果の出力 実行結果をログなどに出力する場合は、org.springframework.test.web.servlet.ResultActionsのandDoメソッドを使用する andDoメソッドの引数には、実行結果に対して、任意の処理を行うorg.springframewok.test.web.servlet.ResultHandlerを指定する 123mockMvc.perform(get(\"/books\")) .andExpect(status().isOk()) .andDo(log()); log: 実行結果をデバッグレベルでログ出力する pring: 実行結果を任意の出力先に出力する 第9章 Spring Security SpringSecurityの「セットアップ方法」と「アーキテクチャ」について説明したあと、 セキュリティ対策の基本となる 「認証」と「認可」、 さらにセキュリティを強化するために必要となる 「CSRF対策」 「セッション管理」 「ブラウザのセキュリティ対策機能との連携（セキュリティヘッダーの出力）」について説明 最後に、SpringSecurityが提供する支援モジュールを使用して、セキュリティ対策が正しく適用されているかをテストする方法についても紹介 9.1 SpringSecurityとは アプリケーションにセキュリティ対策機能を実装する際に使用するフレームワーク 9.1.1 SpringSecurityの特徴 豊富なオプションの提供 SpringSecurityのデフォルト実装の動作をカスタマイズするためのオプションが豊富に提供されている このため、デフォルトの動作がセキュリティ要件に合致しない場合であっても、オプションの値を変更することで要件にあった動作に変更できるケースがある 豊富な拡張ポイントの提供 SpringSecurityは動作をカスタマイズするための拡張ポイントを豊富に提供します。 SpringSecurityのデフォルト実装を使って要件を満たせない場合は、拡張クラスを作成することで要件にあった動作にカスタマイズすることができます。 9.1.2 基本機能 セキュリティ対策の基本機能として「認証機能」と「認可機能」の２つを提供しています。 認証機能：アプリケーションを利用するユーザーの正当性を確認する機能を提供する 認可機能：アプリケーションが提供するリソースや処理に対するアクセスを制御する機能を提供する 9.1.3 強化機能 SpringSecurityでは認証と認可という基本機能に加え、 Webアプリケーションのセキュリティを強化するための機能をいくつか提供している セキュリティ対策の強化機能 セッション管理機能 CSRF対策機能 ブラウザのセキュリティ対策機能との連携機能 ※他にある！TODO: 他のセキュリティ機能も確認しておく 9.2 Spring Securityのセットアップ9.2.1 ライブラリのセットアップ pom.xmlに設定を追加する手順の説明 9.2.2 SpringSecurityのBean定義SpringSecurityのコンポーネントをBean定義します コンフィギュレーションクラスの作成 12345678910// SpringSecurityが提供しているコンフィギュレーションクラスがインポートされ、SpringSecurityを利用するために必要となるコンポーネントのBean定義が自動で行われる仕組み@EnableWebSecuritypublic class AppSecurityConfig extends WebSecurityConfigurerAdapter &#123; // 継承すると、デフォルトで適用されるBean定義を簡単にカスタマイズすることができる @Override public void configure(WebSecurity web) &#123; // セキュリティ対策が不要なリソースがある場合、SpringSecurityの処理を適用しないようにする web.ignoring().antMatchers(\"/resources/**\"); &#125;&#125; web.xmlへの設定追加方法説明 TODO: SpringBootだと必要？ 9.2.3 サーブレットフィルタの設定 最後に、SpringSecurityが提供しているサーブレットフィルタクラス（FilterChainProxy）をサーブレットコンテナに登録する TODO: SpringBootだとConfigでフィルター追加する https://qiita.com/R-STYLE/items/61a3b6a678cb0ff00edf https://qiita.com/opengl-8080/items/c105152c9ca48509bd0c メモ Sevlet3.0以降のサーブレットコンテナでは、サーブレットコンテナの初期化処理をJavaのコードで行うことができる SpringSecurityでは、サーブレットコンテナの初期化処理をJavaを使って行うためのサポートクラス説いて、 AbstractSecurityWebApplicationInitializerという抽象クラスを提供しています 以下の初期化処理を自動で行ってくれる ContextLoaderListenerをサーブレットコンテナに登録する処理 SpringSecurityのサーブレットフィルタクラスをサーブレットコンテナに登録する処理 参考：https://qiita.com/opengl-8080/items/c105152c9ca48509bd0c 9.3 Spring Security のアーキテクチャ 各機能の詳細な説明を行う前に、SpringSecurityのアーキテクチャ概要とSpringSecurityを構成する主要なコンポーネントの役割を見ていく メモ ここで紹介する内容は、SpringSecurityが提供するデフォルトの動作をそのまま利用する場合や、 SpringSecurityのコンフィギュレーションをサポートする仕組みを利用する場合は、開発者が直接意識する必要ない そのため、まず各機能の使い方を知りたい場合は、本説を読み飛ばしてOK カスタマイズする際に必要になってくるので、アーキテクトを目指す方は一読しておくことをおすすめします。 9.3.1 Spring Securityのモジュール構成 提供しているモジュールを紹介 コンポーネントの役割などに応じてモジュール分割されており、標準的なWebアプリケーションに対してセキュリティ対策を講じる際に必要となるモジュールは以下の４つになる spring-security-core: 認証と認可機能を実現するためのコアなコンポーネントが格納されている spring-security-web: Webアプリケーションのセキュリティ対策を実現するためのコンポーネントが格納されている spring-security-config: 各モジュールから提供されているコンポーネントのセットアップをサポートするためのコンポーネント（Java ConfigをサポートするクラスやXMLネームスペースを解析するクラスなど）が格納されている spring-security-taglibs: 認証情報や認可機能にアクセスするためのJSPタグライブラリが格納されている 本書で使い方を紹介しないが、上記以外にも以下のようなモジュールがある 一般的に利用される認証方法（LDAP、OpenID、CASなど）をサポートするためのモジュール ACL（AccessControlList）を使用したドメインオブジェクトの認可制御を行うモジュール SpringのWebSocket機能に対してセキュリティ対策を追加するためのモジュール SpringSecurityの機能を用いる処理に対するテストを支援するためのモジュール メモ SpringSecurityのモジュールではないが、OAuth2.0の仕組みを使用してAPIの認可を実現するためのモジュール（spring-security-oauth2）などが姉妹ライブラリとして提供されている 9.3.2 フレームワークのアーキテクチャ 処理の流れ クライアントはWebアプリケーションに対してリクエストを送る SpringSecurityのFilterChainProxyクラスがリクエストを受け取り、HttpFirewallインターフェースのメソッドを呼び出して、HttpServletRequestとHttpServletResponseに対してファイアウォール機能を組み込む FilterChainProxyクラスはSecurityFilterChainに設定されているセキュリティ対策用のSecurityFilterクラスに処理を移譲する SecurityFilterChainには複数のSecurityFilterが設定されており、SecurityFilterの処理が正常に終了すると皇族のSecurityFilterが呼び出される 最後のSecurityFilterの処理が正常に終了した場合、後続処理を呼び出し、Webアプリケーション内のリソースへアクセスする FilterChainProxyクラスは、Webアプリケーションから返却されたリソースをクライアントに返却する FilterChainProxy FilterChainProxyクラスは、フレームワーク処理のエントリーポイントとなるサーブレットフィルタクラス このクラスはフレームワーク処理の全体の流れを制御し、具体的なセキュリティ対策処理はSecurityFilterに移譲するスタイルとなっている HttpFirewall HttpFirewallインターフェースは、HttpServletRequestとHttpServletResponseに対して、ファイアウォール機能を組み込むためのインターフェースです。デフォルトでは、DefaultHttpFirewallクラスが使用され、ディレクトリトラバーサル攻撃や、不正なリダイレクト先の指定によるHTTPレスポンス分割攻撃に対するチェックなどが実装されている SecurityFilterChain SecurityFilterChainインターフェースは、FilterChainProxyが受け取ったリクエストに対して適用する「SecurityFilterリスト」を管理するためのインターフェース デフォルトではDefaultSecurityFilterChainクラスが使用され、以下のようなBean定義を行うと、指定したパスパターンごとに異なるセキュリティ対策が適用できます。 Security Filter SecurityFilterクラスは、フレームワーク機能やセキュリティ対策機能を提供するサーブレットフィルタクラスです。 SpringSecurityは、複数のSecurityFilterを連鎖させることで、Webアプリケーションのセキュリティ対策を行う仕組みになっています。 コアなSecurityFilter SecurityContextPersistenceFilter UsernamePasswordAuthenticationFilter LogoutFilter FilterSecurityInterceptor ExceptionTranslationFilter 9.4 認証処理の適用 認証処理は、アプリケーションを利用するユーザーの正当性を確認するための処理 最も標準的な方法はアプリケーションを使用できるユーザーをデータストアに登録しておいて、利用者が入力した認証情報と照合する方法 利用者に認証情報を入力してもらう方式もいくつかあり、 HTMLの入力フォームを使う方式 RFCで定められているHTTP標準の認証方式（BASIC認証やDigest認証など）を利用するのが一般的 OpenID認証、シングルサインオン認証などの認証方式を利用するケースもある 本節では、HTMLの入力フォームで入力した認証情報とリレーショナルデータベースに格納されているユーザー情報を照合して認証処理を行う実装例を紹介しながら、SpringSecurityの認証機能を解説 9.4.1 認証処理の仕組み 認証処理の流れ クライントは認証処理を行うパスに対して資格情報（ユーザー名とパスワード）を指定してリクエストを送信する Authentication Filterはリクエストから資格情報を取得し、AuthenticationManagerクラスの認証処理を呼び出す ProviderManager（デフォルトで使用されるAuthenticationManagerの実装クラス）は、実際の認証処理をAuthenticationProviderインターフェースの実装クラスに移譲する メモ Authentication FilterとAuthenticationProviderの実装クラスは複数用意されており、要件に合わせて使用するクラスを選択する仕組みになっている TODO: 選択できるクラスについて確認 Authentication Filter 認証方式に対する実装を提供するサーブレットフィルタ 本書では、フォーム認証用のサーブレットフィルタクラス（UsernamePasswordAuthenticationFilter）をシヨすうる前提で説明しますが、SpringSecurityはBasic認証、Digest認証、Remember Me 認証用のサーブレットフィルタクラスも提供しています AuthenticationManager 認証処理を実行するためのインターフェース SpringSecurityが提供するデフォルトの実装（ProviderManager）では、実際の認証処理はAuthenticationProviderに移譲し、AuthenticationProviderで行われた認証処理結果をハンドリングする仕組みになっています。 AuthenticationProvider 認証処理の実装をて依拠するためのインターフェース 本書では、データストアに登録しているユーザーの資格情報とユーザーの状態をチェックして認証処理を行う実装クラス（DaoAuthenticationProvider）を使用する前提で説明しますが、SpringSecurityは認証方法別の実装クラスも提供している。 ※DBだけでなく他の認証方式にも対応しているという意味だと理解 9.4.2 フォーム認証 SpringSecurityは以下のような流れでフォーム認証を行う クライアントは、フォーム認証を行うパスに対して資格情報（ユーザー名とパスワード）をリクエストパラメータとして送信する UsernamePasswordAuthenticationFilterクラスは、リクエストパラメータから資格情報を取得して、AuthenticationManagerの認証処理を呼び出す UsernamePasswordAuthenticationFilterクラスは、AuthenticationManagerから返却された認証結果をハンドリングする。認証処理が成功した場合は、AuthenticationSuccessHandlerのメソッドを、認証処理が失敗した場合は、AuthenticationFailureHandlerのメソッドを呼び出し、画面遷移を行う フォーム認証の適用 Bean定義 1234567891011121314151617// SpringSecurityが提供しているコンフィギュレーションクラスがインポートされ、SpringSecurityを利用するために必要となるコンポーネントのBean定義が自動で行われる仕組み@EnableWebSecuritypublic class AppSecurityConfig extends WebSecurityConfigurerAdapter &#123; // 継承すると、デフォルトで適用されるBean定義を簡単にカスタマイズすることができる @Override public void configure(WebSecurity web) &#123; // セキュリティ対策が不要なリソースがある場合、SpringSecurityの処理を適用しないようにする web.ignoring().antMatchers(\"/resources/**\"); &#125; // ★追加！！ @Override public void configure(HttpSecurity http) throws Exception &#123; http.formLogin(); // formLoginメソッドを呼び出すと、フォーム認証が有効になり、FormLoginConfigurerのインスタンスが返却される。 &#125;&#125; デフォルトの動作 SpringSecurityのデフォルトの動作では、/loginに対して、GETメソッドでアクセスするとSpringSecurityが用意しているデフォルトのログインフォームが表示され、ログインボタンを謳歌すると/loginに対してPOSTメソッドでアクセスして認証処理を行います。 ログインフォームの作成 SpringSecurityは、フォーム認証用のログインフォームをデフォルトで提供しているが、そのまま利用するケースは殆どないと思う ここでは、自身で作成したログインフォームをSpringSecurityに適用する方法を紹介する まず、ログインフォームを表示するためのJSPを作成 ここでは、SpringMVCのViewResolverに指定しているベースパス（src/main/webapp/views/）の直下にJSPを配置し、SpringMVC経由でログインフォームを表示する前提で説明 ログインフォームをSpringSecurityに適用するために以下のようなBean定義を行う loginPageメソッドを呼び出し、ログインフォームを表示するためのパスを指定する 匿名のユーザーが認証を必要するリソースにアクセスした場合、ここで指定したパスにリダイレクトしてログインフォームを表示する仕組みになっている。loginPageメソッドに与えられた引数によって、認証パス（loginProcessingUrl）も連動して変わる permitAll()メソッドを呼び出して、すべてのユーザーに対してログインフォームへのアクセス件を付与する 123456789101112@Overridepublic void configure(HttpSecurity http) throws Exception &#123; // http.addFilter(this.preAuthenticatedProcessingFilter()); // http.formLogin(); http.formLogin() .loginPage(\"/login\") // 認証を必要とするURLに遷移した場合、このURLにリダイレクトしてログインフォームを表示する仕組み .permitAll(); // すべてのユーザーに対してログインフォームへのアクセス件を付与する http.authorizeRequests() .anyRequest() .authenticated(); // formLoginメソッドを呼び出すと、フォーム認証が有効になり、FormLoginConfigurerのインスタンスが返却される。&#125; デフォルト動作のカスタマイズ フォーム認証処理のカスタマイズポイントとして 認証パス 資格情報を送るリクエストパラメータ名の変更方法を紹介 123456http.formLogin() //.loginPage(\"/login\") .loginProcessingUrl(\"authenticate\") .usernameParameter(\"uid\") .passwordParameter(\"pwd\") .permitAll(); loginPageもloginProcessingUrlもやっていることは同じらしい http://www.ne.jp/asahi/hishidama/home/tech/java/spring/boot/web/form-auth.html 9.4.3 認証成功時のレスポンス SpringSecurityは、認証成功時のレスポンスを制御するためのコンポーネントとして、AuthenticationSuccessHandlerというインターフェースと実装クラスを提供している AuthenticationSuccessHandlerの実装クラス SavedRequestAwareAuthenticationSuccessHanlder: 認証前にアクセスを試みたURLにリダイレクト（デフォルト） SimpleUrlAuthenticastionSuccessHandler: コンストラクタに指定したURLにリダイレクトまたはフォワードする デフォルトの動作 認証前にアクセスを拒否したリクエストをHTTPセッションに保存しておいて、認証が成功した際にアクセスを拒否したリクエストを復元してリダイレクトする仕組みになっている デフォルト動作のカスタマイズ 認証成功時のレスポンスのカスタマイズポイントとして、認証成功時に遷移するデフォルトのパスの変更方法を紹介 1234http.formLogin() .loginPage(\"/login\") // 認証を必要とするURLに遷移した場合、このURLにリダイレクトしてログインフォームを表示する仕組み .defaultSuccessUrl(\"/menu\") // 認証成功時のデフォルトアクセスはルート。カスタマイズするために記載 .permitAll(); // すべてのユーザーに対してログインフォームへのアクセス件を付与する 9.4.5 データベース認証 データベース認証の仕組み SpringSecurityはクライアントからの認証依頼を受け、DaoAuthenticationProviderの認証処理を呼び出す DaoAuthenticationProviderは、UserDetailsServiceのユーザー情報取得処理を呼び出す UserDetailsServiceの実装クラスは、データストアからユーザー情報を取得する UserDetailsServiceの実装クラスは、データストアから取得したユーザー情報からUserDetailsを生成する DaoAuthenticationProviderは、UserDetailsServiceから返却されたUserDetailsとクライアントが指定した認証情報との照合を行い、クライアントが指定したユーザーの正当性をチェックする。クライアントが指定したユーザーが正当なユーザーでない場合は、認証例外をスローする メモ SpringSecurityはユーザー情報をリレーショナルデータベースからJDBC経由で取得するための実装クラスを提供しているが、最低限の認証処理しか行わないため、そのまま利用できるケースは少ないと思われる そのため本書では、UserDetailsとUserDetailsServiceの実装クラスを作成する方法を紹介します。 UserDetailsの作成 MEMO:※細かいのでソースを確認 後で追記 認証処理の適用 9.4.6 パスワードのハッシュ化 いくつか、パスワードを扱う実装クラスが提供されている MEMO:※細かいのでソースを確認 後で追記 9.4.7 認証イベントのハンドリング SpringSecurityは、SpringFrameworkが提供しているイベント通知の仕組みを利用して、 認証処理の結果を他のコンポーネントへ連携する仕組みを提供しています この仕組を利用すると以下のようなセキュリティ要件をSpringSecurityの認証機能に組み込むことができます 認証成功、失敗などの認証履歴をデータベースやログに保存したい パスワードを連続して誤った場合にアカウントをロックしたい 認証イベントの通知は以下のような仕組みで行われる 認証イベントの通知の流れ SpringSecurityの認証機能は、認証結果をAuthenticationEventPublisherに渡して認証イベントの通知依頼を行う AuthenticationEventPublisherインターフェースのデフォルトの実装クラスは、認証結果に対応する認証イベントクラスのインスタンスを生成し、ApplicationEventPublisherに渡してイベントの通知依頼を行う ApplicationEventPublisherインターフェースの実測クラスは、ApplicationListenerインターフェースの実装クラスにイベントを通知する ApplicationListenerの実装クラスの１つであるApplicationListenerMethodAdaptorは、`@org.springframework.context.event.EventLintener`が付与されているメソッドを呼び出してイベントを通知する メモ Spring4.1まではApplicationListenerインターフェースの実装クラスを作成して、イベントを受け取る必要があった Spring4.2からは、POJOに@EventListenerを付与したメソッドを実装するだけでイベントを受け取ることができる Spring4.2以降も、従来と同じ用にApplicationListenerインターフェースの実装クラスを作成してイベントを受け取ることができる 認証成功イベント 認証が成功したときにSpringSecurityが通知する主なイベントは以下の３つです。 この３つのイベントは途中でエラーが発生しなければ、以下の順番ですべて通知されます AuthenticationSuccessEvent AuthenticationProviderによる認証処理が成功したことを通知する。 このイベントをハンドリングすると、クライアントが正しい認証情報を指定したことを検知することができるが、後続の認証処理でエラーになる可能性がある SessionFixationProtectionEvent セッション固定攻撃対策の処理（セッションIDの変更処理）が成功したことを通知する。このイベントをハンドリングすると、変更後のセッションIDを検知することができる InteractiveAuthenticationSuccessEvent 認証処理がすべて成功したことを通知する。このイベントをハンドリングすると、画面遷移を除くすべての認証処理が成功したことを検知することができる 認証失敗イベント 認証が失敗したときにSpringSecurityが通知する主なイベントは以下の通り 認証に失敗した場合は、以下のいずれか１つのイベントが通知される AuthenticationFailureBadCredentialsEvent AuthenticationFailureDisabledEvent AuthenticationFailureLockedEvent AuthenticationFailureExpiredEvent AuthenticationFailureCredentialsExpiredEvent AuthenticationFailureServiceExceptionEvent イベントリスナの作成 認証イベントの通知を受け取って処理を行いたい場合、@EventListenerを付与したメソッドを実装したクラスを作成し、DIコンテナに登録するだけ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * - 認証イベントの通知の流れ * 1. SpringSecurityの認証機能は、認証結果をAuthenticationEventPublisherに渡して認証イベントの通知依頼を行う * 2. AuthenticationEventPublisherインターフェースのデフォルトの実装クラスは、認証結果に対応する認証イベントクラスのインスタンスを生成し、ApplicationEventPublisherに渡してイベントの通知依頼を行う * 3. ApplicationEventPublisherインターフェースの実測クラスは、ApplicationListenerインターフェースの実装クラスにイベントを通知する * 4. ApplicationListenerの実装クラスの１つであるApplicationListenerMethodAdaptorは、`@org.springframework.context.event.EventLintener`が付与されているメソッドを呼び出してイベントを通知する * * - `@EventLitener`を付与したメソッドを実装するだけで認証成功/失敗時の処理を実装できる仕組み * @author Tomo * */@Slf4j@Componentpublic class AppSecurityEventListener &#123; // ============================== // SUCCESS EVENT HANDLERS // ============================== /** * AuthenticationProviderによる認証処理が成功したことを通知する。 * このイベントをハンドリングすると、クライアントが正しい認証情報を指定したことを検知することができるが、 * 後続の認証処理でエラーになる可能性がある。 * @param event */ @EventListener public void handleAuthenticationSuccess(AuthenticationSuccessEvent event) &#123; // &#125; /** * セッション固定攻撃対策の処理（セッションIDの変更処理）が成功したことを通知する。 * このイベントをハンドリングすると、変更後のセッションIDを検知することができる。 * @param event */ @EventListener public void handleSessionFixationProtection(SessionFixationProtectionEvent event) &#123; // &#125; /** * 認証処理がすべて成功したことを通知する。 * このイベントをハンドリングすると、画面遷移を除くすべての認証処理が成功したことを検知することができる。 * @param event */ @EventListener public void handleInteractiveAuthenticationSuccess(InteractiveAuthenticationSuccessEvent event) &#123; // &#125; // ============================== // FAILURE EVENT HANDLERS // ============================== @EventListener public void handleBadCredentials(AuthenticationFailureBadCredentialsEvent event) &#123; log.info(\"BAD Credentials is detected. username : &#123;&#125;\", event.getAuthentication().getName()); &#125; @EventListener public void handleDisabled(AuthenticationFailureDisabledEvent event) &#123; log.info(\"Disabled user is detected. username : &#123;&#125;\", event.getAuthentication().getName()); &#125; @EventListener public void handleLocked(AuthenticationFailureLockedEvent event) &#123; log.info(\"Locked user is detected. username : &#123;&#125;\", event.getAuthentication().getName()); &#125; @EventListener public void handleExpired(AuthenticationFailureExpiredEvent event) &#123; log.info(\"Expired user is detected. username : &#123;&#125;\", event.getAuthentication().getName()); &#125; @EventListener public void handleCredentialsExpired(AuthenticationFailureCredentialsExpiredEvent event) &#123; log.info(\"CredentialsExpired is detected. username : &#123;&#125;\", event.getAuthentication().getName()); &#125; @EventListener public void handleServiceException(AuthenticationFailureServiceExceptionEvent event) &#123; log.info(\"ServiceException is detected. username : &#123;&#125;\", event.getAuthentication().getName()); &#125;&#125; 9.4.8 ログアウト SpringSecurityは以下のような流れでログアウト処理を行う クライアントは、ログアウト処理を行うためのパスにリクエストを送信する LogoutFilterは、LogoutHandlerのメソッドを呼び出してログアウト処理を行う LogoutFilterは、LogoutSuccessHandlerのメソッドを呼び出して画面遷移を行う LogoutHandlerの実装クラス SecurityContextLogoutHandler: 認証情報のクリアとセッションの破棄を行う CookieClearingLogoutHandler: 指定したクッキーの削除するためのレスポンスを行う CsrfLogoutHandler: CSRF対策用のトークンの破棄を行う こららのLogoutHandlerは、SpringSecurityが提供しているBean定義をサポートするクラスが自動でLogoutFilterに設定する仕組みになっているので、基本的にはアプリケーションの開発者が直接意識する必要はない ログアウト処理の適用 ログアウト処理を適用するには、以下のようなBean定義を行う必要がある 1234567891011121314151617http.authorizeRequests() .antMatchers(\"/\", \"/find\", \"/login\", \"/signup\", \"/error\", \"/login-error\").permitAll() .anyRequest().authenticated() .and() // Login処理 .formLogin() .loginPage(\"/login\") // 認証を必要とするURLに遷移した場合、このURLにリダイレクトしてログインフォームを表示する仕組み .defaultSuccessUrl(\"/menu\") // 認証成功時のデフォルトアクセスはルート。カスタマイズするために記載 .failureUrl(\"/login\") // 認証失敗時ログイン画面に戻す .usernameParameter(\"id\") .passwordParameter(\"password\") .and() // Logout処理 .logout() .logoutRequestMatcher(new AntPathRequestMatcher(\"logout**\")) .logoutSuccessUrl(\"/login\") .permitAll(); // すべてのユーザーに対してログインフォームへのアクセス件を付与する デフォルトの動作のカスタマイズ 遷移先を変える logoutSuccessUrlの引数を変えてあげる 9.4.10 認証情報へのアクセス 認証済みのユーザーの認証情報は、SpringSecurityのデフォルト実装では、セッションに格納される セッションに格納された認証情報は、リクエストごとにSecurityContextPersistenceFilterクラスによって SecurityContextHolderというクラスに格納され、同一スレッド内であればどこからでもアクセスすることができる用になる Javaからのアクセス 一般的な業務アプリケーションでは、「いつ」「誰が」「どのデータに」「どのようなアクセスをしたか」を 記録する監査ログを取得することがある。この要件を実現する際の、「誰が」は、認証情報から取得できる 123456789101112// 認証情報（Authenticationオブジェクト）を取得するAuthentication authentication = SecurityContextHolder.getContext().getAuthentication();String userUuid = null;// Authentication#getPrincipal()メソッドを呼び出して、UserDetailsオブジェクトを取得する// 認証済みでない場合は、匿名ユーザーを表す文字列が返却されるので注意if (authentication.getPrincipal() instanceof AccountUserDetails) &#123; AccountUserDetails userDetails = AccountUserDetails.class.cast(authentication.getPrincipal()); // UserDetailsから処理に必要な情報を取得する userUuid = userDetails.getAccount().getUserUuid();&#125; アノテーションでアクセスした方が良さそう https://qiita.com/Hyuga-Tsukui/items/81990938e43c7dff35cf JSPからのアクセス 一般的なWebアプリケーションでは、ログインユーザーのユーザー情報などを画面に表示することがある。 12345&lt;% taglib prefix=\"sec\" uri=\"http://www.springframework.org/security/tags\" %&gt;&lt;%-- ... --%&gt;ようこそ&lt;sec:authentication property=\"principal.account.lastName\" /&gt;さん。 追記：thymeleafからのアクセス 12345678&lt;!DOCTYPE html&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\" xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity4\"&gt; &lt;!-- これを追加してThymeleafからSpringSecurityを利用 --&gt;&lt;!-- 省略 --&gt;&lt;body&gt; &lt;h1&gt;こんにちは、&lt;span sec:authentication=\"principal.userId\"&gt;&lt;/span&gt;さん&lt;/h1&gt; &lt;!-- principal.メンバ変数名 で参照できる --&gt;&lt;/body&gt; 9.4.11 認証処理とSpringMVCの連携 SpringSecurityは、SpringMVCと連携するためのコンポーネントをいくつか提供している ここでは、認証処理と連携するためのコンポーネントの使い方を紹介 SpringSecurityは認証情報（UserDetails）をSpringMVCのコントローラーのメソッドに引き渡すためのコンポーネントとして、AuthenticationPrincipalArgumentResolverというクラスを提供している これを使用すると、コントローラーのメソッド引数として、UserDetailsインターフェースまたはその実装クラスのインスタンスを受け取ることができる 123456789@Controllerpublic class Controller &#123; @RequestMapping(\"/\") public index(@AuthenticationPrincipal UserDetailsImpl userDetails) &#123; System.out.println(userDetails.getUserId) // userId System.out.println(userDetails.getPassword) //password System.out.println(userDetails.getHoge) //hoge &#125; 9.4.12 エラーメッセージ 認証に失敗した場合、SpringSecurityが用意しているエラーメッセージが表示されます このエラーメッセージは内容を変更したり、表示しないようにすることができます。 エラーメッセージの変更 認証失敗時に表示されるエラーメッセージを変更したい場合は、MessageSourceで読み込んでいるプロパティファイルに SpringSecurityが用意しているメッセージの定義を追加してください 12345AbstractUserDetailsAuthenticationProvider.badCredentials = 入力した認証情報に誤りがあります。AbstractUserDetailsAuthenticationProvider.credentialsExpired = 認証情報の利用期限が切れています。AbstractUserDetailsAuthenticationProvider.disabled = 無効なアカウントです。AbstractUserDetailsAuthenticationProvider.expired = アカウントの期限が切れています。AbstractUserDetailsAuthenticationProvider.locked = アカウントがロックされています。 この他にも多数のメッセージが用意されている 種類を確認するには、spring-security-coreモジュールのjarファイルの中のorg/springframework/security/message.propertiesファイルを確認してください メッセージ定義定数クラスは自動生成するべきな件 https://terasolunaorg.github.io/guideline/1.0.x/ja/ArchitectureInDetail/MessageManagement.html メモ MessageSourceの中でプロパティファイルをISO 8859-1(デフォルト)で読み込んでいる場合は、マルチバイト文字は Unicodeコード（\\udddd表記）形式に変換する必要がある。 なお、プロパティファイルを任意の文字コードで読み込む場合は、MessageSourceのdefaultEncodingプロパティに文字コードを指定してください。 1234567@Beanpublic MessageSource messageSource() &#123; ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); messageSource.setBasenames(\"i18n/messages\"); // クラスパス上に格納されているプロパティファイル（拡張子は除く）を指定する messageSource.setDefaultEncoding(\"UTF-8\"); // ★ここのこと！ return messageSource;&#125; システムエラー時のメッセージ 認証処理の中で予期しないエラー（システムエラーなど）が発生した場合、InternalAuthenticationServiceExceptionという例外が発生する。InteractiveAuthenticationServiceExceptionが保持するメッセージには、 原因例外のメッセージが設定されるため画面にそのまま表示するのは好ましくない システムエラーの例外メッセージを画面に表示しない用にするには、ExceptionMappingAuthenticationFailureHandlerやDelegatingAuthenticationFailureHandlerを使用して、InternalAuthenticationServiceExceptionが発生したときの遷移先をシステムエラー画面にするのが良いでしょう。 TODO: この辺見て実装する https://qiita.com/rubytomato@github/items/6c6318c948398fa62275 9.5 認可処理 認可処理は、アプリケーションの利用者がアクセスできるリソースを制御するための処理 最も標準的な方法は、リソース毎にアクセスポリシーを定義しておいて、利用者がリソースにアクセスしようとしたときにアクセスポリシーを調べて制御する方法 アクセスポリシーには、どのリソースにどのユーザーからのアクセスを許可するかを定義します SpringSecurityでは、Webリソース、Javaメソッド、ドメインオブジェクトに対してアクセスポリシーを定義できる ※ドメインオブジェクトに関する認可処理は本書では扱わない興味がある場合は、下記参照http://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#domain-acls 9.5.1 認可処理の仕組み SpringSecrityが提供する認証処理の仕組みを理解しましょう 以下のような流れで認可処理を行います クライアントが任意のリソースにアクセスする FilterSecurityInterceptorクラスは、AccessDecisionManagerインターフェースのメソッドを呼び出し、リソースへのアクセス権の有無をチェックする AffirmativeBasedクラス（デフォルトで使用されるAccessDecisionManagerの実装クラス）は、AccessDecisionVoterインターフェースのメソッドを呼び出し、アクセス件の有無を投票してもらう FilterSecurityInterceptorは、AccessDecisionManagerによってアクセス権が付与された場合に限り、リソースへアクセスする ExceptionTranslationFilter 認可処理（AccessDecisionManager）で発生した例外をハンドリングし、 クライアントに適切なレスポンスを行うためのサーブレットフィルタ デフォルトの実装では、未認証ユーザーからのアクセスの場合は、認証を促すレスポンス、認証済みユーザーからのアクセスの場合は、認可エラーを通知するレスポンスを返却する FilterSecurityInterceptor HTTPリクエストに対して認可処理を適用するためのサーブレットフィルタで、実際の認可処理はAccessDecisionManagerに移譲しています。 AccessDecisionManagerインターフェースのメソッドを呼び出す際には、クライアントがアクセスしようとしたWebリソースに指定されているアクセスポリシーを連携します。 AccessDecisionManager アクセスしようとしたリソースに対してアクセス権があるかチェックを行うためのインターフェース SpringSecurityが提供する実装クラスでは、このあと紹介するAccessDecisionVoterというインターフェースのメソッドを呼び出してアクセス権を付与するか否かを投票するしくみになっており、デフォルトで適用されるクラスはAffirmativeBasedクラスです。AffirmativeBasedクラスは、いずれかのAccessDecisionVoterが付与を投票した場合にアクセス権を与える実装クラス AccessDecisionVoter アクセスしようとしたリソースに指定されているアクセスポリシーを参照し、アクセス権を付与するか否かを投票する（付与、拒否、棄権）するためのインターフェース SpringSecurityではいくつかの実装クラスを提供しているが、4.0からデフォルトで適用されるクラスは、WebExpressionVoterに統一されている WebExpressionVoterはSpring Expression Languageを使用して、利用者が持つ、権限情報とリクエスト情報を参照して投票を行う実装クラス 9.5.2 アクセスポリシーの記述方法 SpringSecurityは、アクセスポリシーを指定する記述方法として、SpringExpressionLanguage（SpEL）をサポート SpELを使わない方法もあるが、本書では、Expressionを使ってアクセスポリシーを指定する方法で解説する CommonExpressions ※割愛 9.5.3 Webリソースへの認可（JavaConfig編） JavaConfigを使用して、Webリソースに対してアクセスポリシーを定義する方法について説明 アクセスポリシーを適用するWebリソースの指定 まずは、アクセスポリシーを適用するリソースを指定 アクセスポリシーを適用するリソースの指定は、ExpressionInterceptUrlRegistryクラスの以下のメソッドを呼び出して行います。 antMatchers regexMatchers requestMatchers anyRequests 12345678910@Overridepublic void configure(HttpSecurity http) throws Exception &#123; // http.addFilter(this.preAuthenticatedProcessingFilter()); // http.formLogin(); http.authorizeRequests() .antMatchers(\"/\", \"/find\", \"/login\", \"/signup\", \"/error\", \"/login-error\").permitAll() // ★記載順には気をつける必要がある .antMatchers(\"/admin/accounts/***\").hasRole(\"ACCOUNT_MANAGER\") .antMatchers(\"/admin/***\").hasRole(\"ADMIN\") .anyRequest().authenticated() アクセスポリシーの指定 次に、アクセスポリシーを指定します。 アクセスポリシーの指定は、AuthorizedUrlクラスのメソッドを使用して行います。 1234567http.authorizeRequests() .antMatchers(\"/\", \"/find\", \"/login\", \"/signup\", \"/error\", \"/login-error\").permitAll() // .antMatchers(\"/admin/accounts/***\").hasRole(\"ACCOUNT_MANAGER\") // .antMatchers(\"/admin/***\").hasRole(\"ADMIN\") .antMatchers(\"/admin/***\").access(\"hasIpAddress('127.0.0.1') and hasRole('CONFIGURATION_MANAGER')\") .antMatchers(\"/admin/***\").hasRole(\"ADMIN\") .anyRequest().authenticated() 9.5.4 Webリソースへの認可（XMLファイル編） 割愛 9.5.5 メソッドへの認可 SpringSecurityは、SpringAOPの仕組みを利用して、アプリケーションコンテキスト内で管理しているBeanのメソッド呼び出しに対して認可処理を行う仕組みを提供しています。 メソッドに対応する認可処理を使用すると、メソッドの引数や戻り値のオブジェクトの状態を参照できるため、よりきめ細かいアクセスポリシーの定義が行える メソッドへの認可を使用する場合は、メソッド呼び出しに対して認可処理を行うためのコンポーネント（AOP）を有効にしてから、アクセスポリシーをクラスやメソッドのアノテーションに定義します。 つまり AOP有効化 メソッドにアノテーション定義 SpringSecurityがサポートしているアノテーションは以下 @PreAuthorize,@PostAuthorize,@PreFilter,@PostFilter: SpringSecurityのアノテーション @Secured: SpringSecurityのアノテーション JSR250(javax.annotation.securityパッケージ)のアノテーション（@RolesAllowedなど） 本書では、アクセスポリシーの指定にExpressionを使用することができる @PreAuthorizeと@PostAuthorizeを紹介する メソッド認可の有効化 まず、メソッドに対して認可処理を行うAOPを有効化します 123@EnableGlobalMethodSecurity(prePostEnabled = true) // メソッドに対して認可処理を行うAOPを有効化 prePostEnabled属性にtrueを指定すると、Expressionを使用してアクセスポリシーを定義することができるアノテーションが有効になるpublic class AppSecurityConfig extends WebSecurityConfigurerAdapter &#123;&#125; メソッド実行前に適用するアクセスポリシーの指定 メソッドの実行前に適用するアクセスポリシーを指定する場合は@PreAuthorizeを使用する @PreAuthorizeのvalue属性に指定したExpressionの結果がtrueになるとメソッドの実行が許可される 12345// 管理者以外の人間が他人のアカウント情報にアクセスできないように定義している@PreAuthorize(\"hasRole('ADMIN') or (#username == principal.username)\")public Account findOne(String username) &#123; return accountRepository.findOne(username);&#125; ここでポイントになるのが、Expressionの中からメソッドの引数にアクセスしている部分 具体的には、#usernameの部分が引数にアクセスしている部分になる Expression内で「# + 引数名」形式のExpressionを指定するとメソッドの引数にアクセスすることができる メモ SpringSecurityは、クラスに出力されているデバッグ情報から引数名を解決する仕組みになっているが、 アノテーション（@P）を使用して明示的に引数名を指定することもできる 以下の場合は、明示的に引数名を指定してあげる必要がある 引数のデバッグ情報を出力しない Expressionの中から実際の引数名とは別の名前を使ってアクセスする（例：短縮した名前） 1234@PreAuthorize(\"hasRole('ADMIN') or (#username == principal.username)\")public Account findOne(@P(\"username\") String username) &#123; return accountRepository.findOne(username);&#125; JavaSE8から追加されたコンパイルオプション（-parameters）を使用すると、メソッドパラメータにリフレクション用のメタデータが生成されるため、アノテーションを指定しなくても引数名を解決してくれる メソッド実行後に適用するアクセスポリシーの指定 @PostAuthorizeを使用する 12345@PreAuthorize(\"hasRole('DEPARTMENT_MANAGER')\")@PostAuthorize(\"(returnObject == null) or (returnObject.departmentCode == principal.account.departmentCode)\")public Account findOne(@P(\"username\") String username) &#123; return accountRepository.findOne(username);&#125; 9.5.6 JSPの画面項目への認可SpringSecurityはJSPタグライブラリを使用してJSPの画面項目に対して認可処理を適用することができる ※管理者の場合、この項目を表示するなどの制御 このURLへ遷移させるなどの制御 9.5.7 認可エラー時のレスポンス SpringSecurityはリソースへのアクセスを拒否した場合、以下のような流れでエラーハンドリング、レスポンスを行う SpringSecurityは、リソースやメソッドへのアクセスを拒否するために、AccessDeniedExceptionをスローする ExceptionTranslationFilterクラスは、AccessDeniedExceptionを捕捉し、AccessDeniedHandlerまたは、AuthenticationEntryPointインターフェースのメソッドを呼び出してエラー応答を行う 認証済みのユーザーからのアクセスの場合は、AccessDeniedHandlerインターフェースのメソッドを呼び出してエラー応答を行う 未認証ユーザーからのアクセスの場合は、AuthenticationEntryPointインターフェースのメソッドを呼び出してエラー応答を行う AccessDeniedHandler AuthenticationEntryPoint 認可エラー時の遷移先 1http.exceptionHandling().accessDeniedPage(\"/accessDeniedError\"); デフォルト動作のカスタマイズ TODO: 認証エラー時にメッセージを出す処理を作るときに記述しないと行けない気がする 9.6 CSRF対策9.6.1 Spring SecurityのCSRF対策 Spring Securityはセッション単位にランダムなトークン値(CSRFトークン)を払い出し、払い出されたCSRFトークンをリクエストパラメータ（HTMLフォームのhidden項目）として送信することで、そのリクエストが正規のWebページからなのか、それとも攻撃者が用意したWebページからなのかを判断する機能がある SpringSecurityのデフォルト実装では、POST,PUT,DELETE,PATCHのHTTPメソッドを使用したリクエストに対して、CSRFトークンチェックを行います 9.6.2 CSRF対策機能の適用 CSRF対策機能はSpring3.2から追加された機能で、SpringSecurity4.0からデフォルトで適用されるようになりました。 そのため、CSRF対策機能を有効にするための特別な定義はありません。 なおCSRF機能を適用したくない場合は、明示的に無効にする必要がある 1234@Overridepublic void configure(HttpSecurity http) throws Exception &#123; http.csrf().disable();&#125; HTMLフォーム使用時のトークン値の連携 JSPでの設定を紹介しているため割愛 Thymeleafだとこんな感じhttps://qiita.com/nenokido2000/items/22a97a26a5858ddb164f Ajax使用時の連携 Ajaxを使ってリクエストを送信する場合は、SpringSecurityから提供されている&lt;sec:csrfMetaTag&gt;要素を使用して、HTMLの&lt;meta&gt;要素としてCSRFトークンの情報を出力し&lt;meta&gt;要素から取得したトークン値をAjax通信時のリクエストヘッダーに設定して連携します。 Thymeleafの場合、以下を参考に、Cookieからcsrfトークンを取り出して、詰めて送る https://qiita.com/nenokido2000/items/22a97a26a5858ddb164f CookieにCSRFトークンを詰める処理は以下で行えるようになっている http.csrf().csrfTokenRepository(new CookieCsrfTokenRepository()); 9.6.3 トークンチェックエラー時のレスポンス CSRFトークンチェックでエラーが発生した場合、SpringSecurityはAccessDeniedHandlerインターフェースを使用してエラーのレスポンスを行う CSRFトークンチェックでエラーが発生したときに専用のエラーページに遷移させる場合は、SpringSecurityから提供されているDelegatingAuthenticationFailureHandlerクラスを利用して、それぞれの例外にAccessDeniedHandlerインターフェースの実装クラスを指定してください CSRFトークンチェックで使用される例外クラス InvalidCsrfTokenException MissingCsrfTokenException TODO: この例外処理を実装する必要がある XMLで記載している例はあるけど、Javaで書いている例がない.. 9.6.4 CSRF対策機能とSpringMVCとの連携 自動でFormにcsrfトークンが入りますよという説明 9.7 セッション管理9.7.1 セッション管理機能の適用 セッション管理機能を使用するには、以下のようなBean定義を行う 1234@Overridepublic void configure(HttpSecurity http) throws Exception &#123; http.sessionManagement();&#125; sessionManagementメソッドを呼び出し、SessionManagementConfigurerのインスタンスを取得する SessionManagementConfigurerには、セッション管理機能のコンポーネントの動作をカスタマイズするためのメソッドが定義されている。なお、WebSecurityConfigurerAdapterを継承して、コンフィギュレーションクラスを作成している場合は、sessionManagementメソッドは親クラスの処理で呼び出されるため、デフォルトでセッション管理機能が適用されている RESTAPIなどセッションを使用しない場合は、セッションの作成方式を stateless に変更する必要がある 1http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) セッションの作成方式は以下のオプションから選択することができる always ifRequired (デフォルト) never stateless 9.7.2 URL Rewriting抑止機能URL Rewritingが行われると、URL内にセッションIDが露出してしまうため、セッションIDを盗まれるリスクが高くなります。 SpringSecurityでは、URL Rewritingを抑止するための仕組みも提供しており、この機能はSpringSecurity4.0以上ではデフォルトで適用されます。 TODO: Cookieを許可しない設定になっているとどのような挙動になる？クエリに埋め込まれない？ 9.7.3 セッション固定攻撃対策機能 セッション管理機能を適用すると、デフォルトでセッション固定攻撃機能が有効になる セッション固定攻撃対策機能を使用すると、ログイン成功時に新たセッションIDを払い直すため、攻撃者が事前に払い出したセッションIDが使われることはありません。 セッション固定攻撃への対策オプション changeSessionId: Servlet3.1で追加されたHttpServletRequest#changeSessionIdメソッドを使用してセッションIDを変更する（Servlet3.1以上のコンテナでのデフォルト動作） migrateSession: ログイン前に使用していたセッションを破棄し、新たにセッションを作成する。ログイン前にセッションに格納されていたオブジェクトは新しいセッションに引き継がれる newSession: migrateSessionと同じ方法でセッションIDを変更するが、ログイン前に格納されていたオブジェクトは新しいセッションには引き継がれない none: SpringSecurityはセッションIDを変更しない 指定方法 12http.sessionManagement().sessionFixation().newSession(); 9.7.4 多重ログインの制御 SpringSecurityは同じユーザー名（ログインID）を使った多重ログインを制御する機能を提供しているが、 SpringSecurityが提供しているデフォルト実装にはいくつかの制約や注意事項がある 本書では、これらの制約と注意事項について紹介するが、具体的な使い方は扱わない、リファレンス参照 SpringSecurityが提供しているデフォルト実装では、ユーザー毎にセッション情報をアプリケーションサーバーのメモリ内で管理します。 そのため、複数のアプリケーションサーバーを同時に実行するシステムでは利用することができません。 また、アプリケーションサーバーを停止または再起動するとメモリ内で管理していたセッション情報はクリアされます。 使用するアプリケーションサーバーによっては、停止または再起動時のセッション状態を復元する機能を持っているため、実際のセッション状態とSpringSecurityが管理しているセッション情報に不整合が生じる可能性がある TODO: Redisで管理する方法探る 9.7.5 無効なセッションを使ったリクエストの検知 SpringSecurityは無効なセッションを使ったリクエストを検知する機能を提供している 無効なセッションとして扱われるリクエストの大部分は、セッションタイムアウト後のリクエストです。 以下の例では、無効なセッションを検知した際の遷移先として &quot;/error/invalidSession&quot;を指定することで、この機能を有効化している 12http.sessionManagement().invalidSessionUrl(\"/error/invalidSession\"); 9.8 ブラウザのセキュリティ対策機能との連携 ブラウザが提供するセキュリティ対策機能の一部は、サーバー側で、HTTPのレスポンスヘッダーを出力することで動作を制御することができる 9.8.1 セキュリティヘッダー出力機能の適用 Spring3.2から追加された機能で、Spring4.0からデフォルトで適用されるようになった 12// 無効にする方法 http.headers().disable(); 9.8.2 デフォルトでサポートしているセキュリティヘッダー SpringSecurityがデフォルトでサポートしているレスポンスヘッダーは以下の５つ Cache-Control（Pragma, Expires） コンテンツのキャッシュ方法を支持するヘッダー 保護されたコンテンツがブラウザにキャッシュされないようにすることで、権限のないユーザーが保護されたコンテンツを閲覧できてしまうリスクを減らすことができる X-Frame-Options フレーム（&lt;frame&gt;または&lt;iframe&gt;要素）内でコンテンツの表示を許可するか否かを支持するためのヘッダー フレーム内でコンテンツが表示されないようにすることで、クリックジャッキングと呼ばれる攻撃手法を使って機密情報を盗み取られるリスクを無くすことができる X-Content-Type-Options コンテンツの種類の決定方法を指示するためのヘッダー 一部のブラウザでは、Content-Typeヘッダーの値を無視して、コンテンツの内容を見て決定します。 コンテンツの種類を決定する際にコンテンツの内容を見ないようにすることで、クロスサイトスクリプティングを使った攻撃を受ける可能性をへらすことができます。 X-XSS-Protection ブラウザのXSSフィルタ機能を使って有害なスクリプトを検知する方法を支持するためのヘッダー XSSフィルタ機能を有効にして有害なスクリプトを検知するようにすれば、クロスサイトスクリプティングを使った攻撃を受ける可能性をへらすことができる。 Strict-Transport-Security HTTPSを使ったアクセスをしたあとに、HTTPを使ってアクセスしようとした際に、HTTPSに置き換えてからアクセスすることを支持するためのヘッダー HTTPSでアクセスした後に、HTTPが使われないようにすることで、中間者攻撃と呼ばれる攻撃手法を使って悪意のあるサイトに誘導されるリスクをへらすことができる TODO: 攻撃手法と対策について再度整理する必要あり 9.8.3 セキュリティヘッダーの選択 出力するセキュリティヘッダーを選択したい場合は、以下のようなBean定義を行います。 ここではSpringSecurityが提供するすべてのセキュリティヘッダーを出力する例になっていますが、実際は必要なものだけ指定する 1234567http.headers() .defaultsDisabled() .cacheControl().and() .frameOptions().and() .contentTypeOptions().and() .xssProtection().and() .httpStrictTransportSecurity(); 不要なものだけ無効化する方法もある 9.9 Spring Securityのテスト MockMvcを使用して「認証処理」や「認可処理」などのテストを行うための機能 テスト時に適用する認証情報をアノテーションで指定できる機能 9.9.1 Spring Security Testのセットアップ 依存ライブラリーの追加 12// build.gradle testImplementation 'org.springframework.security:spring-security-test' SpringSecurityのサーブレットフィルタの追加 TODO: テスト環境が作れて無いため一旦スキップする 第10章 Spring Data JPA10.6 Repositoryの作成と利用10.6.4 ページネーション TODO: DOMAにあるかどうか 10.6.6 監査情報の付与 TODO: DOMAにあるかどうか 第11章 Spring ＋ MyBatis XMLに記述しないといけないので採用したくない 第12章 Spring＋Thymeleaf SpringBootを始め、ViewにJSPではなくテンプレートエンジンであるThymeleafを使用するケースが増えている まずはThymeleaf自体や、Springとセットで開発する際に欠かせない連携ライブラリーの概要を紹介 12.1 Thymeleafとは Thymeleafは、Webアプリケーションと親和性の高いテンプレートエンジン テンプレートエンジンとは 雛形となるドキュメント（テンプレート）に対して、可変データを埋め込むことで動的にドキュメントを生成する仕組み この仕組は、MVCフレームワークのModelとViewを分割する考え方と親和性が高く、しばしばMVCフレームワークのVIEWとし利用される 特徴 XHTMLやHTML5に準拠した形で記述できること JSPはブラウザが認識できないタグライブラリなどが含まれるため、開発中のJSPを直接ブラウザ上で正確に表示させることが難しいという問題があった 一方ThymeleafのテンプレートはHTML5に準拠しているため、テンプレートをブラウザで直接表示させたり。HTMLをデザイナーとプログラマの間で共有することができる MEMO: パーツをIncludeする際はうまく表示できない問題はあると思う 12.1.1 ThymeleafのテンプレートThymeleafはXHTMLやHTML5などで書かれたテンプレートをDOMに変換してから処理を行う仕組みになっている「処理対象のDOMノード」と「DOMノードに適用する処理」をthネームスペースの属性（th属性）を使用して指定します。 th属性が指定されているDOMノードは「プロセッサ」と呼ばれるコンポーネントによってDOM操作（追加、削除、変更）が行われる。th属性の属性値には、OGNL（Object-Graph Navigation Language）と呼ばれる式言語を指定でき、式の中から、ユーザー定義のオブジェクトやThymeleafが提供する暗黙オブジェクトにアクセスすることができる 以下３つのことをDialectと呼ぶ DOM操作を行うプロセッサ th属性の属性値に指定された式を解釈するコンポーネント 暗黙オブジェクトを生成するコンポーネント →デフォルトでは、StandardDialectクラスが使用される Dialectは拡張可能な仕組みになっており、本書で紹介するthymeleaf-spring4を使う場合は、StandardDiarectクラスを継承した、SpringStandardDialectクラスが使用される 12.1.2 ThymeleafとSpringの連携 連携する場合、Thymeleafが提供するthymeleaf-spring4モジュールを利用 SpringMVCがJSP向けに提供しているタグライブラリと同様の機能を、Thymeleafで利用することができる 実現できる機能 Thymeleafが管理するテンプレートをSpringMVCのViewとして扱うことができる テンプレート内でSpringELを利用することができる テンプレートと、フォームクラスおよび入力値チェック結果のバインドが可能となる Springが管理するメッセージリソースを利用し、国際化対応のメッセージを表示することができる 12.2 Spring + Thymeleafのセットアップ12.2.1 ライブラリのセットアップ thymeleaf-spring4を入れる 12.2.2 SpringとThymeleafを連携するための設定 SringBootだと書かなくても動くっぽいけど明示する意味で 1234567891011121314151617181920212223242526272829303132333435@Configuration@Import(ThymeleafConfig.class) // Thymeleafを使用することを明示public class AppConfig implements WebMvcConfigurer &#123;&#125;@Configurationpublic class ThymeleafConfig &#123; @Bean public ClassLoaderTemplateResolver templateResolver() &#123; ClassLoaderTemplateResolver resolver = new ClassLoaderTemplateResolver(); resolver.setPrefix(\"/WEB-INF/templates/\"); resolver.setSuffix(\".html\"); resolver.setTemplateMode(\"HTML5\"); resolver.setCharacterEncoding(\"UTF-8\"); return resolver; &#125; @Bean public SpringTemplateEngine templateEngine() &#123; SpringTemplateEngine templateEngine = new SpringTemplateEngine(); templateEngine.setTemplateResolver(templateResolver()); return templateEngine; &#125; @Bean public ViewResolver viewResolver() &#123; ThymeleafViewResolver viewResolver = new ThymeleafViewResolver(); viewResolver.setTemplateEngine(templateEngine()); viewResolver.setCharacterEncoding(\"UTF-8\"); return viewResolver; &#125;&#125; 12.3 Thymeleafを利用したViewの実装12.3.1 はじめてのThymeleaf Thymeleafを利用したViewへの変更 テンプレートの実装 12.3.2 テキストの出力 th:text — 属性値に指定した値をXHTMLサニタイジングして出力する ユーザからの入力を表示する際はこちら th:utext — 属性値に指定した値をXHTMLサニタイジングせずに出力する プロパティファイルでHTML要素を使用して意図的に装飾しているような場合は、th:utext属性を使用してXHTMLサニタイジングせずに出力する必要がある 12.3.3 式の構文 基本的な式 変数式 選択変数式 メッセージ式：これは利用しておきたい リンクURL式 リテラル 基本的な演算子 テキスト演算子 条件演算子 12.3.4 th属性による属性値の設定 Thymeleafのテンプレートエンジンとしての機能は、th属性に指定された式を解釈し、HTMLの各要素の属性値を設定または上書きすることです。 特定の属性に値を設定する方法 現在の属性値の前後に値を追加する方法 存在有無が重要な属性の出力を制御する方法 複数の属性に同じ値を設定する方法：AltとTitleに同じ値を入れたりとか 任意の属性に値を設定する方法：独自データ属性に値を設定したい場合に使用する &lt;button th:attr=&quot;data-product-id=${product.id}&quot;&gt;削除&lt;/button&gt; 12.3.5 HTML要素の出力制御ここまでth属性を使ってHTML属性の属性値を動的に設定する方法を見てきましたが、動的にHTML要素の出力を制御する必要が出てくる場合がある 例えば、特定の条件下の場合のみメッセージを表示したり、 データの件数だけ行を追加して出力したりする場合などです。 JSPでは、それらの専用タグライブラリが用意されていましたが、Thymeleafでも相当する機能がth属性として提供されている 条件による出力有無の制御 th:if th:unless th:switch th:case 繰り返し出力の制御 th:each java.util.Listの実装クラス java.util.Iterableの実装クラス java.util.Mapの実装クラス 配列 12.3.6 インライン記述th属性を利用しない方法であるインライン記述について説明 [[ ${user.name} ]]でかけるよ インライン記述はデフォルトで無効になっている 有効にするには、 th:inline属性をインライン記述を利用する要素、もしくは親要素に付与する必要がある インライン記述のでメリット テンプレートファイルをブラウザ上で直接表示した際に、インライン記述のテキストがそのまま表示されてしまう点 th:textの用にサンプルデータを表示することができないため、デザイナーとの分業に支障をきたす可能性がある メモ インライン記述はJavascriptなどのスクリプト内でも利用することができる これを利用すると、テンプレートをブラウザで静的に表示した場合や、アプリケーションサーバーにデプロイして動的に表示した場合、その両方においてスクリプトを正常に動作させられる。 MEMO: 結論（個人的な） インライン記述は原則禁止したほうがよいと思う（コーディング規約などで明記すべき） 12.3.7 コメント123456&lt;!-- このブロックはThymeleafの処理後もテンプレートに残ります。 --&gt;&lt;!--/* このブロックはThymeleafの処理後に削除される。*/--&gt; 12.3.8 Springとの連携本項では、thymleaf-springが提供しているSpringとの連携機能に焦点を当てる フォームオブジェクトのバインディング th:object属性 th:field属性 入力エラーの表示 SpringMVCの入力チェック機能で発生したエラーの表示は、 th:errors属性 — エラーメッセージの出力対象を指定するための属性 th:errorclass属性 — エラー時に適用するCSSを指定するための属性 th:fieldsオブジェクト — エラー情報にアクセスするための便利なメソッドを提供するオブジェクト を使用して行う TODO: エラー処理について設計する必要あり SpELの利用 Thymeleafは数式をOGNLとして解釈しますが、thymeleaf-springを利用すると、 変数式はSpELとして解釈されます。 これにより、テンプレート内から、DIコンテナ内に登録されているBeanにアクセスできるようになる 12&lt;span th:text=\"$&#123;@appSettings.passwordValidDays&#125;\"&gt;60&lt;/span&gt;&lt;!-- @Bean名でアクセスできる --&gt; ConversionServiceとの連携 SpringMVCに適用されているConversionServiceと連携して、値の型変換を行うことができる 12345public class AppSettings implements Serializable &#123; @Value(\"$&#123;vasicPostage:1250&#125;\") @NumberFormat(style = NumberFormat.Style.NUMBER) private int basicOneDayCost;&#125; 12&lt;span th:text=\"$&#123;@appSettings.basicOneDayCost&#125;\"&gt;1300&lt;/span&gt;円&lt;span th:text=\"$&#123;&#123;@appSettings.basicOneDayCost&#125;&#125;\"&gt;1300&lt;/span&gt;円 12.3.9 テンプレートの共通化 テンプレートのフラグメント化 共通な内容を別ファイルに切り出す テンプレートのレイアウト化 複数のテンプレートで同じデザインレイアウトを適用する場合は、通常、共通的なレイアウトを定義して共有することになる。このような場合に有効なライブラリとして、Thymeleaf Layout Dialectがある テンプレートのフラグメント化 テンプレートの一部を分割して別ファイルに切り出すことができる ヘッダー、フッター、メニューがフラグメントとしてよく利用されるが、特定のUIコンポーネントをフラグメントとして切り出すことも可能 フラグメントの利用方法 フラグメントの定義と参照という２つの作業が必要になる 定義方法には以下の２つの方法がある Thymeleafのth:fragment属性を利用したフラグメント定義 ★個人的にこっちがわかりやすくていいと思う CSSセレクタと同様、id属性を利用したフラグメント定義 定義したフラグメントを読み込む方法として以下の２つ Thymeleafのth:include属性を利用したフラグメントのインクルード Thymeleafのth:replace属性を利用したフラグメントのち缶 テンプレートのレイアウト化 Thymeleaf Layout Dialectを利用したテンプレートのレイアウト化について説明 セットアップ thymeleaf-layout-dialectのリポジトリ追加 コンフィギュレーションクラスの実装 1234567@Beanpublic SpringTemplateEngine templateEngine() &#123; SpringTemplateEngine templateEngine = new SpringTemplateEngine(); templateEngine.setDialect(new LayoutDialect()); templateEngine.setTemplateResolver(templateResolver()); return templateEngine;&#125; Thymeleaf Layout DialectによるViewの実装 共通レイアウトとなるテンプレートを「Decorator」 共通レイアウトを適用する側の個別のテンプレートを「Fragment」と呼ぶ MEMO: 画面の全体像がわかりづらくなりやすいので、この方法は採用したくないため割愛 12.3.10 SpringSecurityとの連携 SpringSecurityが提供する画面表示に関する機能をThymeleafで利用するためには、 SpringSecurityDialectを利用します。 以下の機能 認証情報にアクセスする機能を持つ sec:authentication属性を提供 SpringSecurity expression を利用した認可処理と同等の機能を持つ sec:authorize属性を提供 URLベースの認可処理を行う sec:authorize-ur属性を提供する ACL(Access Control List)を利用した認可処理を行う sec:authorize-acl属性を提供 CSRFトークンにアクセスする機能を提供 SpringSecurityDialectのセットアップ thymeleaf-extras-springsecurity4 認証情報へのアクセス 12345&lt;!doctype html&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\" xmlns:sec=\"http://www.thymeleaf.ort/extras/spring-security\" th:with=\"title=トップページ\"&gt; &lt;span sec:authentication=\"principal.username\"&gt;テストユーザ名&lt;/span&gt; 画面項目への認可 適用する画面項目とアクセスポリシーの指定 sec:authorize=&quot;hasRole(&#39;ADMIN&#39;)&quot;属性を付与 Trueの場合、HTMLを表示 Webリソースとして指定したアクセスポリシーとの連動 sec:authorize-url=&quot;/admin/accounts&quot;にアクセスできることを条件として表示非表示を設定している CSRFトークンへのアクセス Spring Security Dialectを適用するだけでOK hidden項目としてHTMLに埋め込まれます ajax通信の際は取得してあげる必要がある headerのmeta要素に設定しといて、JSで取得してあげる感じにする TODO: 取得してPOSTする処理は実装考えてみる 12.3.11 JSR 310: Date and Time APIの利用 Thymeleafは、テンプレート内でJSR310:Date and TimeAPIのオブジェクトを操作するための機能を標準ではサポートしておらず、Thymeleafが提供する拡張ライブラリが必要になる 依存ライブラリの追加 thymeleaf-extras-java8timeを利用する なお、thymeleaf-extras-java8timeはSpringIO Platformで管理されていないため、バージョンの指定が必要 Bean定義の追加 1234567@Beanpublic SpringTemplateEngine templateEngine() &#123; SpringTemplateEngine templateEngine = new SpringTemplateEngine(); templateEngine.setDialect(new Java8TimeDialect()); templateEngine.setTemplateResolver(templateResolver()); return templateEngine;&#125; ユーティリティオブジェクト（temporals）を利用 1&lt;title th:text=\"|$&#123;#temporals.format(date, 'yyyy/mm/dd')&#125;の会議室|\"&gt;2020/05/19の会議室&lt;/title&gt; 第13章 Spring Boot機能が豊富な事による課題があるどう組み合わせていいかわからなかったり、ちょっとしたWebアプリケーションを作成するだけでも、数多くの設定が必要であったりする点です。 SpringBootを利用することでこられの課題を解決することができる 13.1 SpringBootとは SpringBoot ２０１３年 ：開発開始 ２０１４年４月：1.0リリース ２０１６年６月：1.3.5 ２０２０年５月：2.3.0 SpringBootを使えば、何も設定しなくてもデフォルトで様々な機能が利用可能 XMLまたはJavaConfigによるBean定義、ログの設定、Servletの設定などが不要になる アプリケーションサーバーをデプロイする必要もなくなり、Javaのmainメソッドを実行すればアプリケーションを実行できる 13.1.1 SpringBootで作るHello Worldアプリケーション13.1.2 AutoConfigureに夜自動設定 自動設定の詳細を知りたい場合は、spring-boot-autoconfigureプロジェクトの◯◯AutoConfigurationクラスのソースを読むことをおすすめします。 13.1.3 Starterによる依存ライブラリの解決 starterライブラリの説明 13.1.4 実行可能jarの作成 実行可能jarとしてパッケージングされる 13.2 SpringBootでSpringMVC13.2.1 RESTful Webサービスの作成13.2.2 画面遷移型アプリケーションの作成 SpringBootの自動設定では、TemplateResolverがビュー名につけるプレフィックスとサフィックスのデフォルト値は、 それぞれ、classpath:/templates/と.htmlになる テンプレートからメッセージを取得する方法 1&lt;title th:text=\"#&#123;app.title&#125;\"&gt; &lt;!-- $&#123;変数名&#125;ではなく#&#123;メッセージキー名&#125;--&gt; 13.3 SpringBootでデータアクセス13.3.1 SpringJDBC これまで必要だったがSpringJDBCでは不要な定義 データソースの定義 トランザクションマネージャの定義 JdbcTemplateの定義 SpringBootのデフォルトの挙動としてクラスパス直下にschema.sqlが存在すると起動時にそのSQLファイルを実行 13.3.2 Spring Data JPA13.3.3 MyBatis13.3.4 コネクションプールライブラリの変更 SpringBootではDatasourceを定義する必要はなく、自動で生成されます。コネクションプーリングの仕組みも自動で決まり、以下のライブラリのうちクラスパス上にあるものが利用されます。 TomcatJDBC HikariCP Commons DBCP Commons DBCP2 TODO: HikariCPが一番速いとのこと 13.4 SpringBootでSpring Security Spring Security用のプロジェクトも当然用意されています。 13.4.1 Basic認証 デフォルトで有効になるらしい デフォルトユーザーはuser パスワードはランダムに設定される 13.4.2 認証・認可のカスタマイズ SpringSecruityの認証・認可の設定はorg.springframework.security.config.annotation.web.configuration.WebSecrityConfigurerAdapterを用いて行う 13.5 Spring Bootで型安全なプロパティ設定application.propertiesから値を取得できる TODO: EnumによるConst管理とどっちがいいか メッセージのとり方確認 定数管理方法のベストプラクティス 13.5.1 @ConfigurationPropertiesを用いたプロパティの設定 プロパティを多用するSpringBootでは、安全にプロパティを扱うための仕組みとして、 @ConfigurationPropertiesアノテーションが用意されている TODO: プロパティ管理はこれが良さそう 13.5.2 Bean Validationに夜プロパティ値のチェック プロパティ値も、起動時にBindされる際、@NotEmptyなどで値の検証ができる 13.5.3 IDEによるプロパティの補完 @ConfigurationPropertiesを用いて定義したプロパティはIDEで補完が効く 補完させるためにプロパティのメタ情報を生成する必要がある spring-boot-configuration-processorの説明 SpringBootでプロパティを外部化する際は積極的に使用していくとよい 13.6 SpringBootAcruatorで運用機能強化 SpringBootでは開発を容易にする機能が提供されるだけでなく、アプリケーションの運用面を考慮した機能も提供されている これを提供するのがSpringBootActuator これだけでアプリケーションの状態を検査するためのエンドポイント（HTTP,JMX,SSH）が追加されたり、ヘルスチェック機能やメトリクス取得機能が有効になる TODO: 有効にして活用したい 13.6.1 HTTPエンドポイントの追加 HTTPエンドポイント /autoconfig /beans /env /configprops /dump /health /info /logfile /metrics /mappings /shutdown /trace /flyway /liquibase エンドポイントのコンテキストパスやポート番号などはプロパティを使用して変更できる 123456789101112management.context-path=/managemanagement.port=8081management.address=127.0.0.1 # localhostからのみアクセスを許可する# 個別のエンドポイントの有効無効を次のプロパティで設定endpoints.shutdown.enabled=trueendpoints.mapping.enabled=falseendpoints.trace.enabled=false# エンドポイントはHTTPだけでなくJMXでもアクセスできる これらの無効にもできるmanagement.port=-1 # HTTPエンドポイントを無効にするendpoints.jmx.enabled=false # JMXエンドポイントを無効にする 13.6.2 ヘルスチェック SpringBootActuatorはヘルスチェック機能を持っている 13.6.3 メトリクス SpringBootActuatorはメトリクス取得機能も備えている 次の２つのメトリクスがサポートされている gauge: 絶対値を記録する counter: 差分値を記録する TODO: メトリクスは収集して管理できる用にしておく 第14章 チュートリアル 会議室予約システムを作成していく手順を記載","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/categories/JAVA/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"}]},{"title":"","slug":"2020-04_Javaによる関数型プログラミングJava8ラムダ式とStream","date":"2020-04-26T04:00:25.602Z","updated":"2020-04-29T15:07:44.045Z","comments":true,"path":"uncategorized/2020-04_Javaによる関数型プログラミングJava8ラムダ式とStream/","link":"","permalink":"http://yoursite.com/uncategorized/2020-04_Javaによる関数型プログラミングJava8ラムダ式とStream/","excerpt":"","text":"Javaによる関数型プログラミングJava8ラムダ式とStream 著者：vankat subramaniam 訳：株式会社プログラミングシステム社 2014年10月 発行 オライリー本 まえがきはじめに対象者 Java5経験者 他の言語で関数型プログラミングを行っていて、Javaで実施したい人 すでにラムダ式に詳しい人は、チームメンバーのトレーニングに使用できる 本書の内容 最初から最後まで通して読むことをおすすめする（前の章で紹介した内容を後ろの章で使ってる） 使用するJavaのバージョン Java8が必要 サンプルコードの読み方 サンプル https://pragprog.com/titles/vsjava8/source_code オンラインリソース サンプルコード https://pragprog.com/book/vsjava8/functional-programming-in-java 1章 Hello、ラムダ式1.1 考え方を変える ラムダ式の紹介 1.2 関数型のコードによる大きな利益1.3 なぜ関数型で記述するのか1.4 革命ではなく、進化1.5 簡単にするためのほんの少しの砂糖1.6 まとめ 第一章はラムダ式の紹介をしていたので流し読み 2章 コレクションの使用2.1 リストをイテレート 今までの書き方から徐々にエレガントに進化させていく 1234567891011121314// 自殺点パターンと呼ぶ for(int i = 0; i &lt; friends.size(); i++) &#123; System.out.println(friends.get(i)); &#125;// 冗長でエラーが発生しやすいから// &lt;i だったかな？ &lt;=i だったかな？と悩む// 上記よりは儀式が少なくなっている// 特定のインデックスに対する操作がなければ、上記より優れているパターン for(String name : friends) &#123; System.out.println(name); &#125;// これら両方とも命令形のコードであり、モダンなJavaでは捨て去ることができる 関数型へ移行を進める理由 forループは本質的にシーケンシャルであり、並列化が極めて難しい このようなループはポリモーフィックではなく、命令した通りのことを実行される。コレクションに対して（ポリモーフィックな処理を行う）メソッドを呼び出すのではなく、forループに渡している 設計レベルで、コードは「伝えろ、聞くな」という原則を破っている。forループではイテレーションの詳細をライブラリに任せるのではなく、特定のイテレーション処理を実行するよう要求している Tell, Don’t Ask https://www.jabba.cloud/20150912232135/ 1234567891011System.out.println(\"//\" + \"START:INTERNAL_OUTPUT\");friends.forEach((final String name) -&gt; System.out.println(name));System.out.println(\"//\" + \"END:INTERNAL_OUTPUT\");friends.forEach((name) -&gt; System.out.println(name));// 型推論されたパラメータはfinalが保証されなくなる// 引数を変更しない習慣を開発者自身が身につける必要があるfriends.forEach(name -&gt; System.out.println(name));friends.forEach(System.out::println); 2.2 リストの変換2.2.1 ラムダ式を使う map()メソッドについて：連続した入力を連続した出力に変換します 123456789// こうじゃなくて final List&lt;String&gt; uppercaseNames = new ArrayList&lt;String&gt;(); friends.forEach(name -&gt; uppercaseNames.add(name.toUpperCase())); System.out.println(uppercaseNames);// こう書く friends.stream() .map(name -&gt; name.toUpperCase()) .forEach(name -&gt; System.out.print(name + \" \")); 2.2.2 メソッド参照を使用123friends.stream() .map(String::toUpperCase) .forEach(name -&gt; System.out.println(name)); メソッド参照の使い所 ラムダ式が非常に短い場合や、ラムダ式がインスタンスメソッドやstaticメソッドをシンプルで直接的に呼び出している場合における優れた代替手段 映画「Offiece Space」のTom Smykowskiのようなもの… 著者が例えている →個人的に「Offiece-spaceパターン」とよんでいる 2.3 要素の検索 fileter() コレクションから要素を抜き出すために用いる map()メソッドと同様にイテレーターを返すが、同じ要素数返すとは限らない 12345678910111213141516&#123; final List&lt;String&gt; startsWithN = new ArrayList&lt;String&gt;(); for(String name : friends) &#123; if(name.startsWith(\"N\")) &#123; startsWithN.add(name); &#125; &#125; System.out.println(String.format(\"Found %d names\", startsWithN.size()));&#125;&#123; final List&lt;String&gt; startsWithN = friends.stream() .filter(name -&gt; name.startsWith(\"N\")) .collect(Collectors.toList()); System.out.println(String.format(\"Found %d names\", startsWithN.size()));&#125; 2.4 ラムダ式の再利用 ラムダ式を定義しておいて重複をなくそうという説明 1234567891011121314final Predicate&lt;String&gt; startsWithN = name -&gt; name.startsWith(\"N\");final long countFriendsStartN = friends.stream() .filter(startsWithN) .count();final long countEditorsStartN = editors.stream() .filter(startsWithN) .count();final long countComradesStartN = comrades.stream() .filter(startsWithN) .count(); DRYの原則 2.5 静的スコープとクロージャ ラムダ式内は実質的にfinalな変数しか使えない Predicate&lt;T&gt;はT型を引数に取り、関数が行う検査の結果としてbooleanを返却。候補値の取捨選択を行う際に利用できる。 Function&lt;T,R&gt;はT型の引数を取り、R型の結果を返す関数。常にbooleanを返却するPredicate&lt;T&gt;より汎用的。 Optionalクラスは、結果が存在しない可能性がある場合に便利 123456789final Function&lt;String, Predicate&lt;String&gt;&gt; startsWithLetter = letter -&gt; name -&gt; name.startsWith(letter);final long countFriendsStartN = friends.stream() .filter(startsWithLetter.apply(\"N\")).count();final long countFriendsStartB = friends.stream() .filter(startsWithLetter.apply(\"B\")).count(); MEMO: Functionで囲うメリットがいまいち理解できていない（2020-04-26 14:52:51） 2.6 要素を 1つ選択 Null初期化は、Nullであることを確認する作業が必要になって来る これを忘れるとNullpointerExcepiton 12345678910// エレガントな例 public static void pickName( final List&lt;String&gt; names, final String startingLetter) &#123; final Optional&lt;String&gt; foundName = names.stream() .filter(name -&gt;name.startsWith(startingLetter)) .findFirst(); System.out.println(String.format(\"A name starting with %s: %s\", startingLetter, foundName.orElse(\"No name found\"))); &#125; OptionalはNull脱臭剤 2.7 コレクションを単一の値に集約（reduce） 本節では、要素の比較や計算状態をコレクションに渡って持ち越して使用する方法を学ぶ 123456789101112131415161718192021222324System.out.println(\"//\" + \"START:SUM_OUTPUT\"); System.out.println(\"Total number of characters in all names: \" + friends.stream() .mapToInt(name -&gt; name.length()) .sum()); &#125;System.out.println(\"//\" + \"END:SUM_OUTPUT\");System.out.println(\"//\" + \"END:AVERAGE_OUTPUT\");System.out.println(\"//\" + \"START:REDUCE_OUTPUT\"); final Optional&lt;String&gt; aLongName = friends.stream() .reduce((name1, name2) -&gt; name1.length() &gt;= name2.length() ? name1 : name2); aLongName.ifPresent(name -&gt; System.out.println(String.format(\"A longest name: %s\", name)));System.out.println(\"//\" + \"END:REDUCE_OUTPUT\"); final String steveOrLonger = friends.stream() .reduce(\"Steve\", (name1, name2) -&gt; name1.length() &gt;= name2.length() ? name1 : name2); System.out.println(steveOrLonger); 2.8 要素の結合 StringJoinerの説明 123456System.out.println(\"//\" + \"START:MAP_JOIN_OUTPUT\"); System.out.println( friends.stream() .map(String::toUpperCase) .collect(joining(\", \")));System.out.println(\"//\" + \"END:MAP_JOIN_OUTPUT\"); 2.9 まとめ コレクションはプログラムにおいてはありふれたもので、 ラムダ式によりJavaにおけるコレクションの利用は従来よりも遥かに簡単で単純になりました 記述するコード量が減少し、保守性が高くなる 3章 文字列、コンパレータ、フィルタ ラムダ式とメソッド参照を使用してSringをいてレートし、Comparatorを実装し、ディレクトリのファイルリストを取得し、 そしてファイルやディレクトリを監視します 3.1 文字列のイテレーション123456789101112131415161718192021222324252627282930313233343536System.out.println(\"//\" + \"START:ITERATE_OUTPUT\");final String str = \"w00t\";str.chars() .forEach(ch -&gt; System.out.println(ch));System.out.println(\"//\" + \"END:ITERATE_OUTPUT\");str.chars() .forEach(System.out::println);System.out.println(\"//\" + \"START:FIX_OUTPUT\");str.chars() .forEach(IterateString::printChar);System.out.println(\"//\" + \"END:FIX_OUTPUT\"); str.chars() .mapToObj(ch -&gt; Character.valueOf((char)ch)) .forEach(System.out::println);System.out.println(\"//\" + \"START:FILTER_OUTPUT\");str.chars() .filter(ch -&gt; Character.isDigit(ch)) .forEach(ch -&gt; printChar(ch));System.out.println(\"\");System.out.println(\"//\" + \"END:FILTER_OUTPUT\");str.chars() .filter(ch -&gt; Character.isDigit(ch));str.chars() .filter(Character::isDigit);str.chars() .filter(Character::isDigit) .forEach(IterateString::printChar); インスタンスメソッドのメソッド参照（String::toUppercase）と、staticメソッドのメソッド参照（Character::isDigit）は構造的に同じように見えるが異なる インスタンスメソッド： 引数.toUppercase(); staticメソッド： Character.isDigit(引数); インスタンスメソッドとstaticメソッドの定義が衝突すると、 どちらを使用していいかコンパイラが判断できなくなりコンパイルエラーとなる →この場合はラムダ式を使う！ ラムダ式とメソッド参照を自由自在に切り替えられるようになる 3.2 Comparatorインタフェースを実装 Listのsort()メソッドだと戻り値がvoidなので、リスト本体が変更されてしまう コピーを取得した上で、変更する必要があったが、面倒 代わりにStreamの力を借りて処理する方法を考える 123people.sorted((person1,person2) -&gt; person1.ageDifference(person2)).collect(toList());// ↓改善people.stream().sorted(Person::ageDifference).collect(toList()); 逆順にしたい場合 123people.stream().sorted((person1, person2) -&gt; person2.ageDifference(person1)).collect(toList());// パラメータの順番が引数受け渡しの規約に従っていないため、メソッド参照を使うようにリファクタリングすることはできません。 事前にComparatorを定義しておいて、使用することで簡潔に記載できる 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 public static void main(String[] args) &#123; final List&lt;Person&gt; people = Arrays.asList( new Person(\"John\", 20), new Person(\"Sara\", 21), new Person(\"Jane\", 21), new Person(\"Greg\", 35));&#123; System.out.println(\"//\" + \"START:AGE_ASCEND_OUTPUT\"); List&lt;Person&gt; ascendingAge = people.stream() .sorted((person1, person2) -&gt; person1.ageDifference(person2)) .collect(toList()); printPeople(\"Sorted in ascending order by age: \", ascendingAge); System.out.println(\"//\" + \"END:AGE_ASCEND_OUTPUT\");&#125;&#123; // メソッド参照（Method Reference） System.out.println(\"//\" + \"START:AGE_ASCEND_MR_OUTPUT\"); List&lt;Person&gt; ascendingAge = people.stream() .sorted(Person::ageDifference) .collect(toList()); printPeople(\"Sorted in ascending order by age: \", ascendingAge); System.out.println(\"//\" + \"END:AGE_ASCEND_MR_OUTPUT\");&#125;&#123; System.out.println(\"//\" + \"START:AGE_DESCEND_OUTPUT\"); printPeople(\"Sorted in descending order by age: \", people.stream() .sorted((person1, person2) -&gt; person2.ageDifference(person1)) .collect(toList())); System.out.println(\"//\" + \"END:AGE_DESCEND_OUTPUT\"); System.out.println(\"//\" + \"START:REVERSE_ORDER_OUTPUT\"); Comparator&lt;Person&gt; compareAscending = (person1, person2) -&gt; person1.ageDifference(person2); // reversed()を使うことで降順の関数を事前に用意できる Comparator&lt;Person&gt; compareDescending = compareAscending.reversed(); printPeople(\"Sorted in ascending order by age: \", people.stream() .sorted(compareAscending) .collect(toList()) ); printPeople(\"Sorted in descending order by age: \", people.stream() .sorted(compareDescending) .collect(toList()) ); System.out.println(\"//\" + \"END:REVERSE_ORDER_OUTPUT\"); // 名前の昇順に並び替え System.out.println(\"//\" + \"START:NAME_ASCEND_OUTPUT\"); printPeople(\"Sorted in ascending order by name: \", people.stream() .sorted((person1, person2) -&gt; person1.getName().compareTo(person2.getName())) .collect(toList())); System.out.println(\"//\" + \"END:NAME_ASCEND_OUTPUT\");&#125;&#123; // min()メソッドはOptionalを返す！ System.out.println(\"//\" + \"START:YOUNGEST_OUTPUT\"); people.stream() .min(Person::ageDifference) .ifPresent(youngest -&gt; System.out.println(\"Youngest: \" + youngest));System.out.println(\"//\" + \"END:YOUNGEST_OUTPUT\");&#125;&#123; System.out.println(\"//\" + \"START:ELDEST_OUTPUT\"); people.stream() .max(Person::ageDifference) .ifPresent(eldest -&gt; System.out.println(\"Eldest: \" + eldest)); System.out.println(\"//\" + \"END:ELDEST_OUTPUT\");&#125; 3.3 複数のプロパティによる流暢な比較12345678910111213141516171819202122232425262728293031323334&#123; // 名前のアルファベット順にするために以下の関数を用意した // 従来の内部クラス構文と比較すると非常に簡潔 people.stream() .sorted((person1, person2) -&gt; person1.getName().compareTo(person2.getName())); printPeople(\"Sorted in ascending order by name: \", people.stream() .sorted(comparing((Person person) -&gt; person.getName())) .collect(toList())); // Comparatorインターフェースのコンビニエンス関数を使用することで、より自由にコードの目的を表現できる // Comparaotrインターフェースのcomparing()メソッドを静的にインポートしました。comparing()メソッドは与えられた // ラムダ式のロジックを使用してComparatorを生成する！ // つまり、関数（Function）を引数に取り、関数（Comparator）を返す高階関数 final Function&lt;Person, String&gt; byName = person -&gt; person.getName(); people.stream() .sorted(comparing(byName));&#125;&#123; System.out.println(\"//\" + \"START:SORT_NAME_AND_AGE_OUTPUT\"); final Function&lt;Person, Integer&gt; byAge = person -&gt; person.getAge(); final Function&lt;Person, String&gt; byTheirName = person -&gt; person.getName(); printPeople(\"Sorted in ascending order by age and name: \", people.stream() .sorted(comparing(byAge).thenComparing(byTheirName)) .collect(toList())); System.out.println(\"//\" + \"END:SORT_NAME_AND_AGE_OUTPUT\");&#125; このように、Comparatorの実装をラムダ式やJDKの新たなユーティリティクラスを使用して簡単に合成できる MEMO: 少し納得してないので再度確認 3.4 collectメソッドとCollectorsクラスの使用 これまでに、Streamの要素をArrayListに変換する例でcollect()メソッドを数回使用している このメソッドは、あるコレクションを可変コレクションなど他のデータ型へ変換する際に便利な集約処理を行います collect()関数はCollectorsクラスのユーティリティメソッドと組み合わせるととても便利 1234567891011121314151617181920212223242526272829303132333435// 20歳以上の人を抽出してリストを取得する&#123; // 従来の書き方 System.out.println(\"//\" + \"START:MUTABLE_OUTPUT\"); List&lt;Person&gt; olderThan20 = new ArrayList&lt;&gt;(); people.stream() .filter(person -&gt; person.getAge() &gt; 20) .forEach(person -&gt; olderThan20.add(person)); System.out.println(\"People older than 20: \" + olderThan20); System.out.println(\"//\" + \"END:MUTABLE_OUTPUT\"); // 問題点： // ターゲットとするコレクションに要素を１つずつ追加する保s理はとても低レベルなもので、宣言型ではなく命令形のコード // 並列に実行させる場合にはスレッドセーフ問題を適切に処理しなければならない // 可変性を持つコードを並列化するのは難しいものです。&#125;// この問題はcollect()を使うことで緩和できる// collect()メソッドの以下の３つについて知っておく// サプライヤ ：結果を収めるコンテナの精製方法（例えば、ArrayList::new）// アキュムレータ：結果コンテナに単一の要素を追加する方法（例えばArrayList::add）// コンバイナ ：結果コンテナを他のコンテナと結合する方法（例えばArrayList::addAll）&#123; // 便利な書き方！ System.out.println(\"//\" + \"START:COLLECT_OUTPUT\"); List&lt;Person&gt; olderThan20 = people.stream() .filter(person -&gt; person.getAge() &gt; 20) .collect(ArrayList::new, ArrayList::add, ArrayList::addAll); System.out.println(\"People older than 20: \" + olderThan20); System.out.println(\"//\" + \"END:COLLECT_OUTPUT\");&#125;// メリット：// より明確で意図を持ったプログラミングを行っている→ArrayListに処理結果を集めることがこのコードの目的// コード内で状態変更を行っていないため、イテレーションを簡単に並列化できる 次は基本のcollect()メソッドよりも簡潔で便利な、オーバーロードされたcollect()メソッドを見ていく このメソッドはCollectorを引数に取ります Collectorはcollect()メソッドに設定された３つの異なるパラメータをカプセル化した、より簡単で再利用可能なインターフェース 様々なCollectorの実装を提供するCollectorsクラスにtoList()というコンビニエンスメソッドがある このメソッドはArrayListに要素を蓄積するメソッドで、Collectorインターフェースの実装 123456789&#123; System.out.println(\"//\" + \"START:COLLECT_TO_LIST_OUTPUT\"); List&lt;Person&gt; olderThan20 = people.stream() .filter(person -&gt; person.getAge() &gt; 20) .collect(Collectors.toList()); System.out.println(\"People older than 20: \" + olderThan20); System.out.println(\"//\" + \"END:COLLECT_TO_LIST_OUTPUT\");&#125; 他にも色々集計できるよっていう説明! https://docs.oracle.com/javase/jp/8/docs/api/java/util/stream/Collectors.html 12345678910111213141516171819202122232425262728293031&#123; System.out.println(\"//\" + \"START:GROUP_BY_OUTPUT\"); Map&lt;Integer, List&lt;Person&gt;&gt; peopleByAge = people.stream() .collect(Collectors.groupingBy(Person::getAge)); System.out.println(\"Grouped by age: \" + peopleByAge); System.out.println(\"//\" + \"END:GROUP_BY_OUTPUT\");&#125;&#123; System.out.println(\"//\" + \"START:GROUP_BY_AGE_NAME_OUTPUT\"); Map&lt;Integer, List&lt;String&gt;&gt; nameOfPeopleByAge = people.stream() .collect( groupingBy(Person::getAge, mapping(Person::getName, toList()))); System.out.println(\"People grouped by age: \" + nameOfPeopleByAge); System.out.println(\"//\" + \"END:GROUP_BY_AGE_NAME_OUTPUT\");&#125;&#123; System.out.println(\"//\" + \"START:OLDEST_IN_EACH_LETTER_OUTPUT\"); Comparator&lt;Person&gt; byAge = Comparator.comparing(Person::getAge); Map&lt;Character, Optional&lt;Person&gt;&gt; oldestPersonOfEachLetter = people.stream() .collect(groupingBy(person -&gt; person.getName().charAt(0), reducing(BinaryOperator.maxBy(byAge)))); System.out.println(\"Oldest person of each letter:\"); System.out.println(oldestPersonOfEachLetter); System.out.println(\"//\" + \"END:OLDEST_IN_EACH_LETTER_OUTPUT\");&#125; MEMO: 集計関数を実際に色々使ってみる！！ 3.5 ディレクトリの全ファイルをリスト Fileクラスのlist()メソッドを使うと、ディレクトリにある全ファイル名を簡単にリスト化できる ファイル名だけでなくすべてのファイルを取得する場合はlistFiles()メソッドが使える ファイルを取得したあとの処理が大変 ここでは、従来のくどい外部イテレータを使用するのではなく、エレガントな関数型スタイルの機能を使ってリストをイテレートしていく 12345678// 以下の２つとも古いjavaより格段にシンプルFiles.list(Paths.get(\".\")) .forEach(System.out::println);&#125;Files.list(Paths.get(\".\")) .filter(Files::isDirectory) // filterはPredicateを期待する .forEach(System.out::println);&#125; 3.6 ディレクトリの特定のファイルだけをリスト 特定のファイル名取得のためにオーバーロードされたFileクラスのlist()メソッドを提供してきました このlist()メソッドはFilenameFilterインターフェースを引数に取ります 123456final String[] files = new File(\"fpij\").list(new java.io.FilenameFilter() &#123; public boolean accept(final File dir, final String name) &#123; return name.endsWith(\".java\"); &#125; &#125;); これをラムダ式に置き換える！ 1234 Files.newDirectoryStream( Paths.get(\"fpij\"), path -&gt; path.toString().endsWith(\".java\")) .forEach(System.out::println);&#125; 3.7 flatMapで直下のサブディレクトリをリスト 与えられたディレクトリ直下のサブディレクトリを探索する方法を解説する 最初に原始的な方法を説明し、次により便利なflatMap()メソッド（Streamクラス）を使用する 123456789101112131415161718192021222324public static void listTheHardWay() &#123; List&lt;File&gt; files = new ArrayList&lt;&gt;(); File[] filesInCurrentDir = new File(\".\").listFiles(); for(File file : filesInCurrentDir) &#123; File[] filesInSubDir = file.listFiles(); if(filesInSubDir != null) &#123; files.addAll(Arrays.asList(filesInSubDir)); &#125; else &#123; files.add(file); &#125; &#125; System.out.println(\"Count: \" + files.size());&#125;public static void betterWay() &#123; List&lt;File&gt; files = Stream.of(new File(\".\").listFiles()) .flatMap(file -&gt; file.listFiles() == null ? Stream.of(file) : Stream.of(file.listFiles())) .collect(toList()); System.out.println(\"Count: \" + files.size());&#125; MEMO: モナド合成という言葉が出てきたが、いまいち意味がわからない 3.8 ファイルの変更を監視 ファイルが生成・変更・削除される際のアラートも簡単に実現できる Java7で追加されたWatchServiceの機能を紹介 12345678910111213141516171819202122232425262728293031public static void main(String[] args) throws Exception &#123; new Thread(() -&gt; watchFileChange()).start(); final File file = new File(\"sample.txt\"); file.createNewFile(); Thread.sleep(5000); file.setLastModified(System.currentTimeMillis());&#125;public static void watchFileChange() &#123; try &#123; final Path path = Paths.get(\".\"); final WatchService watchService = path.getFileSystem() .newWatchService(); path.register(watchService, StandardWatchEventKinds.ENTRY_MODIFY); System.out.println(\"Report any file changed within next 1 minute...\"); final WatchKey watchKey = watchService.poll(1, TimeUnit.MINUTES); if(watchKey != null) &#123; watchKey.pollEvents() .stream() .forEach(event -&gt; System.out.println(event.context())); &#125; &#125; catch(InterruptedException | IOException ex) &#123; System.out.println(ex); &#125;&#125; 3.9 まとめ 文字列操作やファイル処理、カスタムコンパレータの生成などの定型タスクはラムダ式とメソッド参照によって非常に楽に、簡潔になりました。 4章 ラムダ式で設計する 本章では、ラムダ式が巧妙なデザインアイデアに生命を与える これまではオブジェクトを使用していた箇所を軽量関数で代用できる 4.1 ラムダ式を使った関心の分離 コードの再利用のためにクラスを生成することは良い心がけですが、それが常に正しいとは限らない クラスの代わりに高階関数を使うことで、クラス階層を必要とせずに同じことが達成できる 4.1.1 デザイン問題の探求123456789101112131415161718// JavaBeanpublic class Asset &#123; public enum AssetType &#123; BOND, STOCK &#125;; private final AssetType type; private final int value; public Asset(final AssetType assetType, final int assetValue) &#123; type = assetType; value = assetValue; &#125; public AssetType getType() &#123; return type; &#125; public int getValue() &#123; return value; &#125;&#125;// Utilクラス public static int totalAssetValues(final List&lt;Asset&gt; assets) &#123; return assets.stream() .mapToInt(Asset::getValue) .sum(); &#125; ラムダ式を使って、totalAssetValues()メソッドを書き、流暢なイテレータと好むべき不変性を使いました しかし今はメソッド自身の設計に目を向けましょう このメソッドでは どのようにイテレーションを行うか 何を合計するか どのように合計するか といった３つの問題が絡み合っている 4.1.2 問題でがんじがらめ 資産のうち、債券（bond）だけを合計したい場合を考える 12345678910111213public static int totalBondValues(final List&lt;Asset&gt; assets) &#123; return assets.stream() .mapToInt(asset -&gt; asset.getType() == AssetType.BOND ? asset.getValue() : 0) .sum();&#125;public static int totalStockValues(final List&lt;Asset&gt; assets) &#123; return assets.stream() .mapToInt(asset -&gt; asset.getType() == AssetType.STOCK ? asset.getValue() : 0) .sum();&#125; こんなふうにコピペで増やしていって良いでしょうか？ DRYの原則に従ってもう少しましな設計をしましょう 4.1.3 主要な関心の分離 イテレーションと合計を求める方法は同じですが、「何を」合計するかが異なります この「何を合計するか」部分はメソッドから切り離す良い候補 12345678910111213141516171819202122232425public static int totalAssetValues(final List&lt;Asset&gt; assets, final Predicate&lt;Asset&gt; assetSelector) &#123; return assets.stream() .filter(assetSelector) .mapToInt(Asset::getValue) .sum();&#125;public static void main(final String[] args) &#123; List&lt;Asset&gt; assets = Arrays.asList( new Asset(Asset.AssetType.BOND, 1000), new Asset(Asset.AssetType.BOND, 2000), new Asset(Asset.AssetType.STOCK, 3000), new Asset(Asset.AssetType.STOCK, 4000) ); System.out.println(\"Total of all assets: \" + totalAssetValues(assets, asset -&gt; true)); System.out.println(\"Total of bonds: \" + totalAssetValues(assets, asset -&gt; asset.getType() == AssetType.BOND)); System.out.println(\"Total of stocks: \" + totalAssetValues(assets, asset -&gt; asset.getType() == AssetType.STOCK));&#125; 個々まではメソッドレベルでの関心の分離を行いましたが、次はクラスレベルで応用します 4.2 ラムダ式を使った委譲4.3 ラムダ式を使ったデコレーション Cameraクラスのフィルター設定 4.4 defaultメソッドを覗く interfaceがdefaultメソッドを持てる 実装の衝突を防ぐためにルールが存在する 実際にinterfaceにdefaultメソッドが記述できるメリットがあまり浮かばないような気がする 4.5 ラムダ式を使った流暢なインタフェース MEMO: ここは参考になる実装だと感じた 用途例：メーラの設定、データベース設定パラメータの設定、インスタンスの連続した状態を管理下におきつつ構築する必要のある場合 ローンパターンと言うらしい 123456789101112131415161718192021private FluentMailer() &#123;&#125;public FluentMailer from(final String address) &#123; /*... */; return this; &#125;public FluentMailer to(final String address) &#123; /*... */; return this; &#125;public FluentMailer subject(final String line) &#123; /*... */; return this; &#125;public FluentMailer body(final String message) &#123; /*... */; return this; &#125;public static void send(final Consumer&lt;FluentMailer&gt; block) &#123; final FluentMailer mailer = new FluentMailer(); block.accept(mailer); System.out.println(\"sending...\");&#125;//...public static void main(final String[] args) &#123; FluentMailer.send(mailer -&gt; mailer.from(\"build@agiledeveloper.com\") .to(\"venkats@agiledeveloper.com\") .subject(\"build notification\") .body(\"...much better...\"));&#125; 4.6 例外処理 ラムダ式の例外処理について MEMO: 再読する必要あり 4.7 まとめ5章 外部リソースを扱う Java仮想マシン（JVM）は、自動的にガベージコレクション（GC）を行っているものだと信じているかもしれません。 内部リソースだけを扱っている場合はJVMにGCを任せられることは事実 しかし、 データベース接続 ファイルやソケット ネイティブリソースといった外部リソースを使用する場合は GCは開発者の責任範囲 本章では、ラムダ式を使って、execute around method(EAM)を実装します。 連続操作をより効率的に制御できます。そしてこのパターンを使ってロック管理と書き込み例外テストを行います 5.1 リソースの解放 finalize()なんて使ったらGCされずに貯まるでしょ？ close()メソッドで閉じる？→閉じ忘れたらどうするの？→エラー発生したらclose()呼ばれないままになるよね？ try-with-resources構文使う？Java7から追加された便利な構文だけど、開発者が下記忘れたら元も子もない、AutoClosableの実装もしておかないと行けないでしょ？ →ラムダ式で解決しましょう！という説明 5.2 ラムダ式でリソース解放 ラムダ式で設計して、開発者にこれを使うように共有すれば問題なし 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class FileWriterEAM &#123; private final FileWriter writer; private FileWriterEAM(final String fileName) throws IOException &#123; writer = new FileWriter(fileName); &#125; private void close() throws IOException &#123; System.out.println(\"close called automatically...\"); writer.close(); &#125; public void writeStuff(final String message) throws IOException &#123; writer.write(message); &#125; //... public static void use(final String fileName, final UseInstance&lt;FileWriterEAM, IOException&gt; block) throws IOException &#123; final FileWriterEAM writerEAM = new FileWriterEAM(fileName); try &#123; block.accept(writerEAM); &#125; finally &#123; writerEAM.close(); &#125; &#125; public static void main(final String[] args) throws IOException &#123; System.out.println(\"//\" + \"START:EAM_USE_OUTPUT\"); FileWriterEAM.use(\"eam.txt\", writerEAM -&gt; writerEAM.writeStuff(\"sweet\")); System.out.println(\"//\" + \"END:EAM_USE_OUTPUT\"); FileWriterEAM.use(\"eam2.txt\", writerEAM -&gt; &#123; writerEAM.writeStuff(\"how\"); writerEAM.writeStuff(\"sweet\"); &#125;); &#125;&#125;// interface// @FunctionalInterfaceは関数型インターフェースであることの宣言// 例外を考慮する必要がなければ、Consumerインターフェースを使えばよかったが、ラムダ式は、合成されるabstratメソッドのシグネチャの一部として定義されたチェック例外を投げることができるため実装@FunctionalInterfacepublic interface UseInstance&lt;T, X extends Throwable&gt; &#123; void accept(T instance) throws X;&#125; MEMO: execute around methodパターンの構造らしい この仕組はファイル読み込みを行う際に見習うべき そもそも標準のjavaでファイル読み込み時に自動的に開放するような書き方ができないか確認すべき 実際には読み込みファイルと書き込みファイル両方を開いて処理を行う場合が多いのでは？ そのような場合どうやって書いていく？ Transactionという形でUTIL作成して、複数ファイルをオープンして操作していけば行ける？ 5.3 ロックの管理 コンカレントなJavaアプリケーションにおいてロックは重要な役割を果たす ここでは、ラムダ式を使って細かなロックの制御を行い、重要なセクションの適切なロックの単体テストの可能性を開く 1234567891011public class Locker &#123; public static void runLocked(Lock lock, Runnable block) &#123; lock.lock(); try &#123; block.run(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; MEMO: Lockの使い方確認 このロジックレベルでロックする使い所がいまいちピンとこない 使い所があれば、synchronizedを使用するより、こちらの方が単体テストもしやすいメリットがあるみたい 5.4 簡潔な例外テストの生成 Junitフレームワークなどでアノテーションを使用した、例外テストを実施する場合は、 ラムダ式で書き換えた方が良いという例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class RodCutter &#123; private boolean mustFail; public RodCutter(final boolean fail) &#123; mustFail = fail; &#125; public void setPrices(final List&lt;Integer&gt; prices) &#123; //... if(mustFail) throw new RodCutterException(); &#125; public int maxProfit(final int length) &#123; if (length == 0) throw new RodCutterException(); return 0; &#125;&#125;public class RodCutterTest &#123; private RodCutter rodCutter; private List&lt;Integer&gt; prices; protected RodCutter createCutter() &#123; return new RodCutter(false); &#125; @Before public void initialize() &#123; rodCutter = createCutter(); prices = Arrays.asList(1, 1, 2, 2, 3, 4, 5); &#125; @Test public void VerboseExceptionTest() &#123; rodCutter.setPrices(prices); try &#123; rodCutter.maxProfit(0); fail(\"Expected exception for zero length\"); &#125; catch(RodCutterException ex) &#123; assertTrue(\"expected\", true); &#125; &#125; @Test(expected = RodCutterException.class) public void TerseExceptionTest() &#123; rodCutter.setPrices(prices); rodCutter.maxProfit(0); &#125; // Lamda式を利用したテスト方法 @Test public void ConciseExceptionTest() &#123; rodCutter.setPrices(prices); assertThrows(RodCutterException.class, () -&gt; rodCutter.maxProfit(0)); &#125; public static void main(String[] args) &#123; junit.textui.TestRunner.run(new JUnit4TestAdapter(RodCutterTest.class)); &#125;&#125;// HELPERの実装public class TestHelper &#123; public static &lt;X extends Throwable&gt; Throwable assertThrows( final Class&lt;X&gt; exceptionClass, final Runnable block) &#123; try &#123; block.run(); &#125; catch(Throwable ex) &#123; if(exceptionClass.isInstance(ex)) return ex; &#125; fail(\"Failed to throw expected exception \"); return null; &#125;&#125; MEMO: 現在のフレームワークでラムダ式を利用したメソッドが提供されていないかどうか確認する 5.5 まとめ アプリケーションが外部リソースを使用する場合、全面的に自動ガベージコレクションに頼ることはできません。 execute around methodパターンは実行フローのきめ細かい制御や外部リソースの開放に役立つ オブジェクト生存期間の制御 ロック管理 簡潔な例外テストの記述 6章 「遅延させる」ということ6.1 初期化の遅延 オブジェクト内部に重いリソースが存在する場合、その生成を後回しにできれば有益 オブジェクトの一部の生成をアトマwしにするという設計上の決断は、オブジェクトを使う開発者にとって重荷になるべきではなく、シームレスであるべき 123456789101112131415161718192021222324252627282930313233public class Holder &#123; private Supplier&lt;Heavy&gt; heavy = () -&gt; createAndCacheHeavy(); public Holder() &#123; System.out.println(\"Holder created\"); &#125; public Heavy getHeavy() &#123; return heavy.get(); &#125; //... private synchronized Heavy createAndCacheHeavy() &#123; class HeavyFactory implements Supplier&lt;Heavy&gt; &#123; private final Heavy heavyInstance = new Heavy(); public Heavy get() &#123; return heavyInstance; &#125; &#125; if(!HeavyFactory.class.isInstance(heavy)) &#123; heavy = new HeavyFactory(); &#125; return heavy.get(); &#125; public static void main(final String[] args) &#123; final Holder holder = new Holder(); System.out.println(\"deferring heavy creation...\"); System.out.println(holder.getHeavy()); System.out.println(holder.getHeavy()); &#125;&#125; virtual poroxyパターン オブジェクトの生成に１レベル挟む次はラムダ式で実現する 6.2 遅延評価 短絡評価： fn1() || fn2() メソッドの引数の場合は渡されたものすべてが評価される すべての引数を使用しない場合はその評価に費やした時間とリソースが無駄になる ここでもラムダ式を使って任意の引数の評価を遅らせることができる メソッド実行時にある引数が使用されない可能性があることがわかっていれば、いくつかの引数、またはすべての引数を遅延実行するようにメソッドのインターフェースを変更できる 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Evaluation &#123; public static boolean evaluate(final int value) &#123; System.out.println(\"evaluating ...\" + value); simulateTimeConsumingOp(2000); return value &gt; 100; &#125; //... public static void simulateTimeConsumingOp(final int millseconds) &#123; try &#123; Thread.sleep(2000); &#125; catch(Exception ex) &#123; throw new RuntimeException(ex); &#125; &#125; public static void eagerEvaluator( final boolean input1, final boolean input2) &#123; System.out.println(\"eagerEvaluator called...\"); System.out.println(\"accept?: \" + (input1 &amp;&amp; input2)); &#125; /** * 遅延評価のためのメソッド * ラムダ式を引数に取り、実行自体はこのメソッドの中で行う */ public static void lazyEvaluator( final Supplier&lt;Boolean&gt; input1, final Supplier&lt;Boolean&gt; input2) &#123; System.out.println(\"lazyEvaluator called...\"); System.out.println(\"accept?: \" + (input1.get() &amp;&amp; input2.get())); &#125; public static void main(final String[] args) &#123; System.out.println(\"//\" + \"START:EAGER_OUTPUT\"); eagerEvaluator(evaluate(1), evaluate(2)); System.out.println(\"//\" + \"END:EAGER_OUTPUT\"); // ４秒かかっていた処理が２秒でfalseを返却するようになる System.out.println(\"//\" + \"START:LAZY_OUTPUT\"); lazyEvaluator(() -&gt; evaluate(1), () -&gt; evaluate(2)); System.out.println(\"//\" + \"END:LAZY_OUTPUT\"); &#125;&#125; デメリット ラムダ式をわざわざ書かないと行けないので面倒（場合によってはメソッド参照を利用できる） コード量は多くなる MEMO: フレームワークで遅延処理を行うためにはどのようにするべきか 6.3 Streamの遅延処理を活用 Streamの遅延評価について説明 6.3.1 中間処理と終端処理 Streamには２種類のメソッドがある 中間処理 終端処理 Streamの遅さは複数の中間処理をチェーンし、最後に終端処理を行うことで実現している 12345678910111213141516List&lt;String&gt; names = Arrays.asList(\"Brad\", \"Kate\", \"Kim\", \"Jack\", \"Joe\", \"Mike\", \"Susan\", \"George\", \"Robert\", \"Julia\", \"Parker\", \"Benson\");System.out.println(\"//\" + \"START:CHAIN_OUTPUT\");&#123;// ここの処理はコレクションの変換に多くの作業を費やしている働き者に見えますが、実は見かけによらず怠け者です。final String firstNameWith3Letters = names.stream() .filter(name -&gt; length(name) == 3) .map(name -&gt; toUpper(name)) .findFirst() .get();System.out.println(firstNameWith3Letters);&#125;System.out.println(\"//\" + \"END:CHAIN_OUTPUT\"); 本当に必要な処理以外は実施していないらしい その詳細を次で！述べる 中間処理、終端処理まで考慮された上で、初めて処理が実行される filter 12処理 map 2処理 findFirst 1処理 ではなく！ filter 3 処理！！ map 1処理 findFirst 1処理 という形で評価される JDKが裏で結合（fusing）処理を行うことで実現している データの通り道は１本ということ 要素の抽出、マッピング、選択が１度に行われる 6.4 無限の「遅い」コレクションを生成 MEMO: スキップ 6.5 まとめ7章 再帰の最適化 再帰は魅力的で強力な問題解決方法 再帰はとても表現力に富んでいます 大きな問題の再帰処理を可能とする末尾呼び出し最適化（tail-call optimization TCO）を説明 7.1 末尾呼び出し最適化を使う 再帰を使う上で最も高いハードルは、巨大な入力値によるスタックオーバーフローのリスク しかし、末尾呼び出し最適化（TCO）という優れたテクニックがこの心配のタネを取り除く 末尾呼び出しとは 最後の処理が自身の呼び出しとなるような再帰呼び出しのことを言います JavaはTCOをコンパイラレベルで直接サポートしていませんが、ラムダ式を使って数行で実装できる このソリューションはトランポリンとも呼ばれrます。 12345678// 通常の実装 public static int factorialRec(final int number) &#123; if(number == 1) return number; else return number * factorialRec(number - 1); &#125; // 大きい数を渡すとStackOverflowErrorが発生 この再帰関数は大きな入力値を扱えず、落ちてしまう 再帰が強力で表現力豊かであっても使えません。 この問題は再帰そのものにあるわけではない 再帰の完了を待つ間、部分的な計算結果をすべて保存しているためです。 スタックに積み上げずに再帰を行う方法が必要 7.1.2 末尾再帰に変換する 遅延評価させるために TailCall関数型インターフェース TailCallsクラスを設計する 1234567public static TailCall&lt;Integer&gt; factorialTailRec( final int factorial, final int number) &#123; if (number == 1) return done(factorial); else return call(() -&gt; factorialTailRec(factorial * number, number - 1));&#125; MEMO: TCOについて理解できていない… 再帰処理設計が必要になったら読み返す 7.2 メモ化でスピードアップ7.3 まとめ8章 ラムダ式で合成 Java8には、オブジェクト志向アプローチと関数型スタイルという２つの強力なツールがある 組み合わせて使っていこう！ 本章では、 関数合成を詳しく説明し、実践的なMapReduceパターンを例として実装 MapReduceパターンでは、独立した計算処理を分散し、それらの処理結果を集約して最終的な結果を計算します 最後はJDKの力を借りて、この計算処理を簡単に並列化します。 8.1 関数合成の利用 オブジェクト指向＋関数型スタイル複合アプローチでは、状態が変化するのではなく、軽量なオブジェクトが別のオブジェクトに変換される 可変性がないことで、エラー発生の可能性を減らし、並列実行家より簡単 リストからStreamを作成し、オリジナルのリストは変更されず、新しくオブジェクトを生成するということが言いたいだけ 8.2 MapReduceの使用 MapReduceパターンは２つの操作がある コレクションの各要素で実行する操作 これらの実行結果を組み合わせて最終結果を導き出す このパターンでマルチコアプロセッサを有効活用可能であることから注目をされつつある Tickers.symbols.parallelStream()は裏側に隠れているスレッドプールで管理された複数のスレッドで、 map()やfilter()のようなメソッドを並列処理します。 stream()とparallelStream()のどちらを使用するかを決める際には、いくつかの問題を考えなければいけません 本当にラムダ式を同時に実行したいのか？ 対象コードは副作用や競合状態が発生しない、独立した動作を行える？ 実行順序に影響を与えることはないか？ map()やfilter()のように、計算を行って、その結果を次の処理に回すようなメソッドは並列化に向いている MEMO: 闇雲に並列化はしないほうがよい！！ 並列ストリームを選択すべきか？ ライブラリは簡単に並列化を行ってくれるが、並列化が常に正しい選択であるとは限らない データと、実行する計算内容によっては、並列計算はシーケンシャルな計算より遅くなることもあり得る 並列化実行処理のためのコストもかかる コレクションが小さいのであれば、シーケンシャル実行のほうが早くなるかも 速度を計測して実装していくべき 8.3 並列化への飛躍8.4 まとめ9章 すべてをまとめて 本書を通してJava8のラムダ式を紹介しました コレクションのイテレーションを行い 軽量でよりよい設計を実現し、コードを簡単に合成、そして並列化しました。 この最終章ではまとめとして、関数型スタイルのプログラミングを使って、最大の効果を上げるために 磨いておくべきことを説明し、関数型スタイルを採用して成功するための推奨事項を最後に取り上げる 9.1 関数型スタイルで成功するために実践すべきこと新機能のメリットを十分に活かし、簡潔で軽量なアプリケーションを生成するには、設計、コーディング、そして考え方まで変えなければいけません。 これまでのJavaを使ってきた命令形や、オブジェクト指向のパラダイムとは違うもの ここでは根本的に変えるべきアプリケーション開発手法や、その変更によって得られる利点について説明 9.1.1 宣言的により近く、命令型からより遠く 価格リストを与えられていて、その中から最大値を選ぶようにと依頼されたとしたときに、 命令型のfor文で最大値を探すのではなく、ラムダ式を使ってstream経由で取得する 9.1.2 普遍性の尊重 状態変更が可能な(mutable)変数はあまり上品とは言えません。 そしてそのような変数の共有は単なる害悪 開発者は変数の状態変更によって混乱させられてしまい、時には変更を見逃してしまいます。 したがって、変更可能な変数が多いほど、より多くのエラーが発生する可能性があるということ 正確な並列化が非常に難しくなるということもデメリット 関数型スタイルの導入がそれを簡単にしてくれる 純粋な関数型言語は値しか持っていません。つまり１回しか書き込みができない、初期化後は全く変更を受け付けない変数です。 しかしJavaはそのような言語とはことなり、不変性(immutability)を強制しないため、不変性を尊重する責任は開発者にある 9.1.3 副作用の削減 副作用を減らそう 所感：時間や状態などの外部要員によって関数の処理結果が異なることが無いように作成すること 9.1.4 文より式を優先 文：アクションを実行するが何も返さない 式：アクションを実行して結果を返す 文は何も返さないため、目的を遂行するためには副作用を起こしメモリを書き換える必要がある 一方式は、参照透明性を保つように設計できるため、これまでに述べたメリットを得られる 式を使うメリット 関数合成ができるということが挙げられる チェーンでコードを記述することで、文章を読むように簡単にコードを読めるようになる 9.1.5 高階関数を利用して設計 これまでは匿名内部クラスを単一メソッドのインターフェースに渡していたような場所で、 ラムダ式やメソッド参照を渡すことができる様になり、コードがより簡潔になります。 メーラーを関数で設計することでローンパターンを適用する例 Colorフィルターを関数で表現する例 関数を引数に渡してDRYな設計をしよう 9.2 パフォーマンスの問題 命令型のコードと比較してもパフォーマンスは劣らない メリット 直感的に見やすい 並列化も容易 関数型を採用しましょう MEMO: 処理時間の違いはむやみに信頼できるものではないのでやめましょうと書かれている… 9.3 関数型スタイルを採用 実際に使ってみて、試して、より良い設計を考えていこう！ 付録A 基本的な関数型インタフェース JDK8には様々な関数型インターフェースを持っている ここでは頻繁に出現する基本的なインターフェースをいくつか紹介 A.1 Consumer 入力を受け入れ、戻り値を返さない操作を表すインターフェース 有効活用するためには副作用を伴う必要がある 抽象メソッド accept() defaultメソッド andThen() 主な利用方法 forEach()メソッドの引数 特注なプリミティブ IntConsumer, LongConsumer, DoubleConsumerなど 1234567891011121314package java8sample;import java.util.function.Consumer;public class Java8Sample &#123; public static void main(String[] args) &#123; Consumer&lt;String&gt; hoge = string -&gt; System.out.println(\"hoge : \" + string); Consumer&lt;String&gt; fuga = string -&gt; System.out.println(\"fuga : \" + string); Consumer&lt;String&gt; piyo = hoge.andThen(fuga); piyo.accept(\"piyo\"); &#125;&#125; A.2 Supplier 新しいインスタンス、またはあらかじめ生成しておいたインスタンスを返すファクトリ。 抽象メソッド get() defaultメソッド なし 主な利用方法 遅延実行を行う無限Streamの生成 OptionalクラスのorElseGet()メソッドの引数 特殊なプリミティブ IntSupplier, LongSupplier, DoubleSupplierなど 12345678910package java8sample;import java.util.function.Supplier;public class Java8Sample &#123; public static void main(String[] args) &#123; Supplier&lt;String&gt; supplier = () -&gt; \"hoge\"; System.out.println(supplier.get()); &#125;&#125; 遅延初期化で少し出てきた程度 A.3 Predicate 入力値が何らかの条件に該当するかを確認するために有効。 抽象メソッド test() defaultメソッド and(), nagate(), or() 主な利用方法 Streamのfilter()やanyMatch()メソッドなどの引数 特殊なプリミティブ IntPredicate, LongPredicate, DoublePredicateなど anyMatchはリストのStreamのうちどれか１つでも一致する条件であればtrueを返却する動きになるみたい →終端操作 filterは中間操作 A.4 Function&lt;T, R&gt; 引数をとって適切な結果値を返す操作を表す変換インターフェース 抽象メソッド apply() defaultメソッド andThen(), compose() 主な利用方法 Streamのmap()メソッドの引数 特殊なプリミティブ IntFunction、LongFunction, DoubleFunction, IntToDoubleFunction, DoubleToIntFunction 123456789101112131415package java8sample;import java.util.function.Function;public class Java8Sample &#123; public static void main(String[] args) &#123; Function&lt;String, String&gt; wrapDoubleQuotation = str -&gt; \"\\\"\" + str + \"\\\"\"; Function&lt;String, String&gt; wrapSingleQuotation = str -&gt; \"'\" + str + \"'\"; Function&lt;String, String&gt; wrapDoubleAndSingleQuotation = wrapDoubleQuotation.compose(wrapSingleQuotation); String result = wrapDoubleAndSingleQuotation.apply(\"hoge\"); System.out.println(result); &#125;&#125; 付録B 構文の基礎 関数型インターフェスのクイック・リファレンス B.1 関数型インタフェースの定義 関数型インターフェース interface実装して、@FunctionalInterfaceを付与する 実装されていないabstractメソッドを必ず１つ持つ 必要に応じて実装されたdefaultメソッドを持つ staticメソッドも持つことができる B.2 パラメータを持たないラムダ式の生成B.3 パラメータ 1つのラムダ式の生成型推論は効くが、明示した場合は (final String str) -&gt; System.out.println(str);などとする B.4 ラムダ式のパラメータ型を推論する 通常、型推論されるが、１つでも型を明示的に記載する必要がある場合、 すべて引数の型を記載する必要がある B.5 パラメータ 1つのラムダ式では括弧を省略可能 (name) -&gt; ;とかいても name -&gt; ;とかいてもよい B.6 複数パラメータを持つラムダ式の生成 複数のパラメータを持つ場合はカッコが必須 frinends.stream().reduce((name1,name2) -&gt; name1.length() &gt;= name2.length() ? name1 : name2); B.7 複数の型のパラメータを持つメソッドを呼び出す ラムダ式やメソッド参照を引数に渡せる B.8 ラムダ式を変数に格納 再利用するためにラムダ式を変数に格納できる B.9 複数行のラムダ式を生成 ラムダ式は複数行に渡って記載できる 必要に応じて、return文を記載しないといけない B.10 ラムダ式を返す メソッドの戻り値型として関数型インタフェースを指定できる B.11 ラムダ式からラムダ式を返す ラムダ式を返すラムダ式をかける B.12 クロージャにおける静的スコープB.13 インスタンスメソッドのメソッド参照を渡すB.14 メソッド参照をstaticメソッドに渡すB.15 メソッド参照を他のインスタンスのメソッドに渡すB.16 複数の引数を取るメソッドの参照を渡すB.17 コンストラクタ参照を使うB.18 関数合成付録C Web上のリソース Cutting Stock問題 https://en.wikipedia.org/wiki/Cutting_stock_problem メモ化テクニックを使って解決できる最適化問題 依存関係逆転の原則 クラスの実装で拡張するのではなく、抽象（インタフェース）とカップリングすることによる拡張方法を説明している DRY原則 https://ja.wikipedia.org/wiki/Don%27t_repeat_yourself 本質と儀式について（Essence vs. Ceremony） →古いからやめようと思う Execute Around Methodパターン ローンパターン(Loan Pattern) Scalaにおけるローンパターンの紹介 記事がなかった https://docs.scala-lang.org/ 伝えろ。聞くな。 https://pragprog.com/articles/tell-dont-asks 伝えろ、聞くなという原則を説明するコラム 書籍サイト https://pragprog.com/ 付録D 参考文献訳者あとがき索引","categories":[],"tags":[]},{"title":"Java EE 7徹底入門 標準Javaフレームワークによる高信頼性Webシステムの構築","slug":"2020-04_JavaEE7徹底入門","date":"2020-04-11T15:00:00.000Z","updated":"2020-04-26T03:36:09.891Z","comments":true,"path":"JAVA/2020-04_JavaEE7徹底入門/","link":"","permalink":"http://yoursite.com/JAVA/2020-04_JavaEE7徹底入門/","excerpt":"","text":"Java EE 7徹底入門 標準Javaフレームワークによる高信頼性Webシステムの構築 形式：書籍 発売日：2015年12月15日 ISBN：9784798140926 価格：本体3,800円＋税 仕様：B5変・584ページ 分類：プログラミング・開発 シリーズ：徹底入門 書籍ページ https://www.shoeisha.co.jp/book/detail/9784798140926 サンプルプログラム https://www.shoeisha.co.jp/book/download/9784798140926/detail Chapter 1 Java EEの基礎知識1.1 Java EEのこれまで 1995年 Sun Microsytems,Inc JDK1.0 α版 1998年 Sun JPEと呼ぶプロジェクトを立ち上げ サーバー側の企業アプリケーション開発にJavaを利用できるようにするために立ち上げ 1999年12月 フレームワーク提供(J2EE 1.2) 10個の機能から構成 JSP+Servlet → 急速に普及 EJB 2001年 J2EE 1.3 2003年 J2EE 1.4 XML対応 このころ、オープンソースのフレームワークも台頭 2006年5月 簡単開発(Ease of Development)をテーマに、名前を改名 Java Platform Enterprise Edition(JavaEE)と改め新バージョンをリリース Java EE 5 普及には至らず 改善をすすめる 2009年12月 JavaEE5をさらに大幅改善したJavaEE6をリリース CDI プロファイル：全仕様に対するサブセットを提供 プルーニング：使われなくなって古くなった使用を整理するための仕組み → ミッションクリティカルな企業システムでも採用されるようになった 1.1.3 Java EE 7 へ — 3つのテーマ JavaEE6のリリース後、すぐに次期バージョンの検討 目をつけたのは「クラウド」 より簡単にJavaEEアプリケーションをスケールするような機能を考え、GlassFishというアプリケーション・サーバー上で実際に動作するサンプルも作成 外部からのフィードバックやスペックリードが集まって再検討した結果次期が早いと判断し見送り Column JavaEE7 におけるクラウド対応の見送り 2012年8月12日 開発の遅れと、仕様化に対する十分な経験、検討が足りなかったため見送りを決定 期待があった分失望の声もあったが 有識者やベンダーの多くはこの決断を支持 新しいテーマを考えた HTML5対応 開発用意/生産性の向上 エンタープライズニーズへの対応 1.2 Java EEの全体像 Java EEに含まれる機能の全体像を把握してください JavaEEは企業システムのアプリケーション開発に必要なさまざまな機能を１つにまとめた包括仕様（umbrella specification）の総称 大小さまざまな39個の仕様から構成されています。 主に インテグレーションテクノロジー ビジネスロジックテクノロジー プレゼンテーションテクノロジー を組み合わせながらシステムを構築する インテグレーションテクノロジー 外部システムと連携するための機能を提供 外部システム データベース メールサーバー メッセージングプロバイダ（OpenMQ,WebShereMQ） エンタープライズ情報システム（ERP,メインフレーム）等がある ビジネスロジックテクノロジー 外部システムと連携するプログラムの実装とユーザーインターフェースのプログラムの実装の間に入り、企業システムの業務で必要とされる処理を実装 トランザクションの処理や業務のフローの実装など プレゼンテーションテクノロジー 様々なデバイスからアクセスされることを考慮する必要がある 人だけでなく、物も含め、企業システムに対してアクセスするためのインターフェースを提供 1.2.2 Java EEに含まれる機能 Java Persistence API(JPA) ORM機能 JavaSEでも利用可能 Java Messagge Service(JMS) 外部のメッセージングプロバイダを経由して非同期でテキストメッセージやバイナリメッセージを送受信 JavaSEでも利用可能 Batch Applications for the Java Platform データをまとめて一括処理する場合に利用 JavaSEでも利用可能 Java Mail API 電子メールクライアントを作成するために必要な機能を提供 Java EE Connector Architecture(JCA) EAIを行うために必要な機能を提供 DI/CDI JavaEEに含まれる技術を疎結合で結び合わせるための技術 Enterprise JavaBeans(EJB) もともと、分散コンポーネントを作成するための技術として作られました JavaEE5以降、EJBはビジネスロジックを簡単に実装するための技術として大きく生まれ変わりました XMLの設定は不要で、クラスに対して宣言的に定義できるようになっています。 Java Transaction API(JTA) トランザクション管理を行うための技術 JavaServer Pages(JSP), JSP Standard Tag Library(JSTL) JSPは動的ページ作成 JSTLは、ページ内のループ処理やSQLを使用したデータベースアクセスなど、JSPで共通する機能を隠蔽して利用できるようにした専用タグ JSFの導入以降は徐々に置き換えが進む JSON-P JavaEE7から新たに導入されたJavaEEでJSONを扱うための機能 次期バージョンでは、JSONデータとJavaオブジェクトをマッピングするJSON Bindingの提供も予定されている → もう対応されている？ Expression Language(EL) 簡単な式や変数などを用いて、記述内容の評価が行える言語として作られました Servlet ServletのプログラムはServletコンテナ（Webコンテナとも呼ばれる）と呼ばれる実行環境上でどうsあ HTTP/1.0及び1.1のリクエストに応答する ServletはHTTP処理に対する低レベルAPIしか提供しないため、現在はServletのAPIだけでプログラミングを行う場面は少ない JSFのようなServletコンテナ上で動作する上位フレームワークへ処理を以上するための仲介役として利用されることが多い WebSocket HTTPプロトコルをアップグレードした、双方向/全二重通信が可能なプロトコル HTTPと比べてメッセージ送受信の際のオーバーヘッドが少ないため、効果的にリアルタイムメッセージの送受信ができる Java API for RESTful Web Services(JAX-RS) RESTアーキテクチャに基づいてWebサービスを実装するための機能を提供 従来、Webサービスの実装にはSOAP Webサービス(JAX-WS)とXMLを用いるのが主流だった 現在は、分散システム間連携を行うために、RESTful WebサービスとJSONを組み合わせて実装する場面が多くなっている JAX-RSの仕様は、HTTPの仕様と密接に関連しており、HTTPメソッドに対応するアノテーションを用いて処理を実装する JAX-WSからJAX-RSへと主流が変わってきたことを理解した JavaServer Faces(JSF) コンポーネントベースで開発が可能なWebアプリケーション開発フレームワーク 画面は、フェースレット（Facelets）と呼ばれるXHTML形式のテキストファイルに、HTMLタグやJSF専用タグを記入してデザイン バックエンドの処理はマネージドビーン（Managed Bean）と呼ばれるPOJOクラス、もしくはCDIクラスで処理を実装 JSFは標準でHTML5やAjaxへも対応しており、Javascriptの知識がなくても簡単にAjaxプログラミングが行えます ビーンバリデーション データの整合性を検証するための機能 Common Annotation JavaEE5でMetadata facility for Javaという機能が追加された これに関連して、JavaSE環境、JavaEE環境の両方で共通して利用可能なアノテーションが定期された 例えば インスタンスの生成時、破棄時になんらかの処理を行うことを規定したもの 処理に対する実行権限を規定したもの データベース設定を規定したもの これらのアノテーションを利用して宣言的にプログラミングを行う Managed Bean Common Annotationの中に、Managed Beanというアノテーションがある JavaEE環境で管理されているBeanであることが明示される Managed Beanは、アプリケーション・サーバーで管理されているリソースの参照や、インスタンスのライフサイクル管理ができる 通常、Managed Beanのアノテーションを付加したクラスを実装することはほとんど無い しかし、Managed Beanの機能を持つ上位機能（CDI、EJB）でManaged Beanの機能を利用する Interceptors 複数の機能間で横断的な関心事の実装を行うための機能です。 例えば ログの出力や各処理時間の計測、セキュリティの検査などは、特定部分の実装に限らず、システムの全体で必要な実装 Concurrency Utilities for Java EE JavaEE環境で新たにスレッドを生成するための機能 JavaEE6まではサーバー環境上で新たなスレッドを生成することは非推奨でした。なぜならば、作成されたスレッドがアプリケーション・サーバーから管理できないスレッドとして動作するためでした たとえば セキュリティ情報や、トランザクション情報、コンテキスト情報などを一切含まないため、アプリケーション・サーバーから制御することは不可能 そこで、サーバーが管理できるスレッドを作るために、JavaEE7からConcurrency Utilities for Java EEが新たに導入された 1.2.3 Java EE の仕様策定 Javaの仕様はJCP(Java Community Process)という団体で管理 Java Specification Requests(JSR)と呼ぶ仕様のリクエストに対して、一意の番号を割り当てて管理している JSRをJCPに提出するために必要な成果物について記載（割愛） 1.2.4 Java EEの実行環境とプロファイル 割愛 1.3 Java EEアプリケーション開発の基本1.3.1 Java EEアプリケーションモデル 3階層アプリケーションの開発モデルを採用している ビジネスロジックとユーザーインターフェースを切り分けて実装することが大事 柔軟性の高いシステムを構築していくことが大事 1.4 開発環境の準備 サンプルアプリケーション JavaSE8 JavaEE7 GlassFishv4.1.1 (JavaEE参照実装) 1.4.1 Oracle JDKのインストール1.4.2 NetBeansのインストール1.4.3 NetBeansの起動1.5 サンプルアプリケーションの概要1.5.1 ナレッジバンク 個人が保有する知識情報（ナレッジ）を共有するためのWebアプリケーション JavaEE7で一般的なWebアプリケーションを実装するために必要な機能を使用して構築されている 画面遷移などの説明 1.5.2 ナレッジバンクのセットアップ プロジェクトを読み込み 1.6 まとめ この章のまとめを記載（割愛） Chapter 2 プレゼンテーション層の開発――JSFの基本 以下の３層に分けて開発を行う プレゼンテーション層 ビジネスロジック層 インテグレーション層 2.1 JSF概要2.1.1 JavaSErver Faces(JSF)とは JSFとはJavaEE5から追加されたプレゼンテーション層を作成するための仕様 今まではServletを使用していた サーブレットとは：ブラウザとHTTP通信を行う基礎的な仕様で、最小限の機能を提供 入力値とJavaオブジェクトのマッピング 入力値のチェック エラーメッセージのハンドリング など多くの機能が不足していた Column MVC1.0 次のバージョンのJavaEE8には、「MVC1.0」というプレゼンテーション層を開発する新しい仕様が加わる予定 Webアプリケーションを開発するフレームワークには、HTTPの通信に紐付けて処理を記述するアクションベースのフレームワーク 入力フィールドやボタンに紐付けて処理を記述するコンポーネントベースのフレームワークがある 本書で記述するJSFはコンポーネントベースのフレームワーク そのため開発者から、アクションベースの選択肢も必要という意見があがり、JavaEE8でアクションベースのフレームワークである「MVC1.0」を追加することになった 2.2 JSFの構成要素2.2.1 画面と処理（フェースレットとマネージドビーン） フェースレットとは 画面レイアウトを記述するXHTMLベースのテンプレートエンジン XHTMLとは、HTMLをXMLの文法に適合するように定義し直したもの フェースレットとBeanがどのように紐付いているかを確認 Column マネージドビーンとバッキングビーン フェースレット似バインドするJavaクラスはマネージドビーンといいますが、 フェースレットの裏側で処理を行うという意味で、バッキングビーンと呼ばれることもあります。 マネージドビーンがCDIでも代用できるようになった頃からJSFで使用するマネージドビーンをバッキングビーンと呼ぶことが多くなった 2.2.2 マネージドビーンとスコープ スコープ：マネージドビーンのデータをいつまで保有するかを指定する スコープの一覧の紹介 2.3 JSFの画面遷移2.3.1 画面遷移の方法 JSFで次の画面に遷移する場合、遷移先の名前を文字列で指定 この画面遷移に使用する文字列を「outcome値」といいます 遷移するフェースレットのパスを指定 静的な遷移 マネージドビーンの処理を行わずに直接次の画面に遷移する方法 動的な遷移 マネージドビーンで処理を行い、その結果を基に任意の画面へ遷移する方法 EL式でメソッドをバインドしている 2.3.2 画面のリダイレクト 画面遷移 フォワード：処理後に直接Web画面を生成して結果を返す リダイレクト：一度ブラウザに処理を返した後にサーバーに再アクセスしてWeb画面を生成する JSFではリダイレクトを使用して次の画面に遷移する方法を提供している １画面前のURLを表示することを避けるためにこの機能を提供 ?faces-redirect=trueというパラメータを付与すると動くらしい 問題：リクエストスコープが効かなくなる 対策：フラッシュスコープという特別なスコープを提供している 2.4 JSFの内部処理2.4.1 コンポーネント指向 JSFではWebアプリケーションをより直感的に開発するためにコンポーネントという考え方を導入している メリット Web画面と処理の紐付けを直感的に行える（HTTPの理解が不要） コンポーネントが再利用しやすい Web画面のプロトタイプ作成が容易に行える コンポーネントツリーとしてアクセスできるJavaクラスが存在するらしい 2.4.2 ライフサイクル ビューの復元(Restore View) リクエスト値の適用(Apply Request Values) 入力チェック(Process Validations) モデル値の更新(Update Model Values) アプリケーションの実施(Invoke Application) 画面の生成(REnder Response) 最初のアクセスの場合 ①の復元フェーズ終了後に、⑥の画面生成フェーズに進み、画面を表示 ポストバックの場合 すでにコンポーネントツリーがあり、値の入力やボタンの操作が実施されているので、 ①→⑥まで順番に実施 2.5 JSFの基本設定2.5.1 フォルダ構成 JSFを使用したWebアプリケーションを作成するにはWAR形式のプロジェクトを作成 EAR形式もある 複数のWARファイルやJARファイルを１つにまとめてZIPにしたもの 2.5.2 設定ファイル 必要な設定ファイル web.xml faces-config.xml アプリケーションサーバーの設定ファイル web.xml デプロイメントディスクリプタというWebアプリケーションの設定を記述するファイル webアプリケーションの初期設定 サーブレットの設定 セキュリティの設定 WebアプリケーションでJSFを使用する場合は、web.xmlにJSFが提供するFacesServletを設定 サーブレットの定義 JSFは内部でサーブレットを使用している そのためJSFを使用するにはJSFのサーブレット指定が必要 ロードオンスタートアップの指定はサーバーの起動時にサーブレットのインスタンス化と初期化を行うという指定 サーブレットのマッピング定義 URLパターンとサーブレットの定義で指定したサーブレット名を指定 URLパターンは「/faces/*」という指定がJSFでは一般的らしい facesで始まっている場合に、JSFのアクセスであるとみなされる faces-config.xml JSFの設定を記述するファイル 国際化のせてい フェーズリスなのクラス指定など アプリケーション・サーバー用の設定ファイル 2.5.3 リソースフォルダ JSFの仕様でresourcesフォルダに配置するフォルダ構成が決められているらしい resouces/[ローカルプレフィックス]/[ライブラリ名]/[ライブラリバージョン]/[リソース名]/[リソースバージョン] →わかりにくいと感じた 2.6 フェースレットタグライブラリ2.6.1 タグライブラリの種類 タグライブラリ 画面レイアウトで使用するタグを定義したもの 種類 コアタグライブラリ：他のタグライブラリのサポート的な機能を提供するタグライブラリ HTMLタグライブラリ：HTMLのタグを生成するタグライブラリ フェースレットテンプレーティングタグライブラリ：画面のテンプレート処理や繰り返し処理などを提供するタグライブラリ コンポジットコンポーネントタグライブラリ：コンポジットコンポーネントの作成に使用するタグライブラリ JSTLコア/ファンクションタグライブラリ：JSPで使用するタグライブラリ 最も使用頻度が高いのは「HTMLタグライブラリ JSTLコア/ファンクションタグライブラリ：JSPというJavaEEの仕様で使用するライブラリでJSFでも使用できるが、他のフェースレットが提供するタグライブラリとの実行タイミングが違うため不具合が発生しやすく、基本的に利用しない ※ここで再確認 JSF フェースレット フェースレットタグライブラリ EL式 マネージドビーン タグライブラリを利用するには、冒頭でネームスペースの宣言が必要 2.6.2 HTMLタグライブラリ 一覧を表で記載（割愛） 2.6.3 ヘッダーとボディ&lt;h:head&gt;&lt;h:body&gt; 2.6.4 リソース2.6.5 文字の出力2.6.6 リンクとボタン(割愛) 2.7 EL（Expression Language）2.7.1 ELとは ELとは、演算の結果や値の参照結果を返却するための簡易記法 #または、$で始まり、波括弧で囲んだ中に式を記述 $を使用した場合：ページがレンダリングされた時点で即時評価 #を使用した場合：コンポーネントに式として渡され、ライフサイクルのタイミングで遅延評価される JSFでは基本的に$を使用せずに、#を使用する 2.7.2 オブジェクトの参照 @Namedを付与したマネージドビーンの名前はEL式から参照できる 2.7.3 暗黙オブジェクト 暗黙的に参照可能なオブジェクト一覧を記載（割愛） 2.7.4 演算子 算術演算子 関係演算子 論理演算子 三項演算子 空演算子 empty a : aがNullまたは空文字の場合trueを返す 2.7.5 メソッドの呼び出し メソッドも呼び出せるよって言う説明（割愛） Chapter 3 プレゼンテーション層の開発――JSFの応用 その13.1 入力チェック3.1.1 入力チェック（バリデーション）とは JSFのライフサイクルの中にある JSFでは入力した値をチェックする機能を提供している バリデーションの方法として以下の２つを提供 JSFの初期から提供されているJSFのバリデーション JavaEE6で導入されたビーンバリデーション★ 3.1.2 JSFのバリデーション バリデーションタグを利用する（割愛） 3.1.3 JSFのカスタムバリデータ 細かなチェックをするために独自でバリデータを作成する方法 メソッドを作成する方法 クラスを作成する方法 3.1.4 ビーンバリデーションとは ビーンのフィールドにアノテーションを付与するだけでチェックができる 3.1.5 ビーンバリデーションのバリデータ ビーンバリデーションのアノテーション一覧 @NotNull @Null @Max @Min ..... point: 入力値が空文字の場合NULL値として扱う場合、web.xmlにパラメータを追加する必要がある javax.faces.INTERPRET_EMPTY_STRING_SUBMITED_VALUES_AS_NULL 3.1.6 ビーンバリデーションのエラーメッセージ変更 メッセージを変更する方法は２つある アノテーションに、message属性を指定する propertiesファイルで管理する 多言語対応などする場合、こちらが得策 3.1.7 ビーンバリデーションのバリデータ統合 MEMO: ★このテクニックは覚えておきたい 入力チェックに複数の条件がある場合には、フィールドに標準のアノテーションを複数設定するが、同じような条件を何度も設定するのは面倒なので、アノテーションを作成してまとめる 3.1.8 ビーンバリデーションのカスタマイズバリデータ ビーンバリデーションのカスタマイズも可能 MEMO:（実装方法省略） 3.2 コンバータ3.2.1 コンバータの役割 Web画面に表示する文字列とマネージドビーンのプロパティで保持するJavaのオブジェクトを変換するための仕組み JSFにより自動的に変換されるオブジェクトも存在する short int long float double boolean byte char BigInteger BigDecimal JSFでは任意のフォーマットで画面表示を行うため、標準のコンバータを提供している 3.2.2 標準のコンバータ JSFが標準で提供するコンバータは、日付や数値とおじ列を相互に変換するコンバータ f:convertDateTime f:convertNumber 3.2.3 カスタムコンバータ 独自で作成したクラスなどの標準のコンバータでは対応できないクラスでは、独自にコンバータを作成する JSFが提供するjavax.faces.convert.Converterインターフェースを実装したクラスを作成する MEMO: 確かに変換が必要な場面は絶対あるはずなので、thymeleafとかがどのように変換を持っているか確認する 他のフレームワークでも、convertを実装する方法を書いていた https://qiita.com/alpha_pz/items/21c6eda2fe227abfa403 MEMO: DBSlectした結果をList(category)にかかえているような書き方をしている 3.3 コンポーネントのカスタマイズ JSFではフェースレットが提供するコンポーネントを使用してWeb画面を作成 独自のコンポーネントを作成することもできる 方法として２つある コンポーネントクラスを作成するカスタムコンポーネント フェースレットでコンポーネントを組み合わせて作成するコンポジットコンポーネント★ 3.3.1 コンポジットコンポーネント １つのフェースレットファイルを作成するだけで、複数の画面で使い回せるコンポーネントを作成することができる MEMO: thymeleafでincludeしている感じと同じ 3.3.2 より高度なコンポジットコンポーネント12345678910111213141516171819202122232425262728&lt;!-- テンプレート側 --&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE html&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:h=\"http://xmlns.jcp.org/jsf/html\" xmlns:knowledge=\"http://xmlns.jcp.org/jsf/composite/knowledgecomp\"&gt; &lt;h:head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;h:outputStylesheet library=\"css\" name=\"style.css\" /&gt; &lt;h:outputScript name=\"jsf.js\" library=\"javax.faces\"/&gt; &lt;h:outputScript library=\"js\" name=\"application.js\" /&gt; &lt;title&gt;Knowledge Bank&lt;/title&gt; &lt;/h:head&gt; &lt;h:body&gt; &lt;div id=\"top_content\"&gt; &lt;h:form id=\"form\"&gt; &lt;h1&gt;&lt;h:graphicImage library=\"img\" name=\"logo.png\" /&gt;&lt;/h1&gt; &lt;div class=\"notice\"&gt; #&#123;flash.notice&#125; &lt;/div&gt; &lt;knowledge:login userId=\"#&#123;loginBean.userId&#125;\" password=\"#&#123;loginBean.password&#125;\" loginButtonAction=\"#&#123;loginBean.login()&#125;\"/&gt; &lt;div&gt; &lt;h:link outcome=\"account/register\" value=\"アカウント登録\"/&gt; &lt;/div&gt; &lt;/h:form&gt; &lt;/div&gt; &lt;/h:body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728&lt;!-- 利用する側 --&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE html&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:h=\"http://xmlns.jcp.org/jsf/html\" xmlns:knowledge=\"http://xmlns.jcp.org/jsf/composite/knowledgecomp\"&gt; &lt;h:head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;h:outputStylesheet library=\"css\" name=\"style.css\" /&gt; &lt;h:outputScript name=\"jsf.js\" library=\"javax.faces\"/&gt; &lt;h:outputScript library=\"js\" name=\"application.js\" /&gt; &lt;title&gt;Knowledge Bank&lt;/title&gt; &lt;/h:head&gt; &lt;h:body&gt; &lt;div id=\"top_content\"&gt; &lt;h:form id=\"form\"&gt; &lt;h1&gt;&lt;h:graphicImage library=\"img\" name=\"logo.png\" /&gt;&lt;/h1&gt; &lt;div class=\"notice\"&gt; #&#123;flash.notice&#125; &lt;/div&gt; &lt;knowledge:login userId=\"#&#123;loginBean.userId&#125;\" password=\"#&#123;loginBean.password&#125;\" loginButtonAction=\"#&#123;loginBean.login()&#125;\"/&gt; &lt;div&gt; &lt;h:link outcome=\"account/register\" value=\"アカウント登録\"/&gt; &lt;/div&gt; &lt;/h:form&gt; &lt;/div&gt; &lt;/h:body&gt;&lt;/html&gt; Column: コンポーネントで利用可能な暗黙オブジェクト カスタムコンポーネント内でよく利用する暗黙オブジェクト cc: コンポジットコンポーネントの情報が取得できる component: 現在のコンポーネントの情報や、親や子のコンポーネントの情報にアクセスすることができる 3.4 フェースレットテンプレート3.4.1 フェースレットテンプレートの利用 ヘッダーやサイドバーなどはテンプレート化して管理する説明 こっちがthymeleafのincludeに近い 3.5 HTML5フレンドリマークアップ JavaEE7(JSF2.2)からHTML5の進化へ対応するためにフレンドリマークアップという機能が導入された 以前のJSFでは任意の属性をHTMLとして出力する場合にコンポーネントをカスタマイズして提供していた 画面デザインをWebデザイナーが行い、リッチなWeb画面を作ることが一般化 3.5.1 パススルーアトリビュート3.5.2 パススルーエレメント3.6 Ajax3.6.1 JSFのAjax対応 一般的なAjaxの作りでは、データの取得処理や画面の再描画処理をJavascriptで記述する必要がある JSFのAjax機能を利用するとJavascriptをほとんど記述せずにWeb画面の部分更新が可能 Ajax専用のタグを使用して、結果をRenderingしている MEMO: 専用のタグでAjax処理ができるのは、コンポーネントベースのフレームワークであるJSFの特徴だと感じた 3.6.2 Ajaxを使用した入力チェック3.6.3 Ajaxのイベントハンドリング イベント実行中や完了、エラー発生時の処理を記述するための方法 共通化するための方法を紹介 Chapter 4 プレゼンテーション層の開発――JSFの応用 その24.1 認証／認可4.1.1 認証/認可の仕組み JavaEEのログイン機能を実現するための認証認可の仕組みについて ログイン機能を利用する手順 アプリケーションサーバーの認証/認可設定をする。 アプリケーションの認証/認可設定をする。 プログラムでログイン/ログアウト機能を作成する。 4.1.2 アプリケーションサーバーの認証設定 アプリケーション・サーバーに認証の設定を行う必要がある 認証データの指定先に ファイル データベース LDAPサーバー などを指定する ナレッジバンクではデータベースを指定している Glasfishを使用した認証の設定方法を説明 Glasfishの管理コンソール http://localhost:4848/ 認証設定を行うには Configurations＞server-config＞Security＞Realms＞New ナレッジバンクではJDBCレルムを使用するので ClassNameにJDBCRealmを選択する 4.1.3 アプリケーションの認証設定 アプリケーションサーバーの認証設定が終了したら、 今度はアプリケーションの認証設定を行う 4.1.4 ログイン/ログアウト機能の作成 Oracle18cで接続を試していたがどうしてもうまく行かなかった Oracle11gだとすぐにうまく行った ログインの仕組みを作って、 実際にloginのfaceletでコンテキストのログインメソッドを呼び出して、認証を済ませる MEMO: springsecurityみたいなやつ 認証設定は必ず実装しておく 4.2 国際化4.2.1 JSFの国際化 プロパティファイルでロケール管理して、faces-config.xmlで切り替え UIViewRootクラスのgetLocaleメソッドやsetLocaleメソッドでも切り替えることができるみたい MEMO: ロケール切り替えは実装しておくべき 4.3 ブックマーカビリティ4.3.1 ブックマーカビリティとは JSFでは最初にブラウザからアクセスが来た際に、処理をせずに画面を表示する しかし、Webアプリケーションでデータの一覧や詳細を表示する画面では、なにかしらの事前処理やデータの取得処理が必要 そこで、JSFでは初回アクセス時に処理を実施する機能を提供している 使い方について説明（割愛） 4.4 フェーズリスナ JSFのライフサイクル ビューの復元(Restore View) リクエスト値の適用(Apply Request Values) 入力チェック(Process Validations) モデル値の更新(Update Model Values) アプリケーションの実施(Invoke Application) 画面の生成(REnder Response) フェーズ前後で横断的に行う処理はフェーズリスナを使用する 1234567891011121314151617181920212223242526package knowledgebank.web.listener;import java.util.logging.Logger;import javax.faces.event.PhaseEvent;import javax.faces.event.PhaseId;import javax.faces.event.PhaseListener;public class KnowledgePhaseListener implements PhaseListener &#123; Logger logger = Logger.getLogger(KnowledgePhaseListener.class.getName()); @Override public void beforePhase(PhaseEvent event) &#123; logger.info(event.getPhaseId() + \" beforePhase\"); &#125; @Override public void afterPhase(PhaseEvent event) &#123; logger.info(event.getPhaseId() + \" afterPhase\"); &#125; @Override public PhaseId getPhaseId() &#123; return PhaseId.ANY_PHASE; &#125;&#125; 4.5 Java EE 7で導入されたJSFの機能4.5.1 JSF 2.2 の追加機能 JSF2.2の仕様には大きな特徴として以下の４つが紹介されている HTML5フレンドリマークアップ（パススルーアトリビュートと、パススルーエレメント） リソース・ライブラリコントラクト Faces Flows ステートレスビュー 4.5.2 リソース・ライブラリコントラクトリソースの塊を簡単に切り替えることができる仕組み あまり便利に思わなかった 4.5.3 Faces Flows フロー処理について記載されている スコープを設定ファイルやJavaアノテーションで保持できるみたい MEMO: 他のフレームワークではどのようにスコープ持っているのか確認 4.5.4 ステートレスビュー 状態を保持しないビューを作成する機能 JSFでは画面を表示する際にサーバー側似コンポーネントツリーを作成し、同一画面を表示している間はそのコンポーネントツリーを保持していると説明しました。 ステートレスビューを使用すると、そのコンポーネントツリーを毎回破棄市、アクセスが来るたびに再作成する動きに変わる ステートレスなアプリを作る上で欠かせない MEMO: 他のフレームワークの場合は、redisなどでセッション管理している 4.6 まとめ ここまでの内容を理解していれば、十分JSFを使用してWebアプリケーションを作成することができる 紹介していないライブラリ PrimeFaces RichFaces OmniFaces MEMO: 時間があれば見てみる程度で良いかも Chapter 5 ビジネスロジック層の開発――CDIの利用 本章と次章ではCDIとEJBについて解説 本章ではCDI CDIとEJBの違いについて解説 CDIがJavaEEに採用された経緯 CDIの機能 について解説 5.1 CDIとEJB5.1.1 ビジネスロジック層の部品 CDI,EJB いずれも「ビジネスロジック」を記述するための部品である CDI JavaEE6から採用された新しい技術 EJB Java2Enterprise Edition（J2EE）の頃から存在する歴史ある技術 5.1.2 CDIとEJBの違い CDIとEJBの違いは「設計の柔軟性」 CDIの方が自由度が高い 5.2 DI（Dependency Injection） CDIについて知る前にDIについて理解しておく必要がある DIが考案された歴史的な背景をたどって、CDIの意義について知ることにする 5.2.1 DIとは DI 部品間の依存関係を少なくすることで、部品の分離と結合をコントロールするための考え方、及びその仕組みのこと 「依存」とは、クラス同士が強いつながりを持つことを意味している 直接クラスを宣言し、インスタンス化している強い依存関係は、それ自体で処理が完結しているプログラムモジュール、例えば、 ビジネスロジック層でしか動かないクラス間の依存については問題ありません。 一方で各層をまたがる依存関係はできる限り弱い方がよいという考えがある 依存関係を弱く保つことができれば、変更点は少なくてすむ 5.2.2 DIによる依存関係の解消 DIコンテナがあれば、実行時に動的にクラスを選択できる 用途としては以下 ある条件において別の実装クラスを必要とするケース 処理の流れ自体は変わらないが、ユーザーやリクエストの状況に応じて手続きが異なる、あるいは出力先が異なる テストや開発中のモック入れ替え 層をまたぐ処理や開発中のクラスを利用しなければならないときに、仮となるモックを利用し、将来的に完成したクラスを入れ替える場合。 あるいはテストデータを返却するテスト用のモックと完成したクラスを入れ替える場合 COLUMN ファクトリメソッドパターン DIが実現している実装の入れ替えは、ファクトリメソッドパターンと呼ばれるデザインパターンを採用することでも実現可能 ファクトリメソッドパターンはオブジェクトの生成を管理するクラスを設けることで、任意の振る舞いを持つオブジェクトを取得する方式 ただし、ファクトリメソッドパターンを利用していても、結局返却するインスタンスを選択する処理をソースコードに記述しておく必要があり、 インスタンスをソースコード外で管理するには、プロパティファイルなどを用いる必要があるので、そうするよりはDIコンテナを利用するほうが楽 MEMO: 再読 5.2.3 JavaEEへのDI取り込み( 割愛) 5.3 CDI CDIとはJavaEE6から導入されたJavaEEアプリケーションサーバー上でDI機能を提供するための仕様 CDIを使用するために必要な定義 インジェクションポイント：@Injectが指定された変数 CDIビーン：スコープに関するアノテーションが付与されたクラス Column 設定ファイル beans.xml JavaEE7 からCDIを使うための設定ファイルであるbeans.xmlは特定の用途を除き不要になりました beanx.xmlはインジェクションポイントとCDIビーンの関係性を記述するためのものでしたが、現在では自動的に解決する用になっている CDIの利点 インジェクションを行うのが簡単（アノテーションのみで設定ファイル不要） DIを基礎とした様々な機能があらかじめ準備されている 5.4 CDI基本編 CDI限定子：複数のインジェクション候補クラスが存在する場合に、クラスを特定するためのアノテーション javax.inject.Qualifier 5.4.1 CDIコンテナによるインジェクション CDIコンテナに存在するスコープを過ぎたオブジェクトは破棄される 5.4.2 CDIの型解決方法 CDIがインジェクションポイントに対して注入する対象となるインスタンスを解決する方法は２通りある インジェクションポイントと対象インスタンスが１対１の場合（自動解決） CDI限定子もしくは、beans.xml(@Alternative)で解決する方法 結論：CDI限定子（Qualifier）を使用して書いていくのがよい 設定ファイルも必要ないし、ソースコードを柔軟に変更しながら開発ができるため Column インターフェースを利用するべきか 結論：インターフェースは準備しておくべき 5.5 CDI応用編 CDIに関わる応用的な利用方法について記述 CDIの付加機能 イベント処理：CDIビーン上である条件を満たした場合に、別のクラスに対して通知を行う機能 ステレオタイプ：複数アノテーションをまとめて定義する機能 プロデューサ/ディスポーザ：クラスではなく、フィールドそのものやメソッドの戻り値をインジェクションポイントに注入する機能 インターセプター/デコレータ：処理の前後に別の処理を入れ込んだり、追加したりする機能 5.5.1 イベント処理 イベント処理とは 設定した閾値を超えるなど、特定の条件を満たす情報が発生したとき、その通知と情報をやりとりすることを指す CDIではイベント発火はCDIビーン上で行い、それを処理するクラスを特別な呼び方として「オブザーバ」と呼ぶ イベント処理の実装 イベント情報を格納するクラスを準備する イベントを発火するCDIビーンを作成する オブザーバクラスを作成する イベント処理の留意事項 イベント発火からオブザーバの処理までがすべて同期で実行される 非同期だと勘違いしないように 参照関係を持たず、プログラムモジュール間似おける情報のやり取りを非同期で実行したい場合には、次章で説明するJMSを利用するなど別の方法を検討する必要がある 5.5.2 ステレオタイプの利用 複数のアノテーション定義をまとめて管理できる @StereoTypeを付与してまとめていく 上書きもできるが、あまり上書きしすぎると良くない MEMO: 管理方法について パッケージ名をstereotypeで切って管理する クラス名称の接尾字にTypeをつけておくとアノテーションがステレオタイプで有ることを明示できる MEMO: Springでもまとめていくアノテーションあるか 5.5.3 プロデューサ/ディスポーザの利用 プロデューサを利用すると、インジェクションポイントに注入するオブジェクトをプログラム上で動的に変更することができる プロデューサにより作成されたオブジェクトが終了処理の必要なオブジェクトである場合、ディスポーザを利用することで終了処理を記述することができる プロデューサアノテーションをメソッドに付与して戻り値に@Inject指定した変数と同じ型を指定してあげる メソッドで処理されたあとのオブジェクトがDIコンテナに格納され、インジェクションされる Disposesアノテーションは、Producerメソッドで提供されたクラスの終了処理を行うためのディスポーザ MEMO: Springにもこの概念があるかどうか確認 5.5.4 インターセプタとデコレータ インターセプターとデコレータについて解説 すでに作成済みのメソッドの処理に対して、外部のクラスを用いてその処理の前後や、処理内容に変更を加えることができる技術 インターセプター：対象となる処理の前後やライフサイクルに応じて処理を行うための仕組み 定義方法 @Interceptorを付与したクラスを作成、メソッドに特定のアノテーション付与して機能に関与しない処理を実装 利用側のメソッドで@Interceptors()の引数に作成したインターセプタークラスを追加する または、beans.xmlに使用するインターセプターを定義する Column どこでインターセプターを定義する？ 機能処理内にインターセプター（非機能処理）を記載するのはナンセンス beans.xmlで管理する方が良いのではという意見が記載されている デコレータ：機能追加をするための仕組み 共通のインターフェースを実装したクラスに処理を委譲する MEMO: デコレータの使い所について確認 Springで同様の機能あるかどうか インターセプター＝AOP？こちらも使い所についてまとめておく 5.6 まとめ機能が非常に豊富であることと、ルール似基づいた設計と実装が必要であることをご理解いただけたと思います。 Chapter 6 ビジネスロジック層の開発――EJBの利用6.1 Enterprise Java Beans（EJB）6.1.1 EJBとは アプリケーションサーバー上で動作するJavaのプログラムのうち、特に「ビジネスロジック」を担当する部品を指す EJBは サーブレットやJSF、Webサーバーなどアプリケーションサーバー外からのリクエストを受け付ける層と データベースなどへ情報の永続化を行う層の中間の層の部品として機能する 機能 EJB3.2 トランザクション制御 Java Persistence APIを介した永続化処理 Java Messageing Serviceを介したメッセージ駆動処理 非同期実行制御 同期実行制御 スケジュールに基づいた実行 JNDIを介したインスタンス取得（現在はアノテーションを利用） リモートクライアントからの実行 セキュリティ 6.1.2 EJBの利点 JavaEETutorialを参考 EJBの利点 EJBコンテナがシステムレベルのサービスを提供してくれるため、開発者はビジネスロジックの構築に集中できる クライアントとの分離。クライアントにはビジネスロジックを実装する必要がない JavaEE準拠のアプリケーションサーバー上であればどこでも動く 6.1.3 EJBの種類 ３種類ある セッションビーン メッセージドリブンビーン タイマー 6.2 セッションビーン6.2.1 セッションビーンとは EJBの中核を成すコンポーネント 6.2.2 セッションビーンの種類 セッションビーンの種類 ステートレスセッションビーン ステートフルセッションビーン シングルトン タイマー 6.2.3 ステートレスセッションビーン 一番良く利用されるEJBであり、ごくシンプルで基本的なEJB ステートレスセッションビーンのクラスに@Statelessを付与 利用側は@EJBを付与して使用する @Statefulアノテーションを利用する 留意点 クライアントごとにステートフルセッションビーンのインスタンスが作成される サーブレットからステートフルセッションビーンを呼び出す場合、 通常サーブレットは１リクエストスレッドにより１つのインスタンスが利用されるモデルであるため、 状態を保持できない ライフサイクルの制御 生成 活性化 非活性化 破棄 非活性化されると、メモリ外にシリアライズ処理され出力される。 必要になるとデシリアライズされ、メモリ上に復帰する 6.2.5 シングルトンセッションビーン @Singletonアノテーションを付与 設定ファイルの読み出しの管理などで使う COLUMN @Startupアノテーション デプロイされたアプリケーションが有効化されたタイミングですぐにオブジェクトを生成するよう、アプリケーションサーバーに支持するもの @DependsOnというアノテーションもある 初期化の依存関係を解消するためのもの MEMO: Springの場合初期化のアノテーションは何を使っているか 6.2.6 非同期処理 実装には「@Asynchronousアノテーション」を使用 クラスかメソッドに定義する クラスの場合はすべてのメソッドが非同期になる メソッドの場合は対象メソッドのみ非同期になる MEMO: Futureインターフェースを介した操作について理解する Column 非同期処理の再実行 EJBの非同期実行には処理の再投入（再実行）のためのAPIは定義されていないので 自前で実装するか、他のアーキテクチャを利用する方法も検討する キューを利用して後述のメッセージドリブンビーンを使うなどが考えられる 6.2.7 トランザクション @TransactionManagementアノテーション @TransactionAttributeアノテーションを使用するらしい 詳しい使い方については割愛 6.3 メッセージドリブンビーン メッセージドリブンビーン（Message Driven Bean: MDB）について解説していく メッセージと呼ばれるものを受け取ることで起動するという用途が限定的なコンポーネント 6.3.1 メッセージドリブン便とは MEMO: JMSも理解を深める必要あり JMS キューまたはトピックと呼ばれる方式を利用して、主にシステム間やアプリケーション間の情報を受け渡しを行うための仕組み Column キューとトピック キューとトピックの違いは、送信元と受取側の数の違いにある キュー：１対１ トピック：N対M（多対多） メッセージの受取を担当するのがメッセージドリブンビーン MDBは常にキューまたはトピックにメッセージが配信されるのを待機し、監視している 6.3.2 実装例割愛 MEMO: JMSの使用方法とSpringJMSを使う 6.4 タイマー6.4.1 タイマーとは EJBには時間を指定して起動するための「タイマーサービス」というものが定義されている タイマーはバッチ処理とは異なるので、むやみに使用するべきではない 使用方法は以下の２種類存在する TimerServiceAPIから登録する @Scheduleを使って登録する 6.4.2 タイマーサービスのサンプル割愛 6.4.3 @Scheduleの実装サンプル割愛 6.5 EJBの設計 EJBというのはあくまでビジネスロジックの実装を任されているコンポーネント アプリケーションはビジネスロジックだけでは成り立たない ブラウザの画面などのプレゼンテーション層 Webサービスなどのロジック呼び出し部分、データベース接続などの永続化層、外部サービスの呼び出しなどもある EJBはこれらの処理の中間に位置することになる EJBを設計する上でまず考える必要があるのは、この「外部の層との接点」 6.5.1 EJBメソッドの呼び出しに関する設計 （１）やり取りする情報を保持するクラスを作成し、サーブレットとEJB双方から共通のクラスとして参照する あまりにも多くの情報を保持し、データベースへの永続化が終わるリクエストの最後まで保持し続けるような長寿クラスにならないように注意する必要 （２）引数が増えた分についてはメソッドをオーバーロードして対応する 注意：公開するメソッドが増えて、Webサービスのエンドポイントになるような場合はWSDLの変更が発生するため注意 Column JSPからのEJB呼び出し 画面生成とビジネスロジックの分離ができないためやめた方がいい 6.5.2 ローカル呼び出しとリモート呼び出し リモート呼び出しは可能な限り使わないことをおすすめする リモート呼び出しが必要なパターン バッチの実装 GUIを持つクライアントからのビジネスロジック呼び出し 多段アプリケーションサーバー構成（処理量による業務分離、接続形態によるレイヤー分割） 代替手段としてはEJBはローカル使用のみにしておき JAX-RSなどを使用した層を準備することが考えられる MEMO: JAX-RS層について深堀り 6.5.3 同期/非同期 基本的に非同期にするメソッドはいかに絞るとよい すぐに結果を必要としないもの 結果を得るのに相応の時間がかかる処理 6.5.4 負荷量 MEMO: 設計する際の負荷について考えるべき 6.5.5 データベースアクセス JPA JPA以外のO/RマッピングもしくはDAOフレームワーク JDBCの直接呼び出し 通常はEJBと親和性が高いJPAをEJBトランザクション管理下に置くのが容易 6.6 EJBのテスト6.6.1 EJBのテストの必要性と難しさ EJBの最大の弱点はテストがしづらいものであった JavaSEでも必要な資材を準備すれば動くようになったが、一部対応していないらしい 6.6.2 EJBテストの準備 EJBContainerからEJBモジュールを取得し、Junitなどでテストを実施する説明 6.7 まとめCDIとEJBをうまく組み合わせて設計していこうという説明 Chapter 7 データアクセス層の開発――JPAの基本本章と次章では、JavaEEのにおけるデータベースへのアクセス方法であるJPAについて解説 エンティティやクエリといったJPAの構成要素と、JPQLとCriteriaAPIの２種類のクエリについて説明 7.1 JPAの基礎知識 永続化：Javaのプロセスが終了しても、データが消えずに残るような状態にすること 7.1.1 JPAの構成要素 エンティティクラス（データのレイアウトを規定）とエンティティオブジェクト（データを保持） エンティティマネージャ エンティティオブジェクトとレコードの紐付けを管理 クエリ データを操作 永続化ユニット データベースへの接続情報などJPAの設定を記述する 7.1.2 エンティティクラスとエンティティオブジェクト そのまま、クラスとオブジェクトという理解 テーブルとレコード になぞらえて考えられる 7.1.3 エンティティマネージャ エンティティオブジェクトを取得したり、データベースへ反映、削除したりする 永続化コンテキストの配下にないものは、データベースへは反映されない persist()メソッドで管理下におくみたい 7.1.4 クエリ エンティティマネージャが持つ基本的なメソッドを利用する他に、より自由度の高いクエリを用いる方法がある JPAが用意しているクエリの定義方法 JPQL: SQLに似た記法で記載でき、DBMSを意識しなくて良い Criteria API: APIを使ってクエリを組み立てて行く手法。DBMSを意識しなくて良い ネイティブクエリ: SQL文をかいていく必要があるので、DBMSが変わればここも変更しないと行けない 理由がなければJPQLを用いるのが良いだろう 7.1.5 永続化ユニット 永続化似関する設定をまとめたもので、実態はpersistence.xmlという名前のXMLファイル 設定項目としては以下のようなものがある 永続化ユニットの名前 トランザクションマネージャの設定 永続化プロバイダ（JPAの実行エンジン）のクラス名 永続化プロバイダに与えるプロパティ 接続先データソースの名前★ エンティティクラスの名前★ データベースの接続先を設定する方法 アプリケーションサーバーで定義されているデータソースの名前を指定する方法 永続化プロバイダのプロパティとして、接続先アドレスやユーザー名、パスワードなどを設定する方法 が挙げられる JPAの実行エンジンにどれがエンティティクラスなのか検知してもらう設定も入れる 7.1.6 JPAのメリット ResultSetからDTOにうつして..という処理を記述しなくてよい メソッドかクエリでアクセスできる コード量が従来よりも少ない メモリ上にキャッシュされたエンティティオブジェクトを利用できる アプリ開発者はキャッシュの有無を意識する必要はない 7.2 エンティティの基本（割愛） 7.2.1 エンティティクラスの実装 エンティティクラスには@Entityを付与する publicでなければならず、finalであってはならない 引数のないコンストラクタを作成しとくべき Column Serializableについて EJBのリモート呼び出し 複数のアプリケーションサーバーでJPAの２次キャッシュを構成する場合 MEMO: 他のORMはSerializableに定義しているか確認 7.2.2 ID エンティティクラスはIDとして定義したフィールドを使用してhashCodeメソッド、 equals(Object)メソッドを実装しなければ行けない→通常IDEで自動生成できる toString()をオーバーライドしておくとデバッグに役立つ！ MEMO: 他のORMでもtoString()オーバーライドしたりしてるか確認 7.2.3 リレーション @OneToMany等によるエンティティの紐付け型を説明 MEMO: 他のORMでも存在するか確認 １対１のリレーションについて 通常１対１のリレーションだと、同一エンティティに保持してしまうことが望ましい ただし、ライフサイクルが異なるデータだと、別のエンティティに分けた方が良いケースがある 例）アカウント情報とアカウントに紐づく会社情報 アカウント情報：作成されてから削除されるまで 会社情報：入社して初めてできる、会社に所属しなければレコードがない などのような状況 7.3 エンティティマネージャの基本 エンティティマネージャの実態は javax.persistence.EntityManagerインターフェース このインターフェースに用意されているメソッドを通してエンティティを操作する EntityManagerのインスタンスはCDIを用いてアプリケーションサーバーからインジェクションで取得する @PersistenceContextアノテーションを付与し、属性似unitNameを指定 persistence.xmlの&lt;persistence-unit&gt;タグのname属性と一致した名前を指定 7.3.1 エンティティのライフサイクル ライフサイクル NEW MANAGED REMOVED DETACHED 7.3.2 エンティティオブジェクトの作成と永続化123456// NEW状態でまだ永続化コンテキストと紐付いてないAccount account = new Account();// MANAGED状態になる 次のコミットのタイミングでデータベースに反映されるEntiryManager em = xxx;em.persist(account); 7.3.3 エンティティオブジェクトの取得と更新123456// 取得したいEntityクラスとIDを指定// MANAGED状態で取得されるAccount account = em.find(Account.class, 0);// setter経由で値を設定するとデータベースに反映される（コミットしたタイミングで）account.setName('てらだよしお'); 7.3.4 エンティティの削除1em.remove(account); 7.3.5 デタッチEJBのメソッドの外へ出るとDETACHED状態になる MEMO: 通常アプリでEntityクラスをそのまま画面で使用することは良くないと考える 7.4 クエリAPIJPQLとCriteriaAPIを使ったQuery作成方法を記載 7.4.1 パラメータJPQLとCriteriaAPIはパラメータを取ることができるパラメータは位置で指定する方法と名前で指定する方法があるが通常は名前で指定した方がよい MEMO: 名前で指定するルールを作った方が良さそう 7.4.2 サンプルデータダウンロードデータの中にあるサンプルデータについての説明 7.5 JPQL JPQL(Java Persistence Query Language) 7.5.1 JPQLの基本構文7.5.5 フェッチ 取得するエンティティにリレーションが定義されている場合、リレーション先のエンティティを どのタイミングでデータベースから取得するかを決めることができる これを「フェッチ戦略」という Eagerフェッチ Lazyフェッチ Eagerフェッチ findメソッド実行時に、リレーション定義されている参照先のオブジェクトも取得する リレーション先のエンティティオブジェクトを同時に使用することの多い場合は、 Eagerフェッチを使用する Lazyフェッチ 取得処理時には、リレーション先のエンティティオブジェクトを取得せず、 リレーション先にはじめてアクセスする際に取得する リレーション先のエンティティオブジェクトを頻繁に使用しない場合はLazyにすべき デメリット どこでエンティティの取得が行われたか分かりづらい 性能の劣化の場所を特定しづらい N+1問題とJOINフェッチ １回のクエリを発行したあとにN回のクエリの発行を必要とすることをN+1問題という リレーションが増えるほど、発行するクエリの数が増える これに対応するためにJOIN FETCH節を利用する JOIN句の後ろにFETCHがつくだけ 7.5.6 エンティティオブジェクトの集計 シンプルにCountなどを使う方法 型を意識する必要がある場合、コンストラクタ式を利用する必要があるらしい 割愛）） 7.5.7 名前付きクエリ 開発者はJPQLのクエリに名前をつけることができる 名前をつけられたJPQLのクエリを「名前付きクエリ」と呼ぶ @NamedQueriesと@NamedQueryを使って名前定義しておく方法 MEMO: 他のORMはSQLファイルで管理するのではと思う 7.6 CriteriaAPI Criteriaクエリを利用してクエリを構築していく JPQLと役割は同じであるため、JPQL同様に以下の要素から構成 SELECT FROM JOIN WHERE ORDERBY 7.6.1 Criteria APIの基本構文（割愛） 利用のメリットがあまりわかない 発行されているSQLが分かりづらい SQLNativeでかけない メソッドなど覚えなくては行けない Chapter8 データアクセス層の開発 JPAの応用 エンティティとデータベースの関連付け キャッシュなどJPAの応用的な使い方について紹介 8.1 高度なエンティティの利用方法 日時を指定する日時型、 連続した一意の数字を設定するシーケンス、 リレーション先のエンティティへ処理を伝播するカスケードを紹介 8.1.1 フィールドに関する応用 日時 JPAで日時を使用するには、エンティティクラスのフィールドにjava.util.Date型を指定 @Temporalアノテーションを付与して、引数にTemporalTypeを指定 シーケンス エンティティのIDにはサロゲートキーを使用するのが 一般的 サロゲートキーは人工的に作成されたキーであり、業務上の意味がないもの MEMO: 一般的にサロゲートキーが使われているのか確認 @SequenceGeneratorアノテーションを付与し、作成したシーケンスからエンティティフィールドに自動で値を設定するには @GeneratedValueアノテーションを使用する MEMO: DBとどのように絡んでくるのか、DB定義側も自動的にシーケンス定義が作成されるのか どのDBもだいたいシーケンス定義を作成できるのか カスケード エンティティオブジェクトに任意の操作をしたあと、リレーション先までその操作を反映させるための機能 MEMO: 他のORMはどのようにこの機能を持っているか確認 複合ID @IdClassか@EmbeddedIdを使用して実装する どちらも主キークラスとして定義する必要あり 8.2 ライフサイクルコールバック JPAではコールバックメソッドを使用することで、エンティティオブジェクトの操作に対応した処理を実行することができる 実装方法は２種類 エンティティクラスに実装 エンティティの値を変更する場合にとどめてく エンティティリスナに実装 エンティティの値を変更する処理は実装せず、共通で使用するような処理にとどめておく →あまり複雑にならないように注意 MEMO: 他のORMにはコールバックメソッドの仕組みある？どんな処理を実装するのがベター？ 8.3 エンティティクラスとテーブル構造Javaアプリケーション開発者がエンティティクラスを作成すると、JPAはエンティティクラスの定義を読み込み、データベースへテーブルを作成する MEMO: 他のORMはテーブル自動作成とかされるのか確認 8.3.1 テーブル名とカラム名エンティティの変数とカラム名を変更する方法について記載 多対多の中間表の名前の付け方 LOB定義 @Lob 8.3.2 索引 索引を作成する方法について記載 @Index(columnList = &quot;xxxxx,xxxxx,xxxxxx&quot;) 8.3.3 制約 精度とスケール、長さ @Column(precision=15, scale=0) @Column(length=500) 一意制約 MEMO: 他のORMでもDBMSの方言を吸収しながらテーブル定義ができるか確認、できなければJPAってすごい 他のシステムも同じDBを参照していた場合、衝突する可能性あるので、AP:DBが対になるようなシステムであればよいかも 8.4 トランザクション JavaEEには EJBコンテナにより自動的に開始されるトランザクション Java開発者が任意で開始するトランザクション がある 8.5 キャッシュ8.5.1 これまでのデータアクセス8.5.2 キャッシュを使用したデータアクセス Column 複数アプリケーションによるデータ更新 複数のアプリケーションが同一のデータベースを更新する場合や他のノードやデータベースでデータが更新されると、 キャッシュされているエンティティに伝播されないので、整合性が取れなくなる MEMO: かなり致命的な問題だと思う… マスタテーブルに使うとか？ MEMO: 今キャッシュされているエンティティ情報をログに出力する方法などがあれば可視化されてわかりやすいが、ある？ 8.5.5 プリロード EJBの@Startupなどを利用してアプリケーション起動時に１回だけSQLを実行したり、 JSFやWebサービスを利用して外から初期化処理を起動できるようにすること １回読み込んでおくことでキャッシュに乗せて処理を早くする 8.5.6 EclipseLink GlassFishではJPAの実行エンジンとして、EclipseLinkを使用している EclipseLinkには エンティティキャッシュ エンティティオブジェクトをキャッシュする機能 問い合わせキャッシュ の２種類が存在する クエリの結果をキャッシュする機能 MEMO: EcllipseLink以外の実行エンジンなどが存在する？ 8.6 永続化ユニット http://itdoc.hitachi.co.jp/manuals/link/cosmi_v0870/APKC/EU070266.HTM アプリケーションからJPAを使用する場合，次のような情報を定義する必要があります。 アプリケーション内のエンティティクラスの情報エンティティクラスとデータベーステーブルとのマッピング情報JPAプロバイダがデータベースコネクションを取得するためのデータソースの情報これらの情報を定義したものを永続化ユニットといいます。 APサーバーにJNDIを定義し、APサーバー経由で接続→こちらを推奨しますとのこと 設定ファイルをアプリケーションに保持して直接接続 Column JavaSEでJPAを使う jarファイルをクラスパスに追加して、persistence.xmlを用意すれば使えますとのこと EJBコンテナがないので、EntityManagerFactory経由でEntityManagerオブジェクトを取得する 8.7 環境構築手順割愛 8.8 アプリケーション開発手順8.8.2 JPQLの開発IDE上で試しにSQL流せる機能 MEMO: 他のORMにも同様の機能あるか確認する Chapter9 RESTful Webサービスの開発9.1 Webサービスの基礎9.1.1 Webサービスとは サーバーで行われたなんらかの処理の結果をHTMLではなく、処理結果だけで返すものをWebサービスと呼びます Webサービスを実現するために使われる技術 SOAP: 信頼性を必要とする企業間でのWebサービスで多用されている REST: 一般に公開されているWebサービスでよく使用されている RESTベースのWebサービスをRESTfulWebサービスと呼ぶ JavaEEでもSOAPとRESTを利用したWebサービスを作成するためのAPIを提供している SOAPを使用したWebサービスを作成するAPIがJAX-WS RESTful Webサービスを作成するAPIが、JAX-RS 9.1.2 RESTful Webサービスとは RESTful Webサービスとは、RESTに則ったWebサービス REST原則 a.すべてのリソースに一意なアドレス（URI）を与える b.情報の操作には予め定義された命令体型（統一インターフェイスという）を使用する c.プラットフォームに応じて複数の表現（データ形式）を使用する d.セッションなどの状態管理を行わず、ステートレスに通信する e.アプリケーションはリンクによって、次の状態に遷移する 上記のすべてを守る必要はないが、少なくとも、aとbは守っておくべき 制約がゆるいので、かんたんに実装できる 一方、SOAPは定義が厳密なので実装ハードルが高い 9.1.3 RESTとHTTP HTTPヘッダー HTTPメソッド GET POST PUT DELETE URI MEMO: マトリックスパラメータは初めて聞いた ステータスコード 9.2 JAX-RSの基本9.2.1 JAX-RSとは リクエストパラメータ マーシャル：XML形式やJSON形式→Javaオブジェクト アンマーシャル：Javaオブジェクト→XML形式やJSON形式 JAX-RS2.0仕様の参照実装はJersey JerseyはGlassFishサーバーでも使用されている 主に５つの機能を提供 １．HTTPメソッド/URIパターンとリソースメソッドとのバインド機能 ２．メッセージボディのデータ形式指定機能 ３．リクエスト情報のインジェクション機能 ４．リクエスト/レスポンスのメッセージボディの変換機能 ５．例外のレスポンスマッピング機能 9.2.2 サンプルアプリケーションにおけるJAX-RSの機能9.3 RESTful Webサービス作成のための事前準備9.3.1 RESTful Webサービスの認証方式 ナレッジバンクのRESTサービス機能ではWEBアプリケーション機能で採用しているFORM認証ではなく BASIC認証で認証を行う BASIC認証を行うための設定を記載 web.xmlに追記するみたい MEMO: 他のフレームワークでBASIC認証を行う方法について整理 9.3.2 データクラス（DTO） クライアントからのリクエストをJavaオブジェクトに変換する際に受け皿クラスを作成 @XMLRootElementアノテーションなどを不要しないと行けないらしく、不便そう 9.3.3 Application サブクラス 作成するリソースクラスなど、JAX-RSで使用する一連のファイルをJAX-RSランタイムに通知するためにApplicationサブクラスをクラスパス上に配置 このファイルの存在により、作成するリソースクラスをRESTful Webサービスとして公開できる ApplicationConfig.javaに@ApplicationPath(&quot;xxxxxx&quot;)を指定することでOK 9.4 RESTサービスクラス（サーバー側）の作成9.4.1 リソースクラスの構成要素 RESTful Webサービスで提供する処理を定義するRESTサービスクラスを作成します。 RESTではすべてをリソースとして扱うため、リソースクラスとも呼ばれる MEMO: Springの場合、Controller 9.4.2 エンドポイントURIの設定 @Path(&quot;{id}&quot;) などと指定 9.4.3 HTTPメソッドとリソースメソッドのバインド @GET,@POSTなどを指定 9.4.4 メッセージボディのデータ形式指定 @Consumes({}): クライアントから受け取るデータ形式 @Produces({}): クライアントに返却するデータ形式 MINEタイプの抽象化：javax.ws.rs.core.MediaType APPLICATION_XML = &quot;application/xml&quot;; などの定義がある Column コンテンツネゴシエーション クライアントがサーバーにリクエストする際に、返してもらいたいメッセージボディのデータ形式やエンコード方式などをリクエストヘッダーで要求できる これを「HTTPコンテンツネゴシエーション」といいます。 コンテンツネゴシエーションはAcceptヘッダーに要求するデータ形式を指定して行う 要求されたデータ形式をサーバーが提供できない場合、「406 Not Acceptable」のステータスコードをクライアントに返す Accept-Charsetヘッダー、Accept-Languageヘッダー、Accept-Encodingヘッダーなど MEMO: 見たことはあったが用語として抑えれてなかったので覚えておく メッセージボディとJavaオブジェクトとのマッピング アンマーシャル：javax.ws.rs.ext.MessageBodyReader マーシャル：javax.ws.rs.ext.MessageBodyWriter 9.4.5 リクエスト情報のインジェクション `@javax.ws.rs.PathParam`アノテーション：{id}などのパスパラメータを取得 `@javax.ws.rs.QueryParam`アノテーション：クエリパラメータを取得 `@javax.ws.rs.MatrixParam`アノテーション：URIのマトリクスパラメータを取得する `@javax.ws.rs.FormParam`アノテーション：HTMLのフォームから送信された情報を取得する `@javax.ws.rs.HeaderParam`アノテーション：リクエストヘッダーから値を取得する `@javax.ws.rs.CookieParam`アノテーション：リクエストのCookieヘッダーから値を取得する `@javax.ws.rs.core.Context`アノテーション：リクエストURIやリクエストヘッダー、セキュリティ情報などのコンテキスト情報を取得する汎用的なアノテーション `@javax.ws.rs.BeanParam`アノテーション：リクエストのパラメータ一式をビーンとして取得する `@javax.ws.rs.DefaultValue`アノテーション：対象に値が入らなかった場合、デフォルト値を指定するアノテーション 9.4.6 リクエストのメッセージボディの受取 リクエストの引数にアノテーションを付与しなければ、メッセージボディを受け取れる 9.4.7 入力チェック リクエストのメッセージボディにマッピングしているJavaオブジェクトをバリデーションするには@Validアノテーションを使用する 9.4.8 レスポンスの定義 return する時に javax.ws.rs.core.Responseクラスを用意している Response.created(URI.create(&quot;/knowledge&quot; + knowledge.getId())).build() みたいな感じで生成して返却する レスポンスメッセージボディのみを指定するときは、Response型以外のオブジェクトを戻り値にするとよい エンティティプロバイダ（MessageBodyWriterインターフェース実装クラス）がリクエストのAcceptヘッダーに指定されているデータ形式に変換し、レスポンスのメッセージボディに書き出します 成功時のレスポンスにメッセージボディが含まれている場合、「200 OK」 メッセージボディが含まれていない場合、「204 No Content」 MEMO: レスポンスの 204 No Contentは覚えておく 9.5 HTTPメソッドに応じた処理9.5.1 ナレッジの検索（GETメソッドによる操作）9.5.2 ナレッジの登録（POSTメソッドによる操作）9.5.3 ナレッジの更新（PUTメソッドによる操作）9.5.4 ナレッジの削除（DELETEメソッドによる操作）9.5.5 例外クラス JAX-RSの例外クラスを使用する JAX-RS2.0の例外体系 非チェック例外である、WebApplicationExceptionを用意している コンストラクタにステータスコードを指定すると、アプリケーションからスローされた際にステータスコードを含んだResponseインスタンスをクライントに返す 何も指定しなかったら 500 Internal Server Error JAX-RS2.0ではこのクラスを継承した例外クラスが追加された ClientErrorExceptionを継承した例外クラス BadRequestException(400) NotAuthorizedException(401) ServerErrorExceptionを継承した例外クラス InternalServerErrorException(500) ServiceUnavailableException(503) MEMO: 他のフレームワークでもこの標準エラーを使用しているような気がする。あとで確認しておく 独自例外の作成方法 RuntimeExceptionを継承して例外クラスを作成 マッパークラスを作成し、JAX-RSに認識させる MEMO: 独自例外を作成することは必ず必要になってくるので、ここ後で見返しておく Responseが持っているステータスについても覚えておく MEMO: 標準提供の例外をマッピングすることも可能！ 標準のExceptionはステータスコードしかクライアントに返却しないため、ここでマッピングして再定義しておくと、メッセージも合わせて返却できるということ 9.6 RESTクライアントクラス（クライアント側）の作成9.6.1 データクラス（DTO）9.6.2 RESTクライアントクラス MEMO: Javaクライアント側でJAX-RSのWebサービスを利用したい場合の実装方法 BASIC認証にサードパーティのクラスを使う 9.7 メッセージフィルタクラス9.7.1 メッセージフィルタとエンティティインターセプタ JAX-RS2.0では新たに、 メッセージフィルタ：リクエスト/レスポンスヘッダーの編集などに使用 エンティティボディインターセプター：エンティティボディの編集などに使用 割愛 MEMO: Logging用のフィルタの実装について考える ベストプラクティスは？ FileterとInterceptorの違いhttps://meetup-jp.toast.com/698 9.8 まとめ JAX-RS アノテーションでRESTful-Webサービスを作成できる Chapter10 バッチアプリケーションの開発JavaEE7では、Javaにおけるバッチ処理の標準化仕様が盛り込まれました。 この仕様はJSR352(Batch Applications for the Java Platform)で規定されている 通称「jBatch」と呼ばれている 10.1 jBatchの基本10.1.1 バッチ処理とその特徴 バッチ処理とは 複数のデータや複数の処理を一括して実行する方式のこと 一方、Webブラウザなどの画面を介して入力と応答が繰り返される処理をリアルタイム処理、オンライン処理と呼ぶ 特徴 一度に多くのデータが処理される 実行時間が長い 非対話型（人間による画面での入出力操作を伴わない） リクエストに従って起動されることよりも、実行する時刻を指定して起動されることが多い 10.1.2 jBatchとは jBatchとは 前項で述べたような特徴を持つバッチ処理をJava言語で実装するためのフレームワーク 業務システムにおけるバッチ処理は、全体的な処理の流れや設計時に注意すべきポイントなど、 時代や言語を伴わない共通点が多く見られる jBatchはこうした業務システムのバッチ処理似求められる要素を盛り込んだ「以前から培われている雛形」を標準として提供 jBatchを使わなくてもバッチ処理を実現できるが、活用することで、理解が容易で考慮漏れの少ないバッチ処理を効率よく提供刷ることができる jBatchの機能と構成要素 大まかに言うと ジョブ ステップ で構成される ジョブ：全体の流れを記述 ステップ：ここの処理を実装する ジョブとステップの分離により、業務の変更に対して柔軟に対応できる仕組みになっている jBatchのアーキテクチャはオープンソースのSpringBatchから多くを受け継いでいるが ジョブとステップの分離は、メインフレーム時代から受け継がれているもの メインフレームでは、全体の流れはジョブとしてJCLによって記述され、 業務ロジックはステップとして、COBOLやPL/Iなどの言語で記述されたプログラムを用いて実装される jBatchの機能と構成要素 jBatchにはジョブとステップ以外にいくつか保s所的な機能がある リスナ：ジョブやステップの開始直前または終了直後に処理を差し込む ジョブリポジトリ：ジョブやステップの状態を永続的に保持する コンテキスト：一時的に保持する メトリック：統計的な情報を確認刷る 10.1.3 ジョブ ジョブはステップの入れ物 １つのジョブの中には１つ以上のステップが必要 XMLで記述する 各ステップの呼び出し先クラス 実行順序 ジョブ全体や各ステップに対する設定、エラー発生時の挙動なども記述 記述のルールを示した仕様は、JSL(Job Specification Language)と呼ばれる ジョブを記述したXMLファイルはJob XMLファイルと呼ばれる JSLには処理の実行順序を制御するために、以下のXML要素が用意されている フロー（flow） スプリット（split） デシジョン（decision） 遷移要素（Transition Elements） 全体図が記載されている（書籍を見たほうが良い） フロー：複数のステップをまとめる要素 スプリット：複数のフローを同時実行させることができる デシジョン：ジョブ内部で次の遷移先を細かくカスタマイズするための機能 遷移要素 next: 遷移先には、ステップ、フロー、スプリット、デシジョンが指定できる end: 正常終了 stop: 中断 fail: 異常終了 リトライとスキップ リトライ：チャンク型ステップの処理中に特定の例外が発生した場合に、再度そのデータの処理を試みる スキップ：チャンク型ステップの処理中に特定の例外が発生した場合に、データを飛ばして次に進む リトライもしくはスキップ対象の例外クラスをJob XMLの中に定義 ジョブオペレータ ジョブ自体の開始や停止の全体的な制御を行う ジョブオペレータの呼び出し方法 バッチ処理の特徴として、「実行する時刻を指定して起動されることが多い」という点をあげたが、 jBatchの仕様にはバッチを決まった時間に起動する方式に関する規定や、それを実現するAPIも含まれていない この部分に関しては、ジョブスケジューラを連携させる方式が一般的に Linuxなどであればcron Windowsであればタスクスケジューラ その他市販のジョブスケジューラを使用する…など ジョブを臨時で実行したい場合や、何らかの異常が発生し、人間が介入して原因を取り除いたあとに再実行する場合は、リクエストに従って起動することになります。（これを「アドホックな実行」と呼びます） そういった場合、画面などのユーザーインターフェースがあると便利だが、この点に関してもjBatchは規定ない 実装する際には、オペレータの運用も考える必要がある MEMO: 手動実行されたジョブか、スケジュールで実行されたジョブかを識別する方法を仕込んでおいた方が良いと思った 10.1.4 ステップ バッチ内部の個々の処理を実装する部分 ステップの実態は、jBatchのAPIの中で定義されているJavaインターフェースであり、実装テンプレートを提供している ステップには２種類ある チャンク型：複数のデータを逐次的に処理するために使われる ItemReader,ItemProcessor,ItemWriterの３つで構成される ItemReaderとItemProcessorを繰り返したあと、ItemWriterが呼ばれる（デフォルトで１０回） この塊（１０回などの処理の塊）をチャンクと呼ぶ バッチレット型：単体で完結する処理で使われます データの加工や計算を１件ずつ繰り返すような処理ではなく、データに依存しない処理やコマンド実行などの処理を担います。 例えば、ディレクトリ作成やファイル圧縮、送受信処理などの処理 「タスク志向のステップ」と呼ばれる場合もある MEMO: このような単純な処理であれば、スクリプトで完結しそうな気もする.. 10.1.5 補助機能 リスナ リスナを用いることで、バッチ処理の進行に応じた特定のタイミングで任意の処理を実行することができる 「特定のタイミング」には、ジョブやステップの開始及び終了、リトライやスキップの発生などがある 各処理のタイミングごとにリスナが用意されている リスナの設置は任意で、設置したい場合、リスナのクラス名をJob XMLの中で記述 ジョブリポジトリ：開発者が意識して操作したりしない部分みたい 実行中のジョブの情報や、実行が終わったジョブに関する情報が保存される 情報の更新はコンテナによって自動的に行われ、情報の取得は、前述のジョブオペレータや、後述するコンテキスト、メトリックAPIを利用する コンテキスト 種類 ジョブコンテキスト ステップコンテキスト それぞれ、実行中のジョブやステップに関する情報を提供する役割を担う 名前やID、ステータスなどがある コンテキストへのアクセスは、jBatchAPIのJobContext、StepContextインターフェースを経由して行います メトリック チャンク型のステップに対して、実行時の統計情報を提供するのがメトリック 情報 読み取りレコード数 書き込みレコード数 スキップが発生した数 など、処理量に関するもの メトリックへのアクセスには、jBatchAPI似あるMetricインターフェースを経由して行う 10.2 jBatchの利用――基本編 実際に実装してみる JobXMLの実装 チャンク型ステップの実装 バッチレット型ステップの実装 ジョブ実行部分の実装 実行結果の確認 10.2.1 JobXMLの実装 バッチの全体を表すJobXMLを作成刷る ファイル名から拡張子を取り除いた部分がそのままジョブの名前となります。 ジョブの名前は実行時にJobOperatorクラスのメソッドにわたす形で利用される それぞれの要素説明 job step chunk batchlet 10.2.2 チャンク型ステップの実装10.2.5 バッチレット型ステップの実装 Batchletを実装 prosess,stopを実装して処理を書くだけ 保守性を高い状態に保つためにも、１機能の実装にとどめておくべき 10.2.6 ジョブ実行部分の実装 JobInstanceとJobExecution 最初にジョブを実行すると、コンテナ内部ではこの２つのインスタンスが生成ｓ荒れる JobInstanceはジョブの１回分を表現 JobExecutionはジョブの実行そのものを表現している パッケージング jBatchでもWebアプリケーションと同様に、構成するファイル群をwarファイル形式にまとめてコンテナにデプロイ刷る ここで注意が必要なのは、JobXMLファイルの配置場所 JobXMLは、warファイル内部のWEB-INF/classes/META-INF/batch-jobsディレクトリの配下に「ジョブ名.xml」という名前で配置しなければ行けない MEMO: パッケージングする際には一般的にどのようにしているか確認、Gradleとかの前処理で調整している？ 10.2.7 実行結果の確認バッチログを掲載 10.3 jBatchの利用――応用編10.3.1 サンプル概要 ナレッジ件数ランキング集計バッチ コメント件数ランキング集計バッチ Column キーブレイク処理について マスタ表から１件読み込み、トランザクション表を操作して処理するという一連の流れ 業務におけるバッチ処理では大変多く見られるパターンの１つ jBatchのチャンク形式のステップは、このようなキーブレイク処理を念頭においたものと言えるので、本書でも取り上げた MEMO: チャンク形式が業務で応用されている例を確認しておくべき SQL一本で済ませる場合が多いのでは？ 10.4 ジョブの作成10.4.1 Job XMLの実装 property要素を利用する方法を記載 感覚的にはmavenみたいな感じ 10.4.2 チャンクの実装※実際に実装刷る際に必要なった時に見返す 10.5 ジョブのフロー制御※実際に実装刷る際に必要なった時に見返す 10.6 まとめ 終了！","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/categories/JAVA/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"}]},{"title":"Web製作者のためのSassの教科書","slug":"2020-04_Web製作者のためのSassの教科書","date":"2020-04-08T15:00:00.000Z","updated":"2020-04-26T03:36:09.892Z","comments":true,"path":"CSS/2020-04_Web製作者のためのSassの教科書/","link":"","permalink":"http://yoursite.com/CSS/2020-04_Web製作者のためのSassの教科書/","excerpt":"","text":"Web製作者のためのSassの教科書1234567891011121314151617・Sassって聞いたことはあるけど、導入が面倒そう・Sassをはじめたいけど、あと一歩が踏み出せない・勉強コストとの天秤にかけて、Sassのメリットが見えない・周りでSassを使いはじめた人がいて、焦りを感じている・CSSを今よりも効率的に書きたいと思っているこうした方がSassを導入するきっかけとなり、ひと通りSassの機能を使いこなせるようになるのが本書の目標です。本書では、HTML+CSSの基本的な知識は必須ですが、Sassにまったく触れたことがない方も対象としています。CSSをHTMLの構造に合わせて入れ子で書いていく「ネスト」や便利な「変数」や「演算」などのSassの基本機能はもちろん、筆者が実際に仕事の現場で使っている実践的なテクニックから新機能もカバーした全機能リファレンスまで、この一冊で網羅しています。 発売日：2017/9/15 ページ数：296 サイズ：B5変形判 著者：平澤 隆（Latele） 著/森田 壮 著 ISBN：9784295002352 URL: https://book.impress.co.jp/books/1117101020 目次 第1章 Sassのキホン 第2章 Sassの利用環境を整えよう 第3章 これだけはマスターしたいSassの基本機能 第4章 高度な機能を覚えてSassを使いこなそう 第5章 現場で使える実践Sassコーディング 第6章 もっとSassを便利にするフレームワークやツール 第7章 Sass全機能リファレンス 公式サポートサイト：https://book2.scss.jp/ 第1章 Sassのキホン1-1 まずはSassって何なのかを知ろう Sassは学習コストもあるけれど、CSSを覚え始めた頃のワクワク感や楽しさを思い出させてくれるよっている説明 Sass＝CSSを拡張したメタ言語 Sass(Syntactically Awesome Strylesheets) Sassには２つの記法がある SASS記法：CSSと互換性が無い。インデントの深さで分ける SCSS記法：CSSと互換性がある。ネストで記載 SCSSファイルはコンパイルが必要だよという説明 魅力的な機能 記述の簡略化（ネスト） コメントに、//が使える！ 変数定義で同じ値を使い回すことができる １度使ったセレクタを使い回せる（エクステンド） コードの再利用が可能 スタイルをまとめてテンプレートやモジュールのように定義し、簡単に読み込んで使うことができる ミックスインと呼ばれており、Sassの中でも最も強力な機能の１つ １つのCSSファイルにまとめることができる（パーシャル） 条件分岐などのプログラム的な処理ができる 関数で様々な処理を実行できる Sassにはかなり多くの関数が用意されている CSSファイルを圧縮できる 他にも魅力が沢山 Sassの歴史について説明（割愛） 1-2 Sassを導入する前の疑問や不安 環境構築に黒い画面を操作することに対しての不安説明 運用時にSassは導入ハードルが高いのではという不安説明 expandedというフォーマットがあり、これを指定してコンパイルすると、普通にCSS書いたみたいになる //コメントは削除されてしまう なので納品後はCSS編集という運用でも問題ない 1-3 何はともあれSassを触ってみよう 使ってみる 「SassMeister」で検索 https://www.sassmeister.com meister = 師匠 Sassを入力するとCSSが出力されるプレイグラウンド Sassに対応しているソースコード共有サービス CodePen Create a new Fiddle - jsFiddle jsdo.it Share Javascript, HTML5 and CSS HTML5, CSS3, JS Demos, Creations and Experiments | CSSDeck 第2章 Sassの利用環境を整えよう2-1 本書で使用する環境について 本書では、node-sasssを使用する Sassは大きく分けて２つのSassが存在する Ruby Sass：Rubyで開発されたもの LibSass：C/C++で開発されたもの node-sass LibSassをNode.jsで動作できるようにしたライブラリ Node.jsについて：Javascriptで作られたサーバーサイド環境 Gulp: タスクランナー 2-2 Node.jsをインストールする Webからインストールする手順を記載 バージョン管理ツールの説明 Windowsならnodist Macならndenv 2-3 黒い画面を使ってみよう コマンドプロンプトを開く手順を記載しているだけ（割愛） 2-4 セットアップ済みの環境をインストールする サンプルファイルコピー https://book2.scss.jp/dl/c2/ gulp-cliをインストール npm install --global gulp-cli モジュールをインストールする npm install 2-5 Sass をコンパイルする gulpfile.jsに記載された処理を実行 gulp sass アウトプットスタイルを指定 Nested Expanded Compact Compressed ファイルの更新を監視する gulp.watch(&#39;./sass/**/*.scss&#39;,[&#39;sass&#39;]); 2-6 セットアップ済みの環境を作成する方法 npm と gulp の説明(割愛) gulpfile.jsのジェネレータについて https://steelydylan.github.io/gulp-generator/ 2-7 GUIコンパイラ（Prepros）でSassを使う https://prepros.io/ 割愛する 2-8 DreamweaverでSassを使う 割愛する 第3章 これだけはマスターしたいSassの基本機能3-1 ルールのネスト（Nested Rules） ネストでCSS定義ができる セレクタも使える 使いすぎるとインデントが深くなり可読性が悪くなる @mediaのネストもできる 3-2 親セレクタの参照&amp;（アンパサンド） &amp;を使えば親セレクタを参照できる BEMやMindBEMingなどBEMの設計思想に近いCSS設計を行っている場合、記述量が大幅に削減される 3-3 プロパティのネスト（Nested Properties） プロパティもネストさせてかけるよっていう説明 ショートハンドでかけるところをネストさせる 慣れないうちは可読性が下がる原因にもなるので、普通に書いたほうが無難 Column: -(ハイフン)があるプロパティはすべてネストできる 3-4 Sassで使えるコメント javascriptのコメント//が使える 通常のCSSコメント /* */ だとコンパイルされても残る スタイルが「compressed」だとコメントは残らない 「compressed」でも残るコメント /*! */ !を追加すれば残るらしい 3-5 変数（Variables） 変数宣言ができる 12// 赤色の変数を宣言$red: #cf2d3a; 変数名で使える文字と使えない文字 1234567891011121314$width10: 10px;$w-10: 10px;$w_10: 10px;$Ｗｉｄｔｈ１０: 10px;$横幅10px: 10px;$１０px: 10px;$___w10___: 10px;$-_-______----w:10px;$変数はSassの便利な機能の１つです:black;// 使えない文字$10width: 10px; // 数字から始まっている$@width10: 10px; // @など使えない記号$--width: 10px; // 連続したハイフンから始まっている ルールセット内で変数を宣言することもできる 変数を参照できる場所 セレクタから参照したり、他の文字列と結合してパスを作成したい場合などに気をつける必要あり 123456$セレクタ名: '.pickupContentsArea, section.main';$IMG_PATH: '../img/bg/';#&#123;$セレクタ名&#125; &#123; background-color: url(#&#123;$IMG_PATH&#125;pickup.png);&#125; 3-6 演算 + - * %などの演算子が使える コンパイル後は、演算結果が出力される 12345// paddingの値が変わった時に変数として持っておくとwidthに反映できるarticle &#123; $padding: 7px; width: $main_width - $padding * 2;&#125; 色の演算も算術演算子でできるが将来的には廃止予定らしい rgba()を使おうとのこと 3-7 Sassの@import SassではCSSで使える@importの他に、Sass独自の@import機能がある CSSファイルを生成しないパーシャル importしたSassファイルなど、特定のSassファイルをCSSファイルとして生成したくない場合、 Sassファイルのファイル名の最初に_アンダースコアをつけることで、コンパイルしてもCSSファイルが生成されなくなる この機能のことをパーシャル(partial)という 第4章 高度な機能を覚えてSassを使いこなそう4-1 スタイルの継承ができるエクステンド（@extend） エクステンド＝指定したセレクタのスタイルを継承することができる機能 あまり継承しすぎると、プロパティがバッティングしてしまう可能性が高くなる エクステンドの連鎖 継承を連鎖して記載可能 エクステンドが使えないセレクタの紹介 .item p 子孫セレクタ #main &gt; article 子セレクタ h2 + h3 隣接セレクタ h3 ~ h3 間接セレクタ 1234567891011// 子孫セレクタ.item p &#123; ... &#125;// 子セレクタ#main &gt; article &#123; ... &#125;// 隣接セレクタh2 + h3 &#123; ... &#125;// 間接セレクタh3 ~ h3 &#123; ... &#125; エクステンド専用のプレースホルダーセレクタ 123456789101112131415// エクステンド専用のプレースホルダーセレクタ%boxBase &#123; padding: 15px; border: 1px solid #999;&#125;// プレースホルダーセレクタを継承.item &#123; @extend %boxBase; margin-bottom: 20px;&#125;section &#123; @extend %boxBase; margin-bottom: 60px;&#125; @media内ではエクステンドは使用できない 123456789101112131415161718192021222324// これはコンパイルエラーになってしまう%btnBase &#123; display: inline-block; padding: 5px 10px; background: #eee;&#125;@media all and (orientation:landscape) &#123; a &#123; @extend %btnBase; &#125;&#125;// こちらに書き直すとうまくいく@media all and (orientation:landscape) &#123; %btnBase &#123; display: inline-block; padding: 5px 10px; background: #eee; &#125; a &#123; @extend %btnBase; &#125;&#125; 警告を抑止する !optionalフラグ 123.btn &#123; @extend %btnBase !optional;&#125; 4-2 柔軟なスタイルの定義が可能なミックスイン（@mixin） スタイルの集まりを定義しておき、それを他の場所で呼び出して使うことができる また、引数を指定することで、定義したミックスインの値を一部変更して使うといった、非常に柔軟で強力な処理が可能 12345678910// ミックスインを定義@mixin boxSet &#123; padding: 15px; background: #999; color: white;&#125;// 定義したミックスインを呼び出し.relatedArea &#123; @include boxSet;&#125; エクステンドと違ってコンパイル後に、展開されて出力されることを確認 12345678// 定義したミックスインを呼び出し.relatedArea &#123; @include boxSet;&#125;// 別のルールセットでも呼び出し.pickupArea &#123; @include boxSet;&#125; 12345678910.relatedArea &#123; padding: 15px; background: #999; color: white;&#125;.pickupArea &#123; padding: 15px; background: #999; color: white;&#125; 引数を使ったミックスイン 123456789101112131415// 引数を使ったミックスインを定義@mixin kadomaru($value) &#123; -moz-border-radius: $value; -webkit-border-radius: $value; border-radius: $value;&#125;.box &#123; @include kadomaru(3px); background: #eee;&#125;.item &#123; border: 1px solid #999; @include kadomaru(5px 10px);&#125;// 可変でプロパティを定義できる 引数に初期値を設定することもできる 12345678910111213@mixin kadomaru($value: 3px) &#123; -moz-border-radius: $value; -webkit-border-radius: $value; border-radius: $value;&#125;.boxA &#123; @include kadomaru; background: #eee;&#125;.boxB &#123; @include kadomaru(); background: #f1f1f1;&#125; 123456789101112.boxA &#123; -moz-border-radius: 3px; -webkit-border-radius: 3px; border-radius: 3px; background: #eee;&#125;.boxB &#123; -moz-border-radius: 3px; -webkit-border-radius: 3px; border-radius: 3px; background: #f1f1f1;&#125; 引数を複数指定することもできる 12345678910111213@mixin boxBase($margin: 30px 0, $padding: 10px) &#123; margin: $margin; padding: $padding;&#125;.boxA &#123; @include boxBase; background: #eee;&#125;.boxB &#123; @include boxBase(0 0 50px, 20px); background: #f1f1f1;&#125; ,(カンマ)を使うプロパティには可変長引数を利用する 1234567@mixin shadow($value...) &#123; text-shadow: $value;&#125;h2 &#123; @include shadow(8px 8px 0 #999, 15px -10px 0 #eee);&#125; 複数の引数があるミックスインを読み込む際に可変長引数を使う 12345678910111213@mixin boxBase($w: 250px, $pd: 15px, $bg_c: #fff, $bd_c: #ccc) &#123; width: $w; padding: $pd; background-color: $bg_c; border: 1px solid $bd_c;&#125;$values: 300px, 20px; // こういう変数定義もできるんだと知った.item &#123; float: left; @include boxBase($values...);&#125; ミックスインのスコープ（利用できる範囲）を制限する 123456789.main &#123; @mixin margin &#123; margin: 50px 0; &#125; .item &#123; @include margin; &#125;&#125;// あまりスコープを制限する例は無いが一応覚えておく ミックスインにコンテントブロックを渡す @content →これは便利！ 123456789101112131415161718192021@mixin media($width-media: 768px) &#123; @media only screen and (max-width: $width-media) &#123; @content; &#125;&#125; .item &#123; .image &#123; float: left; @include media &#123; float: none; &#125; &#125; .text &#123; overflow: hidden; margin-left: 15px; @include media &#123; margin-left: 0; &#125; &#125;&#125; 1234567891011121314151617181920.item .image &#123; float: left;&#125;@media only screen and (max-width: 768px) &#123; .item .image &#123; float: none; &#125;&#125;.item .text &#123; overflow: hidden; margin-left: 15px;&#125;@media only screen and (max-width: 768px) &#123; .item .text &#123; margin-left: 0; &#125;&#125; ミックスイン名で使える文字と使えない文字 123456789101112@mixin shadow1 &#123; ～ &#125;@mixin shadow-1 &#123; ～ &#125;@mixin shadow_1 &#123; ～ &#125;@mixin 影 &#123; ～ &#125;@mixin ｓｈａｄｏw &#123; ～ &#125;@mixin _shadow &#123; ～ &#125;@mixin -shadow &#123; ～ &#125;// 使えない文字@mixin 01shadow &#123; ～ &#125; // 数字から始まっている@mixin shadow@2 &#123; ～ &#125; // @など使えない記号@mixin --shadow &#123; ～ &#125; // 連続したハイフンから始まっている 4-3 ネストしているセレクタをルートに戻せる @at-root あまり使い所が無いと感じたが、使える場面があるらしい 12345678.block &#123; .element-A &#123; width: 80%; &#125; @at-root .element-B &#123; width: 100%; &#125;&#125; 1234567.block .element-A &#123; width: 80%;&#125;.element-B &#123; width: 100%;&#125; 使い所は５章で確認する 4-4 Sassのデータタイプについて Sassのデータ・タイプについて 12345678910111213141516171819.DataTypes &#123; /* Number型 */ property: type-of(10%); /* Color型 */ property: type-of(red); /* String型 */ property: type-of(sans-serif); /* Boolean型 */ property: type-of(true); /* Null型 */ property: type-of(null); /* List型 */ property: type-of(1.5em 1em 0 2em); /* Map型 */ $map:(key1: value1, key2: value2); property: type-of($map); /* Function型 */ property: type-of(get-function(\"lighten\"));&#125; 123456789101112131415161718.DataTypes &#123; /* Number型 */ property: number; /* Color型 */ property: color; /* String型 */ property: string; /* Boolean型 */ property: bool; /* Null型 */ property: null; /* List型 */ property: list; /* Map型 */ property: map; /* Function型 */ property: function;&#125; 123456@function example($value) &#123; @if type-of($value) == number &#123; 処理 &#125;&#125;// typeで判断して関数を作れますよという説明 4-5 制御構文で条件分岐や繰り返し処理を行う @if,@for,@while,@eachを使って表現 4-6 関数を使ってさまざまな処理を実行する Sassには予め用意された関数がある 使用頻度の高いものをピックアップして紹介 参照 https://book2.scss.jp/code/c4/06.html 4-7 自作関数を定義する@function 自作関数の定義方法 そんなに変わったことはしていない 12345678910$width: 105px;@function halfSize($value:$width) &#123; @return round($value / 2);&#125;.boxA &#123; width: halfSize();&#125;.boxB &#123; width: halfSize(200px);&#125; 4-8 テストやデバックで使える@debug、@warn、@error 変数のデバッグに使用できる機能もある 1@debug 10em + 12em; 1test.scss:1 DEBUG: 22em 1234567891011121314151617181920212223242526272829// WARNで警告$value: 1000px;@function warnTest()&#123; @if unitless($value) &#123; $value: $value + px; &#125; @else &#123; @warn \"#&#123;$value&#125;は駄目！$valueに単位は入れないで！\"; &#125; @return $value;&#125;.box &#123; width: warnTest();&#125;// ERROR で処理を中断$value: 1000px;@function errorTest()&#123; @if unitless($value) &#123; $value: $value + px; &#125; @else &#123; @error \"#&#123;$value&#125;は駄目！$valueに単位は入れないで！\"; &#125; @return $value;&#125;.box &#123; width: errorTest();&#125; 4-9 使いどころに合わせて補完（インターポレーション）してくれる#{} インターポレーションとは 変数が参照できない場所でも使うことができるようにする機能 #{}←これ 演算しないようにする font: #{$font-size}/#{$line-height} 演算できない場所で演算する .mt#{$i * 5} { 4-10 変数の振る舞いをコントロールする !default と !global !defaultフラグ デフォルト値とは上書きされることを前提にした変数の初期値 このフラグを使用していると、先に宣言されている変数が優先される →ライブラリで使用しているの確認済み。よく使われる !globalフラグ ローカル変数をグローバル変数にするフラグ グローバル変数とはドキュメントルートで宣言した、どこからでも参照できる変数のこと ネスト内からグローバル変数を上書きしたい場合や、ローカル変数をスコープ外から参照したい場合などに使用する 第5章 現場で使える実践Sassテクニック5-1 管理／運用・設計で使えるテクニック ネストが深すぎると生じる問題を把握して、バランスを見ながら利用する ネストが深すぎて可読性が落ちてしまう セレクタが長くなってしまうことの弊害 CSSが肥大化する Column: ネストは何階層までがよいか 2～3階層程度にするのがよい HTMLのツリー構造に沿った形でCSSを指定するストラクチャタイプの設計の場合は、 ある程度ネストを深くしたほうがよい CSSとは違うパーシャルによるSassファイルの分割 _mixin.scssなど分けて作成して、@importでまとめる サイトの基本設定を変数にして一元管理する 複数人で制作する場合は各自のSassファイルを用意する Gitなどが汚れるのではとも感じる… コメントを活用してソースをわかりやすくする 大規模サイトで活用できる@importのネスト &amp;(アンパサンド)を活用してBEM的な設計を快適に 123456789.navigation &#123; width: 100%; &amp;__item &#123; color: #666; &amp;_state_active &#123; color: #000; &#125; &#125;&#125; @keyframesをルールセット内に書いて関係性をわかりやすくする 1234567891011.example &#123; @keyframes anima-example &#123; 0% &#123; transform: translate(0%, -100%); &#125; 100% &#123; transform: translate(0%, 0%); &#125; &#125; animation: anima-example 0.9s linear 500ms 1;&#125; @keyframesはルートに書き出してくれる 1234567891011.example &#123; animation: anima-example 0.9s linear 500ms 1;&#125;@keyframes anima-example &#123; 0% &#123; transform: translate(0%, -100%); &#125; 100% &#123; transform: translate(0%, 0%); &#125;&#125; EditorConfigとStylelintでコーディングルールを統一する EditorConfig：拡張機能を入れて、.editorconfigファイルを作成 Stylelint：拡張機能を入れる npm install --global stylelint .stylelintrcという設定ファイルをおけばOK Column: 他の人を思いやってSass設計をしよう 本書のシリーズ「Web製作者のためのCSS設計の教科書」はFLOCSS（フロックス）を提唱しているらしい 5-2 レイアウト・パーツで使えるテクニック clearfixをミックスインで活用する 12345678910111213141516171819@mixin clearfix &#123; &amp;::after &#123; content: \"\"; display: block; clear: both; &#125;&#125;// include.item &#123; @include .clearfix; background: #eee; .image &#123; float: left; width: 100px; &#125; .text &#123; float: left; &#125;&#125; 変数を使って、サイドバーの幅を自動的に計算する 123456789101112131415// 全体の幅$wrap-width: 960px;// メインエリアの幅$main-width: 640px;// サイドバーの幅$side_width: $wrap_width - $main_width - 20;#contents &#123; width: $wrap_width;&#125;#main &#123; width: $main_width;&#125;#side &#123; width: $side_width;&#125; nullで簡単に条件分岐してレイアウトする nullを指定するとコンパイルした時にプロパティごと生成されない calc と Sass を組み合わせて四則演算を便利に使う calcと組み合わせる際の注意点について @forを使って余白調整用のclassを生成する 12345678910111213141516171819202122$spaceClass: true !default;$spacePadding: false !default;$endValue: 10 !default;@if $spaceClass &#123; @for $i from 0 through $space_endValue &#123; .mt#&#123;$i * 5&#125; &#123; margin-top: 5px * $i !important; &#125; .mb#&#123;$i * 5&#125; &#123; margin-bottom: 5px * $i !important; &#125; @if $spacePadding &#123; .pt#&#123;$i * 5&#125; &#123; padding-top: 5px * $i !important; &#125; .pb#&#123;$i * 5&#125; &#123; padding-bottom: 5px * $i !important; &#125; &#125; &#125;&#125; 1234567891011121314151617181920.mt0 &#123; margin-top: 0px !important;&#125;.mb0 &#123; margin-bottom: 0px !important;&#125;.mt5 &#123; margin-top: 5px !important;&#125;.mb5 &#123; margin-bottom: 5px !important;&#125;...（略）....mt50 &#123; margin-top: 50px !important;&#125;.mb50 &#123; margin-bottom: 50px !important;&#125;// あまり作成しすぎるとCSSコード量も増えるので程々に リストマーカー用の連番を使った class名 を作成する 連番を使ったclass名のゼロパディング（0埋め）をする 文字リンクカラーのミックスインを作る 12345678910@mixin link-color2($n) &#123; color: $n; &amp;:hover &#123; color: lighten($n, 30%); text-decoration: none; &#125;&#125;a &#123; @include link-color2(#f00);&#125; 複数の値を@eachでループし、ページによって背景を変更する シンプルなグラデーションのミックスインを作る Map型と@eachを使ってSNSアイコンを管理する 値が比較しづらい z-index をMap型で一括管理する メディアクエリ用のミックスインを作成して楽々レスポンシブ対応 123456789101112131415161718192021222324$breakpoints: ( xs: \"only screen and (max-width: 320px)\", s: \"only screen and (max-width: 575px)\", m: \"only screen and (max-width: 767px)\", l: \"only screen and (max-width: 991px)\", xl: \"only screen and (max-width: 1199px)\",);@mixin media($breakpoint) &#123; @media #&#123;map-get($breakpoints, $breakpoint)&#125; &#123; @content; &#125;&#125;body &#123; background-color: white; @include media(l) &#123; background-color: blue; &#125; @include media(m) &#123; background-color: green; &#125; @include media(xs) &#123; background-color: red; &#125;&#125; 5-3 スマホ・マルチデバイス、ブラウザで使えるテクニック5-4 gulpのタスクを追加してもっと便利な環境にする パーシャルファイルを一括で読み込む ソースマップでコンパイル前のソース場所を知る エラー時にWatchを停止させずに、自動コンパイルを継続させる エラーに気づきやすくするために通知を出す 5-5 PostCSSでSassをさらに便利にする PostCSSとは Node.js製のCSSの変換ツール ベンダープレフィックスを自動付与する 対象ブラウザを確認するには https://browserl.ist/ 画像名だけで画像のパスやサイズを取得する CSSプロパティの記述順を自動でソートする 並び替えオーダーの種類 alphabetically smacss concentric-css バラバラになったメディアクエリをまとめてコード量を削減してスッキリさせる 第6章 もっとSassを便利にするフレームワークやツール6-1 Sassのフレームワーク紹介6-2 SassのGUIコンパイラ第7章 Sass全機能リファレンス7-1 Sassの基本と高度な機能7-2 Sassの関数一覧7-3 Sassの拡張付録コマンド一覧用語集","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"}]},{"title":"１分で話せ","slug":"2020-03_１分で話せ","date":"2020-02-29T15:00:00.000Z","updated":"2020-04-26T03:36:09.875Z","comments":true,"path":"EX/2020-03_１分で話せ/","link":"","permalink":"http://yoursite.com/EX/2020-03_１分で話せ/","excerpt":"","text":"１分で話せ 立ち読みレベル 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172プレゼンのゴールを設定する相手に動いて欲しいのか？相手に賛成、許可をして欲しいのか意見が欲しいのか、教えて欲しいのかロジカルな１分ストーリーを考える主張 結論がある複数の根拠がある 意味が結論に通じている根拠は３つ必要あのお店美味しいから行こう！じゃあ、美味しいお店は他にもあるよ、、あのお店美味しくて、安くて、雰囲気いいから行こう！そこまでいうなら行ってみようか！より聞き手に伝わるように削った文章を話す基本的に、は、例外を離さないならいらない念頭に、は、~すべく横文字は伝わりやすいか考える先ほど述べたように、も、いらない頑張ったことは話すな結論だけ話すこと！聞き手の数や会議室の広さを考えてパワポの文字サイズを考える1番後ろの席の人が見えるように聞き手が行動するもう一歩をイメージさせるポイントについての深掘りをするためにたとえば、具体的に、などで繋げて話す人は80%のことを聞いていないキチリクルンの例私という人間はどういう人間かを伝えることが大事覚えてもらうことが大事会社の上司に説明してもらうことが大事そのためには短い言葉で印象に残らせる必要がある人前で話すときの4つのポイント視線 しっかり相手を見る手振り 多少、動きをつける声 相手と対話するように声を届ける間合い 話の区切りで普段より3秒ほど長く間をとってみるメタ認知は優秀なビジネスパーソンに共通するスキル■人から話しかけられた時◯状況判断・目的は何なのか（連絡されるのか、相談されるのか、何かしてほしいのか）・相手の目的を満たす回答をする・この話はどれくらいかかるのかを考える（場合によっては後に回してもらう）■人に話しかける時◯目的別・報告、連絡・相談、解決策やアドバイスが欲しい・依頼、何かをして欲しい・説得、自分はこう思う、理由はこうです・雑談◯ジェスチャー、振る舞い・視線 しっかり相手の目を見る・手振り 多少動きをつける・声 相手に声を確実に届ける、聞こえているか、理解しているかを確認しないままだらだら話さない・間合い 話の区切りで3秒ほど長く間をとる◯構成・結論ファースト・要点をまとめておく◯振り返り・メタ認知・反省","categories":[{"name":"EX","slug":"EX","permalink":"http://yoursite.com/categories/EX/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"}]},{"title":"AngularWebアプリ開発スタートブック","slug":"2020-02_Angularアプリケーションプログラミング","date":"2020-02-14T15:00:00.000Z","updated":"2020-02-24T12:31:34.913Z","comments":true,"path":"EX/2020-02_Angularアプリケーションプログラミング/","link":"","permalink":"http://yoursite.com/EX/2020-02_Angularアプリケーションプログラミング/","excerpt":"","text":"Angularアプリケーションプログラミング 電子書籍購入 説明書 学習ログ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849こちらの書籍は 2019/06/19 紙版の3刷に対応するため更新をおこないました。（概要）本書は，JavaScriptの定番SPA開発フレームワーク「Angular」の解説書です。データバインディング，コンポーネント，依存性注入といったAngularを理解するための基本要素をはじめ，ディレクティブ／パイプ，フォーム，ルーティング，モジュール／コンポーネントの技術解説，ディレクティブ／パイプ／サービスの自作やテストなどの応用的なテーマまでを網羅。また，Angular 4に対応し，5以降のアップグレードにも留意した解説を行っています。Angularによる動的Webアプリケーション開発に必要となる知識が，この1冊で身に付きます！（こんな方におすすめ）・Angularを利用したSPAアプリケーション開発に興味のある人（目次）導入編第1章イントロダクション第2章Angular の基本第3章データバインディング基本編第4章標準パイプ／ディレクティブ第5章フォーム開発第6章コンポーネント開発第7章サービス開発応用編第8章ルーティング第9章パイプ／ディレクティブの自作第10章テスト第11章関連ライブラリ／ツールAppendixTypeScript簡易リファレンスフォーマット： Kindle版ファイルサイズ： 56752 KB推定ページ数： 838 ページ出版社: 技術評論社 (2017/8/4)販売： Amazon Services International, Inc.言語: 日本語ASIN: B074M54GM5Text-to-Speech（テキスト読み上げ機能）: 有効 X-Ray:有効Word Wise: 有効にされていませんカスタマーレビュー: 5つ星のうち 4.7 14件のカスタマーレビューAmazon 売れ筋ランキング: Kindleストア 有料タイトル - 21,411位 (Kindleストア 有料タイトルの売れ筋ランキングを見る)1165位 ─ 工学 (Kindleストア) 書籍情報ページhttps://wings.msn.to/index.php/-/A-03/978-4-7741-9130-0/","categories":[{"name":"EX","slug":"EX","permalink":"http://yoursite.com/categories/EX/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"}]},{"title":"AngularWebアプリ開発スタートブック","slug":"2019-12_AngularWebアプリ開発スタートブック","date":"2019-12-28T15:00:00.000Z","updated":"2020-02-24T12:29:25.706Z","comments":true,"path":"EX/2019-12_AngularWebアプリ開発スタートブック/","link":"","permalink":"http://yoursite.com/EX/2019-12_AngularWebアプリ開発スタートブック/","excerpt":"","text":"AngularWebアプリ開発スタートブック 電子書籍購入 学習ログ 書籍情報 著者 大澤 文孝 出版社 ソーテック社; B5変形版 (2018/4/7) 定価 3,025円 発売日 2018/4/7 ISBN-13 978-4-8026-1185-5 ISBN-10 4800711975 目次 Chapter1 Angularって何? Chapter2 開発環境を整えよう Chapter3 Angularプロジェクトを作ろう Chapter4 Angularの基本 Chapter5 入力フォームを作ってみよう Chapter6 入力エラーを検知するバリデータ Chapter7 リアクティブフォーム入門 Chapter8 さまざまな入力コントロール Chapter9 ページの割り当てと遷移 Chapter10 検索機能を実装する Chapter11 Webサーバで動かす サンプルプログラム http://www.sotechsha.co.jp/sp/1197/ こんな方に ○「将来、Webアプリ開発に取り組みたい」 ○「Angular特有の機能について学びたい」 ○「TypeScriptの作法について学びたい」 ○「新しいフレームワークの作法をざっと知りたい」 はじめに 次の２点を重点的に解説 Angularの動作の仕組み 何をどのような書式で記述しなければならないのか","categories":[{"name":"EX","slug":"EX","permalink":"http://yoursite.com/categories/EX/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"}]},{"title":"コンサル一年目が学ぶこと","slug":"2019_11_コンサル一年目が学ぶこと","date":"2019-11-02T15:00:00.000Z","updated":"2020-02-24T12:12:16.697Z","comments":true,"path":"EX/2019_11_コンサル一年目が学ぶこと/","link":"","permalink":"http://yoursite.com/EX/2019_11_コンサル一年目が学ぶこと/","excerpt":"","text":"コンサル一年目が学ぶこと 学習ログ 学んだこと 結論ファースト、PREP法で話す、言い訳から取り繕った話し方をしない（Talk Straight） 出来ないときは出来る方法を提案することが大事（何があればできるのか、何人いればできるのか、いつまでならできるのか） 相手の期待値を把握することの重要性 数値を用いて説明する 考えてから仕事を進める（道筋決めてから） ロジックツリーを使いこなす（ケース問題の紐解き方法と同じだと感じた） 「雲雨傘」提案法 事実、解釈、アクションの区別をつける 議事録のエッセンス（日時・場所・参加者・アジェンダ・決まったこと・決まらなかったこと・確認が必要な事・次回TODO・キーパーソンの意見） 説明資料はワンスライド・ワンメッセージの構成にすること 余計なことをやらない・価値のあることだけする しゃべらないなら会議に出るな コミットメント力の高い人の傍にいること フォロワーシップは部下としてのリーダーシップ 手に取った理由 コンサルタントとしての考え方の基礎的な要素が知りたかった","categories":[{"name":"EX","slug":"EX","permalink":"http://yoursite.com/categories/EX/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"}]},{"title":"Github実践入門","slug":"2019_03_Github実践入門","date":"2019-02-28T15:00:00.000Z","updated":"2019-08-05T15:15:35.106Z","comments":true,"path":"EX/2019_03_Github実践入門/","link":"","permalink":"http://yoursite.com/EX/2019_03_Github実践入門/","excerpt":"","text":"Github実践入門 学んだこと そもそも「Githubとは」という部分 Githubの基本的な使い方を手を動かしながら確認できた 途中、UIがそもそも変わっており、情報として古さを感じたため、さっと確認で済ませている 手に取った理由 業務でGitの構成管理方針を決定する立場となったため、今一度基礎から情報を取得する必要があると考えたため","categories":[{"name":"EX","slug":"EX","permalink":"http://yoursite.com/categories/EX/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"}]},{"title":"Azure実践ガイド","slug":"2019_03_Azure実践ガイド","date":"2019-02-28T15:00:00.000Z","updated":"2019-07-21T16:44:04.905Z","comments":true,"path":"Azure/2019_03_Azure実践ガイド/","link":"","permalink":"http://yoursite.com/Azure/2019_03_Azure実践ガイド/","excerpt":"","text":"Azure実践ガイド 学んだこと ※読書中.. 学習メモ 手に取った理由 業務でAzure環境を使用することになり、基礎知識を養うために購入","categories":[{"name":"Azure","slug":"Azure","permalink":"http://yoursite.com/categories/Azure/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"},{"name":"読書中","slug":"読書中","permalink":"http://yoursite.com/tags/読書中/"}]},{"title":"AmazonAlexa開発ガイド","slug":"2019_01_AmazonAlexa開発ガイド","date":"2018-12-31T15:00:00.000Z","updated":"2019-07-20T15:44:41.467Z","comments":true,"path":"AI/2019_01_AmazonAlexa開発ガイド/","link":"","permalink":"http://yoursite.com/AI/2019_01_AmazonAlexa開発ガイド/","excerpt":"","text":"AmazonAlexa開発ガイド 目次 Chapter 1 Amazon AlexaとAmazon Echo Chapter 2 Amazon AlexaとAWSの準備 Chapter 3 スキル開発入門 Chapter 4 スキルのデバッグから公開 Chapter 5 Webサービス連携アプリの開発 Chapter 6 スマートホームスキルの開発 Chapter 7 AVSを利用したアプリケーションの構築方法 Appendix SSML/CLI 学んだこと AmazonAlexaSkillKitを利用したスキル開発方法 AWS Lambda にサンプルをデプロイし実際に動作させる方法 AlexaSkillKitについての基礎知識 インテント・スロットなど SSML ※本書では、後半、AVSについても述べられているが、直近で必要な知識ではなかったため割愛 手に取った理由 Alexaスキル開発の基礎知識を習得するため 学習メモ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221# はじめに□付属データ（amazon_alexa_sample.zip）の内容付属データには、以下の内容が含まれています。Chapter2～7、Appendixで紹介しているサンプルデータChapter7の04節のコマンド入力用テキスト（一部修正用テキスト含む）Chapter5の02節（P.137）：補足資料1「Twitter developer accountへのアプリ登録」（PDFファイル）Chapter7の04節（P.210）：補足資料2「Raspberry Pi 3の初回起動時のセットアップ」（PDFファイル）Chapter7の04節（P.248）：補足資料3「Lチカを行うための配線」（PDFファイル）□付属データのテスト環境OS：macOS 10.13.5Node.js：8.11.1npm：5.6.0Alexa開発者コンソールURL https://developer.amazon.com/alexa/console/AWSURL https://aws.amazon.com/jp/ASK SDK for Node.js：2.0.5Amazon EchoデバイスAmazon Echo dotURL https://www.amazon.co.jp/dp/B072B5BTLKHomebrew: 1.6.7AVS Device SDK：1.8.1□Chapter7 04節で利用した機材サンワサプライUSBマイクロホンMM-MCU02BKURL https://direct.sanwa.co.jp/のサイトで「MM-MCU02BK」で検索Raspberry Pi 3（Model B）Raspberry Pi 3 Model Bケース+ヒートシンクhttps://www.physical-computing.jpのサイトで「Raspberry Pi 3」で検索ブレッドボード マイコンボード用実験パーツセット KP-PRTSET01URL http://eleshop.jp/shop/g/g402534/※補足1：上記の「ブレッドボード マイコンボード用実験パーツセット」には、ジャンプワイヤ（オス・オス）しかありませんので、別途ジャンプワイヤ（オス・メス）をご購入ください。ジャンプワイヤ（オス・メス）の購入先例例：ELEGOO 50 PCS オスメスジャンパーワイヤ200mm (無料 170 タイポイント ブレッドボード)URL https://www.amazon.co.jp/dp/B06ZZXH4XT/□Chapter7 04節に関するコマンドやリンク先（著者提供サイト）紙面コマンド &amp; リンクまとめURL https://gist.github.com/ShinjiKobayashi/1383691df9d43edd60267e44f6e2e923# Chapter 1 Amazon AlexaとAmazon Echo##### Echo Show2018/08時点では発売されていないがecho show という製品があったりする（画面がついている）スマートフォンやブラウザ上で実行できるAlexaアプリへカードを表示する機能はあるが、別のデバイスに取り出す必要があり、シームレスな体験でない##### Echo Look360度の3Dスキャンが可能な衣装のコーディネートの良し悪しを判断してくれる機能をもつ製品##### 車載AlexaBMWやToyotaがプレスリリース手がふさがっていてもVUIであれば操作可能##### Alexa Mobile Accessory KitスマートフォンのAlexaアプリを介してAlexaの機能を利用できるようにするアプリ##### Amazon LexAWSサービスAlexaに採用されている深層学習の技術と同等の技術を利用できるサービス### Alexaスキルキット（ASK）開発者がAlexaを通じて公開できるアプリケーションのような機能### Alexaの特色- スキルの種類 * カスタムスキル + 料理レシピやしりとりゲームな一般的なAlexaスキル + Alexaを通じて商品の購入ができるようになったりする * スマートホームスキル + カメラや証明、鍵等のスマートホームデバイスを制御するスキル * フラッシュブリーフィングスキル + ※言及なし## 02カスタムスキルの開発事例### Alexaスキルの動きを確認する##### インテント音声入力の内容を解釈して、キーワードに合わせたタグ付けのようなことを行い、対話モデルを作成##### スロット対話モデルをより柔軟に活用することができる（プログラミングにおける変数に近い役割）「*東京タワー*の天気を教えて」という発話があった場合、*東京タワー*がPlaceスロットに格納されて、インテントと同じくタグ付けされるこの要素を参照すれば、ユーザがどこの天気を知りたいのか把握できる##### マルチターン会話とダイアログまるで本当に会話している様に実装できる### Alexaスキルの開発事例##### 人気のあるスキルについてスキル順位を記載している##### ユーザーストーリーの作成##### スキルの目的を決める##### 明確なユーザ操作をイメージする## チャプターまとめ- Alexaを取り巻く世界観やスキルを用いて実現できること- Alexaの機能や大まかな挙動- スキル開発をするときに気をつけておくとよいこと# Chapter 2 Amazon AlexaとAWSの準備## 01Alexaの開発環境の準備※割愛### 全体の構成### Amazon開発者コンソールの登録方法### AWSの登録方法## 02Amazon Echo を使って Hello World### カスタムスキルの開発工程- Amazon開発者コンソールの設定- Lambdaの実装及び設定- 動作確認### Amazon 開発者コンソールの設定およびLambdaの実装1. スキルの基本情報設定2. Alexaデバイスの応答設定3. Lambdaの設定及び実装4. LambdaとAlexaデバイスの応答設定と紐付け～実際に操作してハローワールドを表示～# Chapter 3 スキル開発入門## 01カスタムスキルの開発方法### カスタムスキルの開発環境構築### カスタムスキル開発の基本- Amazon開発者コンソールの設定- Lambdaの実装### Amazon開発者コンソールの設定方法命令文をインテントと呼ばれるものに変換して該当のスキルにわたすアニマルブックスという架空のスキルを作成する例### Lambdaの実装方法npm install --loglevel=error ask-sdk-core ask-sdk-model##### 実装について見ていく### 対話型のカスタムスキル開発repromptを使用して「本のおすすめでよろしいですか？」と聞き返す実装### 会話内容の一部を扱うスキル開発##### スロットの実装## 02Alexaアプリにカードを表示させる### カードの表示Alexaではスキルでの発話と同時に発話内容の保管情報としてカードをAlexaアプリに表示することができます。- カードの種類 * シンプルカード * スタンダードカード## 03AudioPlayerでスキルを開発する### AudioPlayerとは- MP3などのオーディオファイルをストリーミング再生するAlexaの仕組み- 一時停止やシャッフル再生、ループ再生、キューイングなどもサポートしている- 再生状態をモニタリングするための仕組みもある- SSMLを用いることでオーディオファイルの再生をすることも可能だが、90秒の制限がある### AudioPlayerを使ったスキルを作成する# Chapter 4 スキルのデバッグから公開## 01Alexaスキルのデバッグ方法### Alexaスキルのデバッグ方法- Alexa Skill Testing Toolについての説明### Lambdaのデバッグ方法- Cloud Watchで設定する- ## Alexaスキルの公開方法## 多言語対応# Chapter 5 Webサービス連携アプリの開発## 01フラッシュブリーフィングの作り方### フラッシュブリーフィングスキルとは- 最新のニュースフィードを提供する機能- インストールされているフラッシュブリーフィングスキルから提供される最新のニュースフィードをすべて収集し、ユーザに対して収集したニュースを提供する- 作成手順について * フィード提供環境構築 * フィードの登録### フィード提供環境構築amzon api gatewayの設定で躓いた！！問いかけても「フラッシュニュースです」という内容しか返さない## 02外部サービス連携アプリの作り方(Twitter連携)※一旦とばす！# Chapter 6 スマートホームスキルの開発※一旦とばす！# Chapter 7 AVSを利用したアプリケーションの構築方法※一旦とばす！端末メーカー様のコネクテット製品に、 簡単にAlexaを実装するためのSDK# Appendix SSML/CLI","categories":[{"name":"AI","slug":"AI","permalink":"http://yoursite.com/categories/AI/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"}]},{"title":"徹底攻略AWS認定ソリューションアーキテクト-アソシエイト教科書","slug":"2019_01_徹底攻略AWS認定ソリューションアーキテクト-アソシエイト教科書","date":"2018-12-31T15:00:00.000Z","updated":"2019-07-20T15:41:00.036Z","comments":true,"path":"AWS/2019_01_徹底攻略AWS認定ソリューションアーキテクト-アソシエイト教科書/","link":"","permalink":"http://yoursite.com/AWS/2019_01_徹底攻略AWS認定ソリューションアーキテクト-アソシエイト教科書/","excerpt":"","text":"徹底攻略AWS認定ソリューションアーキテクト-アソシエイト教科書 学んだこと AWS サービスについて、Well-architectedフレームワークに沿った５つの観点から説明されておりとても参考になった。（学習メモ参照） 学習メモ 手に取った理由 AWSサービスについて、どんなサービスがあって、どんな使われ方をして、どのように便利なのかなど、基本的な知識を習得するため AWS SAA資格取得のため","categories":[{"name":"AWS","slug":"AWS","permalink":"http://yoursite.com/categories/AWS/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"}]},{"title":"Javascript本格入門","slug":"2019_01_Javascript本格入門","date":"2018-12-31T15:00:00.000Z","updated":"2019-07-20T16:01:27.730Z","comments":true,"path":"Javascript/2019_01_Javascript本格入門/","link":"","permalink":"http://yoursite.com/Javascript/2019_01_Javascript本格入門/","excerpt":"","text":"Javascript本格入門 学んだこと Javascript開発の体系的な知識 細かく理解できていなかった構文に関する知識 学習メモ 手に取った理由 Nodejs環境でがっちりJavascriptを開発していくにあたり、現在の知識確認とより効率的な開発方法の知識を得るため","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/categories/Javascript/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"}]},{"title":"Googleアシスタントアプリ開発入門","slug":"2019_01_Googleアシスタントアプリ開発入門","date":"2018-12-31T15:00:00.000Z","updated":"2019-07-20T15:51:52.664Z","comments":true,"path":"AI/2019_01_Googleアシスタントアプリ開発入門/","link":"","permalink":"http://yoursite.com/AI/2019_01_Googleアシスタントアプリ開発入門/","excerpt":"","text":"Googleアシスタントアプリ開発入門 目次 ●chapter1 GoogleアシスタントとAction 1.1 AIアシスタント ～対話型のインタフェースで問題を解決～ 1.2 Googleアシスタントとは？ 1.3 Googleアシスタントから呼ばれる機能「Action」を使いこなそう ●chapter2 Googleアシスタントのアプリ「Action」の作り方 2.1 アプリ開発エコシステム「Actions on Google」で快適開発 2.2 簡単な会話アプリを作ってみる 2.3 やまびこアプリを作ろう（会話アプリのはじめの一歩） ●chapter3 しっかり作るGoogleアシスタントアプリ 3.1 標準的なアプリ実行環境を知ろう 3.2 基本的な処理フローをおさえよう 3.3 アプリのテーマと会話内容を決めよう 3.4 スピーカー向けアプリを作ろう1（静的会話をDialogflowで実装してみる） 3.5 スピーカー向けアプリを作ろう2（「じゃんけんアプリ」に動的会話を実装） 3.6 シミュレータや実機でしっかりテストしよう 3.7 アプリの会話音声をチューニングしよう（SSMLを使う） 3.8 UIを視覚的にリッチにしよう（Rich Responses） 3.9 最終的なプログラムコードを確認しよう 3.10 column：アプリのアルファリリース、ベータリリース ●chapter4 いろいろな機能を活用してアプリを作ってみよう 4.1 ToDoリストアプリを作ろう（データベースを利用する） 4.2 位置情報を音声で返すアプリを作ろう（位置情報を利用する） 4.3 天気予報アプリを作ろう（位置情報を利用して周囲の天気予報を応える） 4.4 アラームアプリを作ろう（Push APIを使う） 4.5 column：Actions on Googleのさまざまな機能 ●chapter5 アプリが世の中に出るまで／出たあと 5.1 作ったアプリを配信しよう（Google社の審査） 5.2 Googleアシスタントにアプリをおすすめしてもらおう 5.3 船出のあと…… 学んだこと Googleアシスタントアプリ開発に必要な用語 ※業務で必要な箇所のみ拾い読み あとで再読したい 手に取った理由 Googleアシスタントアプリの運用/保守に携わっていく上で必要なスキルを習得するため スピーカー開発関連の知識を増やすため","categories":[{"name":"AI","slug":"AI","permalink":"http://yoursite.com/categories/AI/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"},{"name":"再読","slug":"再読","permalink":"http://yoursite.com/tags/再読/"}]},{"title":"AWS認定ソリューションアーキテクトアソシエイト","slug":"2018_12_AWS認定ソリューションアーキテクトアソシエイト","date":"2018-12-27T16:07:30.000Z","updated":"2019-07-20T01:37:17.456Z","comments":true,"path":"AWS/2018_12_AWS認定ソリューションアーキテクトアソシエイト/","link":"","permalink":"http://yoursite.com/AWS/2018_12_AWS認定ソリューションアーキテクトアソシエイト/","excerpt":"","text":"書籍「AWS認定ソリューションアーキテクトアソシエイト」 著者 ：大塚 康徳（日立インフォメーションアカデミー） 単行本（ソフトカバー）: 168ページ 出版社: リックテレコム (2016/8/17) 言語: 日本語 ISBN-10: 486594043X ISBN-13: 978-4865940435 発売日： 2016/8/17 第1章 AWSと認定プログラム ーAWSクラウドとは何か、そして認定プログラムとは何か？ー 割愛 試験概要、AWSとはについて説明しているだけ 第2章 リージョン／アベイラビリティーゾーンとAWSサービス ーリージョンとAZ、そして各種サービスの提供レベルについてー 試験のポイント！ サーバやデータはAZ間で冗長的に配置する サービス種別 リージョンサービス AZサービス グローバルサービス ※サービスの中のコンテンツ毎に種別が違ったりして掘り下げるとややこしい参考）https://stay-ko.be/aws/solutionarchitect-pro-aws-global-vs-resion-vs-az-resources 章末問題 ELBはAZサービスでありリージョンをまたいで負荷分散できない！ 複数のAZにEC2を配置して、ELBで負荷分散するのが鉄則 第3章 責任分担セキュリティモデルとAWSにおける認証（IAM）責任分担セキュリティモデル 責任分担セキュリティモデル 利用者とAWSが協力してセキュリティを高める考え方 サービス種別 インフラストラクチャサービス ハードウェア部分までAWSが管理 EC2など コンテナサービス ハードウェア部分からミドルウェア部分までAWSが管理 RDSなど アブストラクトサービス ハードウェア部分からソフトウェア部分までAWSが管理 S3やDynamoDB 試験のポイント！ インフラストラクチャサービス、コンテナサービス、アブストラクトサービスの各サービスについて、利用者の責任範囲を明確にする AWSにおける認証とアクセス制御 試験のポイント！ 日常の操作にはルートアカウントを使用せずに、IAMユーザを使用する 試験のポイント！ 各IAMグループ、IAMユーザには、最小権限のアクセス権を与える。 IAMポリシーは最も厳しいポリシー（拒否）が優先される。 アクセス許可と拒否が相反する場合、拒否が優先 試験のポイント！ EC2インスタンス上で実行されるプログラムの認証にはIAMロールを割り当てる IAMロールを使用することでアクセスキーとシークレットアクセスキーがなくてもAWSサービスにアクセスできる キーを使わないアクセスで、キーの流出を防ぐことが狙い IDフェデレーション 事例 要求 自社の従業員に各自の業務レポートを毎月月末にS3にアップロードさせるたい 問題 S3バケットへのアクセス権を付与したいが、毎月１回だけのために全従業員分のIAMユーザを作成するのは非効率すぎて現実的ではない。 解決策 AWS Security Token Service（STS）という一時的に認証情報を付与するサービスとIDブローカー（IDプロバイダー）を利用して、自社の認証基盤で認証が通ればS3バケットへのアップロードを一時的に許可することができる →これを「IDフェデレーション」という！ 他にも以下がある Security Assertion Markup Language(SAML)を使用したシングルサインオン GoogleやFacebookといったウェブIDプロバイダーを使用したシングルサインオン 試験のポイント！ AWSの使用頻度が低いユーザは、IDフェデレーションで社内の認証基盤とIAMを連携する 章末問題 利用者の責任で実施しなければならないセキュリティ対策は？ S3上のデータの暗号化 EC2インスタンス上のOSのセキュリティパッチの適用 AWSアカウント/認証情報の推奨される運用は？ S3バケットへのアップロードをEC2インスタンスで実行する場合は、S3バケットへのファイルアップロードが許可されたIAMロールをEC2インスタンスに割り当てる 第4章 AWSにおけるネットワーク（VPC）VPCの機能と設定 VPC（Amazon Virtual Private Cloud） 利用者毎にプライベートなネットワーク空間を提供するサービス １．VPCの作成 ２．サブネットの作成 重要！ サブネットはAZをまたがることはできない。サブネットを選択することはAZを選択することと同じ ３．ゲートウェイの作成 インターネットゲートウェイ（IGW）をVPCにアタッチ オンプレと通信するためのゲートウェイはバーチャルプライベートゲートウェイ（VGW） ４．ルートテーブルの設定 重要！ インターネットとのアクセスを許可するサブネット：パブリックサブネット インターネットとのアクセスを許可しないサブネット：プライベートサブネット パブリックかプライベートはサブネットに適用されているルートテーブルによってきまる パブリック：デフォルトゲートウェイ（送信先：0.0.0.0/0）のターゲットとしてIGWが設定 プライベート：上記でない VPCの内の通信はルートテーブルでは制御できないので、VPC内のサブネットであれば、通信が可能になっている Webサーバ、DBサーバ、その他のサーバ、でサブネットを分けていても、相互通信可能な状態になっている ５．NATインスタンスの作成 プライベートサブネット内のパッチ当て等 NATインスタンスの実態はEC2インスタンス（※注意※最新ではNATゲートウェイというAWSサービスが存在する！） 送信元/送信先チェック：宛先が自身のIPアドレスでなければトラフィックを破棄する設定。EC2インスタンスはデフォルトでON NATインスタンスはこの機能を無効化している 試験のポイント！ プライベートサブネット内のインスタンスがインターネットにアクセスするための設定を押さえる！ EC2インスタンスのIPアドレス IPアドレスの種類 Public IP Elastic IP EC2インスタンスのプライベートIPアドレスとグローバルIPアドレスの紐付けは、VPCの仮想ネットワークで行われているので、EC2インスタンスのOSにログインし、ipconfigコマンドやifconfigコマンドを実行しても、プライベートIPしか確認できない セキュリティグループとネットワークACL ファイアウォール機能 セキュリティグループ ネットワークACL セキュリティグループ ネットワークACL 適用単位 EC2やRDS、ELBなどインスタンス毎 サブネット単位 作成可能なルール 許可のみ 許可/拒否 デフォルトルール インバウンド：すべて拒否/アウトバウンド：すべて許可（ホワイトリスト方式） インバウンド：すべて許可/アウトバウンド：すべて許可（ブラックリスト方式） 特徴 ステートフル ステートレス 試験のポイント！ セキュリティグループとネットワークACLの違いを抑えて、ファイアウォールによるトラブルシューティングに対応できるようにする VPCピア接続 使い所 本番環境と開発環境で異なるVPCを構築したが、２つのVPCを接続して、プライベートIPで通信したい 接続が確立されると、PCXというゲートウェイに相当するものが作成される ルートテーブルの設定で送信先のターゲットとして、PCXを設定することで、各VPC内のサブネット間でのプライベートIPでの通信が可能になる ピア接続の制約 接続するVPCは同じリージョンに存在する必要がある 接続するVPCのプライベートネットワークアドレス空間は重複していない 接続する可能性があるならはじめから分けておく必要性を示唆している １対１の接続 ここはAWS対策講座でも強調して説明されていた 試験のポイント！ VPCピア接続の特徴/制約を押さえる 章末問題 VPC内のすべてのサブネット間の通信はデフォルトのルーティングルールで許可されており、変更や削除はできない セキュリティグループはステートフルのため戻りのトラフィックを確認する必要ない VPCピア接続にあたってVPCが同一のリージョンに存在する必要がある点 VPCピア接続は１対１ 第5章 AWSにおけるコンピューティング（EC2／AMI／EBS／インスタンスストア）EC2の初回起動と設定【作成ステップについて】 Amazon Machine Image(AMI)の選択 インスタンスタイプの選択 インスタンスファミリー選択 ネットワーク/IAMロール/ユーザデータなどの設定（インスタンスの詳細設定） ユーザデータ：シェルスクリプト メタデータ：インスタンス自身に関するデータ ストレージの設定 EBS インスタンスストア：追加できるのはEC2インスタンスの初回起動時のみ タグ付け タグ付けができる。おおよそ、Nameをキーにサーバー名を値に設定したりする セキュリティグループの設定 EC2には少なくとも１つのセキュリティグループを割り当てる必要がある 個々までの設定の確認 キーペアの選択 試験のポイント！ ユーザデータおよびメタデータの用途と、メタデータで参照できる主要なデータを押さえる EC2インスタンスのライフサイクル ステータスチェック System Status Checks:インフラストラクチャ（HW、ハイパーバイザ）のチェック Instance Status Checks：OSのチェック EC2のインスタンスがrunningになった時点から料金が発生し、stopped,terminatedになるまで発生 EBSとインスタンスストア Amazoon EBS(Elastic Block Store) AZ内に作成されるネットワーク接続型のブロックストレージ 不揮発性 インスタンスストア EC2インスタンスの物理ホストの内蔵ストレージで、揮発性（一時的なデータボリューム） 揮発性：EC2が停止すると保存されていたデータは削除される EC2が停止して起動すると、物理ホストが変わるため、揮発性という特徴がある 重要！ ブロックストレージにはEBSとインスタンスストアの２種類があり、不揮発性と揮発性という違いがある！ OSがどこにインストールされるかによる違い EBS-backedインスタンス EBSにOSがインストールされる instance store-backedインスタンス インスタンスストアにインストラクターされる 試験のポイント！ EBS-backedインスタンスとinstance store-backedインスタンスの特徴を押さえる！ EBSのタイプ EBSのタイプとして３種類言及しているが、情報として古いので、最新を確認したほうがよい EBS最適化オプション（Black Beltより最新情報を記載） ネットワークのIO帯域とEBSのIO帯域を分け、EBS専用帯域を確保するオプション 試験のポイント！ EBSボリュームタイプの性能の違いとEBS最適化インスタンス(今はEBS最適化オプション？)の使い所を押さえる EBSスナップショット 試験のポイント！ EBSスナップショットの特徴を押さえる！ 試験のポイント！ EBSスナップショットを介したAZ/リージョン間のEBSボリュームの複製の流れを押さえる リージョン-a/AZ-a → リージョン-a/S3 にスナップショット取得 リージョン-a/S3 → リージョン-a/AZ-b にスナップショット復元 リージョン-a/S3 → リージョン-b/S3 にスナップショットコピー リージョン-b/S3 → リージョン-b/AZ-c にスナップショット復元 S3間はリージョンをまたいでスナップショットをコピーすることができる点 プレイスメントグループ初めて聞いた… 試験のポイント！ プレイスメントグループ内にEC2インスタンスを起動することで、EC2インスタンス間のネットワーク接続を高速化できる Dedicatedインスタンス ソフトウェア・ライセンスの、ハードウェア制約を解消するために、EC2インスタンスを起動する物理ホストに、別のEC2インスタンスが起動しないことを保証 Dedicatedホストという、物理ホストをアカウントに割り当てておき、その中にEC2インスタンスを起動していくサービスが利用できるようになった AWS参考https://aws.amazon.com/jp/ec2/purchasing-options/dedicated-instances/ 章末問題 ユーザデータについて EC2の停止は「EBS-backedインスタンス」しかできない（instance store-backedインスタンスはできない） EC2の再起動は揮発性ボリュームデータを失わない スナップショット取得の留意事項（アンマウント＋取得後すぐにIO可能） EBSボリュームはAZ間コピーもリージョン間コピーもできない、S3にスナップショットを取得して適応する プレイスメントグループについて Dedicatedインスタンスについて 第6章 オブジェクトストレージ（S3／Glacier）S3バケット／オブジェクトとストレージクラス S3（Amazon Simple Storage Service） スタンダード（標準）クラス 低冗長化（Reduced Redundancy Storage;RRS）ストレージクラス ※この本では言及してないが、Black Beltで最新は以下の４種類 ストレージクラス 特徴 耐久性 スタンダード 複数箇所にデータを複製。デフォルトのストレージクラス 99.999999999%(イレブン・ナイン) STANDARD-IA（標準低頻度アクセスストレージ） スタンダードに比べ格納コストが安価。いつでもアクセス可能だが、データの読み出し容量に対して課金。IA（Infrequent Access） 99.999999999%(イレブン・ナイン) Glacier（アーカイブ） 最も低コストだが、データの取り出しにコストと時間を要する。ライフサイクルマネジメントにて指定する 99.999999999%(イレブン・ナイン) 低冗長化ストレージ（RRS） RRSはReduced Redundancy Storageの略。Glacierから取り出したデータの置き場所として利用 99.99% 試験のポイント！ S3のストレージクラスには、失われることが許されないデータを格納する用途に適したスタンダードクラスと、失われても再作成可能なデータを格納する用途に適した低冗長化クラスがある！ S3の整合性S3はオンラインで頻繁に更新されるデータの格納先には向かない 格納されている静的データを何度も読み取るような用途に向いている 新規オブジェクトの追加は「完了」と表示されれば、画面上、lsコマンド上で確認できる 更新、削除は「完了」と表示されても、結果整合性をとるために、画面上、lsコマンド上で前のオブジェクトが表示されたり、削除できていなかったりする 試験のポイント！ S3の各操作とデータ整合性について押さえ、整合性を考慮したS3の利用用途を押さえる！ S3のアクセス制限とセキュリティ アクセス管理の方法 アクセスコントロールリスト（ACL） バケットポリシー IAM(ユーザ)ポリシー その他 署名（期限）付きURL アクセス許可設定をしていない特定のオブジェクトを指定した期間に限定して公開 用途）商品購入後、期間限定でURLに署名をつけて購入者に渡してダウンロードしてもらう際などに用いられる オブエジェクトの暗号化とアクセスログ 試験のポイント！ S3の暗号化やアクセスログの取得はデフォルトではなく、ユーザの責任の元に実施する！ S3の静的Webサイトホスティング機能 Webサイトホスティング機能 エンドポイント バケット名.s3-website-リージョン名.amazonaws.com 準備 Route53やDNSドメインサービスで名前解決する必要がある S3のバージョニング機能 バージョニング機能 S3バケット単位で有効/無効にできる 誤って上書き、削除した場合でも、操作前のオブジェクトを復元できる 有効にした場合、キーの他にバージョンIDが付与される 試験のポイント！ S3のバージョニング機能を利用すれば、誤操作などにより上書きや削除をしてしまっても、元のデータを復元できる！ S3のライフサイクル機能とGlacierへのアーカイブ 普段アクセスしないものは、より安く運用できる「Glacier」へ移動 格納方法 ライフサイクル機能 指定日数が経過したら、Glacierに格納、削除といった操作ができる機能 SDKを利用して直接格納 試験のポイント！ Glacierは参照する頻度の少ないデータを長期間保管するのに適している 章末問題 第7章 データベース（RDS／ElastiCache／DynamoDB）マネージド・サービス マネージド・サービスとは 利用者が自身でOSやミドルウェア/ソフトウェアをインストールすることなくサービスを利用でき、サービスの可用性や拡張性、バックアップやパッチ適用といった管理作業の多くをAWSが管理してくれるサービスのこと RDSはマネージド・サービスで、他にもELBやSQSなどが存在する マネージド型データベースサービス AWSが提供するマネージド型データベースサービス Amazon RDS：リレーショナルデータベースサービス Amazon DynamoDB：NoSQLデータベースサービス Amazon ElastiCache：インメモリキャッシュサービス Amazon Redshift：データウェアハウスサービス ※最新では、Amazon Neptuneというサービスも存在する（フルマネージドのグラフデータベースサービス） RDS 種類 Amazon Aurora MySQLとPostgreSQLとの互換性のあるエンジン MySQL MariaDB MySQLから分岐（フォーク）して作成された PostgreSQL Oracle Microsoft SQL Server 特徴 １）マルチAZ配置 複数のAZにRDSインスタンスを配置して可用性を高める機能（マスタ-スレーブ構成） MySQL、MariaDB、PostgreSQL、Oracleでは同期物理レプリケーション、 SQL Server では同期論理レプリケーションを使用してマスタからスレーブにデータ同期 スレーブデータは完全にスタンバイ状態で、読み取りもできないので、読み取り性能を上げたい場合は、リードレプリカや、ElastiCacheを利用すること マスタに障害や停止が発生した場合、フェイルオーバーが開始される。フェイルオーバーの過程で、RDSインスタンスのCNAMEがマスタースレーブに付け替えられます AuroraのマルチAZ配置は、マスタ-スレーブ構成ではなく、３つのAZにまたがるクラスターボリュームが作成され、各AZにクラスターデータのコピーが格納される 試験のポイント！ RDSのマルチAZ配置の特徴、フェイルオーバー時の挙動を押さえる！ ２）自動バックアップ機能 RDS標準機能で、１日１回自動的にデータのバックアップを取得する 取得中は多少の読み書き遅延が発生する可能性があるので、利用者は、バックアップウィンドウと呼ばれる設定項目でバックアップが取得される時間帯を選択する バックアップの保持期間はデフォルトで７日間。０～３５日間の間で指定する（０を選択するとバックアップが取得されない） RDSはトランザクションログも自動的に取得しており、１日１回の自動バックアップとトランザクションログを利用して、設定している保存期間の特定時点のデータを持つRDSインスタンスを復元可能 トランザクションログは５分に１回永続ボリュームに書き込まれている 試験のポイント！ RDSの自動バックアップ機能のメリットを押さえる！ ３）パッチ適用 自動パッチ適用機能を有効にしておくと、メンテナンスウィンドウと呼ばれる設定項目で指定した曜日/時間帯にパッチが適用される。 パッチ適用時に数分のダウンタイムが生じることがあるが、RDSをマルチAZ配置にすることで、先にスタンバイにパッチがてきようされ、フェイルオーバーした後に旧マスタ-でパッチが適用されるため、その影響を軽減できる 利用者がパッチ適用を有効/無効に設定できるが、重要なセキュリティ脆弱性が発生した場合は自動的に適用されることがある ４）ストレージ RDSのストレージも、EBSのストレージと同様に、種類がある General Purpose SSD Provisioned IOPS SSD Magnetic（Black Beltに「下位互換のためサポート」と記載あり） （具体的な数値についてはBlack Beltを見たほうがよいため割愛） DynamoDB マネージド型のNoSQLデータベースサービス 特徴 ストレージ容量が必要に応じて自動的に拡張 秒間あたりのI/O性能を指定できる ストレージはSSDのみで安定したI/O性能を提供 データを３つのデータセンタに複製することで高可用性と高い耐久性を提供 読み込み整合性の強弱を指定することで、性能と整合性のバランスを選択 拡張性 冗長性 整合性（結果整合性） ユースケース セッションデータ ゲームの点数 買い物リスト（買い物かご） センサーデータ １つの項目の実データは最大400KBまで １つ１つの項目に対応する実データサイズが大きくなる場合は、実データをS3に保管して、DynamoDBにはS3の格納先URLや格納日付といったメタデータを格納するということもできる 試験のポイント！ DynamoDBのメリットとユースケースを押さえる！ DynamoDBはリージョンサービス プライベートサブネットからのアクセスはNATインスタンスを経由する 試験のポイント！ DynamoDBのアクセス制御はIAMで行い、EC2インスタンス上で実行されるプログラムの認証には、IAMロールを活用する ElastiCache 種類 Memcached Key-Value Store形式 キャッシュクラスタ構成 Redis Key-Value Store形式 マスタースレーブ構成 ElastiCacheはAZサービスでサブネットグループに配置 アクセス制御はセキュリティグループとサブネットのルーティングルール 試験のポイント！ ElastiCacheのメリット/ユースケースを押さえる！ 章末問題 第8章 AWSにおける監視と通知（CloudWatch／SNS）CloudWatchによるモニタリング CloudWatchとは モニタリングサービス メトリックス（監視項目） EC2インスタンスのCPU利用料 EBSのディスクI/O S33の格納オブジェクト総数 RDSインスタンスのCPU利用率 RDSインスタンスのメモリ空き容量 RDSインスタンスのストレージ空き容量 DynamoDBに書き込まれたユニット数 など。。。 CloudWatchは各種AWSリソースから送られてきたモニタリングデータを保存し、メトリックス毎にグラフ化して表示することができる 保持期間は２週間、それ以降のデータは破棄されてしまうため、月次のモニタリングレポート必要な場合は、保持期間内にCloudWatchからモニタリングデータをダウンロードしておく必要があります。 EC2のモニタリングCloudWatchはあくまで、AWSリソースから送られてきたデータを保存/可視化するサービスであるため、CloudWatchにデータを送る仕組み/機能をEC2インスタンスや、RDSインスタンスなどのAWSリソース側で用意する必要がある RDSはマネージドサービスであり、デフォルトで様様なモニタリングデータを収集して、CloudWatchに送信するエージェントがインスタンスに導入されている EC2はマネージドサービスではないため、デフォルトではハイパーバイザが収集できるモニタリングデータのみを収集してCloudWatchに送っている 標準（デフォルト）メトリックス：ハイパーバイザが取得してCloudWatchに送信するメトリックス CPUクレジット利用数（CPUCreditUsage） CPUクレジット累積数（CPUCreditBalance） CPU利用率（CPUUtilization） １秒あたりのDisk読み込み回数（DiskReadOps） １秒あたりのDisk書き込み回数（DiskWriteOps） インスタンスストレージの読み取りバイト数（DiskReadBytes） インスタンスストレージの書き込みバイト数（DiskWriteBytes） 受信したバイト数（NetworkIn） 送信したバイト数（NetworkOut） OS/インフラストラクチャステータスチェックの成功(0)/失敗(1)（StatusCheckFailed） カスタムメトリックス：OSにインストールしたエージェントが取得して、CloudWatchに送信するメトリックス 参考）よくある質問「カスタムメトリックスとは」 https://aws.amazon.com/jp/cloudwatch/faqs/ カスタムメトリクスとは、Amazon CloudWatch でモニタリングするためにお客様自身が用意するメトリクスのことです。 カスタムメトリクスを使用してモニタリングできるものの例としては、ウェブページのロードに要する時間、リクエストエラー率、インスタンス上のプロセスやスレッドの数、アプリケーションで実行された作業の量などがあります。 カスタムメトリクスを使用するには、PutMetricData API を使用します。Windows および Linux 向けのモニタリングスクリプトのサンプル、CloudWatch プラグイン集が用意されているほか、AWS パ&gt;ートナーからも多数のアプリケーションやツールが提供されています。 基本モニタリング ３種類のステータスチェックは１分間隔、その他は５分間隔 詳細モニタリング 標準メトリックスをすべて１分間隔（ただし、追加料金が必要） 試験のポイント！ EC2の標準メトリックスや基本/詳細モニタリングを押さえる！ アラームとアクション CloudWatchの各メトリックスに対して、アラームを設定することができる 閾値を超えた時に所定のアクションを呼び出す アクション例 メールなどの通知（Simple Notification Service） Auto Scalingポリシー（EC2インスタンス数の増減） EC2アクション（停止/削除/再起動/復旧） アラームの３つの状態 OK アラーム（ALARM） 不足（INSUFFICIENT_DATA） 設定例 EC2インスタンスの１分間のCPU利用率の平均が閾値の７０％を３期連続（３分間連続）で上回っている場合に、EC2インスタンスを２台増やすAutoScalingポリシーのアクションを呼び出す など。。。 重要！ CloudWatchのアラームとアクションについて、特徴と代表的な利用の流れを押さえる SNS SNS(Amazon Simple Notification Service) ユーザやアプリケーションにメッセージを送信できる CloudWatchのアラームアクションとしてメッセージを通知することもできる 押さえるべき３つの用語 メッセージ 通知するメッセージ サブスクライバ 受信者を指し、サポートされているプロトコルは次の通り Eメール SMS HTTP/HTTPS SQS（Simple Queue Service） Lambda（サーバ無しのプログラムコード実行サービス） トピック 単一/複数のサブスクライバをまとめたもの 利用例 １．SampleTopicというシステムのアラートが通知されるトピックを作成し、運用管理者のEメールアドレス/メーリングリストをサブスクライバとしてSampleTopicに登録 ２．CloudWatchでシステムのEC2インスタンスをモニタリングし、１分間の平均CPU利用率が８０％を１回超えたというアラームが発生すると、SampleTopicにメッセージを通知するアクションを設定 ３．該当するEC2インスタンスのCPU利用率が８０％を超えてあアラームが発生すると、「CPU利用率が８０％を超えてアラームの状態がOKからALARMに遷移した」というメッセージをSampleTopicに送信 ４．SNSはSampleTopicに登録されている運用管理者のEメールアドレス/メーリングリスト（サブスクライバ）にメッセージを送信 章末問題 WEbサーバとして利用しているEC2インスタンスの標準メトリックスとして正しいものは？ [誤]メモリ使用率 [誤]Webページへのロード時間 [誤]Webサーバのプロセス/スレッド数 [正]Network I/O ※デフォルトは、ハイパーバイザが取得できる値のみ。メモリの使用率は、OSで収集する必要があります。 第9章 AWSにおける拡張性と分散／並列処理（ELB／Auto Scaling／SQS／SWF）密結合と疎結合 通常のオンプレでWeb-AP-DBサーバーの3Tier構成を組むと、サーバー間が密結合担ってしまう。 AWSではサーバ間を疎結合にするために、負荷分散装置を用いて、WEBサーバ、APサーバのインスタンスが入れ替わっても問題ないように３Tier構成を組む そのためのサービスをELB（Elastic Load Balancing）という（マネージドサービス） 重要！ コンポーネント間を疎結合にして伸縮自在性を実装し、AWSのメリットを活かすシステム構成にする！ ELB 機能 複数のAZにまたがる負荷分散 EC2インスタンスのヘルスチェック ELB自体の自動スケーリング SSLのオフロード Connection Draining アクセスログ記録 スティッキーセクション (1)複数のAZにまたがる負荷分散 (2)EC2インスタンスのヘルスチェック 補足）EC2インスタンスを再起動した際、ELBのヘルスチェック間隔によってインスタンス異常と判定され、そのインスタンスのトラフィックが行われなくなり、再起動後もトラフィックの再開をしなかったが、2015/12にEC2インスタンスのELBへの自動再登録が可能になった (3)ELB自体の自動スケーリング ELBは、受信するトラフィックの流量に合わせて自動的にその実態を増減させる ELBの実態はサブネットの中に作成される 割り当てられるIPアドレスはサブネットの中から採番されるが、同時にDNS名が付与され、DNS名で通信される 実態はサブネットの中にあるが、AZ間をまたいで通信されるため、AZの間にELBのアイコンを書くことがおおい (4)SSLのオフロード SSL証明書はEC2インスタンスに配置するのではなく、ELBに配置して一元管理する (5)Connection Draining ELBが配下のEC2インスタンスの登録解除をするときに、新規のリクエストについてはそのインスタンスへのトラフィックの送信を停止し、登録解除前にそのインスタンスで処理中だったリクエストについては完了まで待つようにする機能です。 (6)アクセスログ記録 ELBにはアクセスログ収集機能があり、S3バケットに保存することで、アクセスログを一元管理できる (7)スティッキーセクション ELBには、スティッキーセクションという、システムにアクセスしているクライアントを特定のEC2インスタンスに紐付けできる機能がある。 例）ユーザ認証が必要な会員WebサイトをEC2インスタンス上に構築し、その前段にELBを配置するとする。クラアイアンとは会員Webサイトにアクセスした際に、ELBに割り振られたEC2インスタンスのWebサーバ上でユーザ認証手続きを行います。ユーザ認証に成功すると、Webサーバ側でセッション情報が保持されるため、クライアントが会員Webサイト内で別ページを閲覧して、再度Webサーバに要求が送られても、Webサーバはセッション情報を参照することで、認証済みであることが確認でき、改めてユーザ認証を行わずにすむ →ただし、この方法は「伸縮自在性を実装」に影響を及ぼすので、注意が必要。 「各コンポーネントが特定の状態を持たいない（ステートレス）」であることが重要。スティッキーセクションの代わりに、DynamoDBや、ElastiCacheを利用するほうが懸命 試験のポイント！ ELBの機能/特徴を理解して、ELBによるシステムの可用性向上メリットを押さえる！ 分散／並列処理ある１台のEC2インスタンスでは性能が不足する場合の対処方法２つ (1) スケールアップ：インスタンスタイプを変更し、より高スペックに (2) スケールアウト：EC2インスタンスの台数を増やして分散処理させる スケールアップの問題点 EC2インスタンスを一旦停止する必要があり、１台のインスタンスの場合は業務を停止する必要がある 最終的にはスペックの限界がある １台のインスタンスでは「故障に備えた設計で障害を回避」を実践できない構成になる システム負荷が減少した際に、スケールアップしたインスタンスタイプではオーバースペックになる。スケールダウンするためには再度EC2インスタンスを一旦停止する必要がある 試験のポイント！ 分散/並列処理できる処理は並列化して業務を効率化する！ Auto Scaling Auto Scaling EC2のインスタンスでAuto Scalingグループというグループを構成し、設定に従って自動的にEC2インスタンスの台数を増減させる 負荷が現象した際は、スケールインすることでコストメリットを図れる Auto Scalingの利用料金は無料で、起動したEC2インスタンスの利用料金のみ費用が発生する ユースケース 負荷に基づいた利用 スケジュールに基づいた利用 正常なEC2インスタンスの台数を維持するための利用 Auto Scalingのコンポーネント 起動設定（Launch Configration） どんなEC2インスタンスを起動するのか？という設定 AMI インスタンスタイプ IAMロール CloudWatch詳細モニタリング ユーザデータ IPアドレス ストレージ（EBS、インスタンスストア） セキュリティグループ キーペア など、、 Auto Scaling Group（Auto Scalingグループとは異なり、設定項目） どこに、どんな規模のグループ？という設定です EC2インスタンスが起動するサブネットや特定のELB配下など、どこに？の設定 最小/最大台数などグループの規模を定める設定 スタートのグループサイズ（EC2インスタンス数） サブネット（AZ） ELB（ヘルスチェック設定も含む） 最小/最大グループサイズ（EC2インスタンス数） など、、 Auto Scaling ポリシー いつ、何台増減させるか？という設定 例えば、負荷に基づく設定であれば、CPU利用率のCloudWatchアラームを設定しておき、OKからアラームに状態遷移した際に、アクションとしてAuto Scalingポリシーを呼び出す アラームXが発生した際 N台追加/削除 猶予時間（インスタンスの増減後に、次の増減アクションが発生するまでのクールダウン時間） 補足 2015/7にAuto Scalingポリシーに「Step Scaliing」というタイプが追加され、それまでのポリシーは「Simple Scaling」というタイプになった Step Scaling 複数ステップでの増減が可能。まずこうなったら１台増やす、さらに何秒後までに、何％だったら、もう１台増やすのような設定 Simple Scaling 条件が１つの設定 試験のポイント！ Auto Scalingにおける３つの設定項目を押さえる！ Auto Scalingの２つの特徴 正常なEC2インスタンスを希望する台数（Desired Capacity）維持するため、インスタンスのヘルスチェックをかけている Auto Scalingグループが複数のAZにまたがるとき、AZ間でEC2インスタンス数を均等にする Auto Scalingのシュミレーションが記載されている項目がある～ スケールアウト時のインスタンス削除ルール １．起動している台数が最も多いAZのインスタンス（大原則） ２．起動設定が最も古いインスタンス ３．次の課金タイミングが最も近いインスタンス 試験のポイント！ Auto Scalingにおける大原則を押さえ、EC2インスタンスの増減がどの様に発生するかを押さえる！ SQS (Amazon Simple Queue Service) ELBと並んでコンポーネントを疎結合にする要素で、AWSで分散/並列処理を行う上で重要なサービス 特徴 (1)Pull型（ポーリングされる必要がある） アプリケーションにポーリングされる必要がある (2)順序性の保証はしない（FirstInFirstOutが保証されない） 順序性は保たれない (3)最低１回配信保証 メッセージはあるアプリケーションによって取得されてもキューから削除されることはなく、アプリケーションがバッチ処理の最後で明示的に削除する必要がある メッセージを取得したアプリケーションがバッチ処理の最中で停止しても、他のノード上のアプリケーションが再度同じメッセージを取得して処理できる (4)可視性タイムアウト あるメッセージを取得したアプリケーションがバッチ処理を実行中に、他のノード上のアプリケーションがキューに残っている同じメッセージを取得して島わあないように、可視性タイムアウトという機能が備わっている。デフォルトで３０秒、利用者による設定も可能 (5)メッセージサイズは最大256KB サイズが大きい場合はS3に保存して、SQSにはデータの格納先の情報を格納する SQSはリージョンサービスで、プライベートサブネットからキューのポーリングやメッセージの格納といった操作を行うにはNATインスタンスが必要 EC2上でSQSへのアクセスがあるアプリケーションを動作させる場合は、IAMポリシーが設定されたIAMロールをEC2インスタンスにアタッチすることで安全に利用できる 試験のポイント！ 分散/並列処理におけるSQSのメリット/特徴を理解し、SQSのユースケースを押さえる！ SWF（Amazon Simple Workflow） マネージド型のタスクコーディネータ 重複が許されない、厳密に１回限りで順序性が求められる処理のコーディネータとしての利用に適している 構成要素 ワークフロースターター ワークフローを開始する ディサイダー ワークフロー中の各処理を調整する アクティビティ・ワーカー ワークフロー中の各処理を実行する 試験のポイント！ 分散/並列処理における厳密に１回限りで順序性が求められる処理というSWFのユースケースを押さえる！ 章末問題 ELBのIPアドレスを直接指定してはいけない 予測できない負荷にたいするテストに時間をかけるのではなく、負荷ベースのAuto Scalingを利用することで、負荷に対応する １台のインスタンスを４０時間稼働させる利用料金と４０台のインスタンスを１時間可動させる利用料金は同じなので、可能な限り並列処理を実施する 一時的にAuto Scaling設定がされているEC2インスタンスの台数を増やしたいときに変更するのは？ Auto Scaling Group設定 動画トランスコード処理はSQSを利用するべき 第10章 DNSとコンテンツ配信（Route 53／CloudFront）エッジロケーション AWSにはリージョンとAZ以外に、エッジロケーションというデータセンタが世界に５０箇所以上あります。 エッジロケーションには、EC2やS3、RDSといったサービスでなく、Amazon Route 53のDNSサーバやAmazon Cloud Frontのキャッシュサーバが動作している エッジロケーションは数が多いので、AWSインフラストラクチャページで確認する 重要！ 世界５０箇所以上のエッジロケーションを利用して、DNSサービスやコンテンツ配信（CDN）サービスが提供されている！ Route 53 マネージド型のDNSサービス DNSサービスが53番ポートを利用することからその名前がついている Route53を使用してゾーン/ドメイン情報を登録すると、４箇所のエッジロケーションのDNSサーバにゾーン/ドメイン情報が格納される Route53が管理しているドメインに対してクエリが発生すれば、その４箇所のうちエンドユーザに最も近いDNSサーバが応答する ４箇所のDNSサーバが同時に停止する可能性は限りなく低いため、Route53のSLAは１００％として提供されている 利用料金は、管理しているホストゾーン（従来のDNSゾーンファイル）の数とクエリ回数などの従量課金制となっており、低額から利用可能 Route53 レコードタイプ A AAAA(IPv6) CNAME MX NS PTR SOA（Ｓtart Ｏf Ａuthority） SPF SRV TXT ALIAS(エイリアス：AWS独自レコード) Zone Apex（ゾーンエイペックス）：ゾーンの頂点のこと 試験のポイント！ Route53の独自レコードであるALIASレコードは、CNAMEレコードでは対応できないZone Apexの名前解決をサポートする！ レコードに行える設定 荷重ラウンドロビン レイテンシーベースルーティング 位置情報ルーティング ヘルスチェックとフェイルオーバー 試験のポイント！ Route53の各種機能による、リージョンレベルのユースケースを押さえる！ CloudFront CloudFrontはCDNサービス（Contents Delivery Network） 全国５０箇所のエッジロケーションの中の地理的に近い場所からコンテンツをダウンロード アクセス回数とデータ転送量による従量課金制、長期契約や最低利用料金はない CloudFrontではエッジロケーションにキャッシュさせる時間を設定できる 静的なコンテンツについてはキャッシュ時間を長く 動的なコンテンツについてはキャッシュ時間を短く といった具合 サービス提供側のメリット 大量のアクセスが各地のエッジロケーションに分散され、オリジンサーバの負荷が大幅に減少 オリジンサーバのリソース削減 S3バケットに直接アクセスされるよりもAWSの利用料金を抑えることができる 試験のポイント！ CloudFrontの特徴/メリットを理解し、ユースケースを押さえる！ CloudFrontを利用したコンテンツ配信においても、CloudFrontのSSL証明書、あるいは利用者独自のSSL証明書を利用した暗号化通信が可能 CloudFront経由でエンドユーザに、S3へアクセスさせる際は、バケットポリシーでCloudFrontからのアクセスだけ許可する設定（OAI:Original Accesss Identity）を作成し、OAIからのアクセスだけを許可 試験のポイント！ CloudFrontを利用したコンテンツ配信におけるセキュリティ/アクセス制限を押さえる 章末問題 第11章 AWSサービスのプロビジョニング／デプロイ／構成管理（CloudFormation／Elastic Beanstalk／OpsWorks）CloudFormation CloudFormation プロビジョニングサービス。利用者が用意した定義にしたがってAWSリソースを自動的にプロビジョニングする 自動化により、AWSリソースの構築/管理を効率化できる インフラストラクチャをコード化して、インフラのバージョン管理が可能 利用料は無料で、プロビジョニングされたリソースの利用料金のみ発生 押さえておく用語 テンプレート プロビジョニングするリソースを規定するJSON形式のテキストファイル スタック CloudFormationによってプロビジョニングされるリソースの集合/管理単位 試験のポイント！ CloudFormationを利用したインフラストラクチャのバージョン管理イメージを押さえる！ テンプレートの作成について AWSから提供されるサンプルテンプレートを元に利用者が編集したり、CloudFormerというツールを利用して作成することもできる CloudFormer 利用者のアカウントで現在作成されているAWSリソースを元にテンプレートを作成することができるツール JSONの書き方について～ 試験のポイント！ CloudFormationで設定できる項目や、エラー発生時の動きなどを押さえる！ Elastic Beanstalk/ OpsWorks Amazon Elastic Beanstalk アプリケーションのデプロイツール アプリケーションのバージョニング管理ができ、既存の環境を以前のバージョンに戻すことができる CloudFormation同様、プロビジョニングされたリソースにたいする課金 OpsWorks AWS上のアプリケーションサーバの構成管理ツール ELBやEC2インスタンスを作成し、その後にChefのレシピを実行してソフトウェアのインストールや設定などを自動化できる まとめると CloudFormation VPC以下の構成をプロビジョニング Elastic BeanstalkとOpsWorksを呼び出して一気に設定できる Elastic Beanstalk アプリケーションのデプロイ関連（アプリケーションのバージョン管理） OpsWorks アプリの設定（chefのレシピを実行してソフトウェアのインストールや設定） 章末問題 第12章 EC2の料金モデル（オンデマンドインスタンス／リザーブドインスタンス／スポットインスタンス）オンデマンドインスタンス デフォルトの課金形式 インスタンスが起動しているときに１時間単位で支払いが発生 料金は次の３要素で決まる リージョン インスタンスタイプ OS(Amazon Linux/RHEL/Windows Serverなど) 使用用途 開発/検証環境のサーバ Auto Scalingグループで増減するサーバ １年を通して常時稼働することが求められていないサーバ リザーブドインスタンス １年あるいは３年契約を結ぶことにより、オンデマンドインスタンスより割安にEC2インスタンスやRDSインスタンス、ElastiCacheノードやRedshiftノードを利用できる RI(Reserved Instance)と略した名称で呼ばれることもある DynamoDBやCloudFrontにも同様の割引方式がありますが、こちらはキャパシティを事前に予約するリザーブドキャパシティといいます リザーブドインスタンスはEC2インスタンスの起動/停止にかかわらず、利用料金が発生 支払い方式 前払いなし 一部前払い 全額前払い 使用用途 いつでも確実にインスタンスを立ち上げたい 長期間継続的に利用することが決まっている スポットインスタンス 入札形式のEC2インスタンスの利用/支払い方式で、需要と供給のバランスによって決まるスポット価格（市場価格）を入札価格が上回ると、EC2インスタンスが利用できる スポット価格の設定項目 アベイラビリティゾーン（AZ） インスタンスタイプ OS(Amazon Linux/SUSE Linux/ Windows Serverなど) 入札価格をスポット価格が上回った時、インスタンスはターミネートされる 計算クラスタノードの一部や、Auto Scalingの増加部分のインスタンスなど、突然削除されても問題ないところで利用します。 スポットインスタンス上のデータについては、頻繁にチェックポイントを設けて、S3やEBS、DynamoDBといった不揮発性のストレージに書き出す必要があります。 EC2インスタンスをターミネートする２分前に通知があるため、その通知をトリガーに外部ストレージに書き出す 重要！ スポットインスタンスは、単独で使用するのではなく、オンデマンドやリザーブドインスタンスと組み合わせて利用する！ 試験のポイント！ 業務（提供サービス）の継続とEC2のコスト最適化の業法を考慮して、オンデマンド/リザーブド/スポットインスタンスそれぞれのユースケースを押さえる！","categories":[{"name":"AWS","slug":"AWS","permalink":"http://yoursite.com/categories/AWS/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"}]},{"title":"HTML5プロフェッショナル認定試験 レベル１ 問題集","slug":"2018_06_HTML5","date":"2018-05-31T15:00:00.000Z","updated":"2019-07-20T01:36:32.691Z","comments":true,"path":"HTML/2018_06_HTML5/","link":"","permalink":"http://yoursite.com/HTML/2018_06_HTML5/","excerpt":"","text":"LPIC Level1 教科書 目次 1章 Webの基礎知識 2章 CSS 3章 要素 4章 レスポンシブWebデザイン 5章 APIの基礎知識 6章 模擬試験 学んだこと 教科書で学んだことの復習 問題傾向の整理 手に取った理由 HTML5 Level1資格取得のため","categories":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/categories/HTML/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"}]},{"title":"LPIC Level1 問題集","slug":"2018_04_LPIC_Level1_問題集","date":"2018-03-31T15:00:00.000Z","updated":"2019-07-20T01:31:28.549Z","comments":true,"path":"LPIC/2018_04_LPIC_Level1_問題集/","link":"","permalink":"http://yoursite.com/LPIC/2018_04_LPIC_Level1_問題集/","excerpt":"","text":"LPIC Level1 教科書 目次 第1部 101試験 1章 基本コマンドとファイルの操作 2章 正規表現とviエディタ 3章 プロセス管理 4章 ファイルシステムの管理 5章 マウントとクォータ機能 6章 ファイルの管理 7章 ソフトウェア管理 8章 システムアーキテクチャ 模擬試験 第2部 102試験 1章 シェル、スクリプト、SQLの基礎 2章 X Windows System 3章 ユーザアカウントの管理 4章 システムサービスの管理 5章 ネットワークの基礎 6章 セキュリティ 模擬試験 学んだこと 教科書で得た知識の再確認 問題の出題傾向の把握 手に取った理由 LPIC Level1資格取得のため","categories":[{"name":"LPIC","slug":"LPIC","permalink":"http://yoursite.com/categories/LPIC/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"}]},{"title":"LPIC Level1 教科書","slug":"2018_04_LPIC_Level1","date":"2018-03-31T15:00:00.000Z","updated":"2019-07-20T01:28:13.848Z","comments":true,"path":"LPIC/2018_04_LPIC_Level1/","link":"","permalink":"http://yoursite.com/LPIC/2018_04_LPIC_Level1/","excerpt":"","text":"LPIC Level1 教科書 目次 序章 LPI認定試験の概要 第1章 システムアーキテクチャ 第2章 Linuxのインストールとパッケージ管理 第3章 GNU＆UNIXコマンド 第4章 ファイルとプロセスの管理 第5章 デバイスとLinuxファイルシステム 第6章 101模擬試験 第7章 シェル、スクリプト、データ管理 第8章 ユーザーインターフェイスとデスクトップ 第9章 システム管理（1） 第10章 システム管理（2） 第11章 ネットワークの基礎 第12章 セキュリティ 第13章 102模擬試験 学んだこと LinuxOSのシステムアーキテクチャ パッケージ管理システムについて OSの種類(Redhat系/Debian系) シェルスクリプト（一般的なコマンドのオプション含めた使い方） シェル起動時の環境設定ファイル 手に取った理由 LinuxOSについて体系的な知識を身に着けるため","categories":[{"name":"LPIC","slug":"LPIC","permalink":"http://yoursite.com/categories/LPIC/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"}]},{"title":"データベーススペシャリスト 2017年版 EXAM PRESS","slug":"2018_01_データベーススペシャリスト","date":"2017-12-31T15:00:00.000Z","updated":"2019-07-20T01:07:01.041Z","comments":true,"path":"DB/2018_01_データベーススペシャリスト/","link":"","permalink":"http://yoursite.com/DB/2018_01_データベーススペシャリスト/","excerpt":"","text":"データベーススペシャリスト EXAM PRESS 目次 序章 試験対策（学習方法と解答テクニック） 第1章 概念データモデル 第2章 関係スキーマ 第3章 SQL 第4章 重要キーワード 学んだこと DBスペシャリストに出題される問題傾向 今までの業務経験等である程度理解はしていたが、得られるものがあった 手に取った理由 DB関連知識の深堀のため","categories":[{"name":"DB","slug":"DB","permalink":"http://yoursite.com/categories/DB/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"}]},{"title":"Photoshopレタッチ・加工","slug":"2017_09_PhotoShopレタッチ・加工","date":"2017-08-31T15:00:00.000Z","updated":"2019-07-20T01:02:00.549Z","comments":true,"path":"EX/2017_09_PhotoShopレタッチ・加工/","link":"","permalink":"http://yoursite.com/EX/2017_09_PhotoShopレタッチ・加工/","excerpt":"","text":"Photoshopレタッチ・加工 学んだこと Photoshopの加工テクニックを抜粋して拾い読み 手に取った理由 趣味で一眼レフにはまっており、row画像を加工・人の目を引く写真の作成方法を学習したかった","categories":[{"name":"EX","slug":"EX","permalink":"http://yoursite.com/categories/EX/"}],"tags":[{"name":"再読","slug":"再読","permalink":"http://yoursite.com/tags/再読/"},{"name":"レシピ","slug":"レシピ","permalink":"http://yoursite.com/tags/レシピ/"}]},{"title":"詳解 Amache Spark","slug":"2017_06_ApacheSpark","date":"2017-05-31T15:00:00.000Z","updated":"2019-08-05T15:18:37.346Z","comments":true,"path":"DA/2017_06_ApacheSpark/","link":"","permalink":"http://yoursite.com/DA/2017_06_ApacheSpark/","excerpt":"","text":"詳解 Amache Spark 目次 学んだこと Sparkとは Spark環境構築 Scalaを使用したハンズオン RDD操作 Sparkを取り巻くエコシステムについて理解 ※もう一回読みたい書籍 手に取った理由 ApacheSparkを使ってデータ予測ができる成果物を作成する機会があり、実際に開発/使用することになったが、前提知識がなかったため購入","categories":[{"name":"DA","slug":"DA","permalink":"http://yoursite.com/categories/DA/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"},{"name":"再読","slug":"再読","permalink":"http://yoursite.com/tags/再読/"}]},{"title":"データサイエンティスト養成読本","slug":"2017_06_データサイエンティスト養成読本","date":"2017-05-31T15:00:00.000Z","updated":"2019-07-21T16:44:59.326Z","comments":true,"path":"DA/2017_06_データサイエンティスト養成読本/","link":"","permalink":"http://yoursite.com/DA/2017_06_データサイエンティスト養成読本/","excerpt":"","text":"データサイエンティスト養成読本 学んだこと データサイエンティストとは Pythonの環境構築/使用 R言語の環境構築/使用 ※もう一回読みたい書籍 手に取った理由 ApacheSparkを使ったデータ分析をする機会があり、データ分析関連知識の習得のため","categories":[{"name":"DA","slug":"DA","permalink":"http://yoursite.com/categories/DA/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"},{"name":"再読","slug":"再読","permalink":"http://yoursite.com/tags/再読/"}]},{"title":"応用情報技術者試験 問題集","slug":"2017_06_ap_問題集","date":"2017-05-31T15:00:00.000Z","updated":"2019-07-19T15:41:34.993Z","comments":true,"path":"IPA/2017_06_ap_問題集/","link":"","permalink":"http://yoursite.com/IPA/2017_06_ap_問題集/","excerpt":"","text":"応用情報技術者試験 教科書 学んだこと 基本情報の派生形知識の習得 手に取った理由 応用情報技術者資格取得のため","categories":[{"name":"IPA","slug":"IPA","permalink":"http://yoursite.com/categories/IPA/"}],"tags":[{"name":"問題集","slug":"問題集","permalink":"http://yoursite.com/tags/問題集/"}]},{"title":"応用情報技術者試験 教科書","slug":"2017_06_ap","date":"2017-05-31T15:00:00.000Z","updated":"2019-07-19T15:41:17.458Z","comments":true,"path":"IPA/2017_06_ap/","link":"","permalink":"http://yoursite.com/IPA/2017_06_ap/","excerpt":"","text":"応用情報技術者試験 教科書 学んだこと 基本情報の派生形知識の習得 手に取った理由 応用情報技術者資格取得のため","categories":[{"name":"IPA","slug":"IPA","permalink":"http://yoursite.com/categories/IPA/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"}]},{"title":"SEの基本","slug":"2017_04_SEの基本","date":"2017-03-31T15:00:00.000Z","updated":"2019-07-21T16:52:10.475Z","comments":true,"path":"EX/2017_04_SEの基本/","link":"","permalink":"http://yoursite.com/EX/2017_04_SEの基本/","excerpt":"","text":"SEの基本 目次 0章 SEって、いったい何をする人？ 1章 SEには、どんなテクニカルスキルが必要か 2章 ソフトウェアエンジニアリングを意識したスキルを形成する 3章 プロジェクトに必要なリーダーシップとチームワーク 4章 プロジェクトを成功に導くマネジメントスキル 5章 これだけはマスターしたいヒューマン系スキル 6章 SEとしての自覚と心構え 学んだこと テクニカルな情報というより、概念的、心構え的な知識を習得することが出来た 手に取った理由 ２年間SEとして動いてきて、そもそもSEとしての基本とはなにか、振り返り、答え合わせがしたかったので購入 学習メモ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101【読書】SEの基本1 SE、プログラマーって何？様々な職種のエンジニアを技術的に統括し、システム開発全体を制御、管理する職種2 様々なシステム開発に関わる職種プロジェクトマネージャーテクニカルリーダースタッフチームリーダーはプロジェクトマネージャーを指すことが多いSEがカバーする範囲は広いので求められる期待値は大きい皆、SEを目指すことになるだろう3 スキル標準における位置づけを知ろうITSS 情報システムの企画から運用 保守に至るまで必要とされる実務能力を明確化、体系化した指標いろんな使われ方をする。企業が、個人が、教育機関が、行政が、、対象は下記4種ITアーキテクトプロジェクトマネージメントITスペシャリストアプリケーションスペシャリスト全てを習得する必要はない。しかし、最低限必要な技術力やマネジメント能力があることも確か。最低限必要な「テクニカルスキル」「マネジメントスキル」「ヒューマンスキル」についてみていく4 SEがする仕事の全体像SEの仕事は「システムに対する要求をヒアリングする」ところから始まるわけではない作業顧客 経営戦略策定SE 戦略的情報化企画SE 開発SE 運用・保守SEに求められるスキルは・顧客のビジネス戦略・課題に対するITソリューションを構築するスキル・さまざまな技術を用いて要件を満たす情報システムを構築するスキル・プロジェクトをマネジメントするスキル・上記３つを実行するためのヒューマンスキル5 SEが活躍する会社ユーザ企業SI企業（元請け）・SI企業（下請け企業）ベンダー企業それぞれ経験できる領域が異なる。初めはプログラミングを経験できる環境が良いでしょう。6SEの最大のミッション第1章 SEにはどんなテクニカルスキルが必要か1 工学的手法をもってソフトウエア開発に臨む場当たりシステム開発からの脱却◎プロフェッショナルな開発ソフトウエアの構造について説明がつかなければいけない。大工でいうと犬小屋ではなく、高層ビルを建てているのです。◎ソフトウエア工学ソフトウエア開発を量的、質的に向上させるための学術的分野企画から運用までを明確な行程にわけて工程ごとに課題を解決する工学的手法によって質を向上◎SWEBOKソフトウエア工学に関する理論、方法論、ツール、ノウハウといった知識体系が整理されIEEEにより制定安定した品質を提供できるようになろう2 業務分析がシステム開発のカギまず、システム化戦略の策定が必要アプローチ方法・トップダウンビジョン⇨戦略 ITを武器に戦略を策定・ボトムアップ戦略⇨ビジョン 阻害要因を排除するためBSCを用いる3 ビジネスモデリングシステム要件を導く論理的手法ビジネス構造を表現するというもくてきで使用する場合作成する図をビジネスモデル、ビジネスモデルを作成する過程をビジネスモデリングという◎ビジネスモデリングで表現するもの外部ビュー 顧客パートナーに対してどのようなサービスを提供しているか内部ビュー 製品 社員などの関係◎ビジネスモデリングの目的重要なのはなんのために実施するのか目的を持って実施することになる◎業務を支える情報システムを検討現状のビジネス構造をモデル化し、システムを導入することで業務プロセスを最適化するスタイルでなければシステムは使いづらく、問題解決に繋がりません◎業務パッケージの導入業務に成熟していない組織に対しては一定の効果が見込めるが、パッケージに依存した業務構造となりそこからビジネス構造を変えることが難しくなる◎ビジネスモデリング例■ビジネスユースケースモデル（外部ビュー）■ビジネス分析モデル（内部ビュー）4 分析術！ コンサルティングツールの選択と活用「超上流」 システム開発に入るまでにビジネス課題に適合したシステムを検討する上流工程◎3C分析市場（customer）競合（competitor）自社（corporation）市場と競合からその事業に対する成功要因KSFを分析し、自社の現状とギャップから市場にどのように打って出るかを検討し、ビジョンや戦略を導きだします。◎SWOT分析企業の内部と外部の環境を適合させた戦略を立案するためのツール企業の目標が明確になっている必要がある◎7S分析企業における7つの経営資源の頭文字を表したもの企業の戦略を考えるときに考慮すべきポイントとされている●ハードのＳ戦略組織システム●ソフトのＳ価値観スキル人材スタイル◎5Force業界に影響する5つの力（脅威）を分析することで、業界の収益構造を理解し、適切な事業参画や経営資源の投入を判断するためのツール","categories":[{"name":"EX","slug":"EX","permalink":"http://yoursite.com/categories/EX/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"}]},{"title":"HTML5プロフェッショナル認定Level1 マイナビ","slug":"2017_04_HTML5プロフェッショナル認定_マイナビ","date":"2017-03-31T15:00:00.000Z","updated":"2019-07-21T16:55:44.370Z","comments":true,"path":"HTML/2017_04_HTML5プロフェッショナル認定_マイナビ/","link":"","permalink":"http://yoursite.com/HTML/2017_04_HTML5プロフェッショナル認定_マイナビ/","excerpt":"","text":"HTML5プロフェッショナル認定Level1 マイナビ 目次 学んだこと HTML/CSSの基礎 HTML要素、CSSのクラス、疑似クラスなど セレクタの優先順位 手を動かしながら、実際にサンプルページを自分で作成しつつ少しずつ覚えた 手に取った理由 HTML5/CSSを活用したWeb開発のための知識習得 資格認定の為 学習メモ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185118611871188118911901191119211931194119511961197119811991200120112021203120412051206120712081209121012111212121312141215121612171218121912201221####################################################################### HTML5認定試験対策メモ######################################################################■Chapter1 HTMLの基礎知識■====================================================================■1-1.HTML5の基本文法・空要素(void element)には終了タグを指定できない・空要素のタグの&gt;の直前にはスラッシュを入れても良い・空白文字半角スペース、タブ、改行(CR,LF,FFを含む)を纏めて空白文字と言います。・属性を指定する際に「=」の前後には空白文字を入れることができ、属性値を囲う引用符(「&quot;」または「&apos;」)は省略することが出来ます・属性値を囲う引用符が省略できるのはその文書がHTML構文で書かれていて属性値に空白文字の他に「=」「&quot;」「&apos;」「&gt;」「&lt;」「`(グレーブアクセント)」を含んでない場合に限りますまた属性値がからの場合は省略出来ません。・HTML5文書の先頭にはオプションでBOM(バイトオーダーマーク)を入れることができる・DOCTYPE宣言ブラウザの表示モードを「標準モード」にする目的で指定することになっている・文字参照ソースコード内にそのまま記入出来ない文字などをテキストに書き入れられるようにするために、HTMLでは文字参照という特別な書式を利用することが出来ます。・グローバル属性すべての要素に共通して指定できる属性のこと◆練習問題◆====================================================================①HTML5のDOCTYPE宣言として妥当なもの②状況によっては開始タグと終了タグの両方を省略できるものはどれか・html・head・body・colgroup・tbodyのみ！③空要素のタグ指定方法/の後ろに空白スペースを記入できない空要素には終了タグを記入できな④DOCTYPE宣言の中でHTML5では使用できないもの⑤HTML5のコメント記述方法として正しくないもの「&lt;!--」「--&gt;」は続けて書く必要があるコメント内部のテキストは - で終了することは出来ない⑥論理型属性であるhidden属性の指定方法として間違っているものを選択&lt;div hidden=&quot;true&quot;&gt; ～ &lt;/div&gt;引用符も省略できるが、true,falseで指定することはできない⑦HTML5のclass属性またはid属性の値の指定方法として間違っているものはどれかid=&quot;&quot;id=&quot;abc xyz&quot;id属性は空文字は許さないid属性は空白を含むことが出来ない⑧HTML5で利用可能な属性のうち、任意の要素に指定可能でないものはどれかdata属性：object要素にしか指定できない■Chapter2 HTML5で追加された要素■====================================================================◯セクショニングルート・body要素・blockquote要素・fieldset要素・figure要素・td要素◯セクションを表す要素の種類・section・article記事を始めとする、「それだけで全部の/それだけで完結している」セクションを表す場合に使用します単独で配布・再利用可能なコンテンツに対して使用し、記事のほかにもブログのコメントやフォーラムの投稿、インタラクティブなウィジェットやガジェットなどをマークアップする際にも利用できます。・aside前後の内容とほぼ関係がなく、それらとは分離されたものであると考えられるセクション・navそのページにおけるナビゲーションのリンクを含むセクションを表す場合に使用します。◯構造を示す要素・header要素・footer要素・main要素main要素の内容には、そのページに特有のコンテンツのみを入れ、サイト内の複数のページで共有しているナビゲーションやロゴ、検索フォーム、著作権情報などのコンテンツは含めないようにするmain要素は1つのHTML文書につき1つしか配置出来ない◯テキスト・mark要素黄色いマーカー線で表示して目立たせるオリジナルの文書がそうなっていたわけではないが、それを引用した人が読者に注目してもらいたいので目立つようにする場合などにも使用されますその他、検索結果の一覧で、検索に使用した単語を目立つようにする場合などにも使用されます・data要素人が普通に読み取り可能な要素内容とともに機会読み取りが可能なデータも提供する要素機械読み取りが可能なデータは、必須属性であるvalue属性の値として指定します・time要素data要素を日時での使用に特化させた要素・wbr要素通常、英単語やURLなどはいくら長くてもその途中で行を折り返すことはアリません。英単語やURLの途中でも行を折り返すことができるようにする要素です。・bdi要素特定の範囲のテキストだけを意図的に分離・独立させることができる◯ルビ・ruby要素・rt要素ルビ(ひらがな)として小さい文字を表示させるテキストruby関連要素の終了タグは省略可能・rb要素漢字の部分を示すための要素なくてもいいが、細かく分ける場合は必要&lt;ruby&gt;&lt;rb&gt;漢字&lt;/rb&gt;&lt;rt&gt;かんじ&lt;/rt&gt;&lt;/ruby&gt;&lt;ruby&gt;&lt;rb&gt;漢字&lt;rt&gt;かんじ&lt;/ruby&gt;&lt;ruby&gt;&lt;rb&gt;漢&lt;/rb&gt;&lt;rb&gt;字&lt;/rb&gt;&lt;rt&gt;かん&lt;/rt&gt;&lt;rt&gt;じ&lt;/rt&gt;&lt;/ruby&gt;&lt;ruby&gt;漢&lt;rb&gt;字&lt;rt&gt;かん&lt;rt&gt;じ&lt;/ruby&gt;・rp要素ルビ未対応のブラウザで表示させるときに、()カッコくくりでルビを表示させるための要素&lt;ruby&gt;漢字&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;かんじ&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;&lt;ruby&gt;漢字&lt;rp&gt;(&lt;rt&gt;かんじ&lt;rp&gt;)&lt;/ruby&gt;&lt;ruby&gt;&lt;rb&gt;漢&lt;/rb&gt;&lt;rb&gt;字&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;かん&lt;/rt&gt;&lt;rt&gt;じ&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;&lt;ruby&gt;漢&lt;rb&gt;字&lt;rp&gt;(&lt;rt&gt;かん&lt;rt&gt;じ&lt;rp&gt;)&lt;/ruby&gt;・rtc要素rt要素をグループ化する要素ルビは↑だけでなく下(左)にもつけることが出来ます。&lt;ruby&gt;漢字&lt;rt&gt;かんじ&lt;/rt&gt;&lt;/ruby&gt;◯動画・音声・video要素動画を再生させるための要素・audio要素音声を再生させるための要素・source要素代替データとして異なる形式のデータも併せて指定しておきたい場合・track要素動悸させる外部のテキストトラック(字幕などのテキストデータ)を指定する場合に使用します。・embed要素プラグインを使用する外部コンテンツを組み込む際に使用される要素◯フォーム・meter要素メーターとして使用する要素です。特定の範囲内での位置を示す場合に使用します。・progress要素タスク(コンピュータが行っている作業)の進み具合を表すための専用要素・datalist要素input要素にサジェスト機能を追加する(入力候補の選択肢を与える)要素datalist要素の中に入れたoption要素が選択肢となります。&lt;p&gt; &lt;label&gt; 取得したい資格： &lt;input type=&quot;text&quot; name=&quot;c&quot; list=&quot;certifications&quot;&gt; &lt;datalist id =&quot;certifications&quot;&gt; &lt;option value=&quot;HTML5プロフェッショナル認定試験&quot;&gt; &lt;option value=&quot;ウェブデザイン技能検定&quot;&gt; &lt;/datalist&gt; &lt;/label&gt;&lt;/p&gt;・output要素計算結果やユーザーの操作による結果を示すための要素&lt;form onsubmit=&quot;return false&quot; oninput=&quot;sum.value=a.valueAsNumber+b.valueAsNumber&quot;&gt; &lt;input name=&quot;a&quot; type=&quot;number&quot;&gt; + &lt;input name=&quot;b&quot; type=&quot;number&quot;&gt; = &lt;output for=&quot;a b&quot; name=&quot;sum&quot;&gt;&lt;/output&gt;&lt;/form&gt;・keygen要素公開鍵暗号における公開鍵・秘密鍵のペアを生成するフォーム部品フォームを送信すると秘密鍵はローカルに保存され、公開鍵はサーバーに送られますこの要素は空要素です。◯その他の新要素・figure要素figureという英単語は、図・図表、挿絵などの意味を持つそれがメインコンテンツの本文から参照される図版のようなコンテンツであることを示します具体的な要素内容としては、図表・写真・イラストソースコードの一部のような、それ自身がまとまった一つの完結した内容になっているFlow content(一般コンテンツ)を入れます&lt;p&gt;CSSを使用すると、影を表示させることが出来ます。(&lt;a href=&quot;#&quot;&gt;図版01&lt;/a&gt;)&lt;/p&gt;&lt;figure id =&quot;fig01&quot;&gt;&lt;figcaption&gt;図版01：CSSでボックスに影を表示させる例&lt;/figcaption&gt;&lt;pre&gt;&lt;code&gt;.sample &#123; box-shadow: 3px 3px 10px #999; &#125;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;・figcaptionfigure要素で表す図版のキャプションや説明文部分をマークアップするための専用要素figure要素の一番前か一番後ろにしか配置できない点に注意する・template要素その範囲がスクリプトによって生成(複製・挿入)される部分であることを示す要素・canvas要素スクリプトによって描画するビットマップの動的なグラフィックとなる要素■Chapter3 HTML5で変更・廃止された要素■====================================================================◯HTML5で変更された要素・hr要素従来：横罫線を表示させるための空要素コンテンツの内部的に「段落レベルで主題が変わるところ(区切り・変わり目)」を示す話題が変わるところや、物語の場面が変わる所などセクションはそれ自体が主題の区切りを示す為、セクショントセクションの間にhr要素を入れる必要はアリませんhr要素はセクション内部の段落レベルでの区切りを示すために使用します。・small要素従来：テキストを小さなフォントサイズで表示させるためのものでした「一般的に小さな文字で示される付帯情報」をマークアップする為に使用します。具体的には、Copyrightの表記や帰属、免責事項、警告と言った部分で使用されます・strong要素従来：em要素よりも強い協調を示す要素「重要性」「重大性」「緊急性」のあるコンテンツをマークアップするために使用しますstrong要素が重なれば重なる程その度合は強くなります。・b要素従来：テキストを太字で表示させるためのもの重要性やその他の特別な意味合いは持たずに、実用的な意味で目立たせたほうが良いと思われる部分をマークアップする為に使用具体的には、レビュー記事における製品名、概要説明に於けるキーワード、記事のリード文など・i要素従来：テキストをイタリックで表示させるためのもの学名のほか英文中での船名、専門用語、言語が異なっている部分、小説などにおける頭のなかで考えていることの表現など、普通のテキストとは違う性質のものに切り替わっているような部分を示す・s要素従来：取り消し線を引いた状態で表示させるためのもの既に正しい情報ではなくなった部分、関係のない情報となってしまった部分を表すために使用します。文書の編集によって削除された部分はs要素を使用せずに、del要素を使用します。・u要素従来：テキストに河川を引いた状態で表示させるための要素耳で聞いてもわからないけれども表示上は明確に示される、テキスト以外で注釈的な表現をする範囲をマークアップするために使用します。用途は、中国語でテキストが固有名詞であることを示す場合や、スペルミスの箇所を示す場合などと限定的で、一般的なページではほとんど利用されない要素リンク付き要素とかぶってしまうため、それらの要素と混在するのは避けられる。◯HTML5で廃止された要素・center要素やfont要素といった表示指定の要素派廃止された・small要素は利用可能だが、big要素は廃止された・s要素は利用可能だが、strike要素は廃止された◯HTML5で廃止された属性・alignやbgcolorといった表示指定の属性は基本的にすべて廃止された・一部の要素を覗いてname属性は廃止され、代わりにid属性が使用される・あまり使われていなかった属性、他の機能で代用可能な属性の多くも廃止された■Chapter4 HTML4.01以前からある要素■====================================================================◯基本構造▼ココが重要・html要素のversion属性は廃止され、新しくmanifest属性が追加された・HTML5では、titile要素がなくても良いケースがある・address要素はもっとも近いarticle要素またはbody要素の問合せ先▼html要素manifest属性：アプリケーションキャッシュマニフェスト(キャッシュさせるファイル、させないファイルなどの情報を明記したテキスト形式のファイル)を指定するための属性・補足html要素の開始と終了タグは、その直後にコメントがなければ省略することも可能・注意HTML5にはHTML構文とXHTML構文がアリますが、タグの省略が可能なのはHTML構文だけである▼head要素HTML文書のMetadata content(文書情報コンテンツ)を入れるための要素▼body要素HTML文書のコンテンツを入れるための要素です。▼title要素HTML文書のタイトル、または名前であることを示す要素head要素の中に記載する。title要素は1つのhtml文書につき1つしか配置できない点に注意してください。▼base要素HTML文書内で指定されている相対URLの基準にするURLを設定する為の要素です。必ずhead要素内で使用target属性を使用することでデフォルトの表示先(ブラウジングコンテキスト)を設定しておくことも出来ます。・ブラウジングコンテキストHTML5の仕様書では、HTML文書を表示させるウィンドウやタブ、インラインフレームなどのことをブラウジングコンテキストと呼んでいます。・注意1つのHTML文書につき1つまで少なくともhref属性かtarget属性のいずれか一方を指定する必要があるbase要素で指定した基準URLはhtml属性のmanifest属性で指定するアプリケーションキャッシュマニフェストのURLには影響を与えない点に注意▼meta要素様々な種類のメタデータを指定できる要素・メタデータあるデータに関するデータのことを指す一般的な用語で、HTML文書でいうと、「HTML文書自身に関する情報」のことです。HTMLのhead要素内に入れられる要素は基本的にすべてメタデータであるといえます。・プラグマディレクティブ/プラグマ指示子HTML文書の状態や挙動を支持する命令のことたとえばブラウザへの再読込や他文書への移動の命令、デフォルトのスタイルシート言語やスクリプト言語の設定、文字コードの宣言などがこれに当たります。meta要素にhttp-equiv属性が指定されているとき、そのmeta要素はプラグマディレクティブとなります。▼address要素自分自身に最も近いarticle要素またはbody要素の内容に関する問い合わせ先を示す要素・ココに注意address要素の内容に入れられるのは、問合せ先の情報だけです。著作権情報や更新日のような問合せ以外の情報は入れられませんので注意してください▼div要素予め決められた役割や意味を持たない要素です。似た要素としてspan要素があります違いはインライン要素/ブロックライン要素でしたが、HTML5ではそのような分類はされなくなりました。▼span要素◯テキスト・h1～h6要素はセクションの見出しを表す・blockquote要素の内部には、footer要素やcite要素を配置できる・cite要素は作品のタイトル・作者名・参照先URLのいずれかを示す▼h1～h6要素セクションの見出しとなる要素▼p要素段落を表す要素▼blockquote要素要素内容が引用してきた文書であることを示すブロックレベル要素：blockquoteインライン要素 ：q指定できる属性：cite属性▼q要素その要素内容が引用してきた文書であることを示すインライン要素で使用指定できる属性：cite属性▼cite要素創作物に言及する際にそのタイトルを示すための要素要素内容には、作品の題名か作者の名前(個人・団体・組織も可)、参照先のURLのいづれかを含めなければなりません。▼ins要素文書に追加した部分(inserted text)を示す為に使用◯指摘できる属性・cite・datetimeins要素のコンテンツモデルはトランスペアレント▼del要素文書から削除した部分を示すdel要素のコンテンツモデル派トランスペアレント▼em要素強調されている部分を示すための要素▼br要素その位置で改行さえるための空要素改行がコンテンツの一部であるような部分で使用します。余白をとるために使用したり、段落のように見せるために改行として使用するものではアリません。▼abbr要素略語であることを示す。省略していない状態の言葉を示すには、title属性を指定する。※注意title属性は補足情報を提供するグローバル属性ですが、abbr要素で使用する場合、「省略してない状態の言葉を示す」以外の用途には使用できない点に注意・すべての略語に対してabbr要素を指定する必要はない。使いたいときだけ！・abbr要素の他にacronym要素も以前はあったが、使い分けに混乱が生じたので、廃止になった▼dfn要素その部分が定義の対象となっている用語であることを示す。▼pre要素その要素内容であるテキストが整形済み(performatted)であることを示す要素ここで言う整形とは、半角スペースやタブ、改行を使って表示を整えているという意味で、pre要素の要素内容は入力されているとおりにそのまま表示されます。ただし具体的にどのように表示させるかはCSSで指定可能です。・ソースコード・アスキーアート・メール内容※注意HTML構文の場合、pre要素の開始タグ直後にある改行は取り除かれる事になっている▼code要素その部分がコンピュータで使用されるソースコードであるということを示す要素▼samp要素コンピュータのプログラムやシステムからの(サンプル)出力であることを示す▼kbd要素ユーザーが入力する内容であることを示す要素▼var要素その部分が変数(variable)であることを示す要素▼bdo要素Unicodeの双方向アルゴリズムの文字表記の方向を上書きして指定する要素内容のテキストを左から右へと表示するのか、右から左へと表示するのかをグローバル属性であるdir属性を使って設定する要素▼sup要素その部分が上付き文字要素であることを示す▼sub要素その部分が下付き文字要素であることを示す◯リスト※ココが重要・HTML5ではul要素 / ol要素 / dl要素の内容はからでもOK・HTML5のdl要素で用語をの定義をする場合、dfn要素も必要になる・HTML5のdl要素は、会話・対談を表す場合には使用できない▼ul要素箇条書きのようなリスト▼ol要素連番つけられた項目を持つリスト※指定可能な属性・type・start・reversed▼li要素リストの各項目人なる要素▼dl要素内容となる各項目が「名前(dt要素)」「値(dd要素)」のペアになっている形式のリスト※注意・HTML5ではdl要素の要素内容はからでもOK。また必要に応じてtemplate要素とscript要素を配置することもできる以前：dl要素 definition listを意味HTML5:dl要素 description listを意味これによってdl要素から「定義」の意味がなくなった為、dl要素を「用語の定義」に使用する場合には、次のようにdfn要素(定義対象の用語であることを示す要素)を追加する必要がある点に注意▼dt要素名前(用語)などを示す▼dd要素値(説明文等)◯リンク※重要・a要素のコンテンツモデル派条件付きのトランスペアレント・a要素にはdownload属性が追加されている・link要素にはsizes属性とcrossorigin属性が追加されている▼a要素要素内容がハイパーリンクになります。▼link要素関連する別の文書やファイルなどを示すための空要素href属性とrel属性は必ず指定する必要があります。href属性とrel属性は必ず指定する必要があります。◯画像とオブジェクト※重要・HTML5では、特別なケースにおいてはimg要素のalt属性を省略できる・HTML5では、width属性とheight属性に％値は指定できない・map要素とobject要素のコンテンツモデルはトランスペアレント▼img要素src属性で指定したアドレスの画像を表示させる空要素▼map要素イメージマップを定義するための要素▼area要素イメージマップでリンクする領域を定義する空要素▼object要素様々な形式の外部データを組み込むための要素画像や別のHTML文書、プラグインを使用するデータなども組み込むことが出来ます。▼param要素object要素によって呼び出されるプラグインのパラメータを設定する要素◯フォーム※重要・HTML5では、フォーム関連の属性が多数追加されている・input要素で作成可能な部品の種類は、HTML5になって約2倍に増えた・form要素の外部にある部品でも、form要素に関連付けることが可能となった▼form要素フォーム関連の要素をとりまとめ、ユーザーが入力・選択したデータをサーバーに送信するための要素▼input要素type属性で指定したキーワードによって様々な種類の入力・選択用部品となる要素▼textarea要素複数行のテキストフィールドとなる要素▼button要素要素内容がそのままラベルとして表示されるボタン▼select要素選択肢の中から選ぶ形式のフォーム部品になる要素▼option要素select要素またはdatalist要素の選択肢となる要素▼optgroup要素option要素をグループ化してそこにグループの名前をつける要素▼label要素その要素内容であるラベルとフォーム部品とを関連付けるための要素▼fieldset要素フォーム関連の要素をグループ化するための専用要素▼legend要素fieldset要素によってグループ化されたフォーム関連要素のグループ名(キャプション)を表示させるための要素枠で囲われるやつね！◯テーブル※重要・table要素のborder属性は、レイアウト用のテーブルではないことを示す・tfoot要素は、tbody要素の前にでも後ろにでも配置できる・table要素内で使用する要素の多くは、終了タグを省略できる▼table要素表形式のデータを表すための要素※注意table要素のborder属性は以前は表の線の太さを指定するために使用されていましたが、HTML5ではレイアウト用のテーブルではないことを示す目的で使用されます。その為、値には1か空文字以外は指定できなくなっている点に注意！！※説明補足HTML5の仕様書には、「テーブルをレイアウトのために使用するべきではない」と明確に記載されているまた、「もし、テーブルをレイアウトの為に使用するのであれば、role=&quot;presentation&quot;を指定しなければならない」とも書かれています。▼tr要素表の横一列を表すために使用▼th要素表の見出し用のセルを表すために使用▼td要素データ用のセルを表す要素▼thead要素見出しとなっているtr要素をグループ化する要素簡単に言えば表のヘッダーを表す要素▼tbody要素表の本体部分を表す▼tfoot要素表のフッター部分を表す※注意以前はtfoot要素は必ずtbody要素よりも前に配置する必要が有りました。HTML5ではtfoot要素はtbody要素の前でも後ろでも配置出来ます。ただし1つのtable要素内に複数のtfoot要素を配置することは出来ません。▼caption要素table要素のキャプション(表のタイトル)となる要素▼col要素span属性のないcolgroup要素内に配置して、1列分以上の縦列を表す空要素col要素にspan属性を指定していなければ、１列分の縦列を表し、span属性を指定して値に１以上の整数を指定していればその列分の縦列となります。▼colgroup要素1列分以上の縦列をグループ化する要素※注意colgroup要素にspan属性を指定している場合は、colgroup要素の要素内容は空にします。span属性を指定していない場合は、0個以上のcol要素かtemplate要素を入れます。◯その他※重要・iframe要素のsrcdoc属性には、HTML文書全体を記入できる・script要素のtype属性のデフォルト値は「text/javascript」で省略も可能・noscript要素はXHTML構文では使用できない▼iframe要素HTML文書の中で、別の文書を表示させる領域(ブラウジングコンテキスト)となる要素「iframe」は「inline frame(インラインフレーム)」の略▼script要素HTML文書内にスクリプトまたはデータブロックを組み込む為の要素▼noscript要素スクリプトが向こうの場合に利用されるコンテンツを要素内容としてもつ要素■Chapter5 CSSの基礎知識■====================================================================◯CSSの基本文法と組み込み方※重要・CSSの書式には自由に空白文字を入れられるが、セレクタだけは例外・HTML5では、link要素とstyle要素のtype属性が省略可能となった・link要素とstyle要素のmedia属性と@importにはメディアクエリが指定可能▼基本的な書式と各部の名称▼link要素でHTMLに組み込むhead要素の中にlink要素を指定してHTMLに埋め込む方法▼style要素でHTMLに読み込む要素内容としてスタイルシート言語を組み込むことのできる要素▼style属性でHTMLに組み込むグローバル属性であるstyle属性を指定して、その値としてCSSを組み込む方法▼@importでCSSに組み込む@importの書式を使用することで、CSSの中で更に外部スタイルシートを読み込ませる事もできます。最も簡単な方法は、次のように@importの後に外部スタイルシートのURLを文字列として指定する方法文字列として指定するので、ダブルクォーテーションまたはシングルクォーテーションが必要です。@import &quot;style.css&quot;;@import url(style.css);URLの後には、link要素やstyle要素で指定可能なメディア型やメディアクエリを指定することもできる@import &quot;style.css&quot; screen, print;◯セレクタ※重要・属例セレクタと結合子の記号はしっかりと覚える・擬似クラスの式「an+b」の指定方法をしっかりと覚える・疑似要素の先頭のコロンはCSS3から2つになった▼セレクタの種類と組み合わせのルール▼タイプセレクタ要素名をそのまま使って適用先を示すシンプルセレクタをタイプセレクタと言います。▼ユニバーサルセレクタ要素名の代わりに(*)を指定すると、すべての要素が適用対象となります。▼クラスセレクタ▼IDセレクタ▼属性セレクタ NEW!!特定の属性が指定されている要素、またhあ特定の属性に特定の値が指定されている要素を適用対象として指定できるのが属性セレクタです。img[src$=&quot;.jpg&quot;] &#123; border: 3px solid #f00 &#125;▼リンク関連の擬似クラスある要素が特定の状態にあるときなどに限定して適用対象とするのが擬似クラスCSS3では23種類の擬似クラスが定義されていますが、はじめに使用頻度の高いリンク関連の擬似クラスを説明・:link リンク先をまだ見ていない・:visited リンク先を既に見た状態・:hover カーソルが上にある状態・:active マウスのボタン等が押されている状態※注意同時になる状態がある場合は、後に指定されたほうが有効になるので、基本的に上記の順序で指定しなければならない！！▼その他の擬似クラス▼疑似要素要素ではない部分(タグのつけられていない範囲)を適用対象とするCSS3では次の4種類の疑似要素が定義されている・::first-line ブロックレベル要素の一行目・::first-letter ブロックレベル要素の1文字目・::before 要素の直前にコンテンツを追加・::after 要素の直後にコンテンツを追加▼結合子組み合わせたシンプルセレクタ同士を区切って使用する結合子には次の4種類がある・空白文字 セレクタAの中に含まれているセレクタB・&gt; セレクタAの直接の子要素であるセレクタB・+ セレクタAの直後に現れるセレクタB・~ セレクタAよりも後に現れるセレクタB◯CSS適用の優先順位※重要・ユーザーエージェント・ユーザー・制作者の優先度は!importantで逆転する・詳細度が最も高いのはstyle属性による指定・セレクタの詳細度は、IDセレクタ・属性系セレクタ・要素系セレクタの3桁で示す▼CSSの指定元による優先順位▼!importantで優先順位を高くする▼セレクタの詳細度による優先順位の計算方法■Chapter6 CSS3の主な新機能■====================================================================◯色※重要・CSS3からは色の値が指定可能なすべての箇所でtransparentが使用可能・不透明度は0.0~1.0までの単位をつけない数値で指定する・hslは、hue(色相)・saturation(彩度)・lightness(明度)の意味▼色を示す値：16進数▼色を示す値：キーワード▼色を示す値：rgb(),rgba()rgb()という関数形式の書式を使用すると、RGBの値を10進数のまま指定可能▼色を示す値：hsl(), hsla()直感的に色を指定したり変更できるようにするために作られたもの▼colorプロパティテキストの文字色を設定するプロパティです。▼opacityプロパティ要素の不透明度を設定するプロパティ◯背景※重要・CSS3では複数の背景画像が指定できる・CSS3では背景の表示領域を変更できる・CSS3では背景画像のサイズが指定できる▼ボックスの構造▼長さを表す単位▼background-colorプロパティボックスの背景色を設定するプロパティ▼background-imageプロパティ▼background-clipプロパティ背景をボックスのどの領域に表示させるのかを設定するプロパティ▼background-repeatプロパティ背景画像を縦または横に繰り返し表示させるかどうかを設定するプロパティ▼background-sizeプロパティ背景画像の表示サイズを設定するプロパティ1つ目が幅 2つ目が高さ▼background-originプロパティclipの画像版プロパティ的なもの※注意背景色も含めた背景の表示範囲を設定するbackground-clipプロパティの初期値は▼background-positionプロパティ背景画像を表示させる領域内での画像の配置位置を設定するプロパティ▼background-attachmentプロパティ背景画像を表示領域に固定して、ページの内容をスクロールしても動かないようにすることができる▼backgroundプロパティ背景関連のプロパティの値を纏めて指定できる※注意backgroundプロパティで指定されていない値は現状が維持されるのではなく初期値に戻されるので注意 backgroundプロパティの値もカンマで区切ることで、複数の背景画像のレイヤーを指定できます。その際に、background-colorプロパティは一番下のレイヤー(書式上はカンマで区切られた一番右側の値)にしか指定できません◯アニメーション※重要・transform関連プロパティでは、ボックスの回転・拡大縮小・移動などを行う・トランジションは、値の切り替わりを滑らかに連続した動きで見せる機能・アニメーションは、キーフレームでトランジションを連続実行させるようなもの▼回転・拡大縮小・移動などtransformプロパティを使用すると、要素のボックスを回転させたり、拡大縮小させたり、移動させることなどが出来ます。しかもそれらは平面的な2次元空間だけでなく3次元空間デモ行える様になっているため、立体的な3D表現も可能▼transformプロパティ要素のボックスを回転・拡大縮小・移動・変形さえるプロパティ値は関数形式になっており、空白文字で区切って必要なだけ指定できます。▼transform-originプロパティtransformプロパティの原点を指定するプロパティ1つ目は横方向の位置2つ目は縦方向の位置transform-origin: top loft;transform: translate(200px, 100px) scale(1.5, 1,5) rotate(45deg);▼CSS3のトランジションとは例えば、セレクタの:hoverを使って表示を変更すると、その表示は瞬時に切り替わります。それを連続した動きで滑らかに変化させるのがCSS3のトランジション▼transition-propertyプロパティ「どのプロパティ」の値が変更されたときにトランジションを実行させるのかを設定するプロパティ▼transition-durationプロパティどれだけの時間をかけて変化させるのかを設定する▼transition-timing-functionプロパティトランジション機能で表示を変化させる際、最初から最後まで一定のスピードになっていると、変化の種類によっては機械的で不自然な印象を与えてしまいます。そこでゆっくりと変化を開始して徐々にスピードを上げ、だんだんとスピードを落としながら終了すると言ったように様々なパターンで速度に変化をつけられるようになっています。その指定を行うのがtransition-timing-functionプロパティです。▼transition-delayプロパティトランジションの開始を遅らせるプロパティ▼transitionプロパティトランジション関連のプロパティの値を纏めて指定できるプロパティ▼CSS3のアニメーションとはCSS3のアニメーションとは、ひとことで言ってしまえばトランジションを連続して実行させるようなものキーフレームを指定する▼@keyframescss3のアニメーションでは、決められた時間の中の度のタイミングでどの値がどう変化するのかをキーフレームと呼ばれる書式で記入します。@keyframes 名前 &#123; 0% &#123; プロパティ: 値; プロパティ: 値; … &#125; ?% &#123; プロパティ: 値; プロパティ: 値; … &#125; ?% &#123; プロパティ: 値; プロパティ: 値; … &#125; 100% &#123; プロパティ: 値; プロパティ: 値; … &#125;&#125;※補足説明キーフレームの「0%」は「from」、「100%」は「to」と書くことも出来ます。▼animation-nameプロパティアニメーションを実行させるためには、キーフレームを名前で指定し、アニメーションの再生時間を指定する必要がアリます。animation-nameプロパティは、キーフレームを名前で指定して実行させるためのプロパティ▼animation-durationプロパティアニメーションの再生時間を設定するプロパティtransition-durationプロパティと同様に値には時間を設定します。初期値は0sです。▼animation-timing-functionプロパティアニメーションの再生速度の変化パターンを設定するのがanimation-timing-functionプロパティ▼animation-delayプロパティアニメーションの再生を遅らせるプロパティ▼animation-iteration-countプロパティアニメーションを何回繰り返して再生させるのかを設定するプロパティ初期値は１inifiniteを指定すると、止めるかウィンドウを閉じるまで再生を繰り返します。▼animation-directionプロパティ再生の際に逆再生させるかどうか、または繰り返し再生する中で度のタイミングで逆再生させるのかを設定するプロパティ初期値はnormalです。▼animation-paly-stateプロパティアニメーションの再生を一時停止させる際に使用するプロパティpauseを指定すると一時停止し、runningを指定すると再生が開始されます。初期値はrunningです。▼animation-fill-modeプロパティanimation-delayプロパティによって再生の開始が遅延されている間の表示、及び再生終了後の表示を設定するプロパティ初期値はnone▼animationプロパティアニメーション関連のプロパティを纏めて指定できるプロパティ◯マルチカラムとフレキシブルボックス※重要・CSS3のマルチカラムレイアウトはボックスの内部を複数の段に分割する・columnsプロパティで段数を指定するだけで段組みになる。・display: flex;を指定すると、その子要素は左から順に横に並ぶ▼マルチカラムレイアウト複数のボックスを横に並べるタイプのレイアウトではなく、１つのボックスの内部を複数の段に分割するタイプのレイアウトです。▼column-countプロパティ何段組するのかを設定するプロパティ値には段数を１以上の整数で指定しまうす。初期値はautoです。body &#123; column-count: 3; &#125;▼column-width段の幅を設定するプロパティ初期値はauto▼columnsプロパティcolumn-countプロパティとcolumn-widthプロパティを纏めて指定できるプロパティ▼column-gapプロパティ段と段の間隔を指定する初期値はnormal 1em▼column-ruleプロパティ段と段の感化kの中央にはボックスのボーダーと同様の線を表示させることが出来ます。その線種・色・太さを個別に設定するのが次の３つのプロパティ・column-rule-styleプロパティ・column-rule-colorプロパティ・column-rule-widthプロパティ纏めて設定できるのがcolumn-ruleプロパティです。▼column-spanプロパティ指定された要素を段の中におさめて表示させるのではなく、段組が設定されているボックスの幅いっぱいに(すべての段をまたいで)表示させるプロパティです。値にはallとnoneが指定でき、初期値はnoneです。▼フレキシブルボックスレイアウト◯その他の新機能※重要・border-radiusの角丸の値は、角を1/4円に見立てたときの半径を指定する・box-shadowとtext-shadowの影の指定方法はほぼおなじ・グラデーション指定の基本形は、方向または中心位置と色を２色指定すればOK▼border-radiusプロパティボックスの角を丸くするプロパティ▼box-shadowプロパティボックスに影を表示させるプロパティ▼text-shadowプロパティテキストに影を表示させるプロパティ▼直線上のグラデーションCSSの書式で画像が指定可能なところであれば、url()の代わりにlinear-gradient()またはradial-gradient()という関数を使用してグラデーションを表示させることができるbackground: linear-gradient(#ddd, #333);▼放射状のグラデーション■Chapter7 CSSの各種プロパティと値■====================================================================◯フォント※重要・Webフォントを使用するには、@font-face&#123;&#125; の書式を指定する・CSS3では、font-variantは関連プロパティの値を一括指定するプロパティ・fontプロパティは、値の指定順序に注意する▼Webフォント@font-faceという書式を使用してWeb上にあるフォントを指定することで、そのフォントがインストールされていない環境でもそのフォントを表示させられるようになります。▼font-familyプロパティフォントの種類を設定するプロパティフォントはより前に(左側に)指定されているものが優先して適用されますので、キーワードは最後に指定するようにp&#123; font-family: &quot;メイリオ&quot;, &quot;ヒラギノ角ゴ pro W3&quot;, Helvetica, sans-serif; &#125;▼font-sizeプロパティフォントサイズを設定することができる初期値はmidiumです。▼font-weightプロパティ太さの異なる書体を選択するためのプロパティ初期値はnormal400が標準の太さ▼font-styleプロパティ同じフォントファミリーの中のイタリックまたは斜体の書体を選択するためのプロパティ・italic イタリック体専用にデザインされたフォントで表示。ない場合「oblique」と同様・oblique 斜体で表示。ない場合標準のフォントを斜めに変換して表示・normal イタリック体や斜体ではない標準のフォントで表示▼font-variantプロパティ▼fontプロパティフォント関連プロパティの値を纏めて指定できるプロパティ◯テキスト※重要・CSS3からは、下線・上線・取消線の色や線種が指定できる・word-breakプロパティは、行の折り返しに関する設定をする・hyphensプロパティは、ハイフネーションに関する設定をする▼text-decoration関連のプロパティ▼word-breakプロパティ行の折り返しに関する設定▼hyphensプロパティハイフネーションの設定を行うプロパティ▼white-spaceプロパティ「連続する空白文字を１つの半角スペースに変換するかどうか」と「自動的な行の繰り返しを行うかどうか」を制御する▼text-alignプロパティブロックレベル要素に指定し、その内容の行揃えを設定▼vertical-alignプロパティインライン要素の縦方向の位置を設定する▼line-heightプロパティ行の高さを設定するプロパティ▼text-indentプロパティブロックレベル要素の１行目のインデントを設定する▼letter-spacingプロパティ文字間隔を設定するプロパティ▼word-spacingプロパティ単語と単語の間隔を設定するプロパティ▼text-transformプロパティアルファベットの大文字小文字を変換して表示させるプロパティ▼directionプロパティ文字表記の方向を設定するltr：左から右rtl：右から左▼unicode-bidiプロパティ文字表記の方向に関する指示を組み込んだり上書きすることのできるプロパティよくわからない。。。◯ボックス※重要・幅と高さの適用される領域は、box-sizingプロパティで設定する・clearプロパティはブロックレベルの要素に指定する・displayプロパティは、テーブル関連・ルビ関連の表示形式も指定できる▼margin関連プロパティ▼padding関連プロパティ","categories":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/categories/HTML/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"}]},{"title":"ORACLE MASTER Oracle Database12c DBA Bronze","slug":"2016_10_ORACLE-MASTER_12c_DBA_Bronze","date":"2016-09-30T15:00:00.000Z","updated":"2019-07-19T14:46:58.271Z","comments":true,"path":"DB/2016_10_ORACLE-MASTER_12c_DBA_Bronze/","link":"","permalink":"http://yoursite.com/DB/2016_10_ORACLE-MASTER_12c_DBA_Bronze/","excerpt":"","text":"ORACLE MASTER Oracle Database12c DBA Bronze 学んだこと 別書籍で知識を付けていたOracleDBAの再学習 プロセスやOracleが持っている機能について、別書籍では触れられていない部分を学ぶことが出来た。 学習ログ 手に取った理由 Oracle Master Bronze資格取得のため","categories":[{"name":"DB","slug":"DB","permalink":"http://yoursite.com/categories/DB/"}],"tags":[{"name":"問題集","slug":"問題集","permalink":"http://yoursite.com/tags/問題集/"}]},{"title":"Webを支える技術","slug":"2016_07_Webを支える技術","date":"2016-06-30T15:00:00.000Z","updated":"2019-07-21T16:56:52.420Z","comments":true,"path":"EX/2016_07_Webを支える技術/","link":"","permalink":"http://yoursite.com/EX/2016_07_Webを支える技術/","excerpt":"","text":"Webを支える技術 目次 学んだこと WEBの歴史的なところ リソースとURI 使用すべきメソッド RESTについて 理解が難しかったので、もう一回読みたい本.. 手に取った理由 業務でJavaからPUTで他社APIを呼び出す必要に迫られた際、なんでPUT？POSTじゃだめなの？と思い、理由を深堀すべく本書を見つけ、購入","categories":[{"name":"EX","slug":"EX","permalink":"http://yoursite.com/categories/EX/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"},{"name":"再読","slug":"再読","permalink":"http://yoursite.com/tags/再読/"}]},{"title":"ORACLE MASTER Oracle Database12c SQL Bronze","slug":"2016_04_ORACLE-MASTER_12c_SQL_Bronze","date":"2016-03-31T15:00:00.000Z","updated":"2019-07-19T14:46:26.299Z","comments":true,"path":"DB/2016_04_ORACLE-MASTER_12c_SQL_Bronze/","link":"","permalink":"http://yoursite.com/DB/2016_04_ORACLE-MASTER_12c_SQL_Bronze/","excerpt":"","text":"ORACLE MASTER Oracle Database12c Bronze 学んだこと 別書籍で知識を付けていたOracleDBAの再学習 プロセスやOracleが持っている機能について、別書籍では触れられていない部分を学ぶことが出来た。 学習ログ 手に取った理由 Oracle Master Bronze資格取得のため","categories":[{"name":"DB","slug":"DB","permalink":"http://yoursite.com/categories/DB/"}],"tags":[{"name":"問題集","slug":"問題集","permalink":"http://yoursite.com/tags/問題集/"}]},{"title":"Effective Java","slug":"2016_03_Effective-Java","date":"2016-02-29T15:00:00.000Z","updated":"2019-07-21T16:45:15.406Z","comments":true,"path":"Java/2016_03_Effective-Java/","link":"","permalink":"http://yoursite.com/Java/2016_03_Effective-Java/","excerpt":"","text":"Effective Java 第二版 著者：Joshua Bloch ジョンシュア・ブロック （sun → google[Chief Java Architect]） 訳 ：柴田芳樹 Effective Java によせて 言語を使用するために習得しなければならない３つの事項 1. 文法 2. 語彙 3. 日々の事柄を話すための慣習的で効果的な方法 教室では文法、語彙のみ教わることが多い 慣習的な方法を習わずに必死に話を伝えようとするして、ネイティブに笑われる プログラミング言語も全く同じ 本書は３番目の要求に取り組んでいる 全体読んでわかったこと 基本的に言いたいことは、エラーについてコンパイル時に気づくことが正しく、実行時に気づくことは良くない パフォーマンスに言及している 他、英語翻訳の片言的な書き方が目立つ 第１章 はじめに ライブラリ - java.lang - java.util - java.util.concurrent - java.io 対象者 - Java使いこなしている人 そうでない人は入門書をお読みください 第２章 オブジェクトの生成と消滅- どのようにオブジェクトを生成スべきか - いつどのように生成を回避スべきか - オブジェクトが適切なタイミングで消滅することをどのように保証するか - オブジェクト消滅前に実行しなければならない後処理をどのように行うか 項目１ コントラクタの変わりにstaticファクトリーメソッドを検討するStaticファクトリーメソッド 長所と短所が存在する 長所 メソッド名がつけられるので分かりやすい コンストラクタのように同じシグニチャを持つものが２つ以上存在できないという制約はないし、ドキュメントがなくても分かりやすい コンストラクタはドキュメントがないと、中身を見ないと何をしているかわからない メソッドが呼び出されるごとに新たなオブジェクトを生成する必要がない 不必要に重複したオブジェクトの生成を回避できる Flyweightパターンに似てる 何度呼び出されても同じオブジェクトを返すことができる インスタンス制御されている（incetance-controlled） equalsメソッドの代わりに==演算子が使用可能 →パフォーマンスが大幅に上がる Enum型はこの保証を提供している 戻り値の型の任意のサブタイプのオブジェクトでも返すことができる インターフェースに基づくフレームワーク（interface-based-framework）項目１８ Collections Framework コレクションのインターフェースの便利な実装が３２個ある 概念的重みが軽くなっている クライアントはインターフェースで返されたオブジェクトを受け取る EnumSetはenum型の要素数に応じて返却するインスタンスが異なる これらはクライアントには見えない Java Database Connectivity API (JDBC) などのサービス・プロバイダフレームワークの基本となるもの サービスインターフェース：プロバイダが実装する プロバイダ登録API：クライアント サービスアクセスAPI：サービスのインスタンスをクライアントが取得するためのもの パラメータ化された型のインスタンス生成の面倒さを低減する new でもダイヤモンド構文でJava1.7から簡単に記述可能 あまりすごいメリットでもない 短所 publicあるいはprotectedのコンストラクタを持たないクラスのサブクラスを作れないこと 継承ではなくコンポジションを使おう それらが容易に他のstaticメソッドと区別がつかないこと 項目２ 数多くのコンストラクタパラメータに直面した時にはビルダーを検討するstaticファクトリメソッドもコンストラクタが持っている共通の制約 数多くのパラメータに対してうまく対応できない これらの対処として、テレスコーピングコンストラクタパターンを利用していた テレスコーピングパターン パラメータの数が増えるとすぐに手に負えなくなる クライアントがパラメータの値の２つを逆にしてしまっても、コンパイラは何も警告しませんが誤った振る舞いをしてしまう JavaBeansパターン パラメータなしのオブジェクトを生成して、setメソッドでセットしていく 生成過程で不整合な状態にあるかもしれない バグを含んでいるコードから離れた場所で失敗するかも Builderパターン テレスコーピングコンストラクタの安全性とJavaBeansパターンの可読性を併せ持つ AdaやPythonにみたいな名前付きオプションパラメータをビルダーパターンは模倣しています パフォーマンスに影響がある可能性があるが、パラメータが４つ以上ある場面では大抵の場合メリットのほうが大きい 途中でBuilderに替えると使われなくなったコンストラクタやStaticメソッドはゴミになってしまうので、最初からビルダーで始めたほうがよい 項目３ privateのコンストラクタかenum型でシングルトン特性を強制するシングルトンとは 一度しかインスタンスが作成されないクラス ＊割愛＊再確認 現状、シングルトンを実装する最善の方法は、単一要素のenum型を用いること 項目４ privateのコンストラクタでインスタンス化不可能を強制するユーティリティクラスを作成する際は、public static メソッドを定義のうえ、 コンストラクタをprivateにして、明示的にインスタンス化できないかつ継承できないことをコメントに記すべし コンストラクタの中に、throw new AssertionError(); を定義すると、誤ってクラス内からコンストラクタが呼び出されたときの保険になる 項目５ 不必要なオブジェクトの生成を避けるString s = new String(“stringette”); // これは絶対にやってはいけない 呼び出しごとに新しいインスタンスが生成されてしまう。 不変な値であれば、クラス定数としてprivate static finalで定義しておき、 初期化を static{}でするべき 一度も呼び出されない場合は無駄な初期化になりえるが、遅延初期化を実装するのはもっと大変なので避けてもよい 自動ボクシング時にインスタンスが生成されるので気をつけて 項目３９「防御的コピー」との対比 必要な場所で防御的コピーをしなければ、悪質なバグやセキュリティホールを生み出しかねない 不必要なオブジェクトを生成するのは、単にスタイルとパフォーマンスに影響するだけ 項目６ 廃れたオブジェクト参照を取り除く配列の廃れた参照に対する配慮 スタックが大きくなったあとに小さくなるト、大きくなった部分のオブジェクトがガベージコレクトの対象にならない Queオブジェクトでよいよねー 項目７ ファイナライザを避けるファイナラーザは予測不可能で大抵の場合は必要ない 不安定な振る舞い低いパフォーマンス移植性の問題原因 実行される保証がないファイナライザを持つオブジェクトの生成と開放は430倍遅い明示的に閉じる、inputStream,outputStreamオブジェクトもfinalizeメソッドを実装しており、GC対象になったときに呼び出されるが、あくまで保険的な意味合いなので、明示的にcloseするのが好ましい ファイナライザを使用する場面安全ネット（closeシワスレの保険）ネイティブ資源の開放 結論ファイナライザは使用しない 第３章 すべてのオブジェクトに共通のメソッド項目８ equalsをオーバーライドする時は一般契約に従うequalsメソッドを誤ってオーバーライドしては行けない 次の条件に当てはまるときはオーバーライドしないのが妥当 クラスの個々のインスタンスは、本質的に一意である 論理的等価性検査をクラスが提供するかどうか関心がない スーパークラスがすでにequalsをオーバーライドしており、スーパークラスの振る舞いがこのクラスに対して適切である AbstractSetやAbstractListが実装しており、SetやListは継承している クラスがprivateあるいはパッケージプライベートであり、そのequalsメソッドが決して呼び出されないことが確かである このような場合は、偶然呼び出された時を考慮して、 throw new AssertionError(); を実装するべき equalsメソッドは同値関係を実装する 反射的 対照的 推移的 整合的 咀嚼できていない そもそもequalsメソッドを実装（オーバーライド）することが稀 いままでそのような処理を見たことがない 項目９ equalsをオーバーライドする時は、常にhashCodeをオーバーライドするhashMapのキーにequalsメソッドを実装したクラスを設定する場合、new 対象オブジェクト名();で 設定すると、equalsメソッドではtrueを返却する場面で、hashCodeメソッドはことなる値を返却するためMapの値が取れない現象が発生するらしい こちらも項目８同様あまり使用しないのではないか equalsメソッドをオーバーライドするときに気をつけよう！ そもそもオブジェクトをキーにHashマップを作成する場面があまり想像できない hash値を算出するにあたって「31」を使用するべきらしい 偶数だと乗算がオーバーフローしたときに情報が失われる？みたい https://www.thekingsmuseum.info/entry/2015/08/28/000748 https://computinglife.wordpress.com/2008/11/20/why-do-hash-functions-use-prime-numbers/ 項目10 toStringを常にオーバーライドするデフォルトだと「クラス名@ハッシュコード」 一般的にユーザが見てもなんのメリットもない情報 返される文字列は「簡潔だが、人が読みやすくなっている有益な表現」であるべき！ 実用的な場合には、toStringメソッドはオブジェクトに含まれる興味のある情報をすべて！！返すべき！ なお、返却する値の説明はJavadocコメントに記載すべき！ フィールド値をすべて出力したい際は、 commmons.langのToStringBuilder#reflectionToString(Object object)を使ってもよいのでは？ パフォーマンスが懸念… どのくらい遅くてどんなデメリットがあるのか別途検証したい！ 項目11 cloneを注意してオーバーライドするcloneメソッドはObjectクラスで実装されている Cloneableインターフェース自体は空である。 Cloneableインターフェースを実装しないと、cloneメソッド呼び出し時に CloneNotSupportedExceptionがスローされる Cloneableインターフェースを実装しているクラスは、適切に機能する、publicかprotectedのCloneメソッドを提供すべき 返却されるオブジェクトは自クラスにキャストすべき x.clone () != x が true であり、 x.clone().getClass() == x.getClass() も true であるインスタンスを生成すること。 ただし、これらの項目は絶対的なものではなく、 x.clone().equals(x) は通常 true である。 ObjectクラスはJavaのNativeソースでCloneableの実装をしているみたい http://stackoverflow.com/questions/12032292/is-it-possible-to-find-source-for-java-native-method 少し消化不良なので再確認 項目12 Comparableの実装を検討するソートしたい場合に検討 Comparableインターフェース compareToメソッドを実装する 自分自身が渡されたオブジェクトより小さければ負の値を返す 自分自身が渡されたオブジェクトより大きければ正の値を返す 自分自身が渡されたオブジェクトと等しければ 0 を返す ので、こちらを順序だてて実装 ただ、実装クラスを拡張する場合は、継承ではなく移譲すること 補足 Comparatorインターフェースを実装することで並び替えを実現することもできる 違い Comparableインターフェース：自クラスに実装 Comparatorインターフェース：他クラスに実装 Comparatorが比較処理を外だしできていい感じに思えるが、クラス作成するのが面倒。。 JavaSE8から、「Comparator.comparingメソッド」が使えるようになったので、キー項目を単純にソートするだけならラムダ式でスマートに実装可能 http://totech.hateblo.jp/entry/2017/01/10/123602 第４章 クラスとインタフェース項目13 クラスとメンバーへのアクセス可能性を最小限にするうまい設計と下手な設計の違い どの程度内部データと実装の詳細を隠蔽しているか 情報隠蔽またはカプセル化と呼ばれる ソフトウェアの再利用を促進 大規模システム構築の場合のリスク軽減 システムが成功しなくても、個々のモジュールとしては成功するかもしれません 各クラスやメンバーをできる限りアクセスできないようにするべき メソッドをオーバーライドする際は、スーパークラスが実装しているメソッドより、広い範囲のアクセス修飾子を指定しないといけない インターフェース内のすべてのメソッドは暗黙にpublic インターフェースを実装するクラスは、オーバーライド時、絶対にpublicを指定しないと行けない インスタンスフィールドは決して、publicにしては行けない publicの可変フィールドを持つクラスはスレッドセーフではない！ スレッドセーフ関連について深く理解できていないので再確認 public static finalで可変オブジェクトを格納しているソースはありえない。しては行けない。 そのフィールドに入る値の不変性を保証できなくなる 配列をfinalで宣言しても変更できないのは配列のインスタンスであり、配列の要素を変更することは可能 リストやマップも通常finalで宣言しても変更可能 unmodifiableListを使わなければならない https://www.sejuku.net/blog/20977 セキュリティホールになりうる例として紹介されている 項目14 publicのクラスでは、publicのフィールドではなく、アクセッサーメソッドを使うセッターゲッタの話 publicなクラスの場合、フィールドをpublicで公開すると、 その内部的な表現を永久に変更できなくなる クラスがパッケージプライベートかprivateのネストしたクラスならpublicにすることは本質的に問題ない Javaライブラリーでいくつかのクラスはこの提言を無視している Java.awtのPointクラスやDimensionクラス フィールドが不変な場合、publicとして公開することは、害が少ないが、一般的にはゲッターとセッターを提供すべき 項目15 可変性を最小限にするクラスを不変にするための５つの原則 １・オブジェクトの状態を変更するためのいかなるメソッドも提供しない ２．クラスが拡張できないことを保証する。 finalでクラスを定義 ３．すべてのフィールドをfinalにする。 ４．すべてのフィールドをprivateにする。 ５．可変コンポーネントに対する独占的アクセスを保証する クラスが可変オブジェクトを参照しているフィールドを持っている場合、クライアントが参照できないことを保証すること この項目で言いたいことを掘り下げれてないのであとで見返す 項目16 継承よりコンポジションを選ぶ継承はコードを再利用するための強力な方法 不適切に使用されると継承はもろいソフトウェアを作り出します パッケージをまたがって普通の具象クラスから継承することは危険 ここでいう継承は実装継承を意味します クラスがインターフェースを実装した場合や、 インターフェースが他のインターフェースを拡張した場合のインターフェース継承には適用しない メソッド呼び出しと異なり、継承はカプセル化をやぶる スーパークラスに変更があった場合、サブクラスは一緒に変更しなければ行けない可能性がある HashSetを継承して、addメソッドが呼び出された回数をカウントするサブクラスを作成する add時にカウントアップ addAll時に、引数のサイズ分カウントアップしようとするが、HashSetクラスが内部的に addAllメソッドの中でaddメソッドを呼び出しているので、２重カウントとなってしまう このサブクラスはHashSetの実装に依存しており、脆いクラスになっていると言える スーパークラスのメソッド追加も、サブクラスの実装メソッドと同じシグニチャで、戻り値が異なる場合、 サブクラスはコンパイルできなくなる propertiesクラスの例 結論 継承はなるべく使わないようにしよう 経験則、Javaでバッチ処理を実装する際、ログを残すための設定、基本となる設定ファイルを読み込み値の保持をスーパークラスでやっているロジックをみたことがあるが、そういう場合は継承は効果的なのかもしれない。（処理をがつがつ書いているスーパークラスじゃないから） 項目17 継承のために設計および文書化する、でなければ継承を禁止するクラスはオーバーライド可能なメソッドの事故利用を文書化しないと行けない 自己利用(self-use)の文書化 継承は慎重に カプセル化を破壊する可能性がある 咀嚼しきれてないので再度見直す 項目18 抽象クラスよりインタフェースを選ぶ複数の実装を許す型を定義するために 抽象クラスとインターフェースを定義している 違いは、抽象クラスはいくつかの実装を含むことが許されていて、インターフェースは許されていないこと 抽象クラスで定義された型を実装するためには、クラスはその抽象クラスのサブクラスでなければならない 複数のインターフェースを混ぜ合わせて実装することをミックスインという このミックスインはインターフェースのみ許されていて、抽象クラスでは多重継承が許されていないため実現できない P92の組み合わせ爆弾について不明 なんで抽象クラスではなく、インターフェースじゃないとだめなのか、具体的なデメリットが確立できていないので再確認が必要 以下に調査を書いていたが結論でてない https://www.thekingsmuseum.info/entry/2015/09/26/165815 項目19 型を定義するためだけにインタフェースを使用するインターフェースを実装するということは、そのクラスのインスタンスは何ができるかについて述べているべき 定数インターフェースはこの限りでない。定数管理にインターフェースを使うのはよろしくない Javaのライブラリーにはjava.io.ObjectStreamConstantsなどの定数インターフェースがあるが、真似すべきではない！ 定数を提供する場合、 クラスやインターフェースと強く結びついているならば、IntegerやFloatなどのように定数を提供 定数が列挙型のメンバーとしてみなされるべきなら、Enum型で提供すべき そうでなければインスタンス化不可能なユーティリティクラスで定数を提供すべき 項目20 タグ付クラスよりクラス階層を選ぶタグ付きクラスは冗長で誤りやすく、非効率 タグ付きクラス：インスタンスが２以上の特性を持っていて、その特性を示すためのタグフィールドを持ったクラスのこと 円と四角形を表現したいと思い、２種類のタグ属性をフィールドに保持したクラス コンストラクタでオブジェクト生成時に、生成しようとしているオブジェクトはどちらのタグに当たるのかを判断して、 フィールドに保持する。 タグ付きクラスを使用する事によるデメリット 一方のタグでは使わない、不要なフィールドにより、メモリ領域を抱えることになる 処理にswitchを用いる事になり、タグが増加した場合の修正が大変 タグフィールドを持つクラスを書きたくなったら、そのタグを取り除いてクラス階層で置き換えられないかを考えてください タグフィールドを持つクラスに出くわしたら、クラス階層になるようにリファクタリングできないか検討してください 腑に落ちた。タグ付きクラスは設計しないようにする。できるだけ継承関係（階層）で表現する 項目21 戦略を表現するために関数オブジェクトを使用する関数ポインタの主な使用方法は、戦略パターンを実装すること 戦略を表すインターフェースと、個々の具象戦略に関してそのインターフェースを実装しているクラスを宣言 具象クラスが１度しか使用されない場合はそのクラスは一般には無名クラスを使用して宣言及びインスタンス化すべき 繰り返し使用される場合は、そのクラスは一般的にprivate staticのメンバークラスであり、戦略インターフェースの型を持つpublic static finalのフィールドを通して提供されます インターフェースを実装したフィールドを持たないステートレスなクラスを定義することは有用 ステートレスなクラスは、シングルトンで設計すべき、メモリ節約 項目22 非staticのメンバークラスよりstaticのメンバークラスを選ぶネストしたクラスは、他のクラス内に定義されたクラスのこと ネストしたクラスは、そのエンクロージングクラスに対して仕えるためだけに存在すべき ネストクラスとしては以下の４種類がある staticのメンバークラス 非staticのメンバークラス（内部クラス） 無名クラス（内部クラス） ローカルクラス（内部クラス） 非staticな内部クラスはエンクロージングクラスへの参照を持っているので、 参照する必要がなければ、staticなメンバークラスを定義するべき 第５章 ジェネリックス項目23 新たなコードで原型を使用しない 原型の使用は実行時例外の可能性があるため、使用しないこと ジェネリクスが提供されるコードとの互換性を保つためだけに、原型の使用がサポートされている 原型のまま使用することは可能であるが、できる限りやめたほうが懸命 ジェネリクスの安全性と表現力をすべて失うことになる 結論 ジェネリクスの型を使用するとコンパイル時に誤りに気づくことができ、メリットのほうが多いため、 必ず型宣言すること。 項目24 無検査警告を取り除く- 無検査キャスト警告 - 無検査メソッド呼び出し警告 - 無検査ジェネリック配列生成警告 - 無検査変換警告 このような警告を放置しているソースを見るが、取り除くことが可能なすべての無検査警告は取り除いたほうがよい もし、警告を起こしているコードが型安全だｓと明確に示すことができれば、そのときに限って @SuppressWarnings(“unchecked”)アノテーションで警告を抑止してください 安全だとわかっているのに警告を放置するのもだめだし、安全じゃない警告も取り除くべき SuppressWarningアノテーションを使用する際はできる限り最小のスコープで使用するべき 広範囲につけることも可能だが、意図せぬ警告を抑止してしまう可能性があるため ■まとめ 無検査警告は重要、無視しないでください すべての無検査警告は実行時の ClassCastExceptionの可能性があることを表しています コードが安全だと明確に示せるのであれば、最小スコープで@SuppressWarningアノテーションで警告を抑止してください 警告を抑止するときは抑止した理由をコメントで残してください 項目25 配列よりリストを選ぶ配列は２つの重要な点でジェネリック型と異なる [１]. 配列は共変 SubがSuperのサブタイプである場合、配列型Sub[]がSuper[]のサブタイプだということ 実行時にわかるよりコンパイル時にエラーになることがわかったほうがよい 123456789// 実行時に失敗するObject[] objectArray = new Long[1];objectArray[0] = \"I don't fit in\"; // ArrayStoreExceptionがスローされる/**しかし、次のコードは許されていない **/// コンパイルされない！List&lt;Object&gt; ol = new ArrayList&lt;Long&gt;();ol.add(\"I don't fit in\"); [２]. 配列は具象化されている ジェネリックはイレイジャ（erasure）で実装されているのでコンパイル時のみ型制約を強制し、 実行時には要素の型情報を廃棄（すなわちイレイズ）することを意味している これらの基本的な相違点により、配列とジェネリックスはうまく調和しません。 ジェネリック配列の生成は、型安全ではないから許されていない もし許されていると、他の正しいプログラム内にコンパイラが生成したキャストが、実行時にClassCastExceptionで失敗することになる これは、ジェネリック型システムが提供している、基本的な保証を破ることになる この２つを調和させることは難しいので、設計する際は配列ではなく、リストを使用する 項目26 ジェネリック型を使用するジェネリック型はクライアントのコードでキャストが必要である型より、安全で使いやすい 新たな型を設計する場合、クライアントのコードでキャストが不要であることを確認してください たいていの場合、型はジェネリックにすることを意味している 時間が許せば、既存の型をジェネリック化してください そうすることで、既存のクライアントヲ動作させたまま、それらの型の新たなユーザをもっと楽にしてくれます ※再確認項目 項目27 ジェネリックメソッドを使用する※再確認項目 項目28 APIの柔軟性向上のために境界ワイルドカードを使用するジェネリック型は本来であれば、継承関係問わずすべて一致していないと行けない PECS Producer Extends Consumer Super APIの型を柔軟にしてくれる ※再確認項目 項目29 型安全な異種コンテナーを検討する※再確認項目 第６章 enumとアノテーションJava1.5より以下が追加された Enum型（あらたな種類のクラス） アノテーション型（新たな種類のインターフェース） これらを活用する方法を紹介 項目30 int定数の代わりにenumを使用する理解度：★★★★☆ int定数に対するenum型の利点は、否定できるものではなく、はるかに読みやすく、安全であり、強力 多くのEnum：明示的なコンストラクタやメンバを必要としない 他の多く：各定数にデータを関連付けたり、そのデータに依存して振る舞いが変わるメソッドを提供 自分自身の値によってswitchを実装するよりは、abstractメソッドを実装するように強制したほうがよい 複数のenum定数が共通の振る舞いヲ共有する場合は、abstractメソッドではなく、戦略enumパターンを検討するほうがよい 項目31 序数の代わりにインスタンスフィールドを使用する理解度：★★★★★ ordinalメソッドが提供されているが、それはEnumSetやEnumMapなどの汎用のenumに基づくデータ構造によりしようされるように設計されているため、そのようなデータ構造を書いているのでなければ、ordinalメソッドは全く使用しないことが最善 フィールドに序数を関連付けたいときは、コンストラクタ引数を渡してインスタンスフィールドに保持すること！！ 項目32 ビットフィールドの代わりにEnumSetを使用する理解度：★★★★☆ ビットフィールドを用いた実装方法 12345678910111213public class Text &#123; public static final int STYLE_BOLD = 1 &lt;&lt; 0; // 1 public static final int STYLE_ITALIC = 1 &lt;&lt; 1; // 2 public static final int STYLE_UNDERLINE = 1 &lt;&lt; 2; // 4 public static final int STYLE_STRIKETHROUGH = 1 &lt;&lt; 3; // 8 public void applyStyles(int styles) &#123; ... &#125;&#125;// 利用text.applyStyles(STYLE_BOLD | STYLE_ITALIC); 定数の集合を引き回す必要がある場合にビットフィールドを使用することに固執している人もいる デメリット int num定数のすべての短所を持っている（コンパイルされるとクラスに入り込む・名前空間がない） 数値として表示された場合は解釈が困難 ビットフィールドすべてをイテレートする簡単な方法も存在しない 良い例） 12345678910111213141516// EnumSet - a modern replacement for bit fields (Page 170)public class Text &#123; public enum Style &#123;BOLD, ITALIC, UNDERLINE, STRIKETHROUGH&#125; // Any Set could be passed in, but EnumSet is clearly best public void applyStyles(Set&lt;Style&gt; styles) &#123; System.out.printf(\"Applying styles %s to text%n\", Objects.requireNonNull(styles)); &#125; // Sample use public static void main(String[] args) &#123; Text text = new Text(); text.applyStyles(EnumSet.of(Style.BOLD, Style.ITALIC)); &#125;&#125; まとめ 列挙型が集合の中で使用されるというだけで、それをビットフィールドで表現する理由はない 短所としては、不変なEnumSetが生成できないことですが、1.6移行のリリースで改善できるだろう EnumSetをCollections.unmodifiableSetで包むことで対応可能 考察 不変のEnumSetはJava8でも追加されていない 項目33 序数インデックスの代わりにEnumMapを使用する理解度：★★☆☆☆ 相転移マップを作成する際の例 固体、液体、気体 の状態遷移 まとめ 配列インデックスのために序数を使用することが適切であることはめったにない 代わりにEnumMapを使用すること 表現使用している関係が多次元なら、EnumMap&lt;…, EnumMap&lt;…&gt;&gt;を使用してください 項目34 拡張可能なenumをインタフェースで模倣する理解度：★★★☆☆ 項目２９の境界型トークンと境界ワイルドカード型らへんが理解できていないので再確認 まとめ 拡張可能なEnum型を書くことはできませんが、基本のenum型に伴うインターフェースを書いて、そのインターフェースをその基本のenum型に実装させることで模倣できる そのインターフェースを実装している独自のenum型を実装させることができる 項目35 命名パターンよりアノテーションを選ぶ理解度：★★★★☆ 命名パターンとは testで始まるメソッドをテスト対象として抽出する、、、みたいなルールをつけておくこと これは簡単に破られる、実行時まで気づかない、下手すると実行時も気づかず、正常終了したと思いこむ アノテーションを使えば、アノテーションが付与されているものを抽出することが可能 まとめ 今はアノテーションが提供されているので命名パターンを使うのは避けること 標準提供のアノテーション例 Override Deprecated SuppressWarnings 項目36 常にOverrideアノテーションを使用する理解度：★★★★★ 常にOverrideすること 問題のあるプログラム 1234567891011121314151617181920212223242526272829package effectivejava.chapter6.item40;import java.util.*;// Can you spot the bug? (Page 188)public class Bigram &#123; private final char first; private final char second; public Bigram(char first, char second) &#123; this.first = first; this.second = second; &#125; public boolean equals(Bigram b) &#123; return b.first == first &amp;&amp; b.second == second; &#125; public int hashCode() &#123; return 31 * first + second; &#125; public static void main(String[] args) &#123; Set&lt;Bigram&gt; s = new HashSet&lt;&gt;(); for (int i = 0; i &lt; 10; i++) for (char ch = 'a'; ch &lt;= 'z'; ch++) s.add(new Bigram(ch, ch)); System.out.println(s.size()); &#125;&#125; eqalsメソッドのシグニチャがObjectではないため、オーバーライドではなく、オーバーロードになってしまっている このことにプログラマは気づけない 常に@Overrideをつけることでこれを回避できる 12345678910111213141516171819202122232425262728293031323334package effectivejava.chapter6.item40;import java.util.HashSet;import java.util.Set;// Fixed Bigram class (Page 189)public class Bigram2 &#123; private final char first; private final char second; public Bigram2(char first, char second) &#123; this.first = first; this.second = second; &#125; @Override public boolean equals(Object o) &#123; if (!(o instanceof Bigram2)) return false; Bigram2 b = (Bigram2) o; return b.first == first &amp;&amp; b.second == second; &#125; public int hashCode() &#123; return 31 * first + second; &#125; public static void main(String[] args) &#123; Set&lt;Bigram2&gt; s = new HashSet&lt;&gt;(); for (int i = 0; i &lt; 10; i++) for (char ch = 'a'; ch &lt;= 'z'; ch++) s.add(new Bigram2(ch, ch)); System.out.println(s.size()); &#125;&#125; HashSetに格納しており、全てすべて異なるオブジェクトと判断されて、結果に誤りが生じているが、正しくequalsメソッドをオーバーライドすることで回避 例外 抽象クラスの抽象メソッドを実装するときは、実装していないことをコンパイラが警告してくれるので@overrideを記載しなくても大丈夫。記載して問題ない まとめ スーパータイプの宣言をオーバーライドしているすべてのメソッド宣言にOverrideアノテーションを使用することでコンパイラは多くの誤りを指摘してくれる 具象クラスでは、抽象メソッド宣言をオーバーライドしているメソッドにアノテーションをつける必要はない 項目37 型を定義するためにマーカーインタフェースを使用する理解度：★★★★☆ マーカーインターフェース メソッド宣言を１つももたいないインターフェース そのインターフェースを実装しているクラスがなにか特別な性質を持っていることを示す マークされたクラスのインスタンスが実装している型を定義することに意味を持っている 指摘：Serializableインターフェースを活用しなかった、ObjectOutputStream.write(Object)への指摘 マーカーアノテーション 型定義はしていない 何らかの特性を示すためのアノテーション アノテーション自体がメタデータを示すものなので、アノテーション全部がマーカーの役割を担っている どちらを使うか決める方法 クラスやインターフェース以外のプログラム要素に対してマーカーが適用されるのであれば「マーカーアノテーション」 このマークを持つオブジェクトだけを受け付ける１個以上のメソッドを書きたいのであれば「マーカーインターフェース」 Serializableト同じ用法 このマーカーの使用を特定のインターフェースの要素に永久に制限したい「マーカーインターフェースのサブインターフェースで使用」 まとめ マーカーインターフェースの使用を最初に検討 使用できないのであれば、マーカーアノテーションを使用する 第７章 メソッド この章について メソッド設計の側面について議論 パラメータと戻り値をどの様に扱うか メソッドのシグニチャをどの様に設計するか メソッドをどの様に文書化するか 多くは、メソッドだけでなく、コンストラクタにも適用される 本章は利便性、頑強性、柔軟性に焦点を当てている 項目38 パラメータの正当性を検査する理解度：★★★★☆ ほとんどのメソッド、コンストラクタはパラメータとして渡される値に関して、何らかの制約を持っている Nullであっては行けない、負の値であっては行けないとか このような制約は明確に文書化すべきであり、メソッド本体のはじめに検査することで制約を強制すべき そうしないと、予想外の場所でエラーになり原因特定が困難になる パラメタの検査をメソッドがしないと発生する問題 メソッドが処理の途中でわけのわからない例外で失敗する メソッドは正常に終了するが、何も言わずに誤った結果を計算する いくつかのオブジェクトを不正な状態にして、あとになって全くコードと関係のないところでエラーを引き起こす publicのメソッドに対しては、パラメータ値に関する制約が守られていない場合にスローされる例外を、Javadocの@throwsタグを使用して文書化すべき（項目６４） アサート定義について 通常の正当性検査とは異なり、アサーションは条件が成り立たなければAssertionErrorをスローします。通常の正当性検査とは異なり、javaのインタプリタに-ea（あるいは、-enableassertions）を渡してアサーションを有効にしない限り、アサーションはなんの効果もなく基本的にコストは発生しません。 まとめ メソッド、コンストラクタを書く場合は、その都度、そのパラメータにどのような制約が存在するのか考えるべき それらの制約を文書化すべきだし、メソッド本体のはじめで、明示的に検査することで制約を強制すべき このような習慣を身につけることが大事 この地道な作業は、正当性検査に初めて引っかかったときに報われます 項目39 必要な場合には、防御的にコピーするJava言語は安全な言語 CやC++などの安全で内言語に感染するバッファーオーバーラン、配列オーバーラン、でたらめなポインタ、他のメモリ破壊エラーなどに対して、Java言語には免疫がある これはメモリをすべて１つの巨大な配列として扱っている言語では不可能です たとえ安全であっても、自分の方で何かしらの努力をしなければ他のクラスから防御されない 「クラスのクライアントは、クラスの不変式を破壊するために徹底した努力をすると想定して防御的にプログラムしなければなりません。」＝壊される想定で防御していかなければならない あなたのプログラムを利用する、プログラマーの単純な間違いに対処するためにも、防御が必要 攻撃の可能性例) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package effectivejava.chapter8.item50;import java.util.*;// Broken \"immutable\" time period class (Pages 231-3)public final class Period &#123; private final Date start; private final Date end; /** * @param start the beginning of the period * @param end the end of the period; must not precede start * @throws IllegalArgumentException if start is after end * @throws NullPointerException if start or end is null */ public Period(Date start, Date end) &#123; if (start.compareTo(end) &gt; 0) throw new IllegalArgumentException( start + \" after \" + end); this.start = start; this.end = end; &#125; public Date start() &#123; return start; &#125; public Date end() &#123; return end; &#125; public String toString() &#123; return start + \" - \" + end; &#125;// // Repaired constructor - makes defensive copies of parameters (Page 232)// public Period(Date start, Date end) &#123;// this.start = new Date(start.getTime());// this.end = new Date(end.getTime());//// if (this.start.compareTo(this.end) &gt; 0)// throw new IllegalArgumentException(// this.start + \" after \" + this.end);// &#125;//// // Repaired accessors - make defensive copies of internal fields (Page 233)// public Date start() &#123;// return new Date(start.getTime());// &#125;//// public Date end() &#123;// return new Date(end.getTime());// &#125; // Remainder omitted&#125; コンストラクタにオブジェクトを渡して、コンストラクタ側でメンバー変数として保持する場合、コンストラクタ内で新たにnewして（防御的にコピーして）メンバー変数に保持しなければならない これを利用した攻撃を、コンピュータセキュリティのコミッティではtime-of-check/time-of-use攻撃と呼ばれている（TOCTOU攻撃） まとめ クラスがそのクライアントから得たり、クライアントへ返したりする可変の要素を持っているならば、そのクラスはそれらの要素を防御的にコピーしなければならない もしコピーのコストが非常に高く、要素を不適切に変更しないということをでクラスがクライアントを信頼できるならば、影響を受ける要素を変更しないことがクライアントの責任であるとドキュメンテーションに概要を示すことで、防御的コピーの代わりとしても良いです。 パフォーマンス懸念について調査 ArrayListのデフォルトコンストラクタで生成されるインスタンスのデータ容量は１０であり、大量データをAddすることが確定している場合は最初からサイズ指定してコンストラクタを使うべき 参考）「Javaでプログラムを書く際に意識しておきたいこと」https://blog.y-yuki.net/entry/2017/06/07/130000 項目40 メソッドのシグニチャを注意深く設計する理解度：★★★☆☆ 本項目はAPI設計のヒントを集めたもの メソッド名を注意深く選ぶ 標準命名規約（項目５６）に従うべき 目標：理解可能で、同じパッケージ内の他の名前と矛盾のない名前を選ぶこと 目標：存在する広範囲のコンセンサス（合致、合意）と矛盾がない名前を選ぶこと 疑問がある場合はガイダンスとして、JavaライブラリのAPIを参考にしてください、矛盾が沢山ありますが、大きさと範囲を考えると避けられない矛盾。 かなりのコンセンサスがあることに注目してほしい 便利なメソッドを提供しすぎない 自分の役割を果たすべき 頻繁に使用される場合だけ、ある操作に対する速記（shorthand）を提供することを検討すること 長いパラメタのリストは避ける（４個以下を目標にする） ほとんどのプログラマは長いパラメータリストを覚えられない 同じ型のパラメータが何個も続くのは特に有害 長いパラメータを短くする方法 1.メソッドを分割して、各メソッドはパラメータのサブセットだけを必要とする 2.パラメータの集まりを保持するヘルパークラスを作成する（Staticのメンバークラス）（項目２２） 3.ビルダーパターンをオブジェクト生成からメソッド呼び出しに適用すること パラメータ型に関しては、クラスよりインターフェースを選ぶ（項目５２） HashMapパラメタに取るメソッドを作成する理由はなくて、Map型で定義しておく そうすれば、Hashtable、HashMap、TreeMapどれでも渡すことが可能となる booleanパラメータより２つの要素を持つenum型を使用する。12345678910public enum TemperatureScale &#123; FAHRENHEIT, CELSIUS &#125;Thermometer.newInstatnce(true);// よりThermometer.newInstance(TemperatureScale.CELSIUS);// のほうが分かりやすい// TemperatureScaleに KELVIN を追加することも可能 項目41 オーバーロードを注意して使用する理解度：★★★☆☆ 123456789101112131415161718192021222324252627282930313233// 不完全！ このプログラムは何を表示するでしょうかpackage effectivejava.chapter8.item52;import java.util.*;import java.math.*;// Broken! - What does this program print? (Page 238)public class CollectionClassifier &#123; public static String classify(Set&lt;?&gt; s) &#123; return \"Set\"; &#125; public static String classify(List&lt;?&gt; lst) &#123; return \"List\"; &#125; public static String classify(Collection&lt;?&gt; c) &#123; return \"Unknown Collection\"; &#125; public static void main(String[] args) &#123; Collection&lt;?&gt;[] collections = &#123; new HashSet&lt;String&gt;(), new ArrayList&lt;BigInteger&gt;(), new HashMap&lt;String, String&gt;().values() &#125;; for (Collection&lt;?&gt; c : collections) System.out.println(classify(c)); &#125;&#125;// Unknown Collection を３回表示することになる まとめ オーバーロードできるからと言ってオーバーロードスべきではない 一般的には、同じ数のパラメータを持つ複数のシグニチャでメソッドをオーバーロードすることは控えるべき 場合によっては、コンストラクタが関与すると従えない可能性もある.. そうなっても、キャストによって同じ組み合わせを異なるオーバーロードされたメソッドにわたすことができる状況は避けるべき 避けられない場合は、オーバーロードされたメソッドが同じふるまいをすることを保証すべき 項目42 可変長引数を注意して使用する理解度：★★★☆☆ 可変長引数メソッド リリース1.5で言語に追加された ０個以上の引数を受け付ける 可変長引数のあたいは配列として初期化される Java1.4の場合 基本型配列はArrays.toList(Object[] obj)メソッドの引数にとれない 渡すと、コンパイルエラーになる Java1.5の場合 コンパイルエラーにならない。しかし、、 配列はObject型のtoStringメソッドを継承しているので、呼び出すと、ハッシュ値が出力され、値が見れない 解決方法は Arrays.toString()メソッドを使用すること まとめ 可変長引数メソッドは、可変長の引数を必要とするメソッドを定義する便利な方法だが乱用すべきではない 不適切に使用すると可変長引数メソッドは困惑する可能性がある 項目43 nullではなく、空配列か空コレクションを返すメッソドの戻り値（オブジェクト）がnullかどうかを判定するロジックを見たことがありますか？ 空（長さゼロ）配列や空コレクションの代わりに、nullを返すメソッドを使用する場合には必ず書かなければ行けない クライアント側を書いているプログラマは戻り値nullを処理する特別なコードを書き忘れてしまう危険性がある 配列を生成するコストを回避できると主張されることもあるが、次の２点を理由に間違いだと言える 1.問題となっているメソッドがパフォーマンス上、本当の原因で有ることがプロファイリングにより示されない限り、ネックと言えない 2.項目を１つも返さない呼び出しすべてが、同一の長さゼロ配列を返すことが可能 長さゼロ配列は不変であり、不変オブジェクトは制限なく共有して問題ないため 1234567891011121314// コレクションから配列を返す正しい方法private final List&lt;Cheese&gt; cheesesInStock = ...; // ここが空であれば、常に同じから配列が返却される仕組みを作れるprivate static final Cheese[] EMPTY_CHEESE_ARRAY = new Cheese[0];/*** @return 店にあるすべてのチーズを含む配列*/public Cheese[] getCheeses() &#123; return cheeseInStock.toArray(EMPTY_CHEESE_ARRAY);&#125;// ドキュメント// https://docs.oracle.com/javase/jp/8/docs/api/java/util/List.html#toArray-T:A- 12345678910// コレクションのコピーを返す正しい方法public List&lt;Cheese&gt; getCheeseList() &#123; if (cheeseInStock.isEmpty()) return Collections.emptyList(); // 常に同一のリストを返す else return new ArrayList&lt;Cheese&gt;(cheeseInStock);&#125;// Collections.emptyList()のドキュメントは以下// https://docs.oracle.com/javase/jp/8/docs/api/java/util/Collections.html#emptyList-- まとめ 配列やコレクションを返すメソッドが、空配列や空コレクションの代わりに、nullを返すべき理由は決してありません。 項目44 すべての公開API要素に対してドキュメントコメントを書く APIを適切に文書化するためには、すべての公開されているクラス、インターフェース、コンストラクタ、メソッド、フィールド宣言の前にドキュメントコメントを書かなければなりません。 メソッドに関するドキュメントコメントは、メソッドとそのクライアント間の契約を簡潔に記述すべき メソッドが何を行っているかを記載するべき メソッドのすべての事前条件、事後条件を列挙すべき 事前条件：@param （引数の説明） に記載する 事後条件：@throws に記載する ↑この部分、書籍の記載不備だと思われ、咀嚼できていない メソッドはいかなる副作用も文書化すべき たとえば、メソッドがバックグラウンドのスレッドを開始するとしたら、明記すべき ドキュメンテーションガイド 公式）https://www.oracle.com/technetwork/java/javase/documentation/index-137868.html Qiita）https://qiita.com/maku77/items/6410c67ce95e08d8d1bd まとめ ドキュメンテーションコメントはAPIを標準化する最善で最も効率的な方法 すべての公開APIでドキュメンテーションコメントは必須だとみなされるべき 標準に沿って記載されるべきで、メタタグはエスケープされるべき 第８章 プログラミング一般項目45 ローカル変数のスコープを最小限にする ローカル変数のスコープを最小限にする最も強力な方法は、ローカル変数が使用される前に宣言されること ローカル変数は、初期化子を含んでいるべき ループ変数の内容が、ループが終了したあとに必要ないものであれば、whileループよりforループを選択スべき forループであれば、２つのループで異なった変数名を使用する理由はありませんので、コピペによる誤りを犯すことはない（コンパイルエラーになるから） まとめ ローカル変数のスコープを最小限にすること 変数使用前に宣言すること whileよりforループをうまく活用すること メソッドを切り分けてスコープを制御すること 項目46 従来のforループよりfor-eachループを選ぶ for-eachループ＝拡張for文のことを言っている 1234// コレクションと配列をいてレートするための好ましいイデオムfor (Element e : elements) &#123; doSomething(e);&#125; for文がネストする際はなおさら、拡張For文の恩恵を受けられる for-eachループにより、コレクションと配列に対してイテレートできるだけでなく、Iterableインターフェースを実装した、いかなるオブジェクトに対してもイテレートできる 利用できる場面であるならば利用するべき 利用できない場面については以下の通り 1.フィルタリング：選択された要素を削除する必要がある場合 2.変換：リストや配列をイテレートして、その要素のいくつかを変換、置換する場合 3.並列イテレーション これらのケースに該当する場合は、通常のfor文を使用して、最善の方法で実装しているという認識を持つこと 項目47 ライブラリーを知り、ライブラリーを使う0からある上限値までの整数の乱数を生成したい時、自分で実装するとうまくいかないケースがある 123456private static final Random rnd = new Random();// よく見かけるが、欠陥がある！！static int random() &#123; return Math.abs(rnd.nextInt()) % n;&#125; ※欠陥の内容については、数学的な内容になるのでここ（今回の学習）では触れない この機能を実現するためのライブラリーはもう既に提供されています。 1Random.nextInt(int); 標準ライブラリを使用することで、それを書いた専門家の知識と、それをあなたよりも前に使用した人々の経験を利用することになる 自分の課題に少しばかりだけ関連している問題に対する場当たり的な解決策を書くことで、時間を無駄にする必要がない。アプリケーションに時間を費やすべき 自分では何もしなくても、時間とともにパフォーマンスが改善されたりする Java標準ライブラリの中で知っておくべきもの(自分の道具箱に入れておくべきもの) java.lang java.util(コレクションフレームワーク) java.io java.util.concurrent まとめ 無駄な努力はしないこと！ ライブラリーに存在していないか、実装前に確認すること！ 一般的なライブラリーは、頭の片隅においておくこと！ 個人的な心がけ あえてライブラリーを実装していない、車輪の再開発実装を見かけたら、ライブラリーを使うとすると…ということを意識しておく 項目48 正確な答えが必要ならば、floatとdoubleを避ける float型とdouble型は、特に金銭計算には適していない 正確に、0.1を表現することが不可能だから この問題を解くために正しい方法は、金銭計算には、BigDecimal、int、あるいはlongを使用すること 留意事項 BigDecimalのデメリット 基本データの算術型を使用するよりは不便 処理が遅い まとめ 正確な答えを必要とする計算に、floatやdoubleを使用しないこと！ BigDecimalの使用を検討する BigDecimalは、小数点を扱っているかいなかという状態の管理と、処理速度が遅いというデメリットを持っている 桁数が９桁を超えないのであればintを用いる 桁数が１８桁を超えないのであればlongを用いる 桁数が１８桁を超えるのであればBigDecimalを用いる 項目49 ボクシングされた基本データより基本データ型を選ぶjava1.5から、自動ボクシングと自動アンボクシングの機能が追加された これは基本データ型とボクシングされた基本データ型の違いを不明瞭にしたが、決して同じものと見てはいけない！ ３つの違い - 基本データ型は値だけを持つが、ボクシングされた基本データのインスタンスは値とは別のアイデンティティを持っている - 基本データ型は完全に機能する値だけを持っているが、ボクシングされた基本データ型は、機能する値＋nullを持つ - 基本データ型は、ボクシングされた基本データ型より時間と空間に関して効率的 ボクシングされた基本データ型に対して == 演算子を適用するのは、殆どの場合誤り オブジェクトの同一性を確認してしまうため まとめ 基本的に基本データ型を使用すること 自動ボクシングの機能に依存しないこと ボクシングされた基本データ型に対して==演算子を用いることはない ボクシングされた基本データ型とアンボクシングされた基本データを含む混合型の計算を行うと、アンボクシングが行われる アンボクシングの際にNullPointerExceptionをスローする可能性がある 項目50 他の型が適切な場所では、文字列を避ける 文字列は、他の値型に対する代替としては貧弱 データが本質的に文字である場合にだけ文字列として扱うべき 「はい/いいえ」の問に対する答えならboolean型 数値なら、int float BigInteger 文字列は、列挙型に対する代替としては貧弱 文字列は、集合型に対する代替としては貧弱 ある実態が複数の構成要素を持っているならば、その集合を示すクラスを定義することが懸命。たいていは private static のメンバークラスを書く 文字列は、ケイパビリティ（capability）に対する代替としては貧弱 ThreadLocalに関する懸念点について咀嚼できていないので再確認する まとめ 何も考えずに文字列ばかりを使用しないこと 基本データ型、enum、集合型が選べないか確認すること 所感 たまにテーブルで数値、タイムスタンプで持っているのに、Java処理で文字列型として扱っているプログラムを見るが、そのようなプログラムは適切ではないと判断することができるのではないか 項目51 文字列結合のパフォーマンスに用心する n個の文字列を結合するのに、文字列結合演算子を繰り返し使用すると、nに関して2次の時間を必要としていまいます この原因は、文字列が不変(immutable)であるという事実の不幸な結果 結合時に両方の内容がコピーされます 許容できるパフォーマンスを達成するためには、Stringの代わりにStringBuilderを使用する パフォーマンスの違いは５０倍～８５倍ほど違い 処理速度検証参考 http://www.code-magagine.com/?p=2022 StringBufferは古い、StringBuilderを使用しましょうと記載があるが、スレッド処理をする場合はStringBuffer１択 上記の検証資料を見るとStringBufferもStringBuilderと速度の大差がない様に思う… まとめ 文字列結合はStringBuilder、またはStringBuilderを用いる 繰り返さない、数の少ない結合に関しては+演算子を用いる場合もある 例えば、 LOG.info(&quot;処理回数:&quot; + count + &quot;回目&quot;) とか局所的に使う場合 項目52 インターフェースでオブジェクトを参照する 適切なインターフェース型が存在するのであれば、パラメータ、戻り値、変数、およびフィールドはすべてインターフェース型を使用して宣言されるべき 型として、インターフェースを使用する癖を身に着けたならば、あなたのプログラムはかなり柔軟になる 注意点 もとの実装がインターフェースの一般契約で要求されていない何らかの特別な機能を提供していて、コードがその機能に依存しているならば、新たな実装が同じ機能を提供することが重要 適切なインターフェースが存在しない場合には、インターフェースではなく、クラスでオブジェクトを参照することは適切 値クラス 基本的なデータ型としてインターフェースではなくクラスであるフレームワークに属しているケース インターフェースは実装しているが、そのインターフェースにない特別なメソッドをクラスが提供しているケース まとめ 適切なインターフェースが存在する場合はインターフェース型で実装 適切なインターフェースが存在しない場合は、クラス改装中で必要な機能を提供しているクラスで実装 項目53 リフレクションよりインタフェースを選ぶ コアリフレクション機構：java.lang.reflect はロードされたクラスに関する情報へのプログラムによるアクセスを提供している Classインスタンスで表されているクラスの、コンストラクタ、メソッド、フィールドを表しているConstructorインスタンス、Methodインスタンス、Fieldインスタンスを取得可能 さらにこれらを反射的に操作できる リフレクションはコンパイルされた時点で存在さえしない他のクラスを使用することを可能にする コンパイル時の型検査の恩恵をすべて失います リフレクションによるアクセスを行うコードは、ぎこちなく、冗長 パフォーマンスが悪くなる リフレクションは設計時のみ使用されるべき 一般に、実行時に普通のアプリケーション内で、オブジェクトはリフレクションによりアクセスされるべきではない まとめ ある種の洗練されたシステムプログラミング処理に必要とされる強力な機構ですが、多くの短所を持っている コンパイル時に知られていないクラスと一緒に動作しなければならないプログラムを書くのであれば、できる限り、オブジェクトのインスタンス化のためだけにリフレクションを使用する 所感 リフレクションはログ出力時に使用したい 実運用では積極的な利用は避けるべきで、ツールとかで使う分であれば問題ない 引数にクラス名を渡して、インスタンス化したあとに、スーパークラスやインターフェースに型を当てて使用する分には問題ないことを理解 項目54 ネイティブメソッドを注意して使用する CやC++などのネイティブのプログラミング言語で書かれた特別なメソッドであるネイティブメソッドをJavaアプリケーションが呼び出すのを可能にするのがJava Native Interface(JNI) JNIは以前パフォーマンスの改善等で使用されていたが、Java1.4以降のリリースあたりで、Javaで実装しチューニングしたクラスを提供し始めたため、現在あまり使われていない リリース1.4 java.util.prefs レジストリの機能 リリース1.6 java.awt.SyustemTray デスクトップのシステムトレイ領域へのアクセスを提供 古いコードへのアクセスにネイティブメソッドを使用することは正当ですが、パフォーマンスの改善のためにネイティブメソッドを使用することは、全く勧められません。 BigIntegerも最初はCで書かれた高速な多倍精度算術ライブラリーを使用して実装されていた歴史があるが、リリース1.3でJavaに置き換えられて注意深くチューニングされた まとめ パフォマンスの改善のために使用しないこと 古いコードへのアクセスで利用する場合は、最小限に留めること 所感 ネイティブコードをJavaで意図的に使用するコーディングの実装経験がないが、以下で紹介されているようにC++のクラス、メソッドを呼び出しできるんだな程度で理解した http://smys0515.hatenablog.com/entry/2015/05/27/075421 実務でネイティブメソッドを使用する場面は今後もないだろう。留意しておく 項目55 注意して最適化する まとめ 早いプログラムを書く努力をしてはいけない、良いプログラムを書く努力をすること API設計、通信プロトコル、永続データ形式を設計しているときは、パフォーマンスについて意識すること システム構築を終えたあと、パフォーマンス測定し、十分に早ければそれでよい、早くなければプロファイラの力を借りて問題の特定、最適化 所感 ビジネスレベルでパフォーマンスを意識した最適化をしようと思いすぎないこと API設計や、汎用的に使用されるようなクラスを作成する際は、パフォーマンスを意識すること（繰り返し呼び出される必要がある） Javaプロファイラについて調査（jvisualvm） http://www.techscore.com/blog/2017/12/11/identifying_performance_bottlenecks_with_jvisualvm/ Eclipse使用時、GUIでメソッドごとに処理時間を一覧できるため便利 項目56 一般的に受け入れられている命名規約を守る 命名規約 活字的規約 文法的規約 パッケージ名 ピリオドで区切られた要素をもち、階層的であるべき 区切られた要素は小文字のアルファベット文字と稀に数字から構成されるべき 組織外で使用されるパッケージの名前は、トップレベルドメインを最初にした、その組織のインターネットドメイン名で始まるべき java,javaxで始まる名前をもつパッケージはこの規約の例外です パッケージを記述する１つ以上の要素から構成されるべき、要素は短く一般的に８文字以下であるべき 意味を持った省略形は推奨されている。例えば、utilitiesesよりはutilなど クラス名、インターフェース名（enum型名、アノテーション型名） １つかそれ以上の単語から構成されるべきであり、個々の単語の最初の文字は大文字（パスカルケース） メソッド名はキャメルケースにすべき 定数フィールドは、大文字＋アンダースコア まとめ 標準の命名規約を取り入れて学習することを意識する 長く維持されてきた観葉的な用法が別に定義されている場合、これらの規約に盲目的に従うべきではない 所感 命名が適切だと他者に伝わりやすい＋自分でも見返しやすい コーディング時に意識する 参考）https://qiita.com/rkonno/items/1b30daf83854fecbb814 第９章 例外最適に使用された場合、例外はプログラムの読みやすさ、信頼性、保守性を改善 不適切に使用された場合、逆効果となる。ここでは例外を効率的に使用するためのガイドラインを定義 項目57 例外的状態にだけ例外を使用する 最悪な例 1234567891011121314// 例外のひどい乱用。決して、行ってはならない！！！try &#123; int i = 0; while(true) &#123; range[i++].climb(); &#125;&#125; catch (ArrayIndexOutOfBoundsException e) &#123;&#125;/** * これを書いた人は、ループ終了検査が冗長で、遅くなるからこうかいた！と* 主張するかもしれないが、今のJVMは最適化されていて、このように書くほうが遅くなるし* 何を意味しているのか、読み手が理解し辛い*/ まとめ 例外は例外的状態で使用されるために設計されている 通常の制御の流れに対して例外を使用しないでください 所感 この項目は明白。あるべきタイミングで例外処理を実装すること。例外処理実装のパターンみたいなものに言及されていないが気になる。。。 項目58 回復可能な状態にはチェックされる例外を、プログラミングエラーには実行時例外を使用する ３種類の例外 チェックされる例外 チェックされない例外（実行時例外） チェックされない例外（エラー） 各例外がいつ使用するのが適切かについてプログラマの間で混乱がある。 呼び出し側が適切に回復できるような状況に対してはチェックされる例外を使用すること プログラミングエラーを示す場合は実行時例外を使用してください。実行時例外の殆どは事前条件違反を示しています。 実装するすべてのチェックされない例外は、RuntimeExceptionをサブクラス化するべき Exception,RuntimeException,Errorのサブクラスではない例外を定義することは可能だが、得られるものはないし、ユーザを混乱させるだけなのでやめたほうがよい まとめ 回復可能な状態にはチェックされる例外を使用 プログラミングエラーには実行時例外を使用 項目59 チェックされる例外を不必要に使用するのを避ける まとめ プログラマがこれ以上どうしようもないのであればチェックしない例外が適切。常にチェックされる例外を実装すべきではない チェックされる例外呼び出しをbooleanで定義して呼び分けをする方法もある このリファクタリングが常に適切とは限らないが、リファクタリング前より見やすくなるのはわかると思う 項目５７の状態検査メソッドと基本的に同じであり、同じ注意事項が課せられる オブジェクトが外部同期なしに並行してアクセスされたり、外部要因により状態遷移したりするのであれば、このリファクタリングは適切でない 所感 booleanを使った処理の成功、失敗の振り分けは実装したことあるが、戻り値がほしい場合はチェック例外を書かざるを得ない印象 項目60 標準例外を使用する ここでは一般的に再利用されている例外について議論する 既存の例外を再利用することのメリット APIを学んで使用するのが容易になる プログラマが既に熟知している確立された慣例と一致するから プログラムが見慣れない例外でごちゃごちゃしないので読みやすい 例外クラスが少ないと、より少ないメモリ量と、クラスロードに費やされる時間が少ない 一般的な例外 IllegalArgumentException パラメータ値が不適切 IllegalStateException メソッド呼び出しに対してオブジェクト状態が不正 NullPointerException パラメータ値が禁止されているnull ArrayIndexOutOfBoundsException インデックスパラメータ値が範囲外 ConcurrentModificationException 禁止されているオブジェクトの並行した変更を検出 UnsupportedOperationException オブジェクトがメソッドをサポートしていない まとめ 一般的な例外を、実装ケースに合わせて使用すること 所感 できるなら、個別に例外クラスを実装するような文化を作らないようにする（個別に定義した例外クラスだらけのシステム（独自ライブラリ）を見たことがあるがよくない） 一般的な例外クラスを使いこなせる様にする この場合はこの例外を使用するのが最適だと判断できるようにする 項目61 抽象概念に適した例外をスローする 上位レイヤは下位レベルの例外をキャッチして、上位レイヤの中で上位レベルの抽象概念の観点から説明可能な例外をスローすべき まとめ 下位レイヤからの例外を防いだり下位レイヤの例外から上位レイヤを隔離剃ることが実現不可能であり、下位レベルのメソッドがスローするどれかの例外が上位レイヤに対して不適切ならば、例外翻訳を使用すること。 所感 例外翻訳は、メソッドで投げられた例外をキャッチして、別の例外をnewして投げ返すこと 投げ返すに適切な例外があれば使用すること そもそも投げ返すパターンについて整理する必要があるなと感じた 項目62 各メソッドがスローするすべての例外を文書化する 例外がthrowされる条件をjavadocの@throwsタグに明記して、正確に文書化してください まとめ 作成する各メソッドがスローする可能性のあるすべての例外を文書化、チェックされない例外に対しても。また、具象メソッドだけでなく抽象メソッドに対しても 個々のチェックされる例外に対してthrows説を提供すること。チェックされない例外はthorows説を提供しないこと メソッドがthrowする可能性のある例外を文書化するのを忘れると、他の人がクラスやインターフェースを効果的に利用したりするのが困難だったり、不可能になる 所感 @thorwsタグに、少なくともチェックされる例外の説明を記載する努力をする どのような原因でその例外が発生するのかなど 項目63 詳細メッセージにエラー記録情報を含める エラーを記録するためには、例外の文字列表現は、その例外の原因となったすべてのパラメータとフィールドの値を含んでいるべき 所感 どの様にエラー情報を提供するのかについて言及していないように思える 再確認したい項目 項目64 エラーアトミック性に努める エラーアトミック：一般的にいえば、失敗したメソッド呼び出しは、オブジェクトをそのメソッド呼び出しの前の状態にしておくべき 達成するためのアプローチ 不変オブジェクトを設計する 可変オブジェクトに対しては 操作を行う前にパラメータの正当性を検査する。そうすることでパラメータの変更を行う前にエラーを投げることができる 1234567public Object poo() &#123; if (size == 0) throw new EmptyStackException(); Object result = elements[--size]; elements[size] = null; // 廃れた参照を取り除く return result;&#125; このように、size０のリストに、サイズを確認せずに要素の取り出しを行うと例外がスローされ、sizeフィールドが不整合な負の状態になり、オブジェクトを扱えなくなる まとめ アトミック性をまもることは必須ではない。コスト、煩雑さとを伴うのであれば避ける APIドキュメントに、アトミック性を保持できないことを明記するべき 残念ながら、既存のAPIドキュメントの多くはこの規則に従っていない 所感 そもそもアトミック性を保持しなければならないようなクラスを実装する機会があまりなかった(変化するフィールド（加算/減算/ステータス定義の変化）を持つクラスを使い回すシチュエーションがないような気がする。あっても既存のライブラリクラス。Dateとか) バッチ処理等でサービス/ビジネスクラス内に処理回数をインクリメントする変数を定義した場合、変数を加算する前に対象の処理が正常終了しているかどうかを確かめるとか… 項目65 例外を無視しない 例外を無視するのはだめ！ 火災警報器を無視して警報を切ってしまうのと同じ。誰も火災があるかどうかを知ることができない 1234try &#123; obj.action(args);&#125; catch (SomeException e) &#123;&#125; まとめ 例外を無視するべきではない 例外を無視しても最低限コメントで説明をするべき 第10章 並行性 スレッドは同一プログラム内で複数の処理を並行して行うことを可能にしている 今日では当たり前になった、マルチコアプロセッサの恩恵を受けるためにも並行処理は必須 本章では明瞭で、正確で、きちんと文書化された並行プログラムを書くのに役立つ助言を含んでいます。 項目66 共有された可変データへのアクセスを同期する 壊れた同期 1234567891011121314151617181920package effectivejava.chapter11.item78.brokenstopthread;import java.util.concurrent.*;// Broken! - How long would you expect this program to run? (Page 312)public class StopThread &#123; private static boolean stopRequested; public static void main(String[] args) throws InterruptedException &#123; Thread backgroundThread = new Thread(() -&gt; &#123; int i = 0; while (!stopRequested) i++; &#125;); backgroundThread.start(); TimeUnit.SECONDS.sleep(1); stopRequested = true; &#125;&#125; １秒後に、メインスレッドがサブスレッドを終了させると思うかもしれませんが、実際そうならない 問題 メインスレッドが行ったsropRequestedの値の変更をサブスレッドが検知できないため 以下、修正されたクラス 12345678910111213141516171819202122232425262728package effectivejava.chapter11.item78.fixedstopthread1;import java.util.concurrent.*;// Properly synchronized cooperative thread terminationpublic class StopThread &#123; private static boolean stopRequested; private static synchronized void requestStop() &#123; stopRequested = true; &#125; private static synchronized boolean stopRequested() &#123; return stopRequested; &#125; public static void main(String[] args) throws InterruptedException &#123; Thread backgroundThread = new Thread(() -&gt; &#123; int i = 0; while (!stopRequested()) i++; &#125;); backgroundThread.start(); TimeUnit.SECONDS.sleep(1); requestStop(); &#125;&#125; 期待通りに１秒でクラスが終了します。 読み込み操作と、書き込み動作の両方が同期されていなければ行けない。同期はなんの効果もない 以下のような書き方もできる 1234567891011121314151617181920package effectivejava.chapter11.item78.fixedstopthread2;import java.util.concurrent.*;// Cooperative thread termination with a volatile fieldpublic class StopThread &#123; private static volatile boolean stopRequested; public static void main(String[] args) throws InterruptedException &#123; Thread backgroundThread = new Thread(() -&gt; &#123; int i = 0; while (!stopRequested) i++; &#125;); backgroundThread.start(); TimeUnit.SECONDS.sleep(1); stopRequested = true; &#125;&#125; だが、volatile修飾子では、加算処理などの同期がうまく取れないので、 場合により、AtomicLongを使用すること 1234567891011121314// 不完全、動機が必要！private static volatile int nextSerialNumber = 0;public static int generateSerialNumber () &#123; return nextSerialNumber++;&#125;// ++演算子がアトミックではないことが問題 これは安全性エラーですprivate static final AtomicLong nextSerialNumber = new AtomicLong();abstractpublic static long generateSerialNumber() &#123; return nextSerialNumber.getAndIncrement();&#125; まとめ 複数のスレッドが可変データを共有する場合には、そのデータを読み書きするスレッドは同期を行わなければなりません。 スレッド間通信だけが必要で、相互排他が必要なければ、volatile修飾子は同期として受け入れられる形式 正しく使用するのは難しい 項目67 過剰な同期は避ける項目６６では不十分な同期の危険性を示唆したが、本項目はその逆 活性エラーと安全性エラーを回避するためには、同期されたメソッドやブロック内で決して制御をクライアントに譲ってはいけません。 項目68 スレッドよりエグゼキューターとタクスを選ぶ項目69 waitとnotifyよりコンカレンシーユーティリティを選ぶ項目70 スレッド安全性を文書化する項目71 遅延初期化を注意して使用する項目72 スレッドスケジューラに依存しない項目73 スレッドグループを避ける第11章 シリアライズ項目74 Serializableを注意して実装する項目75 カスタムシリアライズ形式の使用を検討する項目76 防御的にreadObjectを書く項目77 インスタンス制御に対しては、readResolveよりenum型を選ぶ項目78 シリアライズされたインスタンスの代わりに、シリアライズ・プロキシを検討する付録 初版に対応する項目","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"読書中","slug":"読書中","permalink":"http://yoursite.com/tags/読書中/"},{"name":"技術書籍","slug":"技術書籍","permalink":"http://yoursite.com/tags/技術書籍/"}]},{"title":"AccessVBAエキスパート","slug":"2016_02_AccessVBAエキスパート","date":"2016-01-31T15:00:00.000Z","updated":"2019-07-19T13:08:26.800Z","comments":true,"path":"VBA/2016_02_AccessVBAエキスパート/","link":"","permalink":"http://yoursite.com/VBA/2016_02_AccessVBAエキスパート/","excerpt":"","text":"AccessVBAエキスパート 学習ログ 学んだこと VBAの基礎構文 Excel版で掲載されていなかった多くのメソッドを学べた AccessオブジェクトをVBAで扱う方法 手に取った理由 Excelの学習の延長と思い学習することにした","categories":[{"name":"VBA","slug":"VBA","permalink":"http://yoursite.com/categories/VBA/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"}]},{"title":"JakartaCommonsクックブック","slug":"2016_01_apache_commons","date":"2015-12-31T15:00:00.000Z","updated":"2019-08-05T15:21:45.211Z","comments":true,"path":"Java/2016_01_apache_commons/","link":"","permalink":"http://yoursite.com/Java/2016_01_apache_commons/","excerpt":"","text":"JakartaCommonsクックブック 目次 学んだこと 未読 優先度下げてしまってまだ全部読めてない 触りだけ読んだが、必要に迫られたときに持ち寄りたい 手に取った理由 Commonsのライブラリーを業務で有効活用できておらず、どのようなものがあるか体系的に知りたかった 車輪の再開発反対派","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"再読","slug":"再読","permalink":"http://yoursite.com/tags/再読/"},{"name":"レシピ","slug":"レシピ","permalink":"http://yoursite.com/tags/レシピ/"}]},{"title":"ExcelVBAエキスパート","slug":"2016_01_ExcelVBAエキスパート","date":"2015-12-31T15:00:00.000Z","updated":"2019-07-19T13:06:44.811Z","comments":true,"path":"VBA/2016_01_ExcelVBAエキスパート/","link":"","permalink":"http://yoursite.com/VBA/2016_01_ExcelVBAエキスパート/","excerpt":"","text":"ExcelVBAエキスパート 学習ログ 学んだこと VBAの基礎構文 ExcelオブジェクトをVBAで扱う方法 手に取った理由 業務でVBAコードを書ければ自動化できるタスクがあったため、将来的にもExcelは使用していくことを考えて知識が欲しい 簡単なマクロなら数時間で実装できるスキルが欲しい","categories":[{"name":"VBA","slug":"VBA","permalink":"http://yoursite.com/categories/VBA/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"}]},{"title":"Junit実践入門","slug":"2016_01_Junit実践入門","date":"2015-12-31T15:00:00.000Z","updated":"2019-07-21T16:58:08.930Z","comments":true,"path":"Java/2016_01_Junit実践入門/","link":"","permalink":"http://yoursite.com/Java/2016_01_Junit実践入門/","excerpt":"","text":"Junit実践入門 目次 学んだこと アサーションメソッド 評価する仕組みについて テストランナー Enclosedクラス Theoriesクラス ※業務で必要となった箇所だけ拾い読みレベル 手に取った理由 Junitのフレームワークについて理解できていなかったため、体系的な知識を付ける目的で購入","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"},{"name":"再読","slug":"再読","permalink":"http://yoursite.com/tags/再読/"}]},{"title":"HTML5デザイン","slug":"2016_01_HTML5デザイン","date":"2015-12-31T15:00:00.000Z","updated":"2019-08-05T15:21:16.451Z","comments":true,"path":"HTML/2016_01_HTML5デザイン/","link":"","permalink":"http://yoursite.com/HTML/2016_01_HTML5デザイン/","excerpt":"","text":"HTML5デザイン 目次 学んだこと 未読 優先度下げてしまってまだ全部読めてない 触りだけ読んだが、必要に迫られたときに持ち寄りたい 手に取った理由 HTML/CSS/JSのデザイン知識を蓄えたい 可能なことについて理解しておきたい","categories":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/categories/HTML/"}],"tags":[{"name":"再読","slug":"再読","permalink":"http://yoursite.com/tags/再読/"},{"name":"レシピ","slug":"レシピ","permalink":"http://yoursite.com/tags/レシピ/"}]},{"title":"Java言語で学ぶデザインパターン入門","slug":"2015_10_Java言語で学ぶデザインパターン入門","date":"2015-09-30T15:00:00.000Z","updated":"2019-07-21T16:46:13.700Z","comments":true,"path":"Java/2015_10_Java言語で学ぶデザインパターン入門/","link":"","permalink":"http://yoursite.com/Java/2015_10_Java言語で学ぶデザインパターン入門/","excerpt":"","text":"Java言語で学ぶデザインパターン入門 目次 はじめに UMLについて デザインパターンを学ぶ前に デザインパターンに慣れる 第1章 Iterator ― 1つ1つ数え上げる 第2章 Adapter ― 一皮かぶせて再利用 サブクラスにまかせる 第3章 Template Method ― 具体的な処理をサブクラスにまかせる 第4章 FactoryMethod ― インスタンス作成をサブクラスにまかせる インスタンスを作る 第5章 Singleton ― たった1つのインスタンス 第6章 Prototype ― コピーしてインスタンスを作る 第7章 Builder ― 複雑なインスタンスを組み立てる 第8章 Abstract Factory ― 関連する部品を組み合わせて製品を作る 分けて考える 第9章 Bridge ― 機能の階層と実装の階層を分ける 第10章 Strategy ― アルゴリズムをごっそり切り替える 同一視 第11章 Composite ― 容器と中身の同一視 第12章 Decorator−飾り枠と中身の同一視 構造を渡り歩く 第13章 Visitor ― 構造を渡り歩きながら仕事をする 第14章 Chain of Responsibility ― 責任のたらい回し シンプルにする 第15章 Facade ― シンプルな窓口 第16章 Mediator ― 相手は相談役1人だけ 状態を管理する 第17章 Observer ― 状態の変化を通知する 第18章 Memento ― 状態を保存する 第19章 State ― 状態をクラスとして表現する 無駄をなくす 第20章 Flyweight ― 同じものを共有して無駄をなくす 第21章 Proxy ― 必要になってから作る クラスで表現する 第22章 Command ― 命令をクラスにする 第23章 Interpreter ― 文法規則をクラスで表現する 付録A 練習問題の解答 付録B サンプルプログラムの実行手順 付録C GoFによるデザインパターンの分類 付録D デザインパターンＱ＆Ａ 付録E 参考文献 学習ログ 学んだこと デザインパターンとは、について オブジェクト指向プログラミングの楽しさ EffectiveJavaに通じるところがある 実際に現場で口にされるパターンは限りがある フレームワーク(Struts2やSpringなど)がうまいようにやってくれているので… フレームワーク内で様々なパターンを使用して実装しているな、というのがつかめれたのでよかった 時間を開けてもう一回読みたい 手に取った理由 初学者として、Javaを学んできたので、Javaを使ったデザインパターンの考え方を知りたかった どんなパターンがあって、というのは共通語として押さえておきたかった","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"},{"name":"再読","slug":"再読","permalink":"http://yoursite.com/tags/再読/"}]},{"title":"オラクル認定資格教科書JavaプログラマGoldSE7スピードマスター問題集","slug":"2015_07_オラクル認定資格教科書JavaプログラマGoldSE7スピードマスター問題集","date":"2015-06-30T15:00:00.000Z","updated":"2019-07-21T17:00:35.994Z","comments":true,"path":"Java/2015_07_オラクル認定資格教科書JavaプログラマGoldSE7スピードマスター問題集/","link":"","permalink":"http://yoursite.com/Java/2015_07_オラクル認定資格教科書JavaプログラマGoldSE7スピードマスター問題集/","excerpt":"","text":"オラクル認定資格教科書 Javaプログラマ Gold SE 7 スピードマスター問題集 目次 1章 Javaクラスの設計 2章 高度なクラス設計 3章 オブジェクト指向の設計原理 4章 ジェネリックスとコレクション 5章 文字列処理 6章 例外とアサーション 7章 Java I/Oの基礎 8章 JavaファイルI/O (NIO.2) 9章 JDBCによるデータベースアプリケーションの作成 10章 スレッド 11章 並列処理 12章 口ーカライゼーション 模擬試験 学んだこと Gold教科書で学んだことの整理 プラス、問題として問われやすいところの整理 手に取った理由 Gold資格取得","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"問題集","slug":"問題集","permalink":"http://yoursite.com/tags/問題集/"}]},{"title":"オラクル認定資格教科書JavaプログラマGoldSE7","slug":"2015_04_オラクル認定資格教科書JavaプログラマGoldSE7","date":"2015-03-31T15:00:00.000Z","updated":"2019-07-19T09:28:37.372Z","comments":true,"path":"Java/2015_04_オラクル認定資格教科書JavaプログラマGoldSE7/","link":"","permalink":"http://yoursite.com/Java/2015_04_オラクル認定資格教科書JavaプログラマGoldSE7/","excerpt":"","text":"オラクル認定資格教科書JavaプログラマGoldSE7 目次 学んだこと Silverのステップアップとして、JavaGold取得を決意 列挙型の使用方法 ネストクラスと匿名クラスについて １回読んだときはまだメリットについてあまり理解できなかった デザインパターンの基礎知識 コンポジション シングルトン DAOパターン ファクトリパターン StringBuilder、StringBufferの違い 正規表現処理 コレクション、List、Set、Queue、Mapの利用 ジェネリックについて はじめ何のメリットがあってこんな複雑な事しているのかわからなかった 配列とリストについて 例外処理 SE7から追加された書き方など（try-with-resources） ファイルIOライブラリー JDBC、ResultSet スレッド、排他制御、同期処理 Executorフレームワーク、アトミックとロック、Fork/Joinフレームワーク Javaにおいて業務であまり使用しないのでためになった 手に取った理由 Silverのステップアップとして、JavaGold取得を決意 より実用的な深い知識を習得するため","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"}]},{"title":"完全合格ORACLE-MASTER-DBA12c_Bronze","slug":"2015_05_完全合格ORACLE-MASTER-DBA12c_Bronze","date":"2015-03-31T15:00:00.000Z","updated":"2019-07-19T14:45:51.372Z","comments":true,"path":"DB/2015_05_完全合格ORACLE-MASTER-DBA12c_Bronze/","link":"","permalink":"http://yoursite.com/DB/2015_05_完全合格ORACLE-MASTER-DBA12c_Bronze/","excerpt":"","text":"完全合格ORACLE-MASTER-DBA12c_Bronze 学んだこと OracleDBの仕組み データベース管理概要 ソフトウェアのインストール Oracle Enterprise Manager Database ExpressおよびSQL管理ツール Oracleネットワーク環境 インスタンス管理 データベース領域構造 ユーザおよびセキュリティ バックアップリカバリ データベースの監視 DBMS機能ってこんなのがあるんだということを把握 この時期に発売されていた 12c の教科書がこれしかなかったので本書を選んだが、記載方法が自分好みではなかった.. 学習ログ 手に取った理由 DBMSの一般的な知識がつけたかった Oracleは１年目に業務で触っていたため、書籍で勉強を進めていくのに一番よいと判断した","categories":[{"name":"DB","slug":"DB","permalink":"http://yoursite.com/categories/DB/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"}]},{"title":"電話はなぜつながるのか","slug":"2015_01_電話はなぜつながるのか","date":"2015-01-31T15:00:00.000Z","updated":"2019-07-19T09:17:37.639Z","comments":true,"path":"EX/2015_01_電話はなぜつながるのか/","link":"","permalink":"http://yoursite.com/EX/2015_01_電話はなぜつながるのか/","excerpt":"","text":"電話はなぜつながるのか 学んだこと 電話回線網の仕組み なぜ、「ぷー、ぷー」という音が鳴るのか 電話交換機の役割 IP電話について 携帯電話技術の世代 手に取った理由 業務で、電話回線を使用したダイヤルアップ接続をしなければいけない場面があり、そもそもの電話回線の仕組みに興味を持った これまで何本か本を読んできて、なぜ～シリーズの本が読みやすいと感じたので","categories":[{"name":"EX","slug":"EX","permalink":"http://yoursite.com/categories/EX/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"}]},{"title":"Windowsはなぜ動くのか","slug":"2015_02_Windowsはなぜ動くのか","date":"2014-12-31T15:00:00.000Z","updated":"2019-07-19T09:11:30.643Z","comments":true,"path":"EX/2015_02_Windowsはなぜ動くのか/","link":"","permalink":"http://yoursite.com/EX/2015_02_Windowsはなぜ動くのか/","excerpt":"","text":"Windowsはなぜ動くのか 学んだこと PCが動作する仕組みをハード面からソフト面まで説明 UML、DB操作、TCP/IP、暗号化技術、XMLなどについて説明 まんべんなく、浅く広くという印象 手に取った理由 PCの動作する仕組みについて深く理解できていないと感じ購入","categories":[{"name":"EX","slug":"EX","permalink":"http://yoursite.com/categories/EX/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"}]},{"title":"Windows7 上級マニュアル ネットワーク編","slug":"2015_01_Windows7上級マニュアル-ネットワーク編","date":"2014-12-31T15:00:00.000Z","updated":"2019-07-21T17:03:41.536Z","comments":true,"path":"NW/2015_01_Windows7上級マニュアル-ネットワーク編/","link":"","permalink":"http://yoursite.com/NW/2015_01_Windows7上級マニュアル-ネットワーク編/","excerpt":"","text":"Windows7 上級マニュアル ネットワーク編 学んだこと Windowsのネットワーク設定周りの理解を深めることができた DLNAについて 自宅でネットワーク周りを整理するための知識 ルーター設定 PCの共有サーバー化 リモートデスクトップについて FTPデーモンについて ローカルPCにデーモンを入れ、ドメインを取得しインターネット公開する方法 手に取った理由 より、私生活により沿ったネットワーク関連の知識を深めたい ネットワーク面でより効率的な自宅環境を構築したい WindowsOSは業務で使っているのでなじみある","categories":[{"name":"NW","slug":"NW","permalink":"http://yoursite.com/categories/NW/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"}]},{"title":"コンピュータはなぜ動くのか","slug":"2015_01_コンピュータはなぜ動くのか","date":"2014-12-31T15:00:00.000Z","updated":"2019-07-19T09:10:51.038Z","comments":true,"path":"EX/2015_01_コンピュータはなぜ動くのか/","link":"","permalink":"http://yoursite.com/EX/2015_01_コンピュータはなぜ動くのか/","excerpt":"","text":"コンピュータはなぜ動くのか 学んだこと PCが動作する仕組みをハード面からソフト面まで説明 UML、DB操作、TCP/IP、暗号化技術、XMLなどについて説明 まんべんなく、浅く広くという印象 手に取った理由 PCの動作する仕組みについて深く理解できていないと感じ購入","categories":[{"name":"EX","slug":"EX","permalink":"http://yoursite.com/categories/EX/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"}]},{"title":"基礎からのサーブレットJSP","slug":"2015_01_基礎からのサーブレットJSP","date":"2014-12-31T15:00:00.000Z","updated":"2019-07-19T09:10:32.527Z","comments":true,"path":"Java/2015_01_基礎からのサーブレットJSP/","link":"","permalink":"http://yoursite.com/Java/2015_01_基礎からのサーブレットJSP/","excerpt":"","text":"基礎からのサーブレットJSP 目次 PART01 入門編 CHAPTER01 サーブレット/JSPって何? CHAPTER02 開発環境の準備 CHAPTER03 Webアプリケーションの動作原理を知る CHAPTER04 はじめてのサーブレット CHAPTER05 日本語の表示とコンテンツタイプ CHAPTER06 web.xmlの基本 CHAPTER07 サーブレットを簡単に作る CHAPTER08 はじめてのJSP CHAPTER09 コンテキストパスを理解する PART02 基礎編 CHAPTER10 入力パラメータの取得 CHAPTER11 入力チェックと値の変換 CHAPTER12 フィルタの活用 CHAPTER13 画面遷移を行う CHAPTER14 オブジェクトのスコープとリクエスト属性 CHAPTER15 セッションを使う PART03 もっとサーブレット CHAPTER16 サーブレットクラスの詳細 CHAPTER17 外部ファイルから値を読み込む CHAPTER18 HTTPリクエストとレスポンス CHAPTER19 クッキーの利用 CHAPTER20 WARファイルのデプロイ PART04 クラスとオブジェクト CHAPTER21 アクションクラスとディレクティブ CHAPTER22 JSPの構成要素 CHAPTER23 JavaBeansとEL式 CHAPTER24 カスタムタグとJSTL PART05 データベースの利用 CHAPTER25 データベースの基礎知識 CHAPTER26 JDBCを使う CHAPTER27 Webアプリケーションとデータベース CHAPTER28 データベースアクセスの利用 CHAPTER29 データソースの利用 CHAPTER30 オリジナルアプリケーションの作成 APPENDIX APPENDIX01 EclipseによるWebアプリケーション開発 APPENDIX02 web.xmlの要素 学習ログ 学んだこと Tomcatとは Tomcat使い方 JavaWeb開発の基礎 アプリ開発の手順を順を追って理解できた Web.xmlの役割について理解できた JSPのタグ式の書き方 JSPからサーブレット、サーブレットからサーブレット、サーブレットからJSPまでのつながりが理解できた 実践的な内容まで踏み込めていない（FW未使用）ため、基礎的な事を習得しただけではある 手に取った理由 JavaSilverレベルの知識が身についたところで、Javaを使用したWebアプリの開発方法について理解したかった","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"}]},{"title":"Javaでなぜつくるのか","slug":"2015_01_Javaでなぜつくるのか","date":"2014-12-31T15:00:00.000Z","updated":"2019-07-19T09:10:44.032Z","comments":true,"path":"Java/2015_01_Javaでなぜつくるのか/","link":"","permalink":"http://yoursite.com/Java/2015_01_Javaでなぜつくるのか/","excerpt":"","text":"Javaでなぜつくるのか 学んだこと Javaとは プログラミング言語、というくくりだけでなくもっと広い捉え方をした方がよい 「仮想コンピュータの仕様とそれをとりまく社会環境」らしい 反感買いそう.. Javaの歴史的部分 Javaの長所短所 コンパイラ言語ということ JVMで動作するということ ヒープ領域などについて オブジェクト指向について 基礎的な概念をまんべんなく学んだ印象 書籍は読みやすいので、遅くても2,3時間で読み切れると思う 手に取った理由 Javaの基礎的なところ、概念的なところについて理解を深めたかった","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"}]},{"title":"BIOS/UEFI 完全攻略","slug":"2014_12_BIOS-UEFI完全攻略","date":"2014-11-30T15:00:00.000Z","updated":"2019-07-21T16:46:30.955Z","comments":true,"path":"EX/2014_12_BIOS-UEFI完全攻略/","link":"","permalink":"http://yoursite.com/EX/2014_12_BIOS-UEFI完全攻略/","excerpt":"","text":"BIOS/UEFI 完全攻略 学んだこと BIOSの仕組み UEFIはBIOSの後継。GUI操作ができる。 すべて読み切れていないので時間あるときに戻ってくる 手に取った理由 業務でBIOS設定の変更などを行っていて興味がわいたから LAN起動させるためにマジックパケットを許容する設定とかしていた","categories":[{"name":"EX","slug":"EX","permalink":"http://yoursite.com/categories/EX/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"},{"name":"再読","slug":"再読","permalink":"http://yoursite.com/tags/再読/"}]},{"title":"Windows 7 レジストリ徹底活用マニュアル","slug":"2014_12_Windows7レジストリ徹底活用マニュアル","date":"2014-11-30T15:00:00.000Z","updated":"2019-07-19T07:03:26.699Z","comments":true,"path":"EX/2014_12_Windows7レジストリ徹底活用マニュアル/","link":"","permalink":"http://yoursite.com/EX/2014_12_Windows7レジストリ徹底活用マニュアル/","excerpt":"","text":"Windows 7 レジストリ徹底活用マニュアル 目次 学んだこと Windowsレジストリ操作で出来ること 驚きはあったが実用性はいまいちという印象 WindowsOSに対する理解は進んだと思う 手に取った理由 業務でレジストリ領域をいじる機会(※１)があり、興味を持ったため ※１OracleDBが参照しているレジストリ領域をいじらなければ解決していない事象があり..","categories":[{"name":"EX","slug":"EX","permalink":"http://yoursite.com/categories/EX/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"}]},{"title":"ネットワークの知識と実務","slug":"2014_11_ネットワークの知識と実務","date":"2014-10-31T15:00:00.000Z","updated":"2019-07-21T17:05:11.276Z","comments":true,"path":"NW/2014_11_ネットワークの知識と実務/","link":"","permalink":"http://yoursite.com/NW/2014_11_ネットワークの知識と実務/","excerpt":"","text":"ベテランが丁寧に教えてくれる ネットワークの知識と実務 (IT ENGINEER’S Basic) 学んだこと ネットワーク周りの基本知識の取得 手に取った理由 業務でTCP/IP関連の知識を必要とした","categories":[{"name":"NW","slug":"NW","permalink":"http://yoursite.com/categories/NW/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"}]},{"title":"オラクル認定資格教科書JavaプログラマSilverSE7","slug":"2014_07_オラクル認定資格教科書JavaプログラマSilverSE7","date":"2014-06-30T15:00:00.000Z","updated":"2019-07-19T06:23:30.266Z","comments":true,"path":"Java/2014_07_オラクル認定資格教科書JavaプログラマSilverSE7/","link":"","permalink":"http://yoursite.com/Java/2014_07_オラクル認定資格教科書JavaプログラマSilverSE7/","excerpt":"","text":"オラクル認定資格教科書 Javaプログラマ Silver SE 7 目次 第1章 Javaプログラミング基礎 第2章 配列 第3章 演算子と分岐文 第4章 繰り返し文と繰り返し制御文 第5章 クラス定義とオブジェクトの生成・使用 第6章 継承とポリモフィズム 第7章 例外処理 模擬試験 学んだこと Bronze本に引き続いて、Javaプログラミングの基礎知識を固めることができた 例外クラスの種別について意識しながら学ぶことができた 手に取った理由 JavaBronze本からのステップアップ Javaプログラミングのスキルアップ Silver資格取得 第1章 Javaプログラミング基礎第2章 配列第3章 演算子と分岐文第4章 繰り返し文と繰り返し制御文第5章 クラス定義とオブジェクトの生成・使用第6章 継承とポリモフィズム第7章 例外処理模擬試験","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"}]},{"title":"オラクル認定資格教科書JavaプログラマSilverSE7スピードマスター問題集","slug":"2014_07_オラクル認定資格教科書JavaプログラマSilverSE7スピードマスター問題集","date":"2014-06-30T15:00:00.000Z","updated":"2019-07-19T06:43:59.682Z","comments":true,"path":"Java/2014_07_オラクル認定資格教科書JavaプログラマSilverSE7スピードマスター問題集/","link":"","permalink":"http://yoursite.com/Java/2014_07_オラクル認定資格教科書JavaプログラマSilverSE7スピードマスター問題集/","excerpt":"","text":"オラクル認定資格教科書 Javaプログラマ Silver SE 7 スピードマスター問題集 目次 1章 Javaの基本 2章 Javaのデータ型の操作 3章 演算子と決定構造の使用 4章 配列の作成と使用 5章 ループ構造の使用 6章 メソッドとカプセル化を操作する 7章 継承の操作 8章 例外の処理 模擬試験 学んだこと Silver教科書で学んだことの整理 プラス、問題として問われやすいところの整理 手に取った理由 Silver資格取得 1章 Javaの基本2章 Javaのデータ型の操作3章 演算子と決定構造の使用4章 配列の作成と使用5章 ループ構造の使用6章 メソッドとカプセル化を操作する7章 継承の操作8章 例外の処理模擬試験","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"問題集","slug":"問題集","permalink":"http://yoursite.com/tags/問題集/"}]},{"title":"オラクル認定資格教科書JavaプログラマBronzeSE7","slug":"2014_06_オラクル認定資格教科書JavaプログラマBronzeSE7","date":"2014-05-31T15:00:00.000Z","updated":"2019-07-19T05:43:10.170Z","comments":true,"path":"Java/2014_06_オラクル認定資格教科書JavaプログラマBronzeSE7/","link":"","permalink":"http://yoursite.com/Java/2014_06_オラクル認定資格教科書JavaプログラマBronzeSE7/","excerpt":"","text":"オラクル認定資格教科書 Javaプログラマ Bronze SE7 目次 第1章 Java言語のプログラムの流れ 第2章 データの宣言と使用 第3章 演算子と分岐文 第4章 繰り返し文と繰り返し制御文 第5章 オブジェクト指向コンセプト 第6章 クラス定義とオブジェクトの生成・使用 第7章 継承 第8章 ポリモフィズムとパッケージ 模擬試験 学んだこと 基本型、参照型の違い 条件分岐の基本的な使い方 三項演算子、インクリメント final,static,void 継承の概念、インターフェース定義の概念 手に取った理由 Javaの事始めとして、Bronzeの受験はしないが購入 Silver取得を目指すため 第1章 Java言語のプログラムの流れ第2章 データの宣言と使用第3章 演算子と分岐文第4章 繰り返し文と繰り返し制御文第5章 オブジェクト指向コンセプト第6章 クラス定義とオブジェクトの生成・使用第7章 継承第8章 ポリモフィズムとパッケージ模擬試験","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"教科書","slug":"教科書","permalink":"http://yoursite.com/tags/教科書/"}]}]}