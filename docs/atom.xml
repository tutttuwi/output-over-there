<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>OUTPUT*OVER-THERE</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-23T03:23:23.720Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>t-tsutsui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring徹底入門</title>
    <link href="http://yoursite.com/JAVA/2020-05_Spring%E5%BE%B9%E5%BA%95%E5%85%A5%E9%96%80/"/>
    <id>http://yoursite.com/JAVA/2020-05_Spring徹底入門/</id>
    <published>2020-04-30T15:00:00.000Z</published>
    <updated>2020-05-23T03:23:23.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring徹底入門"><a href="#Spring徹底入門" class="headerlink" title="Spring徹底入門"></a>Spring徹底入門</h1><ul><li><p>目次</p><ul><li>第1章　Spring Frameworkとは</li><li>第2章　Spring Core（DI×AOP）</li><li>第3章　データアクセス（Tx、JDBC）</li><li>第4章　Spring MVC</li><li>第5章　Webアプリケーションの開発</li><li>第6章　RESTful Webサービスの開発</li><li>第7章　Spring MVC の応用</li><li>第8章　Spring Test</li><li>第9章　Spring Security</li><li>第10章　Spring Data JPA</li><li>第11章　Spring ＋ MyBatis</li><li>第12章　Spring＋Thymeleaf</li><li>第13章　Spring Boot</li><li>第14章　チュートリアル</li></ul></li><li><p>形式：書籍</p></li><li>発売日：2016年07月20日</li><li>ISBN：9784798142470</li><li>価格：本体4,000円＋税</li><li>仕様：B5変・744ページ</li></ul><h2 id="第1章-Spring-Frameworkとは"><a href="#第1章-Spring-Frameworkとは" class="headerlink" title="第1章　Spring Frameworkとは"></a>第1章　Spring Frameworkとは</h2><ul><li>Spring Frameworkの概要<ul><li>「Spring Frameworkは、開発当初より古いインフラ環境上でも新しいインフラ環境上でも、最新のプログラミング思想で開発出来ることを設計思想にしている」</li></ul></li><li><p>Spring Frameworkの歴史</p><ul><li>2003年：Interface21 Framework → Spring Frameworkへと変更になった (Expert One-one-One: J2EE Design and Development)</li><li>2004年：EJBを使わずにSpringFramework1.0で開発する方法</li><li>2005年：SpringFramework1.2 の機能をカバーした書籍が刊行 SpringをStruts,Hibernateと組み合わせて使う（SSH）</li><li>2006年：SpringFramework2.0がリリース</li><li>2007年：SpringFramework2.5 アノテーションベースのDIやMVC<ul><li>米国に拠点を移す SpringToolSuiteなど統合開発環境の提供が始まる</li></ul></li><li>2009年：SpringFramework3.0がリリース JSR330に対応</li><li>2013年：SpringFramework4.0がリリース WebsocketやWebメソッドなどをサポート<ul><li>Pivotalという新しい会社にスピンオフ</li></ul></li><li>2014年：昨今注目されているSpringBootやSpringIOPlatformプロジェクトが始まる</li></ul></li><li><p>Springの各種プロジェクトについて</p><ul><li>SpringMVC: Webアプリケーションを開発するためのフレームワークであり、MVCパターンを利用している<ul><li>MVCパターンには、「アクションベースフレームワーク」と「コンポーネントベースフレームワーク」の２パターンある<ul><li>アクションベースフレームワーク<ul><li>リクエストによって実行する処理（アクション）を決定し、処理の結果としてレスポンスを返すフレームワーク</li></ul></li><li>コンポーネントベースフレームワーク<ul><li>リクエストやレスポンスを抽象化（隠蔽）し、画面を構成するコンポーネントをベースにWebアプリケーションを開発するフレームワーク</li><li>JSFはコンポーネントベースのフレームワーク<ul><li>MEMO: JavaEE徹底入門読んで理解した！</li></ul></li></ul></li></ul></li><li>各種サードパーティとの連携機能もある<ul><li>Jackson</li><li>ApacheTiles</li><li>FreeMarker</li><li>Rome</li><li>JasperReports<ul><li>また、Thymeleafなど、サードパーティ自体がSpringMVCをサポートしているケースも有る</li></ul></li></ul></li></ul></li></ul></li><li><p>Spring Security</p><ul><li>Authentication(認証)</li><li>Authorization(認可)などのセキュリテイ要件を用意に実現するためのフレームワーク<ul><li>非常に多くの認証方式に対応している<ul><li>Basic認証</li><li>ダイジェスト認証</li><li>X.509クライアント証明証</li><li>LDAP</li><li>OpenID</li></ul></li></ul></li></ul></li><li><p>Spring Data</p><ul><li>Spring Dataはリレーショナル・データベースやNoSQL、Key-Valueストアなど様々なデータストアへのデータアクセスを用意にするためのもの<ul><li>Spring Data Commons</li><li>Spring Data JPA</li><li>Spring Data MongoDB, Spring Data Redis, Spring Data Solr, etc…</li></ul></li></ul></li><li><p>Spring Batch</p><ul><li>バッチアプリケーション向けの軽量フレームワーク</li><li>大容量のデータ処理に必要な共通機能を提供している</li><li>もともと、Accentureが開発したバッチアプリケーション向けのフレームワークをベースとしており、2008年にSpringBatchとしてバージョン1.0がリリース</li></ul></li><li><p>Spring Integration</p><ul><li>Enterprise Integration Patterns(EIP)としてよく知られているさまざまなシステム間を連携させるアーキテクチャパターンに基づく開発をサポートするフレームワーク</li><li>同様の機能を実現するOSSとして、ApacheCamelが有名です。</li></ul></li><li><p>Spring Cloud</p><ul><li>分散環境でCloud Nativeなアプリケーションを開発するためのフレームワーク及びツール群<ul><li>SpringCloudConfig</li><li>SpringCloudBus</li><li>SpringCloudConnectors</li><li>SpringCloudNetflix</li></ul></li></ul></li><li><p>Spring tool Suite</p><ul><li>Eclipseベースの統合開発環境</li></ul></li><li><p>Spring IO Platform</p><ul><li>依存関係を管理するためのライブラリー</li></ul></li><li><p>Spring Boot</p><ul><li>最小限の設定でプロダクションレベルのSpringアプリケーションを容易に開発するためのSpringプロジェクト</li></ul></li><li><p>JavaEEとの関係</p><ul><li>差は縮まっている</li><li>Springのほうが新しい技術を取り込むサイクルが早い</li></ul></li></ul><h2 id="第2章-Spring-Core（DI×AOP）"><a href="#第2章-Spring-Core（DI×AOP）" class="headerlink" title="第2章　Spring Core（DI×AOP）"></a>第2章　Spring Core（DI×AOP）</h2><ul><li>DIコンテナメリット<ul><li>インスタンスのスコープを制御できる</li><li>インスタンスのライフサイクルを制御できる</li><li>共通機能を組み込める</li><li>コンポーネント間が疎結合になるため、単体テストがしやすい</li></ul></li><li><p>SpringFramework以外の有名なDIコンテナのフレームワーク</p><ul><li>CDI(Contexts&amp;DependencyInjection) ：JavaEE6で導入されたコンテキストに対応したDIの仕様</li><li>Google Guice</li><li>Dagger</li></ul></li><li><p>ApplicationContextとBean定義</p><ul><li>SpringFrameworkではApplicationContextがDIコンテナの役割を担う<ul><li>DIコンテナに登録するコンポーネントのことを「Bean」</li><li>Configurationのことを「Bean定義」</li><li>DIコンテナからBeanを取得することを「ルックアップ」という</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UserService userService = context.getBean(UserService.class);</span><br><span class="line">UserService userService = context.getBean(<span class="string">"userService"</span>,UserService.class);</span><br><span class="line">UserService userService = (UserService)context.getBean(<span class="string">"userService"</span>);</span><br></pre></td></tr></table></figure><ul><li><p>代表的なBean定義の方法</p><ul><li>JavaベースConfiguration</li><li>XMLベースConfiguration</li><li>アノテーションベースConfiguration</li></ul></li><li><p>それぞれ１つだけを使用して実装もできるが、通常は</p><ul><li>JavaベースConfigurationとアノテーションベースConfigurationの組み合わせ、または</li><li>XMLベースConfigurationとアノテーションベースConfigurationの組み合わせを用いてBean定義を行う</li></ul></li><li><p>Configuration方法</p></li><li><p>javaベース、XMLベース、アノテーションベースの説明</p></li><li><p>インジェクションの種類</p><ul><li>セッターインジェクション</li><li>コンストラクタインジェクション</li><li>フィールドインジェクション</li></ul></li><li><p>オートワイヤリング</p><ul><li><code>@Bean</code>メソッドや<code>&lt;bean&gt;</code>要素で明示的にBean定義しなくても自動的にＤＩコンテナにインジェクションさせる仕組み</li><li>解決方法は２つ<ul><li>型によるもの（by Type）</li><li>名前によるもの（by Name）</li></ul></li></ul></li><li><p>型による解決</p><ul><li>デフォルトでインジェクションされる事が必須</li><li>対象の型を持つ<code>Bean</code>が１つも登録されていないと<code>org.springframework.beans.factory.NoSuchBeanDefinitionException</code>が発生</li></ul></li></ul><p>required = false を指定するか</p><ul><li><p>Spring4からは、<code>required = false</code>の代わりに、JavaSE8から導入された、<code>java.util.Optional</code>を使用することが出来る</p><ul><li>MEMO: <code>Optional&lt;T&gt;</code>で実装できる！絶対こっちのほうがいい　関数型プログラミングの本で知った。</li></ul></li><li><p>名前による解決</p><ul><li>同じ親クラスを持つ２つの実装クラスに<code>Bean</code>定義をして、インジェクションする場合</li><li><code>@Qualifier</code>で名前を指定してあげないといけない</li><li><code>@Primary</code>を使えば、名前を指定しなかった時にインジェクションされるデフォルトを指定できる</li><li>名前には、実装クラス名を記載するべきではない。呼び出し側で実装を特定してしまうとDIの意味がなくなる。用途名を指定するべき。</li><li>用途は文字列ではなく、アノテーションでも指定できる。</li></ul></li><li><p>[ ] 用途を指定するためのアノテーション作成してみたい</p></li><li><p>[ ] 独自アノテーションを作成してみる</p></li><li><p>名前によるオートワイヤリング</p><ul><li><code>@Resource</code>を付与</li><li>フィールド名がBean名に一致するパターン</li><li>プロパティ名がBean名に一致するパターン</li></ul></li><li><p>コレクションやmap型によるオートワイヤリング</p></li></ul><h3 id="2-1-6-コンポーネントスキャン"><a href="#2-1-6-コンポーネントスキャン" class="headerlink" title="2.1.6 コンポーネントスキャン"></a>2.1.6 コンポーネントスキャン</h3><ul><li><p>デフォルトのコンポーネントスキャン</p><ul><li>以下のアノテーションが付いたクラスがＤＩコンテナに登録される<ul><li><a href="mailto:`@org.springfrwamework.stereotype.Component" target="_blank" rel="noopener">`@org.springfrwamework.stereotype.Component</a>`</li><li><a href="mailto:`@org.springfrwamework.stereotype.Controller" target="_blank" rel="noopener">`@org.springfrwamework.stereotype.Controller</a>`</li><li><a href="mailto:`@org.springfrwamework.stereotype.Service" target="_blank" rel="noopener">`@org.springfrwamework.stereotype.Service</a>`</li><li><a href="mailto:`@org.springfrwamework.stereotype.Repository" target="_blank" rel="noopener">`@org.springfrwamework.stereotype.Repository</a>`</li><li><a href="mailto:`@org.springfrwamework.context.annotation.Configuration" target="_blank" rel="noopener">`@org.springfrwamework.context.annotation.Configuration</a>`</li><li><a href="mailto:`@org.springfrwamework.web.bind.annotation.RestController" target="_blank" rel="noopener">`@org.springfrwamework.web.bind.annotation.RestController</a>`</li><li><a href="mailto:`@org.springfrwamework.web.bind.annotation.ControllerAdvice" target="_blank" rel="noopener">`@org.springfrwamework.web.bind.annotation.ControllerAdvice</a>`</li><li><a href="mailto:`@javax.annotation.ManagedBean" target="_blank" rel="noopener">`@javax.annotation.ManagedBean</a>`</li><li><a href="mailto:`@javax.inject.Named" target="_blank" rel="noopener">`@javax.inject.Named</a>`</li></ul></li></ul></li><li><p>コンポーネントスキャンは広範囲な程処理が遅くなるので不適切</p><ul><li><code>@ComponentScan(basePackages = &quot;com&quot;)</code></li><li><code>@ComponentScan(basePackages = &quot;com.example&quot;)</code></li></ul></li><li><p>対象のアプリケーションのトップレベル、あるいはもう１階層下をスキャン対象にすべき</p><ul><li><code>@ComponentScan(basePackages = &quot;com.example.demo&quot;)</code></li><li><code>@ComponentScan(basePackages = &quot;com.example.demo.app&quot;)</code></li></ul></li><li><p>value属性は basePackages属性の別名であり、どちらを使用しても構いません。この属性を省略した場合、コンフィグレーションクラスと同じパッケージ配下をスキャンすることに注意する事</p></li><li>スキャン対象のアノテーションとしては以下の４種類がよく使われる</li></ul><table><thead><tr><th>アノテーション</th><th>説明</th></tr></thead><tbody><tr><td>@Controller</td><td>MVCパターンのC(Controller)の役割を担うコンポーネントであることを示すアノテーション。このアノテーションを付与したコンポーネントでは、クライアントからのリクエストとクライアントへのレスポンスに関わる処理を実装する。ビジネスロジックは、<code>@Service</code>を付与したコンポーネントで行う</td></tr><tr><td>@Service</td><td>ビジネスロジック（ビジネスルール）を提供するコンポーネントであることを示すアノテーション。このアノテーションを付与したコンポーネントでは、ビジネスルールが関わる処理を実装する。データの永続化に関わる処理は<code>@Repository</code>を付与したコンポーネントで行う。</td></tr><tr><td>@Repository</td><td>データの永続化に悪化÷処理を提供するコンポーネントであることを示すアノテーション。このアノテーションを付与したコンポーネントでは、ORM(Object-Relational Mapper)などの永続化ライブラリ等を使用して、データのCRUD処理を実装する</td></tr><tr><td>@Component</td><td>上記３に当てはまらないコンポーネント（ユーティリティクラスやサポートクラスなど）に付与するアノテーション</td></tr></tbody></table><ul><li><p>フィルタを明示したコンポーネントスキャン</p><ul><li>アノテーションによるフィルタ</li><li>代入可能な型によるフィルタ</li><li>正規表現によるフィルタ</li><li>AspectJパターンによるフィルタ</li></ul></li><li><p>[ ] フィルタを駆使するパターンについてメリットがあまり分からないため飛ばす.. あとで調べる</p></li></ul><h3 id="2-1-7-Beanのスコープ"><a href="#2-1-7-Beanのスコープ" class="headerlink" title="2.1.7 Beanのスコープ"></a>2.1.7 Beanのスコープ</h3><ul><li>DIコンテナを使用するメリット<ul><li>Beanのスコープ（生存期間）の管理をコンテナに任せる事が出来ること</li></ul></li></ul><table><thead><tr><th>スコープ</th><th>説明</th></tr></thead><tbody><tr><td>singleton</td><td>DIコンテナの起動時にBeanのインスタンスを生成し、同一のインスタンスを共有して利用する。デフォルトの設定であり、スコープを設定しない場合はsingletonとして扱われる</td></tr><tr><td>prototype</td><td></td></tr><tr><td>session</td><td></td></tr><tr><td>request</td><td></td></tr><tr><td>globalSession</td><td></td></tr><tr><td>application</td><td></td></tr><tr><td>カスタムスコープ(独自の命名)</td></tr></tbody></table><ul><li>覚書<ul><li><code>@Bean</code>アノテーションの使いどころ<ul><li><code>@Configuration</code>クラスの中に定義しているメソッドに付与して使う</li><li>DIコンテナに登録され、デフォルトではsingletonで参照出来る</li></ul></li></ul></li></ul><h3 id="2-1-8-Beanのライフサイクル"><a href="#2-1-8-Beanのライフサイクル" class="headerlink" title="2.1.8 Beanのライフサイクル"></a>2.1.8 Beanのライフサイクル</h3><ol><li>初期化フェーズ</li><li>利用フェーズ</li><li>終了フェーズ</li></ol><h3 id="2-1-9-Configurationの分割"><a href="#2-1-9-Configurationの分割" class="headerlink" title="2.1.9 Configurationの分割"></a>2.1.9 Configurationの分割</h3><ul><li>DIコンテナで管理するBeanが多くなるとConfigurationも肥大化してしまう</li><li><p>Configurationの範囲を明確にし、可読性を上げるために、必要に応じてConfigurationの分割を行う</p></li><li><p><code>@import</code>を使えば複数のConfigurationクラスに分割ができる</p><ul><li>MEMO: importでまとめなくても、<code>@Configuration</code>でコンポーネントスキャンされるので関係ないと思う</li><li>Contextから取得してわざわざアクセスしていた際に有用な方法だったと考える</li></ul></li></ul><h3 id="2-1-10-Configurationのプロファイル化"><a href="#2-1-10-Configurationのプロファイル化" class="headerlink" title="2.1.10 Configurationのプロファイル化"></a>2.1.10 Configurationのプロファイル化</h3><ul><li>Springでは異なる環境や目的ごとにConfigurationをグループ化することができる</li><li><p>このグループを「プロファイル」といいます。</p></li><li><p>例えば、環境ごとに「developmentプロファイル」「testプロファイル」などを作成することが考えられる</p></li></ul><p><code>@Profile</code>アノテーションを使用して指定する</p><ul><li><p>使用するプロファイルの選択方法</p><ul><li>JVM引数 <code>-Dspring.profiles.acrive=production</code></li><li>環境変数 <code>export SPRING_PROFILES_ACTIVE=production</code></li><li>WEB.xmlに記載することもできる（割愛）</li><li><code>application.yml</code> に指定することもできる（割愛）</li></ul></li><li><p>MEMO: 環境ごとの情報を定義するためのJavaクラスにアノテーションを付与して実現するのは微妙だと思うので、</p><ul><li><code>application.yml</code>で管理するのが良いだろうと思う</li></ul></li></ul><h3 id="2-1-11-JSR-330-Dependency-Injection-for-Java"><a href="#2-1-11-JSR-330-Dependency-Injection-for-Java" class="headerlink" title="2.1.11 JSR 330: Dependency Injection for Java"></a>2.1.11 JSR 330: Dependency Injection for Java</h3><ul><li>Springで、Java標準のJSR330で定められたAPI（主にアノテーション）を使用することができる</li></ul><table><thead><tr><th>Spring</th><th>JSR</th><th>説明</th></tr></thead><tbody><tr><td><code>@Autowired</code></td><td><code>@Inject</code></td><td><code>@Inject</code>には必須チェック（required属性）がない</td></tr><tr><td><code>@Component</code></td><td><code>@Named</code></td><td>Springの場合はデフォルトでSingletonスコープであるが、JSR330の場合はデフォルトでprototypeスコープである</td></tr><tr><td><code>@Qualifier</code></td><td><code>@Named</code></td><td><code>@Named</code>が兼用される</td></tr><tr><td><code>@Scope</code></td><td><code>@Scope</code></td><td>JSR330の<code>@Scope</code>はスコープを定義するカスタムアノテーションを作るためのメタアノテーション</td></tr></tbody></table><ul><li>Springを使うのであれば、特にこだわりがなければ、Springのアノテーションを使うのがいいでしょう</li></ul><h3 id="2-2-AOP"><a href="#2-2-AOP" class="headerlink" title="2.2 AOP"></a>2.2 AOP</h3><ul><li><p>ロギング処理、キャッシュ処理など本質的ではない処理がいろいろなロジック中に散在するようになる</p></li><li><p>複数のモジュールにまたがって存在する処理は、「横断的関心事（Cross-Cutting Concern）」と呼ばれる</p></li><li><p>代表的なものとしては以下</p><ul><li>セキュリティ</li><li>ログ出力</li><li>トランザクション</li><li>モニタリング</li><li>キャッシュ</li><li>例外ハンドリング</li></ul></li><li><p>プログラムの中から横断的関心事を取り除き、一箇所に集めることを「横断的関心事の分離（Separation Of Cross-Cutting Concerns）」と呼び</p></li><li>これを実現する手法をアスペクト指向プログラミングといいます</li></ul><h3 id="2-2-1-AOPの概要"><a href="#2-2-1-AOPの概要" class="headerlink" title="2.2.1 AOPの概要"></a>2.2.1 AOPの概要</h3><ul><li><p>AOPはDIと並ぶSpringFrameworkの重要な機能</p></li><li><p>AOPのコンセプト</p><ul><li>Aspect<ul><li>AOPの単位となる横断的な関心事を示すモジュールそのもの</li></ul></li><li>Join Point<ul><li>横断的な関心事を実行するポイント（メソッド実行時や例外スロー時など）</li><li>Join PointはAOPライブラリーによって使用が決められている</li><li>SpringのAOPでは、Join Pointはメソッドの実行時</li></ul></li><li>Advice<ul><li>特定のJoin Pointで実行されるコードのことで、横断的な関心事を実装する箇所</li><li>Adviceには、Around,Before,Afterなど複数の種類が存在する</li></ul></li><li>PointCut<ul><li>実行対象のJoin Pointを選択する表現式のこと</li><li>SpringAOPではBean定義ファイルやアノテーションを利用してPointCutを定義</li></ul></li><li>Weaving<ul><li>アプリケーションコードの適切なポイントにAspectを入れ込む処理のこと</li><li>AOPライブラリにはWeavingをコンパイル時に行うもの、クラスロード時に行うもの、実行時に行うものがあり、SpringAOPは実行時にWeavingを行う</li></ul></li><li>Target<ul><li>AOP処理によって、処理フローが変更されたオブジェクトのこと</li><li>TargetオブジェクトはAdvisedオブジェクトと呼ばれることもある</li></ul></li></ul></li></ul><h3 id="2-2-2-Spring-AOP"><a href="#2-2-2-Spring-AOP" class="headerlink" title="2.2.2 Spring AOP"></a>2.2.2 Spring AOP</h3><ul><li>SpringAOP は現場で広く使われているAOPフレームワークであるAspectJを利用している</li></ul><h3 id="2-2-3-Adviceの実装方法"><a href="#2-2-3-Adviceの実装方法" class="headerlink" title="2.2.3 Adviceの実装方法"></a>2.2.3 Adviceの実装方法</h3><ul><li>Before</li><li>After Returning</li><li>After Throwing など記載していく</li><li>括弧にPointCut式を記載する</li></ul><h3 id="2-2-4-XMLでAdviceの実装"><a href="#2-2-4-XMLでAdviceの実装" class="headerlink" title="2.2.4 XMLでAdviceの実装"></a>2.2.4 XMLでAdviceの実装</h3><p>XMLに記載する方法について</p><h3 id="2-2-5-Pointcut式"><a href="#2-2-5-Pointcut式" class="headerlink" title="2.2.5 Pointcut式"></a>2.2.5 Pointcut式</h3><p>Joint Pointを指すPointCutとして<code>execution(* *..*ServiceImple.*(..))</code>という式を使ってきたがその打ち合わけを記載</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">                                                ↓メソッド</span><br><span class="line"><span class="meta">@After</span>(execution(* com.example.domain.*Service.find*(..)))</span><br><span class="line">                 ↑戻り値　↑パッケージ   ↑型、クラス     ↑引数</span><br></pre></td></tr></table></figure><ul><li><p>PointCut式で利用可能なワイルドカード</p><ul><li><code>*</code></li><li><code>..</code></li><li><code>+</code></li></ul></li><li><p>名前付きポイントカットの書き方</p></li></ul><h3 id="2-2-6-Springプロジェクトで利用されているAOP"><a href="#2-2-6-Springプロジェクトで利用されているAOP" class="headerlink" title="2.2.6 Springプロジェクトで利用されているAOP"></a>2.2.6 Springプロジェクトで利用されているAOP</h3><ul><li>トランザクション管理処理：メソッドに<code>@Transaction</code>アノテーションを付与</li><li>認可処理：<code>@PreAuthorize</code>アノテーションを付与</li><li>キャッシュ処理：<code>@Cacheable(&quot;key&quot;)</code>ですでにキャッシュがある場合はメソッドを実行せずにキャッシュされた値を返す</li><li>非同期処理：<code>@Async</code>をメソッドに付与、指定された戻り値（<code>CompletableFuture&lt;Result&gt;</code>）を指定することで非同期実行ができる</li><li>リトライ処理：<code>@Retryable(maxAttempts=3)</code>をメソッドに付与。信頼性をコントロールできない外部接続先の呼び出しなどで有用</li></ul><h3 id="2-3-データバインディングと型変換"><a href="#2-3-データバインディングと型変換" class="headerlink" title="2.3 データバインディングと型変換"></a>2.3 データバインディングと型変換</h3><ul><li>本来であれば、<code>HttpServletRequestクラス</code>からパラメータをgetしてBeanに１つ１つ設定しなければ行けないが、</li><li>型変換しなければ行けない場面もあり面倒でミスが起きやすい</li><li>Springのデータバインディングを利用するとこれらの問題を解消できる</li></ul><h3 id="2-3-1-Springのデータバインディング"><a href="#2-3-1-Springのデータバインディング" class="headerlink" title="2.3.1 Springのデータバインディング"></a>2.3.1 Springのデータバインディング</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EmployeeForm form = <span class="keyword">new</span> EmployeeForm();</span><br><span class="line">ServletRequestDataBinder dataBinder = <span class="keyword">new</span> ServletRequestDataBinder(form);</span><br><span class="line">dataBinder.bind(request);</span><br></pre></td></tr></table></figure><ul><li>これを記載することで、３行でデータバインディングができる</li><li>また、SpringMVCの機能を使えば１行で済む （恐らく、<code>@ModelAttribute</code>を付与することを言っているのだと思う）</li></ul><h3 id="2-3-2-Springの型変換"><a href="#2-3-2-Springの型変換" class="headerlink" title="2.3.2 Springの型変換"></a>2.3.2 Springの型変換</h3><ul><li>型変換を行うための仕組みとして以下の３つを提供している<ul><li>PropertyEditor</li><li>Type Conversion</li><li>Field Formatting</li></ul></li></ul><h3 id="2-4-プロパティ管理"><a href="#2-4-プロパティ管理" class="headerlink" title="2.4 プロパティ管理"></a>2.4 プロパティ管理</h3><ul><li><p>ハードコーディングを避けるためにプロパティから値を読み込む仕組みがある</p></li><li><p>Strutsを使用していたときはプロパティファイルの値取得はResourceBundleでUtilクラス経由で取得していたのに対して、</p></li><li><p>SpringのDIであれば、<code>@Value(xxxx)</code>を引数やフィールドに指定するだけで取得できる</p></li><li><p>MEMO: これは必ず使用する</p><ul><li>:で区切って記載すればデフォルト値も指定できる！</li><li><code>@Value(xxxx:5)</code>などのように</li></ul></li></ul><h3 id="2-5-Spring-Expression-Language-SpEL"><a href="#2-5-Spring-Expression-Language-SpEL" class="headerlink" title="2.5 Spring Expression Language(SpEL)"></a>2.5 Spring Expression Language(SpEL)</h3><ul><li><p>Spring Expression Language (SpEL)は、SpringFrameworkが提供しているExpression Language</p></li><li><p>MEMO: 使用しないことにする</p></li></ul><h3 id="2-5-1-SpELのセットアップ"><a href="#2-5-1-SpELのセットアップ" class="headerlink" title="2.5.1 SpELのセットアップ"></a>2.5.1 SpELのセットアップ</h3><ul><li>pom.xmlの例</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-expression<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-5-2-SpEl-APIの利用"><a href="#2-5-2-SpEl-APIの利用" class="headerlink" title="2.5.2 SpEl APIの利用"></a>2.5.2 SpEl APIの利用</h3><ul><li>直接APIを使用するケースはないと思うが、SpELの仕組みを理解するために使用方法を説明</li></ul><h3 id="2-5-3-Bean定義でのSpELの利用"><a href="#2-5-3-Bean定義でのSpELの利用" class="headerlink" title="2.5.3 Bean定義でのSpELの利用"></a>2.5.3 Bean定義でのSpELの利用</h3><ul><li>SpELで定義した値をコンストラクタの引数に渡す方法の説明</li><li><p>アノテーションの場合は、<code>@Value(&quot;#{T(java.util.UUID).randomUUID().toString()}&quot;) String id</code>のような形で定義する</p></li><li><p>SpELは様々なアノテーションの中で利用することができる</p><ul><li><code>@EventListener</code></li><li><code>@TransactionalEventListener</code></li><li><code>@Cacheable</code></li><li><code>@CachePut</code></li><li>TODO:後で調べる</li></ul></li></ul><h3 id="2-5-4-SpELで使用可能な式の表現"><a href="#2-5-4-SpELで使用可能な式の表現" class="headerlink" title="2.5.4 SpELで使用可能な式の表現"></a>2.5.4 SpELで使用可能な式の表現</h3><ul><li>リテラル値</li><li>オブエジェクトの生成</li><li>プロパティへの参照</li><li>メソッドの呼び出し</li><li>型の解決</li><li>変数の参照</li><li>Beanの参照</li><li>演算子</li><li>テンプレート</li><li><p>コレクションの操作</p></li><li><p>MEMO:テンプレートエンジン使うなら、SpELいらないのは説</p></li></ul><h3 id="2-6-リソースの抽象化"><a href="#2-6-リソースの抽象化" class="headerlink" title="2.6 リソースの抽象化"></a>2.6 リソースの抽象化</h3><ul><li>アプリケーションは様々なリソースにアクセスする必要がある</li><li>これらのリソースが格納されている場所は<ul><li>ファイルシステム上のディレクトリ</li><li>クラスパス上のディレクトリ</li><li>サーブレットコンテナ上のwarファイル</li><li>jarファイル</li><li>別のWebサーバー<ul><li>など多岐に渡る</li></ul></li></ul></li></ul><h3 id="2-6-1-Resourceインターフェースと実装クラス"><a href="#2-6-1-Resourceインターフェースと実装クラス" class="headerlink" title="2.6.1 Resourceインターフェースと実装クラス"></a>2.6.1 Resourceインターフェースと実装クラス</h3><ul><li><p>Resourceインターフェース実装クラス</p><ul><li>ClassPathResource</li><li>FileSystemResource</li><li>PathResource</li><li>UrlResource</li><li>ServletContextResource</li></ul></li><li><p>TODO: Resourceインターフェースを実装しているクラスをいくつか紹介してくれているが、</p><ul><li>実際にこれらのクラスを使ってみる必要あり</li></ul></li></ul><h3 id="2-6-2-ResourceLoaderインターフェース"><a href="#2-6-2-ResourceLoaderインターフェース" class="headerlink" title="2.6.2 ResourceLoaderインターフェース"></a>2.6.2 ResourceLoaderインターフェース</h3><ul><li>MEMO: ResourceLoaderインターフェースと上記のつながりが理解できてないので再確認<ul><li>ResourceLoader経由のほうがよい？</li><li>上記の実装クラスを使わなくて済むならこっちのほうがよいと考える</li></ul></li></ul><h3 id="2-6-3-Resourceインターフェースを利用したリソースアクセス"><a href="#2-6-3-Resourceインターフェースを利用したリソースアクセス" class="headerlink" title="2.6.3 Resourceインターフェースを利用したリソースアクセス"></a>2.6.3 Resourceインターフェースを利用したリソースアクセス</h3><ul><li>TODO: 実際に使ってみる必要あり</li></ul><h3 id="2-6-4-XMLファイル上でのリソースの指定"><a href="#2-6-4-XMLファイル上でのリソースの指定" class="headerlink" title="2.6.4 XMLファイル上でのリソースの指定"></a>2.6.4 XMLファイル上でのリソースの指定</h3><ul><li><p>割愛</p></li><li><p>MEMO: リソース取得先の指定はプロパティファイルにまとめるべき！</p><ul><li>すべて<code>@Value()</code>で記載すればよい</li></ul></li></ul><h3 id="2-7-メッセージ管理"><a href="#2-7-メッセージ管理" class="headerlink" title="2.7 メッセージ管理"></a>2.7 メッセージ管理</h3><ul><li>説明文や項目名などの固定文言</li><li>処理結果に通知するメッセージ</li><li>エラーメッセージなどを表示する際に</li><li>プロパティファイルなどの外部定義から取得することが求められるケースも多いはず</li><li>メッセージの外部化のメリット<ul><li>多言語サポートする要件を満たす</li><li>一箇所で一元管理する</li></ul></li></ul><h3 id="2-7-1-MessageSourceインターフェースと実装クラス"><a href="#2-7-1-MessageSourceインターフェースと実装クラス" class="headerlink" title="2.7.1 MessageSourceインターフェースと実装クラス"></a>2.7.1 MessageSourceインターフェースと実装クラス</h3><ul><li>MessageSource<ul><li>メッセージの格納先を抽象化するためのインターフェース</li></ul></li><li><p>MessageSourceResolvable</p><ul><li>メッセージ解決に必要な値（code,args,defaultMessage）を保持していることを示すインターフェース</li></ul></li><li><p>MessageSourceの実装クラス</p><ul><li>ResourceBundleMessageSource</li><li>ReloadableResourceBundleMessageSource</li></ul></li></ul><h3 id="2-7-2-MessageSourceの利用"><a href="#2-7-2-MessageSourceの利用" class="headerlink" title="2.7.2 MessageSourceの利用"></a>2.7.2 MessageSourceの利用</h3><ul><li>MessageSourceのBean定義</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageSource <span class="title">messageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ResourceBundleMessageSource messageSource = <span class="keyword">new</span> ResourceBundleMessageSource();</span><br><span class="line">  messageSource.setBeannames(<span class="string">"messages"</span>); <span class="comment">// クラスパス上に格納されているプロパティファイル（拡張子は除く）を指定する</span></span><br><span class="line">  <span class="keyword">return</span> messageSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>メッセージの定義ファイルを作成</p></li><li><p>MessageSourceのAPI利用</p><ul><li>DIコンテナに登録したMessageSourceをインジェクションして<code>getMessage</code>メソッドを呼び出す</li></ul></li><li><p>MEMO: 感じたこと</p><ul><li>標準のクラスをDIコンテナで管理したい場合<code>@Bean</code>をメソッドにつけているのかなと思った</li><li>独自のクラスを作るのであれば、<code>@Component</code>でよいのではと</li></ul></li><li><p>MessageSourceResolvableの利用</p><ul><li>メッセージ引数もメッセージ定義で管理したい場合に利用するみたい</li></ul></li></ul><h2 id="第3章-データアクセス（Tx、JDBC）"><a href="#第3章-データアクセス（Tx、JDBC）" class="headerlink" title="第3章　データアクセス（Tx、JDBC）"></a>第3章　データアクセス（Tx、JDBC）</h2><ul><li>データアクセス機能について解説<ul><li>JDBC関連の機能</li><li>トランザクション管理機能</li><li>データアクセスエラーのハンドリング機能</li><li>その他ライブラリの機能（JPA、Hivernate、MyBatisといったORM）は以降の章で解説</li></ul></li></ul><h3 id="3-1-Springによるデータアクセス"><a href="#3-1-Springによるデータアクセス" class="headerlink" title="3.1 Springによるデータアクセス"></a>3.1 Springによるデータアクセス</h3><ul><li>まずはSpringが扱うことができるデータソースの種類について</li></ul><h3 id="3-1-1-データソースについて"><a href="#3-1-1-データソースについて" class="headerlink" title="3.1.1 データソースについて"></a>3.1.1 データソースについて</h3><p>データソースは、データベースにアクセスするためのコネクションをアプリケーションに提供する役割を担う</p><ul><li><p>Springが提供するデータベースアクセス機能では、以下に示す３つのデータソースを利用することができる</p><ul><li>アプリケーション内に定義したデータソース<ul><li>アプリ内にユーザや接続情報などを記載するパターン</li></ul></li><li>アプリケーションサーバーに定義したデータソース<ul><li>APサーバーに定義されたデータソースを利用するパターン<ul><li>MEMO: JavaEE徹底入門ではこのパターンでサンプル実装されていた</li></ul></li></ul></li><li>組み込みデータベースのデータソース<ul><li>HSQLDB、H2、Apache Derbyといった組み込みデータベースをデータソースとして利用する</li></ul></li></ul></li><li><p>MEMO: Commons DBCP はコネクションプール機能付きのデータソースを提供するライブラリー</p><ul><li>実際に定義を作成していく際に、コネクションプール設定方法について確認しておく</li></ul></li></ul><h3 id="3-1-2-データソースのコンフィギュレーション"><a href="#3-1-2-データソースのコンフィギュレーション" class="headerlink" title="3.1.2 データソースのコンフィギュレーション"></a>3.1.2 データソースのコンフィギュレーション</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>アプリケーション定義のデータソース<ul><li>アノテーション定義の例（詳細略）</li><li>XML定義の例（詳細略）</li></ul></li><li>アプリケーションサーバー定義のデータソース<ul><li>Jndiを指定して参照する（詳細略）</li></ul></li><li><p>組み込みデータソース</p><ul><li>（詳細略）</li></ul></li><li><p>TODO: 実際に上記の３種類で接続をしてみる必要がある</p></li></ul><h3 id="3-2-Spring-JDBC"><a href="#3-2-Spring-JDBC" class="headerlink" title="3.2 Spring JDBC"></a>3.2 Spring JDBC</h3><ul><li>前節ではSpring JDBCを使用するために必要となるデータソースのBean定義方法を紹介した</li><li>データアクセス処理を記述するための中心的な役割を持つJdbcTempleteクラスの使用方法を紹介<ul><li>SQLを実行する方法</li><li>SQLへ値をバインドする方法</li><li>SQLの実行結果からデータを取得する方法</li></ul></li></ul><h3 id="3-2-1-Spring-JDBCとは"><a href="#3-2-1-Spring-JDBCとは" class="headerlink" title="3.2.1 Spring JDBCとは"></a>3.2.1 Spring JDBCとは</h3><p>SQLの内容にかかわらす共通に行われる定型的なJDBCの処理をSpringが代替する機能</p><ul><li>定型的な処理<ul><li>コネクションのオープンやクローズ</li><li>SQLステートメントの実行</li><li>処理結果行の繰り返し処理</li><li>例外ハンドリング</li></ul></li><li>SpringJDBCを利用することで、実装範囲を以下のような重要な処理に限定できる<ul><li>SQLの定義</li><li>パラメータの設定</li><li>ResultSetの取得結果において、各レコードに対して実行したい処理</li></ul></li></ul><h3 id="3-2-2-JdbcTempleteクラスを利用したCRUD操作"><a href="#3-2-2-JdbcTempleteクラスを利用したCRUD操作" class="headerlink" title="3.2.2 JdbcTempleteクラスを利用したCRUD操作"></a>3.2.2 JdbcTempleteクラスを利用したCRUD操作</h3><ul><li>JdbcTempleteクラスを用いたCRUD操作の説明</li><li>MEMO: ORMを使用したほうが効率が良さそう<ul><li>念の為読んでおく程度で、覚えておかなくても良いと考える</li></ul></li></ul><h3 id="3-2-3-取得結果の変換処理"><a href="#3-2-3-取得結果の変換処理" class="headerlink" title="3.2.3 取得結果の変換処理"></a>3.2.3 取得結果の変換処理</h3><ul><li><p>SpringJDBCでは取得結果を変換できる３つのインターフェースを用意している</p><ul><li><code>RowMapper</code><ul><li>ResultSetの１行を特定のPOJOインスタンスに変換する</li></ul></li><li><code>ResultSetExtractor</code><ul><li>複数行から１つのインスタンスを生成できる</li></ul></li><li><code>RowCallbackHandler</code><ul><li>ResultSetを参照してなんらかの処理を行うためのインターフェース</li><li>戻り値を返さない。取得結果のファイル出力や、データのチェックなどを行う場合に利用します。</li></ul></li></ul></li><li><p>RowMapperの実装方法</p><ul><li>RowMapperインターフェースを実装したクラスにメソッドを作成して使用する</li><li>BeanPropertyRowMapperクラスを利用することもできる<ul><li>制約はありルールに沿ってBean定義すればかんたんにResultSetを設定可能</li></ul></li></ul></li><li><p>ResultSetExtractorの実装</p><ul><li>割愛</li></ul></li><li><p>RowCallbackHandlerの実装</p><ul><li>割愛</li></ul></li></ul><h3 id="3-2-4-応用的なCRUD操作"><a href="#3-2-4-応用的なCRUD操作" class="headerlink" title="3.2.4 応用的なCRUD操作"></a>3.2.4 応用的なCRUD操作</h3><ul><li>SQLのバッチ実行<ul><li><code>batchUpdate()</code>メソッドを利用する</li></ul></li><li>ストアドプロシージャの呼び出し<ul><li><code>JdbcTemplate</code>の<code>call</code>メソッドや<code>execute</code>メソッドを利用することで呼び出すことができる</li><li>TODO: ストアド・プロシージャ使ってみる。使ったことないので。。</li></ul></li></ul><h3 id="3-3-トランザクション管理"><a href="#3-3-トランザクション管理" class="headerlink" title="3.3 トランザクション管理"></a>3.3 トランザクション管理</h3><ul><li>アノテーションを用いたトランザクション管理方法</li><li>プログラム内に直接commitメソッドやrollbackメソッドを記述する明示的なトランザクション管理について説明</li></ul><h3 id="3-3-1-トランザクションマネージャ"><a href="#3-3-1-トランザクションマネージャ" class="headerlink" title="3.3.1 トランザクションマネージャ"></a>3.3.1 トランザクションマネージャ</h3><ul><li><p><code>PlatformTransactionManager</code>: Springのトランザクション管理の中心となるインターフェース</p></li><li><p>トランザクションマネージャの定義</p><ul><li><code>PlatformTransactionManager</code>のBeanを定義する</li><li>トランザクション対象とするメソッドを定義する</li></ul></li><li><p>ローカルトランザクションを利用する場合</p><ul><li>単一データベースに対する複数の操作</li><li>XMLにTransactionManagerの定義を記載する方法を紹介</li><li>BeanIDは<code>transactionManager</code>を指定することを推奨</li></ul></li><li><p>グローバルトランザクションを利用する場合</p><ul><li>異なるデータベースに対する複数の操作</li><li>グローバルトランザクションの仕組みはJTAというJavaEEの仕様として標準化されておりアプリケーション・サーバーからJTAの仕組みが提供されている</li><li>実装クラスとして<code>JtaTransactionManager</code>を使用する</li><li>ただし、製品ごとの<code>JtaTransactionManager</code>が提供されているのでそちらを使う 自動的に最適なクラスを使う仕組みが用意されているらしい</li></ul></li></ul><h3 id="3-3-2-宣言的トランザクション"><a href="#3-3-2-宣言的トランザクション" class="headerlink" title="3.3.2 宣言的トランザクション"></a>3.3.2 宣言的トランザクション</h3><ul><li><p>宣言的トランザクションとは</p><ul><li>事前に宣言されたルールに従い、トランザクションを制御する方法のこと</li><li>メリット<ul><li>トランザクションの開始やコミット、ロールバックなどの典型的な処理をビジネスロジックの中に記述する必要がなくなる</li></ul></li><li>利用方法<ul><li><code>@Transactional</code></li><li>XMLコンフィギュレーション</li></ul></li></ul></li><li><p><code>@Transactional</code>を利用した宣言的トランザクション</p></li><li>トランザクション制御で必要となる情報<ul><li>アノテーションの引数について説明（割愛）</li><li>クラスに付与するかメソッドに付与するか</li></ul></li><li>コンフィギュレーションクラスに定義する方法も紹介している</li><li>XMLコンフィギュレーションによる宣言的トランザクション<ul><li>割愛</li></ul></li></ul><h3 id="3-3-3-明示的トランザクション"><a href="#3-3-3-明示的トランザクション" class="headerlink" title="3.3.3 明示的トランザクション"></a>3.3.3 明示的トランザクション</h3><ul><li><p>明示的トランザクションとは</p><ul><li>コミットやロールバックといったトランザクション制御に関する処理をソースコードに明示的に記述する方法</li></ul></li><li><p><code>PlatformTransactionManager</code>を利用した明示的トランザクション制御</p><ul><li>commit(),rollback()などを直接書く</li></ul></li><li><p><code>TransactionTemplete</code>を利用した明示的トランザクション制御</p><ul><li>@ConfigurationクラスにBean定義する際にトランザクションを設定</li></ul></li><li><p>MEMO: 明示的トランザクションはどちらも使いにくいような印象</p></li></ul><h3 id="3-3-4-トランザクションの分離レベルと伝播レベル"><a href="#3-3-4-トランザクションの分離レベルと伝播レベル" class="headerlink" title="3.3.4 トランザクションの分離レベルと伝播レベル"></a>3.3.4 トランザクションの分離レベルと伝播レベル</h3><ul><li>TODO: ★見返して実装に組み込む</li><li>トランザクション分離レベル<ul><li>TODO: トランザクション分離レベルについて復習すべし</li></ul></li><li>トランザクション伝播レベル<ul><li>MEMO: 伝播レベルについて意識したことはなかった</li><li>トランザクション処理が入れ子になったときに初めて意識することになる。</li><li>通常の処理の場合はデフォルトの<code>Required</code>で問題ないような気がする。</li><li>TODO: 逆に入れ子にするパターンってどのような要件が考えられるか確認する<ul><li>→本書に解説があった。<ul><li>業務ロジックのトランザクションとは別に、ログ出力用の処理でDBアクセスがある場合</li><li>業務ロジックでロールバックが発生すると、ログ出力用のデータもロールバックされてしまう。</li><li>こうならないように、ログ出力用のトランザクションは<code>REQUIRES_NEW</code>で生成しておく必要があるとのこと</li><li>そもそもDBにログを貯める仕様が良くないのではと思う</li></ul></li></ul></li></ul></li></ul><h3 id="3-4-データアクセスエラーのハンドリング"><a href="#3-4-データアクセスエラーのハンドリング" class="headerlink" title="3.4 データアクセスエラーのハンドリング"></a>3.4 データアクセスエラーのハンドリング</h3><ul><li>データアクセス処理でエラーが発生した際のハンドリング処理を実装しておく必要がある</li><li>Springにおけるデータアクセス例外の抽象化の考えかたを理解した上で、エラーハンドリング処理の実装方法や抽象化のカスタマイズ方法を紹介</li></ul><h3 id="3-4-1-Springが提供するデータアクセス例外"><a href="#3-4-1-Springが提供するデータアクセス例外" class="headerlink" title="3.4.1 Springが提供するデータアクセス例外"></a>3.4.1 Springが提供するデータアクセス例外</h3><ul><li><p>DataAccessExceptionを親クラスとするデータアクセス例外の階層構造</p><ul><li>MEMO: かなり多くの種類のエラーが、<code>DataAccessException</code>から切られていることを確認した</li></ul></li><li><p>非検査例外によるDataAccessExceptionの実装</p><ul><li>DataAccessExceptionはRuntimeExceptionが親クラスなので、例外ハンドリングが強制されてませんよという説明</li></ul></li><li><p>実装を隠蔽したデータアクセス例外</p><ul><li>DBごとに例外コードが異なるが、Springのデータアクセス機能で共通の例外クラスに変換している</li><li>MEMO: これは画期的ですごい便利だと感じた→当たり前でもあるか..</li></ul></li></ul><h3 id="3-4-2-データアクセス例外のハンドリング"><a href="#3-4-2-データアクセス例外のハンドリング" class="headerlink" title="3.4.2 データアクセス例外のハンドリング"></a>3.4.2 データアクセス例外のハンドリング</h3><ul><li><p>非検査例外のため、ハンドリングを行いたい場所だけcatchする、行いたくない場所は何もする必要が無い</p></li><li><p>データアクセス例外のハンドリングを行う実装例</p><ul><li>Springが提供している例外でcatchできるようにtry-catchで囲む</li><li>catch後は、プロジェクトの例外を再throwする</li></ul></li></ul><h3 id="3-4-3-データアクセス例外の変換ルールのカスタマイズ"><a href="#3-4-3-データアクセス例外の変換ルールのカスタマイズ" class="headerlink" title="3.4.3 データアクセス例外の変換ルールのカスタマイズ"></a>3.4.3 データアクセス例外の変換ルールのカスタマイズ</h3><ul><li>各データベースのエラーコードとデータアクセス例外の対応はspring-jdbc-xxx.jarに含まれるsql-error-codes.xmlに定義されているが、クラスパス直下にsql-error-codes.xmlを配置することでこの定義をカスタマイズすることができる</li></ul><h2 id="第4章-Spring-MVC"><a href="#第4章-Spring-MVC" class="headerlink" title="第4章　Spring MVC"></a>第4章　Spring MVC</h2><ul><li>第三章までで得た知識で開発できるのは、データベースにアクセスするスタンドアロンアプリケーション</li><li><p>本章から７章までにかけて、SpringMVCの機能を利用したWebアプリケーションの開発方法について解説</p></li><li><p>本章</p><ul><li>SpringMVCの特徴を簡単に説明</li><li>シンプルなサンプルアプリケーションを作成しながらSpringMVCの基礎を学ぶ</li><li>SpringMVCのアーキテクチャについて説明</li></ul></li></ul><h3 id="4-1-Spring-MVC-とは"><a href="#4-1-Spring-MVC-とは" class="headerlink" title="4.1 Spring MVC とは"></a>4.1 Spring MVC とは</h3><ul><li>フレームワークのアーキテクチャとしてMVCパターンを採用している<ul><li>TODO: MVC以外のアーキテクチャについて理解を深める</li></ul></li><li>Springは正確に言うと、フロントコントローラパターンを採用しているらしい詳細は4.3SpringMVCのアーキテクチャで解説</li></ul><h3 id="4-1-1-Webアプリケーション開発における特徴"><a href="#4-1-1-Webアプリケーション開発における特徴" class="headerlink" title="4.1.1 Webアプリケーション開発における特徴"></a>4.1.1 Webアプリケーション開発における特徴</h3><ul><li><p>SpringMVCはWebアプリケーションをストレスなく快適に開発することができるフレームワークで、次のような特徴がある</p><ul><li>POJO（Plain Old Java Object）での実装<ul><li>フレームワーク独自のインターフェースを実装する必要が無いため、作成するクラスの単体テストのテスタビリティを確保</li></ul></li><li>アノテーションを使用した定義情報の指定</li><li>柔軟なメソッドシグネチャの定義<ul><li>Controllerに渡す引数や戻り値も様々な形がサポートされている</li></ul></li><li>ServletAPIの抽象化<ul><li>ServletAPI（HttpServletRequest,HttpServletResponse,HttpSessionなどのAPI）を抽象化する仕組みを提供</li><li>テスタビリティを確保</li></ul></li><li>Viewの実装技術の抽象化<ul><li>コントローラはView名（Viewの論理名）を返却し、SpringMVCのフレームワーク処理が呼び出すViewを決定</li><li>ControllerはViewの実装技術（Thymeleaf,ServletAPI,FreeMarkerなど）を意識する必要がなくなる</li></ul></li><li>SpringのDIコンテナとの連携<ul><li>SpringMVCはSpringのDIコンテナ上で動作するフレームワーク</li><li>DIやAOPなどの仕組みを活用できる</li></ul></li></ul></li><li><p>MEMO: この辺は開発で感触をつかめているのですんなり理解できた</p></li></ul><h3 id="4-1-2-MVCフレームワークとしての特徴"><a href="#4-1-2-MVCフレームワークとしての特徴" class="headerlink" title="4.1.2 MVCフレームワークとしての特徴"></a>4.1.2 MVCフレームワークとしての特徴</h3><ul><li>豊富な拡張ポイントの提供<ul><li>処理の役割に応じてインターフェースを定義している</li></ul></li><li>エンタープライズアプリケーション向けの機能の提供<ul><li>メッセージ管理</li><li>セッション管理</li><li>国際化</li><li>ファイルアップロードといったエンタープライズアプリケーション向けのWebアプリケーションを開発する際に必要となる機能も提供</li></ul></li><li><p>サードパーティのライブラリとの連携部品の提供</p><ul><li>★Jackson(JSON/XML操作) → JSON操作は他に、org.jsonがあるみたいだが、Jacksonの方が良さそう</li><li>Apache Tiles(レイアウトエンジン) → レイアウトを組める。Thymeleafのincludeで十分なので使わない</li><li>FreeMarker(テンプレートエンジン) → 変数を持つ定型文言を作成しておき（*.ftlファイル）</li><li>★Rome(RSS/Feed操作) → 他に、Informaというのがあるらしい。</li><li>★JsperReports(帳票出力) → 他にも色々なライブラリがあるみたいだが、一旦これを使用したい<ul><li><a href="https://weblabo.oscasierra.net/java-pdf-lib-2017/" target="_blank" rel="noopener">https://weblabo.oscasierra.net/java-pdf-lib-2017/</a></li></ul></li><li>★Apache POI(Excel操作)</li><li>★Hibernate Validator(Bean Validation)</li><li>Joda Time(日付操作) → Java7時代の日付操作</li><li>など</li><li>サードパーティ自体がSpringMVCとの連携部品を提供しているケースもある。<ul><li>Thymeleaf(テンプレートエンジン)</li><li>★HDIV(セキュリティ強化)</li></ul></li></ul></li><li><p>TODO: ★つけたライブラリーは使用したい</p></li></ul><h3 id="4-2-はじめてのSpring-MVCアプリケーション"><a href="#4-2-はじめてのSpring-MVCアプリケーション" class="headerlink" title="4.2 はじめてのSpring MVCアプリケーション"></a>4.2 はじめてのSpring MVCアプリケーション</h3><h3 id="4-2-1-開発プロジェクトの作成"><a href="#4-2-1-開発プロジェクトの作成" class="headerlink" title="4.2.1 開発プロジェクトの作成"></a>4.2.1 開発プロジェクトの作成</h3><ul><li>InteliJ IDEA でプロジェクトを作成することにした</li><li>mavenプロジェクトをstartarのアーキタイプで作成</li><li><p>pom.xmlをサンプルアプリに合わせる</p><ul><li>mavenがうまく動かない不具合発生</li><li>原因: urlがmavenレポジトリを向いていなかったため<ul><li>結果: 解消しなかった</li></ul></li></ul></li><li><p>Intelijだとうまくいかないと判断し、Eclipseで実施</p></li><li><p>Eclipseでサンプルプログラムを配置</p></li><li>mavenの設定をサンプルに合わせる</li><li>javaeeのモジュールがデフォルトで読み込めなくなったみたいなので、pomに定義を入れる</li><li>tomcat9サーバーを立ち上げる</li><li><p>context-pathはデフォルトでプロジェクト名？になるみたいなので、<code>http://localhost:8080/firstapp4-2</code>でアクセスするとうまく行った</p></li><li><p>Web.xmlに<code>jsp-config</code>というものを定義すると、すべてのjspに対してデフォルトでincludeさせることができるみたい</p></li><li><p>TODO: spring bootで生成したプロジェクトだと、web.xmlが必要ない？ そのあたりの仕組みが理解できていない</p></li></ul><h3 id="4-2-2-Spring-MVCの適用"><a href="#4-2-2-Spring-MVCの適用" class="headerlink" title="4.2.2 Spring MVCの適用"></a>4.2.2 Spring MVCの適用</h3><h3 id="4-2-3-トップ画面表示処理の実装"><a href="#4-2-3-トップ画面表示処理の実装" class="headerlink" title="4.2.3 トップ画面表示処理の実装"></a>4.2.3 トップ画面表示処理の実装</h3><h3 id="4-2-4-入力画面表示処理の実装"><a href="#4-2-4-入力画面表示処理の実装" class="headerlink" title="4.2.4 入力画面表示処理の実装"></a>4.2.4 入力画面表示処理の実装</h3><h3 id="4-2-5-送信処理の実装"><a href="#4-2-5-送信処理の実装" class="headerlink" title="4.2.5 送信処理の実装"></a>4.2.5 送信処理の実装</h3><h3 id="4-2-6-入力チェック処理の実装"><a href="#4-2-6-入力チェック処理の実装" class="headerlink" title="4.2.6 入力チェック処理の実装"></a>4.2.6 入力チェック処理の実装</h3><ul><li><p>ここまででサンプルアプリケーションの説明終了</p><ul><li>Controllerクラス</li><li>フォームクラス</li><li>View(JSPなどのテンプレートファイル)</li></ul></li><li><p>本来であれば、JSPではなくThymeleafとかを使うべきだと思うので、詳細な実装はサラッと流し読み</p></li></ul><h3 id="4-2-7-XMLファイルを使用したBean定義"><a href="#4-2-7-XMLファイルを使用したBean定義" class="headerlink" title="4.2.7 XMLファイルを使用したBean定義"></a>4.2.7 XMLファイルを使用したBean定義</h3><ul><li>割愛</li></ul><h3 id="4-3-Spring-MVCのアーキテクチャ"><a href="#4-3-Spring-MVCのアーキテクチャ" class="headerlink" title="4.3 Spring MVCのアーキテクチャ"></a>4.3 Spring MVCのアーキテクチャ</h3><h3 id="4-3-1-フレームワークのアーキテクチャ"><a href="#4-3-1-フレームワークのアーキテクチャ" class="headerlink" title="4.3.1 フレームワークのアーキテクチャ"></a>4.3.1 フレームワークのアーキテクチャ</h3><ul><li><p>Spring MVCは「フロントコントローラパターン」と呼ばれるアーキテクチャを採用している</p><ul><li>クライアントからのリクエストをフロントコントローラと呼ばれるコンポーネントが受け取り、リクエストの内容に応じて実行するHandler(Controller)を選択するアーキテクチャ</li></ul></li><li><p>フロントコントローラが担う処理</p><ul><li>クライアントからのリクエストの受付</li><li>リクエストデータのJavaオブジェクトへの変換</li><li>入力チェックの実行（Bean Validation）</li><li>Handlerの呼び出し</li><li>Viewの解決</li><li>クライアントへのレスポンスデータの応答</li><li>例外ハンドリング</li></ul></li><li><p>TODO: Springフレームワークの全体を把握したときにもう一度見直す</p></li></ul><h2 id="第5章-Webアプリケーションの開発"><a href="#第5章-Webアプリケーションの開発" class="headerlink" title="第5章　Webアプリケーションの開発"></a>第5章　Webアプリケーションの開発</h2><h3 id="5-1-Webアプリケーションの種類"><a href="#5-1-Webアプリケーションの種類" class="headerlink" title="5.1 Webアプリケーションの種類"></a>5.1 Webアプリケーションの種類</h3><ul><li><p>SpringMVCは大きく分けて以下の２種類のアプリケーションを作成するための機能を提供</p><ul><li>画面を応答するアプリケーション</li><li>データのみを応答するアプリケーション（RESTful Webサービス）</li></ul></li><li><p>メモ</p><ul><li>SpringMVCの仕組みは使用していないが、Spring4.0よりWebSocketの連携モジュールが提供されている</li><li>フロントとサーバーサイドの双方向通信用</li><li>TODO: 使ってみる</li></ul></li><li><p>Hamdlerメソッド作成</p><ul><li><code>@RequestMapping()</code>は使用せずに、<code>@GetMapping()</code>を使用する</li></ul></li><li><p>Handlerメソッドの引数に指定可能な型、アノテーションを紹介</p><ul><li>TODO: 再度確認する</li></ul></li><li><p>暗黙的な引数の解決！覚えておく</p><ul><li>引数の型がStringやIntegerといったシンプル型の場合、引数名に一致するリクエストパラメータの値を取得</li><li>引数の方がJavaBeansだった場合、デフォルトの属性名に一致するオブジェクトをModelから取得する<ul><li>該当するオブジェクトがModelに存在しない場合、デフォルトコンストラクタを呼び出して新しいオブジェクトを生成</li></ul></li></ul></li><li><p>ServletAPI(HttpServletRequest,HttpServletResponse,HttpSession,Partなど)や低レベルのJavaAPI(InputStream,Reader,OutputStream, Writer,Map)なども指定できるが、これらのAPIを自由に使うとメンテナンス性を低下させる可能性があるので、使用しないようにする必要がある</p></li><li>TODO: コーディング規約として利用を制限していくべき！</li></ul><h4 id="5-3-5-Handlerメソッドの戻り値"><a href="#5-3-5-Handlerメソッドの戻り値" class="headerlink" title="5.3.5 Handlerメソッドの戻り値"></a>5.3.5 Handlerメソッドの戻り値</h4><ul><li><p>Handlerメソッドは戻り値として様々なオブジェクトを返却できる</p></li><li><p>メモ</p><ul><li>返却できるオブジェクトは<code>org.springframework.web.method.support.HandlerMethodReturnValueHandler</code>インターフェースの実装クラスを作成することで拡張できる</li></ul></li><li><p>SpringMVCがサポートしている主な型</p><ul><li><code>java.lang.String</code></li><li>Model</li><li>ModelAndView</li><li>void</li><li>ResponseEntity&lt;?&gt;</li><li>HttpHeaders</li></ul></li></ul><h4 id="5-3-6-View-Controllerの利用"><a href="#5-3-6-View-Controllerの利用" class="headerlink" title="5.3.6 View Controllerの利用"></a>5.3.6 View Controllerの利用</h4><ul><li>Viewを呼び出すだけであれば、SpringMVCが提供しているViewControllerの仕組みを利用することができる</li></ul><h3 id="5-4-リクエストマッピング"><a href="#5-4-リクエストマッピング" class="headerlink" title="5.4 リクエストマッピング"></a>5.4 リクエストマッピング</h3><ul><li><p><code>@RequestMapping</code>の属性値を使ってリクエストマッピングの条件を指定する</p></li><li><p>指定可能な属性</p><ul><li>value</li><li>path</li><li>method</li><li>params</li><li>headers: リクエストヘッダー</li><li>consumes: Content-Typeヘッダー</li><li>produces: Acceptヘッダー</li><li>name</li></ul></li><li><p>value,pathは複数指定することができる</p><ul><li>or条件として扱われる</li></ul></li><li><p>パスパターンの使用</p><ul><li>URIテンプレート形式のパスパターン</li><li>正規表現も使える</li><li>Antスタイルのパスパターン</li></ul></li><li><p>paramsはメソッドが実行される条件としてパラメータの有無も入る</p></li></ul><h3 id="5-5-リクエストデータの取得"><a href="#5-5-リクエストデータの取得" class="headerlink" title="5.5 リクエストデータの取得"></a>5.5 リクエストデータの取得</h3><ul><li>種類<ul><li><code>@PathVariable</code></li><li><code>@RequestParam</code></li><li><code>@RequestHeader</code></li><li>リクエストパラメータ値の一括取得</li></ul></li></ul><h4 id="5-5-4-コンパイルオプションの注意点"><a href="#5-5-4-コンパイルオプションの注意点" class="headerlink" title="5.5.4 コンパイルオプションの注意点"></a>5.5.4 コンパイルオプションの注意点</h4><ul><li><code>@PathVariable</code>,<code>@RequestParam</code>,<code>@RequestHeader</code>,<code>@CookieValue</code>のvalue属性を省略する場合、</li><li><code>-g</code>オプションまたはJavaSE8から追加された<code>-parameters</code>オプションのどちらかのコンパイルオプションを有効にしておく必要がある<ul><li>TODO: バインドされないとき確認</li></ul></li></ul><h4 id="5-5-7-アノテーションを使用したフォーマットの指定"><a href="#5-5-7-アノテーションを使用したフォーマットの指定" class="headerlink" title="5.5.7 アノテーションを使用したフォーマットの指定"></a>5.5.7 アノテーションを使用したフォーマットの指定</h4><ul><li><a href="mailto:`@org.springframework.format.annotation.DateTimeFormat" target="_blank" rel="noopener">`@org.springframework.format.annotation.DateTimeFormat</a>`</li><li><p><a href="mailto:`@org.springframework.format.annotation.NumberFormat" target="_blank" rel="noopener">`@org.springframework.format.annotation.NumberFormat</a>`</p></li><li><p>JSR354 : Money and Currency APIというものがあるらしい</p><ul><li>TODO: 後で確認する</li></ul></li></ul><h3 id="5-6-フォームクラスの実装"><a href="#5-6-フォームクラスの実装" class="headerlink" title="5.6 フォームクラスの実装"></a>5.6 フォームクラスの実装</h3><h4 id="5-6-1-フォームオブジェクトのスコープ"><a href="#5-6-1-フォームオブジェクトのスコープ" class="headerlink" title="5.6.1 フォームオブジェクトのスコープ"></a>5.6.1 フォームオブジェクトのスコープ</h4><ul><li><p>スコープの種類</p><ul><li>リクエストスコープ</li><li>フラッシュスコープ：PRGパターンのリクエスト間でオブジェクトを共有するためのスコープ</li><li>セッションスコープ：HttpSessionに格納され、明示的に破棄するまで残り続ける</li></ul></li><li><p>フラッシュスコープ</p><ul><li><code>RedirectAttributes</code>の<code>addFlashAttribute()</code>メソッドを使用して詰める</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"create"</span>, method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  @Validated AccountCreateForm form, BindingResult result,</span></span></span><br><span class="line"><span class="function"><span class="params">  RedirectAttributes redirectAttributes)</span> </span>&#123;</span><br><span class="line">    redirectAttributes.addFlashAttribute(form);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:/account/create?complete"</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="5-6-2-フォームクラスの作成"><a href="#5-6-2-フォームクラスの作成" class="headerlink" title="5.6.2 フォームクラスの作成"></a>5.6.2 フォームクラスの作成</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginFormRequestDto</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Serializableインターフェスを実装しておく。これが必要なのはオブジェクトをセッションスコープで管理する場合だが、スコープに関係なく定義しておくのが無難</li></ul><h3 id="5-7-入力チェック"><a href="#5-7-入力チェック" class="headerlink" title="5.7 入力チェック"></a>5.7 入力チェック</h3><ul><li>SpringMVCではBeanValidationの仕組みを利用して、リクエストパラメータ値がバインドされたフォームクラス（またはコマンドクラス）に対して入力チェックを行う</li></ul><h4 id="5-7-1-入力チェックの有効化"><a href="#5-7-1-入力チェックの有効化" class="headerlink" title="5.7.1 入力チェックの有効化"></a>5.7.1 入力チェックの有効化</h4><ul><li>入力チェックを行う場合、<ul><li>入力チェックを行うメソッドの引数にフォームクラスを定義して、<ul><li><a href="mailto:`@org.springframework.validation.annotation.Validated" target="_blank" rel="noopener">`@org.springframework.validation.annotation.Validated</a>`または</li><li><a href="mailto:`@org.springframework.validation.annotation.Valid" target="_blank" rel="noopener">`@org.springframework.validation.annotation.Valid</a>` を指定する<ul><li><code>@Validated</code>を使用すると、BeanValidationのバリデーショングループの仕組みが使用できるらしい</li></ul></li></ul></li></ul></li></ul><h4 id="5-7-2-入力チェック結果の判定"><a href="#5-7-2-入力チェック結果の判定" class="headerlink" title="5.7.2 入力チェック結果の判定"></a>5.7.2 入力チェック結果の判定</h4><ul><li>BindingResultで処理する</li></ul><h4 id="5-7-3-未入力の扱い"><a href="#5-7-3-未入力の扱い" class="headerlink" title="5.7.3 未入力の扱い"></a>5.7.3 未入力の扱い</h4><ul><li><p>未入力は許容するが、入力された場合は６文字移譲であること</p><ul><li>という要件をBeanValidation標準アノテーションを使用して満たすことができない</li></ul></li><li><p>この場合は、Springが提供している<code>org.springframework.beans.propertyeditors.StringTrimerEditor</code>を使用することを検討</p></li><li><p>TODO: 普通に独自アノテーションを作成した方がシンプルなような気がする</p></li></ul><h4 id="5-7-5-ネスト下JavaBeansの入力チェック"><a href="#5-7-5-ネスト下JavaBeansの入力チェック" class="headerlink" title="5.7.5 ネスト下JavaBeansの入力チェック"></a>5.7.5 ネスト下JavaBeansの入力チェック</h4><ul><li><p>ネストしたJavaBeansやコレクション内のJavaBeansに定義したプロパティに対して入力チェックを行いたい場合は、<code>@Valid</code>を指定する</p><ul><li>チェック対象とすることを明示する必要がある</li></ul></li><li><p><code>@Valid</code>と<code>@Validated</code>の違い  </p><ul><li><a href="http://moondream.hatenablog.com/entry/20131006/1381031027" target="_blank" rel="noopener">http://moondream.hatenablog.com/entry/20131006/1381031027</a></li></ul></li></ul><h4 id="5-7-6-入力チェックルールの追加"><a href="#5-7-6-入力チェックルールの追加" class="headerlink" title="5.7.6 入力チェックルールの追加"></a>5.7.6 入力チェックルールの追加</h4><ul><li><p>独自の入力チェックツール追加方法２つ</p><ul><li>既成ルールを合成して作成する方法</li><li>独自のバリデータを実装して作成する方法</li></ul></li><li><p>既成ルールを合成して作成する方法</p><ul><li>→こっちは使った方がよい</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.RetentionPolicy.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.Constraint;</span><br><span class="line"><span class="keyword">import</span> javax.validation.Payload;</span><br><span class="line"><span class="keyword">import</span> javax.validation.ReportAsSingleViolation;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint</span>(validatedBy = &#123;&#125;)</span><br><span class="line"><span class="meta">@Target</span>(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER &#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RUNTIME)</span><br><span class="line"><span class="meta">@ReportAsSingleViolation</span></span><br><span class="line"><span class="meta">@Pattern</span>(regexp = <span class="string">"[a-zA-Z0-9]*"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AlphaNumeric &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "</span>&#123;validation.AlphaNumeric.message&#125;<span class="string">";</span></span><br><span class="line"><span class="string">  Class&lt;?&gt;[] groups() default &#123;&#125;;</span></span><br><span class="line"><span class="string">  Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  @Target(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER &#125;)</span></span><br><span class="line"><span class="string">  @Retention(RUNTIME)</span></span><br><span class="line"><span class="string">  @Documented</span></span><br><span class="line"><span class="string">  public @interface List &#123;</span></span><br><span class="line"><span class="string">    AlphaNumeric[] value();</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p>メモ TODO: 覚えておく</p><ul><li>上の例では１つしか既成ルールを使用していないが、既成ルールを複数まとめた合成アノテーションを作成することもできる<ul><li>なお、既成ルールをまとめた合成アノテーションを作成する場合、<code>@ReportAsSingleViolation</code>も付与するのが一般的で、付与すると、message属性で指定したメッセージが利用される用になる。付与しない場合は、既成ルールに指定したメッセージが利用される</li></ul></li></ul></li><li><p>独自のバリデータを実装して作成する方法</p><ul><li>→冗長になりがちだと思うので作成しないほうが良いのでは？<ul><li>相関チェックも実装できそうだが、<code>@AssertTrue</code>を使用したほうがシンプル</li></ul></li></ul></li><li><p><code>@AssertTrue</code>の使用方法</p><ul><li><a href="https://qiita.com/t-iguchi/items/ea3dd8691d52d7abe695" target="_blank" rel="noopener">https://qiita.com/t-iguchi/items/ea3dd8691d52d7abe695</a></li></ul></li></ul><h4 id="5-7-7-入力チェックツールの切り替え"><a href="#5-7-7-入力チェックツールの切り替え" class="headerlink" title="5.7.7 入力チェックツールの切り替え"></a>5.7.7 入力チェックツールの切り替え</h4><ul><li>コントローラーのメソッドでパラメータ指定して、呼び出すメソッドを変更することで実現する例を記載している</li></ul><h4 id="5-7-8-エラー情報の表示"><a href="#5-7-8-エラー情報の表示" class="headerlink" title="5.7.8 エラー情報の表示"></a>5.7.8 エラー情報の表示</h4><ul><li><p><code>&lt;form:errors path=&quot;name&quot;&gt;</code></p><ul><li>このように記載することでエラー情報取れますよという説明がある</li></ul></li><li><p>エラーメッセージ要素の構成案</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"error-message d-none"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form:errors</span> <span class="attr">path</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">".error-message"</span>).forEach(<span class="function"><span class="params">el</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(el.innerText) el.classList.remove(<span class="string">"d-none"</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>みたいな感じにすればいいのではなかろうかと</li></ul><h4 id="5-7-9-エラーメッセージの解決"><a href="#5-7-9-エラーメッセージの解決" class="headerlink" title="5.7.9 エラーメッセージの解決"></a>5.7.9 エラーメッセージの解決</h4><ul><li><p>エラーメッセージの定義方法</p><ul><li>Springが提供するMessageSourceで読み込んだプロパティファイルにメッセージを定義する</li><li>BeanValidation管理のプロパティファイルにメッセージを定義する</li><li>制約アノテーションのmessage属性に直接メッセージを定義する</li></ul></li><li><p>Spring管理プロパティファイル</p><ul><li>制約アノテーションのクラス名＋「.」＋フォームオブジェクトの属性名＋「.」＋プロパティ名</li><li>制約アノテーションのクラス名＋「.」＋フォームオブジェクトの属性名</li><li>制約アノテーションのクラス名＋「.」＋プロパティ名</li><li>制約アノテーションのクラス名＋「.」＋プロパティの型名（FQCN）</li><li>制約アノテーションのクラス名</li></ul></li><li><p>BeanValidation管理のプロパティファイルにエラーメッセージを定義</p><ul><li>クラスパス直下のValidationMessages.propertiesにメッセージを定義する<ul><li>→あまり使用する機会無いのではと思う</li></ul></li></ul></li></ul><h4 id="5-7-10-BeanValidationのカスタマイズ"><a href="#5-7-10-BeanValidationのカスタマイズ" class="headerlink" title="5.7.10 BeanValidationのカスタマイズ"></a>5.7.10 BeanValidationのカスタマイズ</h4><ul><li>java configに設定<ul><li>→あまりメリットが理解できなかったのでスキップ</li></ul></li></ul><h4 id="5-7-11-Spring-Validatorの利用"><a href="#5-7-11-Spring-Validatorの利用" class="headerlink" title="5.7.11 Spring Validatorの利用"></a>5.7.11 Spring Validatorの利用</h4><ul><li>割愛</li></ul><h3 id="5-8-画面遷移"><a href="#5-8-画面遷移" class="headerlink" title="5.8 画面遷移"></a>5.8 画面遷移</h3><h4 id="5-8-1-遷移先の指定方法"><a href="#5-8-1-遷移先の指定方法" class="headerlink" title="5.8.1 遷移先の指定方法"></a>5.8.1 遷移先の指定方法</h4><ul><li>View名をHandlerメソッドの戻り値として返却することで実現</li></ul><h4 id="5-8-2-リクエストパスへのリダイレクト"><a href="#5-8-2-リクエストパスへのリダイレクト" class="headerlink" title="5.8.2 リクエストパスへのリダイレクト"></a>5.8.2 リクエストパスへのリダイレクト</h4><ul><li>View名に「redirect: + リダイレクト先のリクエストパス」</li><li>RedirectAttributesを使用してパラメータを設定する</li><li>パス変数を指定することもできる</li></ul><h4 id="5-8-3-リクエストパスへのフォワード"><a href="#5-8-3-リクエストパスへのフォワード" class="headerlink" title="5.8.3 リクエストパスへのフォワード"></a>5.8.3 リクエストパスへのフォワード</h4><ul><li>「forward: + 転送先のリクエストパス」</li><li><code>return &quot;forward:/auth/authenticate&quot;;</code></li><li>MEMO: 使い所が知りたい</li></ul><h4 id="5-8-4-Viewとのデータ連携"><a href="#5-8-4-Viewとのデータ連携" class="headerlink" title="5.8.4 Viewとのデータ連携"></a>5.8.4 Viewとのデータ連携</h4><ul><li>JavaオブジェクトをModelに格納する方法は、以下の２つがある<ul><li>ModelのAPIを直接呼び出す</li><li>ModelAttributeアノテーションを付与したメソッドを用意する</li></ul></li></ul><h4 id="5-8-5-リダイレクト先とのデータ連携"><a href="#5-8-5-リダイレクト先とのデータ連携" class="headerlink" title="5.8.5 リダイレクト先とのデータ連携"></a>5.8.5 リダイレクト先とのデータ連携</h4><ul><li>RedirectAttributesのフラッシュスコープの説明</li></ul><h3 id="5-9-Viewの解決"><a href="#5-9-Viewの解決" class="headerlink" title="5.9 Viewの解決"></a>5.9 Viewの解決</h3><ul><li>jspとかいろいろ使えるよ</li><li>JSP使うなら、ViewResolverRegistryに登録する必要があるよっていう説明</li></ul><h3 id="5-10-JSPの実装"><a href="#5-10-JSPの実装" class="headerlink" title="5.10 JSPの実装"></a>5.10 JSPの実装</h3><ul><li>JSP使用しないため割愛</li></ul><h3 id="5-11-SpringのHTMLフォーム用タグライブラリの利用"><a href="#5-11-SpringのHTMLフォーム用タグライブラリの利用" class="headerlink" title="5.11 SpringのHTMLフォーム用タグライブラリの利用"></a>5.11 SpringのHTMLフォーム用タグライブラリの利用</h3><ul><li>JSP使用しないため割愛</li></ul><h3 id="5-12-Springの汎用タグライブラリの利用"><a href="#5-12-Springの汎用タグライブラリの利用" class="headerlink" title="5.12 Springの汎用タグライブラリの利用"></a>5.12 Springの汎用タグライブラリの利用</h3><ul><li>Springで使用できるタグについて説明<ul><li>MEMO: 必要であれば読み返す</li><li>できるだけthymeleafだけの方が良いのではと思う</li></ul></li></ul><h3 id="5-13-例外ハンドリング"><a href="#5-13-例外ハンドリング" class="headerlink" title="5.13 例外ハンドリング"></a>5.13 例外ハンドリング</h3><h4 id="5-13-1-例外の種類"><a href="#5-13-1-例外の種類" class="headerlink" title="5.13.1 例外の種類"></a>5.13.1 例外の種類</h4><ul><li>Webアプリケーションで発生する例外は大きく３つある<ul><li>システム例外:処理を継続することができない例外<ul><li>アプリケーション自体のバグ</li><li>依存ライブラリのバグ</li><li>ミドルウェアやハードウェアの故障</li><li>システムリソースの枯渇</li><li>ネットワーク障害</li></ul></li><li>リクエスト不正を通知する例外：リクエストの内容が不正なときに発生する例外<ul><li>存在しないパスへのリクエスト</li><li>バインディングエラー</li><li>入力チェックエラー</li></ul></li><li>アプリケーション例外：ビジネスルールに違反したときに発生する例外<ul><li>ユーザー登録時のIDの重複エラー</li><li>排他エラー</li><li>在庫数の不足エラー</li></ul></li></ul></li></ul><h4 id="5-13-2-例外の発生箇所とハンドリング方法"><a href="#5-13-2-例外の発生箇所とハンドリング方法" class="headerlink" title="5.13.2 例外の発生箇所とハンドリング方法"></a>5.13.2 例外の発生箇所とハンドリング方法</h4><ul><li>以下の箇所で例外が発生する可能性があり、それぞれ例外ハンドリングの方法も異なる<ul><li>1) Servlet Fileter  <ul><li>サーブレットコンテナへのエラーページ機能（web.xmlの<code>&lt;error-page&gt;</code>要素）を使用してエラー処理を実装する</li></ul></li><li>2) DispatcherServlet: SpringMVCが提供する例外ハンドリングの仕組み（HandlerExceptionResolver）</li><li>3) アプリケーション(Controller, Service, Repositoryなど)：SpringMVCが提供する例外ハンドリングの仕組み（HandlerExceptionResolver）</li><li>4) View（JSPなど）<ul><li>Viewの中で発生した例外は、サーブレットコンテナのエラーページ機能を使用して絵r-あ処理を実装</li></ul></li></ul></li></ul><h4 id="5-13-3-サーブレットコンテナのエラーページ機能を利用"><a href="#5-13-3-サーブレットコンテナのエラーページ機能を利用" class="headerlink" title="5.13.3 サーブレットコンテナのエラーページ機能を利用"></a>5.13.3 サーブレットコンテナのエラーページ機能を利用</h4><ul><li><code>web.xml</code>に<code>error-page</code>を記載する方法を紹介</li></ul><h4 id="5-13-5-ExceprtionHandlerメソッドの利用"><a href="#5-13-5-ExceprtionHandlerメソッドの利用" class="headerlink" title="5.13.5 @ExceprtionHandlerメソッドの利用"></a>5.13.5 @ExceprtionHandlerメソッドの利用</h4><ul><li><p>複数のController間で共通の処理</p><ul><li><code>@ControllerAdvice</code>を用いる</li><li><a href="https://terasolunaorg.github.io/guideline/5.0.1.RELEASE/ja/ImplementationAtEachLayer/ApplicationLayer.html#id160" target="_blank" rel="noopener">https://terasolunaorg.github.io/guideline/5.0.1.RELEASE/ja/ImplementationAtEachLayer/ApplicationLayer.html#id160</a></li></ul></li><li><p><code>@ExceptionHandler</code>メソッドの引数</p><ul><li>Exception</li><li>HandlerMethod</li><li>java.util.Locale</li><li>java.util.Timezone</li><li>java.time.ZoneId</li><li>java.security.Principal</li></ul></li><li><p>戻り値について</p><ul><li>String</li><li>ModelAndView</li><li>void</li><li>ResponseEntity&lt;?&gt;</li></ul></li></ul><h4 id="5-13-6-ResponseStatusを指定した例外クラスの利用"><a href="#5-13-6-ResponseStatusを指定した例外クラスの利用" class="headerlink" title="5.13.6 @ResponseStatusを指定した例外クラスの利用"></a>5.13.6 @ResponseStatusを指定した例外クラスの利用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseStatus</span>(HttpStatus.NOT_FOUND)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceNotFoundException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">  <span class="comment">// *****</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>TODO: 独自Exceptionを作成していくべきかどうか</li></ul><h2 id="第6章-RESTful-Webサービスの開発"><a href="#第6章-RESTful-Webサービスの開発" class="headerlink" title="第6章　RESTful Webサービスの開発"></a>第6章　RESTful Webサービスの開発</h2><h3 id="6-1-REST-APIのアーキテクチャ"><a href="#6-1-REST-APIのアーキテクチャ" class="headerlink" title="6.1 REST APIのアーキテクチャ"></a>6.1 REST APIのアーキテクチャ</h3><ul><li>RESTは「REpresentational State Transfer」の略で、クライアントとサーバー間でデータをやり取りするアプリケーションを構築するためのアーキテクチャスタイルの１つ</li><li>最も重要なのは「リソース」という概念</li><li>REST APIはデータベースなどで管理している情報の中から、クライアントに提供する情報を「リソース」として抽出</li><li>抽出したリソースはWeb上に公開し、リソースにアクセスするための手段としてRESTAPIを用意します</li></ul><h4 id="6-1-1-Resouce-Oriented-Architecture-ROA"><a href="#6-1-1-Resouce-Oriented-Architecture-ROA" class="headerlink" title="6.1.1 Resouce Oriented Architecture (ROA)"></a>6.1.1 Resouce Oriented Architecture (ROA)</h4><h4 id="6-1-2-フレームワークのアーキテクチャ"><a href="#6-1-2-フレームワークのアーキテクチャ" class="headerlink" title="6.1.2 フレームワークのアーキテクチャ"></a>6.1.2 フレームワークのアーキテクチャ</h4><ul><li>割愛 TODO: 詳細を知りたくなったら読む</li></ul><h3 id="6-2-アプリケーションの設定"><a href="#6-2-アプリケーションの設定" class="headerlink" title="6.2 アプリケーションの設定"></a>6.2 アプリケーションの設定</h3><h4 id="6-2-1-ライブラリのセットアップ"><a href="#6-2-1-ライブラリのセットアップ" class="headerlink" title="6.2.1 ライブラリのセットアップ"></a>6.2.1 ライブラリのセットアップ</h4><ul><li>リソース形式としてJSONを使用する際に利用する「FasterXML Jackson Databind」を依存ライブラリに追加する<ul><li>MEMO: SpringBootだと不要みたい</li></ul></li></ul><h4 id="6-2-2-サーブレットコンテナの設定"><a href="#6-2-2-サーブレットコンテナの設定" class="headerlink" title="6.2.2 サーブレットコンテナの設定"></a>6.2.2 サーブレットコンテナの設定</h4><ul><li><p>HiddenHttpMethodFilterの適用</p><ul><li>RESTAPIを提供する場合、HTTPメソッドとして、PUT、PATCH、DELETEなども使用するが、</li><li>Webブラウザなどクライアントの実装によっては、GETとPOSTしか使用できなかったりする</li><li>そこをサポートするために<code>org.springframework.web.filter.HiddenHttpMethodFileter</code>クラスを利用する<ul><li><code>_method=put</code>というパラメータでリクエストが送られると、サーブレットコンテナ内で行われる処理はPUTメソッドでアクセスしたときとおなじになる</li></ul></li></ul></li><li><p>HttpMessageConverterのカスタマイズ</p><ul><li>MEMO: Converterの設定をしているが、SpringBootだと不要だと思うので飛ばす</li></ul></li></ul><h3 id="6-3-RestControllerの実装"><a href="#6-3-RestControllerの実装" class="headerlink" title="6.3 @RestControllerの実装"></a>6.3 @RestControllerの実装</h3><ul><li><p>大きく２つ種類がある</p><ul><li>メソッドシグネチャを参照してフロントコントローラが処理を行う「宣言型」の処理</li><li>Controllerクラスのメソッド内に処理を実装する「プログラミング型」の処理</li></ul></li><li><p>MEMO: クライアントへ返却するオブジェクトは共通で作成しているもの（クラス）を使用するのが良いと思った</p></li><li><p>以下、割愛</p></li></ul><h2 id="第7章-Spring-MVC-の応用"><a href="#第7章-Spring-MVC-の応用" class="headerlink" title="第7章　Spring MVC の応用"></a>第7章　Spring MVC の応用</h2><ul><li>SpringMVCの機能を利用したWebアプリケーションの開発方法を学びましたが、</li><li>典型的なWebアプリケーションの開発では、<ul><li>セッションの利用</li><li>ファイルアップロード</li><li>画面やメッセージの国際化</li><li>共通処理の適用</li><li>静的リソースのキャッシュ制御　などへの考慮も必要になる</li><li>非同期処理（SSE(Server-Sent Events)）</li></ul></li></ul><h3 id="7-1-HTTPセッションの利用"><a href="#7-1-HTTPセッションの利用" class="headerlink" title="7.1 HTTPセッションの利用"></a>7.1 HTTPセッションの利用</h3><ul><li>セッション管理する方法３つある<ul><li>セッション属性（@SessionAttributes）の使用</li><li>セッションスコープのBeanの利用</li><li>HttpSessionのAPIの利用</li></ul></li></ul><h4 id="7-1-1-セッション属性（-SessionAttributes）"><a href="#7-1-1-セッション属性（-SessionAttributes）" class="headerlink" title="7.1.1 セッション属性（@SessionAttributes）"></a>7.1.1 セッション属性（@SessionAttributes）</h4><ul><li>１つのController内で扱う複数のリクエスト間でデータを共有する場合に有効な方法<ul><li>入力画面が複数のページで構成される場合や、複雑な画面遷移を伴う場合は<code>@SessionAttributes</code>を使用することを検討</li></ul></li><li>シンプルな画面構成の場合（入力画面→確認画面→完了画面とかの場合）は、HTMLフォームのHiddenで値を持ち回る方法を検討すること</li></ul><h4 id="7-1-2-セッションスコープBean"><a href="#7-1-2-セッションスコープBean" class="headerlink" title="7.1.2 セッションスコープBean"></a>7.1.2 セッションスコープBean</h4><ul><li>複数のControllerをまたぐ画面遷移において、Controller間でデータを共有する場合に有効な方法</li></ul><h3 id="7-2-ファイルアップロード"><a href="#7-2-ファイルアップロード" class="headerlink" title="7.2 ファイルアップロード"></a>7.2 ファイルアップロード</h3><ul><li>SpringMVCでファイルをアップロードする場合は、以下のいずれかの方法を利用する<ul><li>Servlet標準のアップロード機能</li><li>ApacheCommonsFileUploadのアップロード機能</li></ul></li></ul><h4 id="7-2-2-ファイルアップロード機能のセットアップ"><a href="#7-2-2-ファイルアップロード機能のセットアップ" class="headerlink" title="7.2.2 ファイルアップロード機能のセットアップ"></a>7.2.2 ファイルアップロード機能のセットアップ</h4><ul><li>web.xmlに<code>&lt;multipart-config /&gt;</code>を追加するとのこと</li><li>Servlet標準のファイルアップロード機能をデフォルトのまま利用するとアップロードできるファイルのサイズに上限がないため、上限を設けたい場合は、ファイル単位の最大サイズ、アップロード時のリクエスト全体の最大サイズ、一時ファイル出力有無の閾値サイズの３つを指定する必要がある</li><li><p>上限に引っかかると、<code>MultipartException</code>が発生するので、Handlerでハンドリングすること</p></li><li><p>メモ</p><ul><li>SpringMVCのDispatcherServletより前にリクエストパラメータにアクセスする処理があると、MultipartExceptionが発生しない可能性がある</li><li>SpringWEBから提供されているフィルターを利用すると制御できるとのこと<ul><li>TODO: SpringBootだとどのように記載するか確認</li></ul></li></ul></li></ul><h4 id="7-2-3-アップロードデータの取得"><a href="#7-2-3-アップロードデータの取得" class="headerlink" title="7.2.3 アップロードデータの取得"></a>7.2.3 アップロードデータの取得</h4><ul><li>Formクラスの作成<ul><li>普通にFormクラスの作成 <code>MultipartFile</code>型で変数定義する</li></ul></li><li>Viewの作成<ul><li>input type=”file”で作成して送るだけ</li></ul></li><li><p>Controller</p><ul><li>ファイルを取得して永続化操作</li></ul></li><li><p>Validation</p><ul><li>ファイルサイズや、コンテンツタイプ、ファイル名などをチェックする場合は、Validatorを作成してチェック</li></ul></li><li><p>TODO: 実際にアイコン画像などをDBで保持できる永続化ロジックまで書く</p></li></ul><h3 id="7-3-非同期リクエスト"><a href="#7-3-非同期リクエスト" class="headerlink" title="7.3 非同期リクエスト"></a>7.3 非同期リクエスト</h3><h4 id="7-3-1-非同期リクエストの仕組み"><a href="#7-3-1-非同期リクエストの仕組み" class="headerlink" title="7.3.1 非同期リクエストの仕組み"></a>7.3.1 非同期リクエストの仕組み</h4><ul><li><p>非同期実行が終了してからHTTPレスポンスを開始</p><ul><li>勘違いしやすいのが、HTTPレスポンスは非同期実行している処理が終了したあとに行うため、クライアント側から見ると、同期処理と同じ動作になる</li></ul></li><li><p>SpringMVCはこのパターンの非同期処理をサポートするために以下の２つの方法を提供</p><ul><li>SpringMVC管理のスレッドを使用した非同期処理</li><li>SpringMVC管理外のスレッドを使用した非同期処理</li></ul></li><li><p>非同期実行の処理中にHTTPレスポンスを開始</p><ul><li>ロングポーリングを使用した非同期処理</li><li>SSE（Server-Sent Events）に準拠した非同期処理</li></ul></li></ul><h4 id="7-3-2-非同期実行を有効にするための設定"><a href="#7-3-2-非同期実行を有効にするための設定" class="headerlink" title="7.3.2 非同期実行を有効にするための設定"></a>7.3.2 非同期実行を有効にするための設定</h4><ul><li>web.xmlに設定追記</li><li>java configにBean定義追加</li></ul><h4 id="7-3-3-非同期処理の実装"><a href="#7-3-3-非同期処理の実装" class="headerlink" title="7.3.3 非同期処理の実装"></a>7.3.3 非同期処理の実装</h4><ul><li><p>以下の２つの非同期処理の実装方法を紹介</p><ul><li>CompletableFutureを使用した非同期処理</li><li>SseEmitterを使用したPush型の非同期処理</li></ul></li><li><p><code>@Async</code>の利用</p><ul><li>本書で説明する非同期処理は、どちらもSpringMVC管理外のスレッドを使用した非同期処理</li><li>SpringFrameworkは、特定のメソッドを別スレッドで実行する仕組みを提供しており、別スレッドで実行したいメソッドに、<code>org.springframework.scheduling.annotation.Async</code>を付与するだけ</li></ul></li><li><p>MEMO: SpringBootでの利用に参考</p><ul><li><a href="https://qiita.com/mitsuya/items/c21907ab10919111e773" target="_blank" rel="noopener">https://qiita.com/mitsuya/items/c21907ab10919111e773</a></li></ul></li><li><p>CompletableFutureを使用した非同期処理の実装</p><ul><li><code>CoompletableFuture&lt;String&gt;</code>を返却する</li></ul></li><li><p>SseEmitterを使用したPush型の非同期処理の実装</p><ul><li><code>new SseEmitter();</code>でイベント処理を行う<ul><li>具体的な使用方法について説明なし</li></ul></li></ul></li></ul><h4 id="7-3-4-非同期実行の例外ハンドリング"><a href="#7-3-4-非同期実行の例外ハンドリング" class="headerlink" title="7.3.4 非同期実行の例外ハンドリング"></a>7.3.4 非同期実行の例外ハンドリング</h4><ul><li><code>DeferredResult</code>を使用して結果を設定する</li><li>TODO: 結果を非同期で画面に通知する方法確認</li></ul><h4 id="7-3-5-非同期実行に対する共通処理の実装"><a href="#7-3-5-非同期実行に対する共通処理の実装" class="headerlink" title="7.3.5 非同期実行に対する共通処理の実装"></a>7.3.5 非同期実行に対する共通処理の実装</h4><ul><li><p>CallableProcessingInterceptorもしくはDeferredResultProcessingInterceptorのAdopterを実装したクラスを作成</p></li><li><p>現在は、interfaceにデフォルトメソッドが定義できるようになったので、Adopterではなくて、interfaceの方を使用すべきとのことで、<code>@Deprecated</code>になっている</p></li><li><code>CallableProcessingInterceptor</code>インターフェース</li></ul><h3 id="7-4-共通処理の実装"><a href="#7-4-共通処理の実装" class="headerlink" title="7.4 共通処理の実装"></a>7.4 共通処理の実装</h3><p>ControllerのHandlerメソッドの呼び出し前後に共通処理を実行する方法について説明します。</p><h4 id="7-4-1-サーブレットフィルタの利用"><a href="#7-4-1-サーブレットフィルタの利用" class="headerlink" title="7.4.1 サーブレットフィルタの利用"></a>7.4.1 サーブレットフィルタの利用</h4><ul><li>SpringMVCの呼び出し前後に共通する処理を実行するには、<code>javax.servlet.Filter</code>インターフェースの実装クラスを作成する</li><li><p>Filterクラスを直接実装してもよいが、ここではSpringが提供しているサポートクラスを利用する方法を紹介</p></li><li><p>サポートクラス</p><ul><li><code>GenericFilterBean</code>クラス</li><li><code>OncePerRequestFilter</code>クラス</li></ul></li><li><p>DIコンテナで管理しているBeanのインジェクション方法</p><ul><li>サーブレットフィルター内の処理でDIコンテナ管理しているBeanを利用したい場合は、サーブレットフィルタをDIコンテナに登録し、DelegatingFilterProxy経由でサーブレットフィルタの処理を実行する</li><li>DelegatingFilterProxyは、SpringのDIコンテナに登録されているサーブレットフィルターに処理を移譲するサーブレットフィルタクラス</li></ul></li></ul><h4 id="7-4-2-HandlerInterceptorの利用"><a href="#7-4-2-HandlerInterceptorの利用" class="headerlink" title="7.4.2 HandlerInterceptorの利用"></a>7.4.2 HandlerInterceptorの利用</h4><ul><li><p>Controllerでハンドリングする処理に対してだけ共通処理を実行したい場合は、</p><ul><li><code>org.springframework.web.servlet.HndlerInterceptor</code>インターフェースの実装クラスを作成する</li></ul></li><li><p>メソッド</p><ul><li>preHandle：実行前</li><li>postHandle：例外時は呼び出されない</li><li>afterCompletion：実行後</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandler</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">      ModelAndView modelAndView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (log.isInfoEnabled()) &#123;</span><br><span class="line">      HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br><span class="line">      Method method = ((HandlerMethod) handler).getMethod();</span><br><span class="line">      log.info(<span class="string">"[SUCCESS CONTROLLER] &#123;&#125;.&#123;&#125;"</span>, method.getDeclaringClass().getSimpleName(), method.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">    registry.addInterceptor(<span class="keyword">new</span> LoggingInterceptor())</span><br><span class="line">            .addPathPatterns(<span class="string">"/**"</span>)</span><br><span class="line">            .excludePathPatterns(<span class="string">"/resources/**"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-4-3-ControllerAdviceの利用"><a href="#7-4-3-ControllerAdviceの利用" class="headerlink" title="7.4.3 @ControllerAdviceの利用"></a>7.4.3 @ControllerAdviceの利用</h4><ul><li>Controllerクラスには、Handlerメソッドとは別に、Controller専用の特殊なメソッド（<code>@InitBinder</code>メソッド、<code>@ModelAttribute</code>メソッド、<code>@ExceptionHandler</code>メソッド）を実装することができる</li><li>これらのメソッドを複数のControllerクラスで共有するには、<code>@ControllerAdvice</code>を付与したクラスを作成する</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping</span>(<span class="string">"/error"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">handleError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@ExceptionHandler</span>(Throwable.class)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">handleThrowable</span><span class="params">(Throwable exception, Model model)</span> </span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@ExceptionHandler</span>(Exception.class)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">handleException</span><span class="params">(Exception exception, Model model)</span> </span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@ExceptionHandler</span>(IOException.class)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">handleIOException</span><span class="params">(IOException exception, Model model)</span> </span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-4-4-HandlerMethodArgumentResolverの利用"><a href="#7-4-4-HandlerMethodArgumentResolverの利用" class="headerlink" title="7.4.4 HandlerMethodArgumentResolverの利用"></a>7.4.4 HandlerMethodArgumentResolverの利用</h4><ul><li>SpringMVCのデフォルトでサポートされていないオブジェクトをControllerのHandlerメソッドの引数に渡したい場合は、<code>org.springframework.web.method.support.HandlerMethodArgumentResolver</code>インターフェースの実装クラスを作成します。</li><li>あまり利用するシーンがわからないため割愛する</li></ul><h3 id="7-5-静的リソース"><a href="#7-5-静的リソース" class="headerlink" title="7.5 静的リソース"></a>7.5 静的リソース</h3><ul><li>ルートから任意のディレクトリに配置した静的リソースにアクセスできますという説明</li></ul><h4 id="7-5-1-デフォルトサーブレットとDispatcherServletの共存"><a href="#7-5-1-デフォルトサーブレットとDispatcherServletの共存" class="headerlink" title="7.5.1 デフォルトサーブレットとDispatcherServletの共存"></a>7.5.1 デフォルトサーブレットとDispatcherServletの共存</h4><ul><li>Servletの使用では、ルートパス（）にマッピングされたサーブレットのことを「デフォルトサーブレット」と呼び、デフォルトサーブレット経由でWebアプリケーションのドキュメントルート配下のファイルにアクセスすることができる</li><li>SpringMVCアプリケーションでは、DispatcherServletをルートパスにマッピングするスタイルを採用することがよくあるが、DispatcherServletをルートパスにマッピングすると、Webアプリケーションのドキュメントルート配下のファイルにアクセスできなくなってしまいます。</li><li>この動作を変更するには、SpringMVCが提供している「DispatcherServletで受けたリクエストをデフォルトサーブレットへ転送する機能」を有効化する必要がある</li></ul><h4 id="7-5-2-SpringMVC独自の静的リソース解決の仕組み"><a href="#7-5-2-SpringMVC独自の静的リソース解決の仕組み" class="headerlink" title="7.5.2 SpringMVC独自の静的リソース解決の仕組み"></a>7.5.2 SpringMVC独自の静的リソース解決の仕組み</h4><ul><li>HTTPのキャッシュ制御</li><li><p>ResourceResolverとResouceTransformerの利用</p><ul><li>ResourceHttpRequestHandlerには<ul><li>バージョン付き公開パスを使用した静的リソースへのアクセス</li><li>Gzip化された静的リソースへのアクセス</li><li>WebJars内の静的リソースのバージョン番号の隠蔽<ul><li>を行う機能がある</li></ul></li></ul></li></ul></li><li><p>ResourceResolverインターフェース</p><ul><li>静的リソースにアクセスするための公開パス</li><li>サーバー上の物理的な静的リソースを相互に解決するためのメソッドを提供</li></ul></li><li><p>ResourceTransformerインターフェース</p><ul><li>静的リソースのコンテンツデータを書き換えるためのメソッドを提供</li></ul></li><li><p>バージョン付きの公開パスを使用した静的リソースへのアクセス</p></li><li><p>Thymeleafでのアクセス方法について確認する</p><ul><li>ここで紹介されていた<a href="https://ksoichiro.blogspot.com/2015/04/spring-boot_14.html" target="_blank" rel="noopener">https://ksoichiro.blogspot.com/2015/04/spring-boot_14.html</a></li><li><code>th:href=&quot;@{/css/main.css}&quot;</code>などと記載する</li></ul></li></ul><h3 id="7-6-国際化"><a href="#7-6-国際化" class="headerlink" title="7.6 国際化"></a>7.6 国際化</h3><h4 id="7-6-1-ロケールの解決"><a href="#7-6-1-ロケールの解決" class="headerlink" title="7.6.1 ロケールの解決"></a>7.6.1 ロケールの解決</h4><ul><li><p>アプリケーション内で扱うロケール解決には、<code>org.springframework.web.servlet.LocaleResolver</code>インターフェースを使用する</p></li><li><p>SpringMVCは、ロケールの保存場所に応じて以下の実装クラスを提供しており、デフォルトではAcceptHeaderLocaleResolverが有効になっている</p></li><li><p>提供されているLocaleResolverの実装クラス</p><ul><li>AcceptHeaderLocaleResolver</li><li>SessionLocaleResolver</li><li>CookieLocaleResolver</li><li>FixedLocaleResolver</li></ul></li><li><p>クライアントからロケールの指定がない場合、デフォルトロケールが利用され、</p><ul><li>LocaleResolverに指定したデフォルトロケール</li><li>JVMに指定したロケール</li><li>OSに指定したロケール<ul><li>の順番で解決されます。</li></ul></li></ul></li></ul><h4 id="7-6-2-ロケールの利用"><a href="#7-6-2-ロケールの利用" class="headerlink" title="7.6.2 ロケールの利用"></a>7.6.2 ロケールの利用</h4><ul><li>VIEWからロケールにアクセスするときはSpringのタグを使用する</li><li>Handlerメソッドからロケールにアクセスするときは引数にLocaleを指定する</li><li>Handler以外の場所からロケールにアクセスするときは、RequestContextUtilsのgetLocaleメソッドを使用する</li></ul><h4 id="7-6-3-UIを使用したロケールの切り替え"><a href="#7-6-3-UIを使用したロケールの切り替え" class="headerlink" title="7.6.3 UIを使用したロケールの切り替え"></a>7.6.3 UIを使用したロケールの切り替え</h4><ul><li>画面などのUIを使用してロケールを切り替える方法について説明</li><li><p>ロケールの切り替えは、<code>org.springframework.web.servlet.i18n.LocaleChangeInterceptor</code>を利用することで簡単に行うことができる</p></li><li><p>LocaleResolverのBean定義</p></li><li><p>LocaleChangeInterceptorのBean定義</p></li><li><p>ロケール切り替え用の画面要素の表示</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"?locale=en"</span>&gt;</span>English<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"?locale=ja"</span>&gt;</span>Japanese<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>このリンクをクリクすると、LocaleChangeInterceptorが呼び出され、<br>リクエストパラメータで指定されたロケールがSpringMVCアプリケーションに反映される</p><h2 id="第8章-Spring-Test"><a href="#第8章-Spring-Test" class="headerlink" title="第8章　Spring Test"></a>第8章　Spring Test</h2><ul><li><p>本章では、SpringFrameworkが提供するテスト支援モジュールを利用して、Springアプリケーションに対してテストを行う方法について解説していく</p></li><li><p>紹介を行うテスト</p><ul><li>DIコンテナに登録したBeanへのテスト</li><li>データベースアクセスを伴う処理へのテスト</li><li>SpringMVC上で動くControllerへのテスト</li></ul></li><li><p>第９章では、SpringSecurityの機能を利用した処理へのテストを紹介</p></li></ul><h3 id="8-1-Spring-Testとは"><a href="#8-1-Spring-Testとは" class="headerlink" title="8.1 Spring Testとは"></a>8.1 Spring Testとは</h3><ul><li><p>Spring Testとは</p><ul><li>Spring Framework上で動かすために作成したクラスのテストを支援するモジュール</li></ul></li><li><p>単体テスト</p><ul><li>テスト対象のクラス内で実装しているロジックのみをテスト</li><li>単体テストを行う際には、テスト対象のクラスの中で依存している他のコンポーネントはモックやスタブを使用し、実行結果が他のコンポーネントの実装内容に左右されないようにする</li></ul></li><li><p>結合テスト</p><ul><li>基本的にモックやスタブは使わず、プロダクション環境で使用するクラスを結合してテストを行います。</li><li>ポイントは、システムやアプリケーション全体が正しく動作するかを検証するのではなく、開発者が作成したクラスがSpringのフレームワーク上で正しく動作するかをテストするという点</li></ul></li><li><p>提供されている機能</p><ul><li>JUnitやTestNGといったテスティングフレームワーク上でのSpringのDIコンテナを動かす機能</li><li>トランザクション制御をテスト向けに最適化する機能</li><li>アプリケーションサーバーを使わずにSpringMVCの動作を再現する機能</li><li>テストデータをセットアップするためのSQLを実行する機能</li><li>RestTemplateを使用したHTTP通信に対してモックレスポンスを返却する機能</li></ul></li></ul><h3 id="8-2-DIコンテナ管理のBeanに対するテスト"><a href="#8-2-DIコンテナ管理のBeanに対するテスト" class="headerlink" title="8.2 DIコンテナ管理のBeanに対するテスト"></a>8.2 DIコンテナ管理のBeanに対するテスト</h3><ul><li>junitを使用する前提で説明</li></ul><h4 id="8-2-1-Beanの単体テスト"><a href="#8-2-1-Beanの単体テスト" class="headerlink" title="8.2.1 Beanの単体テスト"></a>8.2.1 Beanの単体テスト</h4><ul><li><p>Serviceクラスをテスト</p></li><li><p>依存しているコンポーネントはできるだけモック化することを検討する</p><ul><li>外部ファイル参照サービスやDBアクセスなど</li></ul></li></ul><h4 id="8-2-2-DIコンテナ内のBeanに対する結合テスト"><a href="#8-2-2-DIコンテナ内のBeanに対する結合テスト" class="headerlink" title="8.2.2 DIコンテナ内のBeanに対する結合テスト"></a>8.2.2 DIコンテナ内のBeanに対する結合テスト</h4><ul><li>Springの機能を使用して、DIコンテナ内のリソースを取得してテストを行う</li><li>単体テストは本当にクラス単体の観点なのに対して、結合テストはプロジェクト内のリソースを結合したテストとみなしている</li></ul><h4 id="8-2-3-Spring-Testcontext-Framework"><a href="#8-2-3-Spring-Testcontext-Framework" class="headerlink" title="8.2.3 Spring Testcontext Framework"></a>8.2.3 Spring Testcontext Framework</h4><ul><li>他のランナーとSpringを併用したい場合は、<code>@ClassRule</code>と<code>@Rule</code>を使用すれば実現できるという説明</li><li>TODO: 使用するランナーによって何が違うのかを後で確認する必要ある</li></ul><h4 id="8-2-4-DIコンテナのコンフィギュレーション"><a href="#8-2-4-DIコンテナのコンフィギュレーション" class="headerlink" title="8.2.4 DIコンテナのコンフィギュレーション"></a>8.2.4 DIコンテナのコンフィギュレーション</h4><p>DIコンテナを作成するには、<br><a href="mailto:`@org.springframework.test.context.ContextConfiguration" target="_blank" rel="noopener">`@org.springframework.test.context.ContextConfiguration</a>`をテストクラスケースに付与する</p><ul><li><p>デフォルトのBean定義ファ入りう</p></li><li><p>Webアプリケーション向けのDIコンテナのコンフィギュレーション</p><ul><li><code>@WebApplicationConfiguration</code>付与について説明<ul><li>Webアプリケーション向けのDIコンテナに加えて、</li><li>ServletAPIに依存する各種モックオブジェクトなどをテストケースクラスにインジェクションできる</li></ul></li></ul></li></ul><h4 id="8-2-5-DIコンテナのライフサイクル制御"><a href="#8-2-5-DIコンテナのライフサイクル制御" class="headerlink" title="8.2.5 DIコンテナのライフサイクル制御"></a>8.2.5 DIコンテナのライフサイクル制御</h4><ul><li><p>Spring TestContext Framework上に生成されたDIコンテナは、テスト実行時のJavaVMが終了するまでキャッシュされ、必要に応じてテストケース間で共有される仕組みになっています。</p></li><li><p>DIコンテナのキャッシュ</p><ul><li>デフォルトの動作では、同一テストケースクラスのテストメソッドで同じDIコンテナが使われる</li><li>さらにテストケースクラスが別の場合でも、<code>@ContextConfiguration</code>などに指定した属性値が同じであれば、キャッシュ済みのDIコンテナが利用される</li></ul></li><li><p>DIコンテナの破棄</p><ul><li>割愛…TODO: 実際のテストケースの組み方について調査する必要あり</li></ul></li></ul><h4 id="8-2-6-プロファイルの指定"><a href="#8-2-6-プロファイルの指定" class="headerlink" title="8.2.6 プロファイルの指定"></a>8.2.6 プロファイルの指定</h4><ul><li>Springのプロファイル機能を使用しているアプリケーションに対してテストを行う場合は、<a href="mailto:`@org.springframework.test.context.ActiveProfiles" target="_blank" rel="noopener">`@org.springframework.test.context.ActiveProfiles</a>`を使う</li></ul><h4 id="8-2-7-テスト用のプロパティ値の指定"><a href="#8-2-7-テスト用のプロパティ値の指定" class="headerlink" title="8.2.7 テスト用のプロパティ値の指定"></a>8.2.7 テスト用のプロパティ値の指定</h4><ul><li><p>テスト用のプロパティ値を設定できる</p><ul><li><a href="mailto:`@org.springframework.test.context.TestPropertySource" target="_blank" rel="noopener">`@org.springframework.test.context.TestPropertySource</a>`を使う</li></ul></li><li><p>プロパティ値の指定には２つの方法がある</p><ul><li>アノテーションに直接指定する</li><li>プロパティファイルに指定する</li></ul></li></ul><h3 id="8-3-データベースアクセスを伴う処理のテスト"><a href="#8-3-データベースアクセスを伴う処理のテスト" class="headerlink" title="8.3 データベースアクセスを伴う処理のテスト"></a>8.3 データベースアクセスを伴う処理のテスト</h3><ul><li>データベースへアクセスするBeanに対するテスト方法について説明</li><li>データベースにアクセスするBeanに対してテストを行う場合、以下の作業が必要になる<ul><li>テスト用のデータソースの設定</li><li>テストデータのセットアップ</li><li>テストケース用のトランザクション制御</li><li>テーブルの中身の検証</li></ul></li></ul><h4 id="8-3-1-テスト用のデータソースの設定"><a href="#8-3-1-テスト用のデータソースの設定" class="headerlink" title="8.3.1 テスト用のデータソースの設定"></a>8.3.1 テスト用のデータソースの設定</h4><ul><li>Test用のConfigクラスを作成して、既存のコンフィグクラスを上書きする説明</li></ul><h4 id="8-3-2-テストデータのセットアップ"><a href="#8-3-2-テストデータのセットアップ" class="headerlink" title="8.3.2 テストデータのセットアップ"></a>8.3.2 テストデータのセットアップ</h4><ul><li><code>@Sql</code>を使用すると、テストケース・メソッドの呼び出し前に任意のSLQを実行できる</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sqlを付与することで、テストメソッド実行前に任意のSQL文を実行することができる</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Sql</span>(&#123; <span class="string">"/account-delete.sql"</span>, <span class="string">"/account-insert-data.sql"</span> &#125;)</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">testFindOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Account account = accountRepositry.findOne(<span class="string">"001"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>メモ<ul><li><code>@Sql</code>にはJavaSE8で追加された<code>@Repeatable</code>が付与されているため、JavaSE8以降を使う場合は同じ箇所に複数指定できる<ul><li>JavaSE7以前のJavaでも、<a href="mailto:`@org.springframework.test.context.jdbc.SqlGroup" target="_blank" rel="noopener">`@org.springframework.test.context.jdbc.SqlGroup</a>`を使うことで、複数のSQLを指定できる</li></ul></li></ul></li></ul><h4 id="8-3-3-テストケース用のトランザクション制御"><a href="#8-3-3-テストケース用のトランザクション制御" class="headerlink" title="8.3.3 テストケース用のトランザクション制御"></a>8.3.3 テストケース用のトランザクション制御</h4><ul><li>デフォルトではテストデータをセットアップする際に使用するトランザクションと、</li><li>テスト対象のデータアクセス処理で使用するトランザクションは別々になってしまう</li><li>テストが途中で失敗して、レコードが更新されてしまったり、データの状態が変わってしまうため注意が必要</li><li>このような事故を防ぐには、JUnit専用のデータベースを用意しておくと確実</li><li>ローカルなんかも優位だと思う</li><li><p>あるいは、SpringTestが提供しているテスト用のトランザクション制御の仕組みを利用して防ぐこともできる</p></li><li><p>トランザクション境界の移動</p><ul><li>SpringTestでは、、JUnit実行時のトランザクション境界を、テストケースメソッドの呼び出し前に移動する仕組みを提供している。</li><li>この仕組を利用すると、<code>@Sql</code>で指定したSQLファイルの実行とテストを同一のトランザクション内で行うことができる</li><li><code>@Transactional</code>をクラス、メソッドに指定する</li></ul></li><li><p>トランザクション境界でのロールバック/コミットの制御</p><ul><li>処理が完了したあと、ロールバックするのではなくコミットしたい場合、<code>@Commit</code>を付与すれば実現できる</li></ul></li><li><p>永続コンテキストをフラッシュ</p><ul><li>JPAやHibernateがEntityへの更新操作を永続コンテキストと呼ばれるインメモリ領域に蓄積しておき、トランザクションのコミット時にSQLを発行する仕組みになっているため、明示的にSQLが発行されるようにフラッシュする必要がある</li></ul></li></ul><h4 id="8-3-4-テーブルの中身の検証"><a href="#8-3-4-テーブルの中身の検証" class="headerlink" title="8.3.4 テーブルの中身の検証"></a>8.3.4 テーブルの中身の検証</h4><ul><li>JdbcTemplateを使用して検証する</li><li>DIコンテナに入っている同じオブジェクトを使用すること</li></ul><h3 id="8-4-Spring-MVC-のテスト"><a href="#8-4-Spring-MVC-のテスト" class="headerlink" title="8.4 Spring MVC のテスト"></a>8.4 Spring MVC のテスト</h3><ul><li>SpringMVC上で動くControllerに対するテスト方法について説明</li><li>Controllerに対するテストの話をするときにいつも出てくる話題がある<ul><li>→「Controllerに対する単体テストは必要か？」という話題</li></ul></li><li>Controllerの主な役割は、<ul><li>リクエストマッピング</li><li>入力チェック</li><li>リクエストデータの取得</li><li>ビジネスロジックの呼び出し</li><li>遷移先の制御</li></ul></li><li><p>これらは、SpringMVCのフレームワークと結合しないと妥当性を検証することができないので、単体テストではなく、結合テストとして行ったほうがよい</p></li><li><p>では、SpringMVCのフレームワーク機能と結合した状態でControllerをテストするにはどうすればよいのでしょうか？</p></li><li>最もオーソドックスな選択肢は、Webアプリケーションをアプリケーションサーバーにデプロイし、E2E（End to End）テストとして実施する方法</li><li>E2Eテストとして実施すると、Viewが生成したレスポンスデータの妥当性を検証できるのがメリット</li><li><p>一方、以下のようなデメリットがある</p><ul><li>アプリケーションサーバーやデータベースの起動が必須となる</li><li>トランザクションがコミットされるため、テスト実施前の状態に戻すことができない</li><li>回帰テストを実行するために、Seleniumなどを利用したテストケースの実装が必要になる</li><li>Seleniumを使うと、テストの実行時間が長くなる</li></ul></li><li><p>SpringTestはE2Eテストのデメリットを解消しつつ、SpringMVCのフレームワーク機能と結合した状態でControllerをテストするためのプラットフォームとして、<code>org.springframework.test.web.servlet.MockMvc</code>というクラスを提供している</p></li></ul><h4 id="8-4-1-MockMvcとは"><a href="#8-4-1-MockMvcとは" class="headerlink" title="8.4.1 MockMvcとは"></a>8.4.1 MockMvcとは</h4><ul><li><p>アプリケーションサーバー上にデプロイせず、SpringMVCの動作を再現する仕組みを提供するクラス</p></li><li><p>流れ</p><ol><li>テストケース・メソッドは、DispatcherServletにリクエストするデータ（リクエストパスやリクエストパラメータなど）をセットアップする</li><li>MockMvcは、DispatcherServletに対して擬似的なリクエストを行う。実際に使われるDispatcherServletは、テスト用に拡張されている、<code>org.springframework.test.web.servlet.TestDipacherSevlet</code>となる</li><li>DispatcherServletは、リクエスト内容に一致するHandlerのメソッドを呼び出す</li><li>テストケースメソッドは、MockMvcが返却する実行結果を受け取り、実行結果の妥当性を検証する</li></ol></li><li><p>動作モードには２つある</p><ul><li>ユーザー指定のDIコンテナと連携するモード</li><li>スタンドアロンモード</li></ul></li><li><p>SpringMVCのコンフィギュレーションも含めてテストしたい場合、ユーザー指定のDIコンテナと連携するモードを利用すること</p></li><li><p>メモ</p><ul><li>本書では扱わないが、SpringTestは、MockMvcとHtmlUnitを連携する機能も提供している</li><li>HtmlUnitと連携することで、テンプレートエンジンが生成したHTMLを検証することができる</li><li>さらに、SeleniumWebDriverやGebと連携すると、Page Object Patternを活用した可読性および再利用性の高いテストケースを記載することも可能</li><li>TODO: あとで確認してみる</li></ul></li></ul><h4 id="8-4-2-MockMvcのセットアップ"><a href="#8-4-2-MockMvcのセットアップ" class="headerlink" title="8.4.2 MockMvcのセットアップ"></a>8.4.2 MockMvcのセットアップ</h4><ul><li><p>ユーザー指定のDIコンテナと連携するモード</p></li><li><p>スタンドアロンモード</p><ul><li>SpringMVCのコンフィギュレーションはSpringTest側が行い、SpringTestが生成したDIコンテナを使用してSpringMVCの動作を再現</li></ul></li><li><p>サーブレットフィルタの追加</p><ul><li>MockMvcには、サーブレットフィルタを追加することができる</li></ul></li><li><p>staticメソッドのインポート</p><ul><li>テストを書く前に、MockMvcを使用したテストをサポートしてくれるstaticメソッドをインポートします。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// よく使用するstaticメソッド</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultHandlers.*;</span><br></pre></td></tr></table></figure><h4 id="8-4-3-テストの実行"><a href="#8-4-3-テストの実行" class="headerlink" title="8.4.3 テストの実行"></a>8.4.3 テストの実行</h4><ul><li>テストを実行する際は、Controllerを呼び出すために必要なリクエストデータをセットアップし、MockMvcにリクエストの実行依頼を行います。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHome</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  mockMvc.perform(get(<span class="string">"/"</span>))</span><br><span class="line">      .andExpect(status().isOk())</span><br><span class="line">      .andExpect(forwardedUrl(<span class="string">"/WEB-INF/index.jsp"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-4-4-リクエストデータのセットアップ"><a href="#8-4-4-リクエストデータのセットアップ" class="headerlink" title="8.4.4 リクエストデータのセットアップ"></a>8.4.4 リクエストデータのセットアップ</h4><ul><li>リクエストデータのセットアップは、<ul><li><code>org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder</code></li><li><code>org.springframework.test.web.servlet.request.MockMultipartHttpServletRequestBuilder</code></li><li>のファクトリメソッドを使用して行います。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBooks</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  mockMvc.perform(get(<span class="string">"/books"</span>)</span><br><span class="line">      .param(<span class="string">"name"</span>, <span class="string">"Spring"</span>)</span><br><span class="line">      .accept(MediaType.APPLICATION_JSON)</span><br><span class="line">      .header(<span class="string">"X-Track-Id"</span>, UUID.randomUUID().toString()))</span><br><span class="line">      .andExpect(status().isOk());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-4-5-実行結果の検証"><a href="#8-4-5-実行結果の検証" class="headerlink" title="8.4.5 実行結果の検証"></a>8.4.5 実行結果の検証</h4><ul><li><p>MockMvcResultMathcersの主なメソッド</p><ul><li>status</li><li>header</li><li>cookie</li><li>content</li><li>view</li><li>forwardedUrl</li><li>redirectedUrl</li><li>model</li><li>flash</li><li>request</li></ul></li><li><p>メモ</p><ul><li>ResultMatcherでサポートされていない検証を行いたい場合は、以下のいずれかの方法で検証ロジックを実装する<ul><li>独自のResultMatcherを作成する</li><li>ResultActionsのandReturnメソッドを呼び出して、MvcResultを取得し、テストケース内で検証ロジックを実装する</li></ul></li><li>MEMO: 検証ロジックを複数のテストケースで共有したい場合は、ResultMatcherを作成すること</li></ul></li></ul><h4 id="8-4-6-実行結果の出力"><a href="#8-4-6-実行結果の出力" class="headerlink" title="8.4.6 実行結果の出力"></a>8.4.6 実行結果の出力</h4><ul><li>実行結果をログなどに出力する場合は、<code>org.springframework.test.web.servlet.ResultActions</code>の<code>andDo</code>メソッドを使用する</li><li>andDoメソッドの引数には、実行結果に対して、任意の処理を行う<code>org.springframewok.test.web.servlet.ResultHandler</code>を指定する</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(get(<span class="string">"/books"</span>))</span><br><span class="line">    .andExpect(status().isOk())</span><br><span class="line">    .andDo(log());</span><br></pre></td></tr></table></figure><ul><li>log: 実行結果をデバッグレベルでログ出力する</li><li>pring: 実行結果を任意の出力先に出力する</li></ul><h2 id="第9章-Spring-Security"><a href="#第9章-Spring-Security" class="headerlink" title="第9章　Spring Security"></a>第9章　Spring Security</h2><ul><li>SpringSecurityの「セットアップ方法」と「アーキテクチャ」について説明したあと、</li><li>セキュリティ対策の基本となる<ul><li>「認証」と「認可」、</li></ul></li><li><p>さらにセキュリティを強化するために必要となる</p><ul><li>「CSRF対策」</li><li>「セッション管理」</li><li>「ブラウザのセキュリティ対策機能との連携（セキュリティヘッダーの出力）」について説明</li></ul></li><li><p>最後に、SpringSecurityが提供する支援モジュールを使用して、セキュリティ対策が正しく適用されているかをテストする方法についても紹介</p></li></ul><h3 id="9-1-SpringSecurityとは"><a href="#9-1-SpringSecurityとは" class="headerlink" title="9.1 SpringSecurityとは"></a>9.1 SpringSecurityとは</h3><ul><li>アプリケーションにセキュリティ対策機能を実装する際に使用するフレームワーク</li></ul><h4 id="9-1-1-SpringSecurityの特徴"><a href="#9-1-1-SpringSecurityの特徴" class="headerlink" title="9.1.1 SpringSecurityの特徴"></a>9.1.1 SpringSecurityの特徴</h4><ul><li>豊富なオプションの提供<ul><li>SpringSecurityのデフォルト実装の動作をカスタマイズするためのオプションが豊富に提供されている</li><li>このため、デフォルトの動作がセキュリティ要件に合致しない場合であっても、オプションの値を変更することで要件にあった動作に変更できるケースがある</li></ul></li><li>豊富な拡張ポイントの提供<ul><li>SpringSecurityは動作をカスタマイズするための拡張ポイントを豊富に提供します。</li><li>SpringSecurityのデフォルト実装を使って要件を満たせない場合は、拡張クラスを作成することで要件にあった動作にカスタマイズすることができます。</li></ul></li></ul><h4 id="9-1-2-基本機能"><a href="#9-1-2-基本機能" class="headerlink" title="9.1.2 基本機能"></a>9.1.2 基本機能</h4><ul><li><p>セキュリティ対策の基本機能として「認証機能」と「認可機能」の２つを提供しています。</p></li><li><p>認証機能：アプリケーションを利用するユーザーの正当性を確認する機能を提供する</p></li><li>認可機能：アプリケーションが提供するリソースや処理に対するアクセスを制御する機能を提供する</li></ul><h4 id="9-1-3-強化機能"><a href="#9-1-3-強化機能" class="headerlink" title="9.1.3 強化機能"></a>9.1.3 強化機能</h4><ul><li>SpringSecurityでは認証と認可という基本機能に加え、</li><li><p>Webアプリケーションのセキュリティを強化するための機能をいくつか提供している</p></li><li><p>セキュリティ対策の強化機能</p><ul><li>セッション管理機能</li><li>CSRF対策機能</li><li>ブラウザのセキュリティ対策機能との連携機能</li><li>※他にある！TODO: 他のセキュリティ機能も確認しておく</li></ul></li></ul><h3 id="9-2-Spring-Securityのセットアップ"><a href="#9-2-Spring-Securityのセットアップ" class="headerlink" title="9.2 Spring Securityのセットアップ"></a>9.2 Spring Securityのセットアップ</h3><h4 id="9-2-1-ライブラリのセットアップ"><a href="#9-2-1-ライブラリのセットアップ" class="headerlink" title="9.2.1 ライブラリのセットアップ"></a>9.2.1 ライブラリのセットアップ</h4><ul><li>pom.xmlに設定を追加する手順の説明</li></ul><h4 id="9-2-2-SpringSecurityのBean定義"><a href="#9-2-2-SpringSecurityのBean定義" class="headerlink" title="9.2.2 SpringSecurityのBean定義"></a>9.2.2 SpringSecurityのBean定義</h4><p>SpringSecurityのコンポーネントをBean定義します</p><ul><li>コンフィギュレーションクラスの作成</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SpringSecurityが提供しているコンフィギュレーションクラスがインポートされ、SpringSecurityを利用するために必要となるコンポーネントのBean定義が自動で行われる仕組み</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123; <span class="comment">// 継承すると、デフォルトで適用されるBean定義を簡単にカスタマイズすることができる</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// セキュリティ対策が不要なリソースがある場合、SpringSecurityの処理を適用しないようにする</span></span><br><span class="line">    web.ignoring().antMatchers(<span class="string">"/resources/**"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>web.xmlへの設定追加方法説明<ul><li>TODO: SpringBootだと必要？</li></ul></li></ul><h4 id="9-2-3-サーブレットフィルタの設定"><a href="#9-2-3-サーブレットフィルタの設定" class="headerlink" title="9.2.3 サーブレットフィルタの設定"></a>9.2.3 サーブレットフィルタの設定</h4><ul><li><p>最後に、SpringSecurityが提供しているサーブレットフィルタクラス（FilterChainProxy）をサーブレットコンテナに登録する</p></li><li><p>TODO: SpringBootだとConfigでフィルター追加する</p><ul><li><a href="https://qiita.com/R-STYLE/items/61a3b6a678cb0ff00edf" target="_blank" rel="noopener">https://qiita.com/R-STYLE/items/61a3b6a678cb0ff00edf</a></li><li><a href="https://qiita.com/opengl-8080/items/c105152c9ca48509bd0c" target="_blank" rel="noopener">https://qiita.com/opengl-8080/items/c105152c9ca48509bd0c</a></li></ul></li><li><p>メモ</p><ul><li>Sevlet3.0以降のサーブレットコンテナでは、サーブレットコンテナの初期化処理をJavaのコードで行うことができる</li><li>SpringSecurityでは、サーブレットコンテナの初期化処理をJavaを使って行うためのサポートクラス説いて、</li><li><code>AbstractSecurityWebApplicationInitializer</code>という抽象クラスを提供しています</li><li>以下の初期化処理を自動で行ってくれる<ul><li>ContextLoaderListenerをサーブレットコンテナに登録する処理</li><li>SpringSecurityのサーブレットフィルタクラスをサーブレットコンテナに登録する処理</li><li>参考：<a href="https://qiita.com/opengl-8080/items/c105152c9ca48509bd0c" target="_blank" rel="noopener">https://qiita.com/opengl-8080/items/c105152c9ca48509bd0c</a></li></ul></li></ul></li></ul><h3 id="9-3-Spring-Security-のアーキテクチャ"><a href="#9-3-Spring-Security-のアーキテクチャ" class="headerlink" title="9.3 Spring Security のアーキテクチャ"></a>9.3 Spring Security のアーキテクチャ</h3><ul><li><p>各機能の詳細な説明を行う前に、SpringSecurityのアーキテクチャ概要とSpringSecurityを構成する主要なコンポーネントの役割を見ていく</p></li><li><p>メモ</p><ul><li>ここで紹介する内容は、SpringSecurityが提供するデフォルトの動作をそのまま利用する場合や、</li><li>SpringSecurityのコンフィギュレーションをサポートする仕組みを利用する場合は、開発者が直接意識する必要ない</li><li>そのため、まず各機能の使い方を知りたい場合は、本説を読み飛ばしてOK</li><li>カスタマイズする際に必要になってくるので、アーキテクトを目指す方は一読しておくことをおすすめします。</li></ul></li></ul><h4 id="9-3-1-Spring-Securityのモジュール構成"><a href="#9-3-1-Spring-Securityのモジュール構成" class="headerlink" title="9.3.1 Spring Securityのモジュール構成"></a>9.3.1 Spring Securityのモジュール構成</h4><ul><li>提供しているモジュールを紹介</li><li><p>コンポーネントの役割などに応じてモジュール分割されており、標準的なWebアプリケーションに対してセキュリティ対策を講じる際に必要となるモジュールは以下の４つになる</p><ul><li><code>spring-security-core</code>: 認証と認可機能を実現するためのコアなコンポーネントが格納されている</li><li><code>spring-security-web</code>: Webアプリケーションのセキュリティ対策を実現するためのコンポーネントが格納されている</li><li><code>spring-security-config</code>: 各モジュールから提供されているコンポーネントのセットアップをサポートするためのコンポーネント（Java ConfigをサポートするクラスやXMLネームスペースを解析するクラスなど）が格納されている</li><li><code>spring-security-taglibs</code>: 認証情報や認可機能にアクセスするためのJSPタグライブラリが格納されている</li></ul></li><li><p>本書で使い方を紹介しないが、上記以外にも以下のようなモジュールがある</p><ul><li>一般的に利用される認証方法（LDAP、OpenID、CASなど）をサポートするためのモジュール</li><li>ACL（AccessControlList）を使用したドメインオブジェクトの認可制御を行うモジュール</li><li>SpringのWebSocket機能に対してセキュリティ対策を追加するためのモジュール</li><li>SpringSecurityの機能を用いる処理に対するテストを支援するためのモジュール</li></ul></li><li><p>メモ</p><ul><li>SpringSecurityのモジュールではないが、OAuth2.0の仕組みを使用してAPIの認可を実現するためのモジュール（spring-security-oauth2）などが姉妹ライブラリとして提供されている</li></ul></li></ul><h4 id="9-3-2-フレームワークのアーキテクチャ"><a href="#9-3-2-フレームワークのアーキテクチャ" class="headerlink" title="9.3.2 フレームワークのアーキテクチャ"></a>9.3.2 フレームワークのアーキテクチャ</h4><ul><li><p>処理の流れ</p><ol><li>クライアントはWebアプリケーションに対してリクエストを送る</li><li>SpringSecurityのFilterChainProxyクラスがリクエストを受け取り、HttpFirewallインターフェースのメソッドを呼び出して、HttpServletRequestとHttpServletResponseに対してファイアウォール機能を組み込む</li><li>FilterChainProxyクラスはSecurityFilterChainに設定されているセキュリティ対策用のSecurityFilterクラスに処理を移譲する</li><li>SecurityFilterChainには複数のSecurityFilterが設定されており、SecurityFilterの処理が正常に終了すると皇族のSecurityFilterが呼び出される</li><li>最後のSecurityFilterの処理が正常に終了した場合、後続処理を呼び出し、Webアプリケーション内のリソースへアクセスする</li><li>FilterChainProxyクラスは、Webアプリケーションから返却されたリソースをクライアントに返却する</li></ol></li><li><p>FilterChainProxy</p><ul><li>FilterChainProxyクラスは、フレームワーク処理のエントリーポイントとなるサーブレットフィルタクラス</li><li>このクラスはフレームワーク処理の全体の流れを制御し、具体的なセキュリティ対策処理はSecurityFilterに移譲するスタイルとなっている</li></ul></li><li>HttpFirewall<ul><li>HttpFirewallインターフェースは、HttpServletRequestとHttpServletResponseに対して、ファイアウォール機能を組み込むためのインターフェースです。デフォルトでは、DefaultHttpFirewallクラスが使用され、ディレクトリトラバーサル攻撃や、不正なリダイレクト先の指定によるHTTPレスポンス分割攻撃に対するチェックなどが実装されている</li></ul></li><li><p>SecurityFilterChain</p><ul><li>SecurityFilterChainインターフェースは、FilterChainProxyが受け取ったリクエストに対して適用する「SecurityFilterリスト」を管理するためのインターフェース</li><li>デフォルトではDefaultSecurityFilterChainクラスが使用され、以下のようなBean定義を行うと、指定したパスパターンごとに異なるセキュリティ対策が適用できます。</li></ul></li><li><p>Security Filter</p><ul><li>SecurityFilterクラスは、フレームワーク機能やセキュリティ対策機能を提供するサーブレットフィルタクラスです。</li><li>SpringSecurityは、複数のSecurityFilterを連鎖させることで、Webアプリケーションのセキュリティ対策を行う仕組みになっています。</li></ul></li><li><p>コアなSecurityFilter</p><ul><li>SecurityContextPersistenceFilter</li><li>UsernamePasswordAuthenticationFilter</li><li>LogoutFilter</li><li>FilterSecurityInterceptor</li><li>ExceptionTranslationFilter</li></ul></li></ul><h3 id="9-4-認証処理の適用"><a href="#9-4-認証処理の適用" class="headerlink" title="9.4 認証処理の適用"></a>9.4 認証処理の適用</h3><ul><li>認証処理は、アプリケーションを利用するユーザーの正当性を確認するための処理</li><li>最も標準的な方法はアプリケーションを使用できるユーザーをデータストアに登録しておいて、利用者が入力した認証情報と照合する方法</li><li><p>利用者に認証情報を入力してもらう方式もいくつかあり、</p><ul><li>HTMLの入力フォームを使う方式</li><li>RFCで定められているHTTP標準の認証方式（BASIC認証やDigest認証など）を利用するのが一般的</li><li>OpenID認証、シングルサインオン認証などの認証方式を利用するケースもある</li></ul></li><li><p>本節では、HTMLの入力フォームで入力した認証情報とリレーショナルデータベースに格納されているユーザー情報を照合して認証処理を行う実装例を紹介しながら、SpringSecurityの認証機能を解説</p></li></ul><h4 id="9-4-1-認証処理の仕組み"><a href="#9-4-1-認証処理の仕組み" class="headerlink" title="9.4.1 認証処理の仕組み"></a>9.4.1 認証処理の仕組み</h4><ul><li><p>認証処理の流れ</p><ol><li>クライントは認証処理を行うパスに対して資格情報（ユーザー名とパスワード）を指定してリクエストを送信する</li><li>Authentication Filterはリクエストから資格情報を取得し、AuthenticationManagerクラスの認証処理を呼び出す</li><li>ProviderManager（デフォルトで使用されるAuthenticationManagerの実装クラス）は、実際の認証処理をAuthenticationProviderインターフェースの実装クラスに移譲する</li></ol></li><li><p>メモ</p><ul><li>Authentication FilterとAuthenticationProviderの実装クラスは複数用意されており、要件に合わせて使用するクラスを選択する仕組みになっている</li><li>TODO: 選択できるクラスについて確認</li></ul></li><li><p>Authentication Filter</p><ul><li>認証方式に対する実装を提供するサーブレットフィルタ</li><li>本書では、フォーム認証用のサーブレットフィルタクラス（UsernamePasswordAuthenticationFilter）をシヨすうる前提で説明しますが、SpringSecurityはBasic認証、Digest認証、Remember Me 認証用のサーブレットフィルタクラスも提供しています</li></ul></li><li><p>AuthenticationManager</p><ul><li>認証処理を実行するためのインターフェース</li><li>SpringSecurityが提供するデフォルトの実装（ProviderManager）では、実際の認証処理はAuthenticationProviderに移譲し、AuthenticationProviderで行われた認証処理結果をハンドリングする仕組みになっています。</li></ul></li><li><p>AuthenticationProvider</p><ul><li>認証処理の実装をて依拠するためのインターフェース</li><li>本書では、データストアに登録しているユーザーの資格情報とユーザーの状態をチェックして認証処理を行う実装クラス（DaoAuthenticationProvider）を使用する前提で説明しますが、SpringSecurityは認証方法別の実装クラスも提供している。<ul><li>※DBだけでなく他の認証方式にも対応しているという意味だと理解</li></ul></li></ul></li></ul><h4 id="9-4-2-フォーム認証"><a href="#9-4-2-フォーム認証" class="headerlink" title="9.4.2 フォーム認証"></a>9.4.2 フォーム認証</h4><ul><li><p>SpringSecurityは以下のような流れでフォーム認証を行う</p><ol><li>クライアントは、フォーム認証を行うパスに対して資格情報（ユーザー名とパスワード）をリクエストパラメータとして送信する</li><li>UsernamePasswordAuthenticationFilterクラスは、リクエストパラメータから資格情報を取得して、AuthenticationManagerの認証処理を呼び出す</li><li>UsernamePasswordAuthenticationFilterクラスは、AuthenticationManagerから返却された認証結果をハンドリングする。認証処理が成功した場合は、AuthenticationSuccessHandlerのメソッドを、認証処理が失敗した場合は、AuthenticationFailureHandlerのメソッドを呼び出し、画面遷移を行う</li></ol></li><li><p>フォーム認証の適用</p><ul><li>Bean定義</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SpringSecurityが提供しているコンフィギュレーションクラスがインポートされ、SpringSecurityを利用するために必要となるコンポーネントのBean定義が自動で行われる仕組み</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123; <span class="comment">// 継承すると、デフォルトで適用されるBean定義を簡単にカスタマイズすることができる</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// セキュリティ対策が不要なリソースがある場合、SpringSecurityの処理を適用しないようにする</span></span><br><span class="line">    web.ignoring().antMatchers(<span class="string">"/resources/**"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ★追加！！</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.formLogin();</span><br><span class="line">    <span class="comment">// formLoginメソッドを呼び出すと、フォーム認証が有効になり、FormLoginConfigurerのインスタンスが返却される。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>デフォルトの動作</p><ul><li>SpringSecurityのデフォルトの動作では、<code>/login</code>に対して、GETメソッドでアクセスするとSpringSecurityが用意しているデフォルトのログインフォームが表示され、ログインボタンを謳歌すると<code>/login</code>に対してPOSTメソッドでアクセスして認証処理を行います。</li></ul></li><li><p>ログインフォームの作成</p><ul><li>SpringSecurityは、フォーム認証用のログインフォームをデフォルトで提供しているが、そのまま利用するケースは殆どないと思う</li><li>ここでは、自身で作成したログインフォームをSpringSecurityに適用する方法を紹介する</li><li>まず、ログインフォームを表示するためのJSPを作成</li><li>ここでは、SpringMVCのViewResolverに指定しているベースパス（src/main/webapp/views/）の直下にJSPを配置し、SpringMVC経由でログインフォームを表示する前提で説明</li></ul></li><li><p>ログインフォームをSpringSecurityに適用するために以下のようなBean定義を行う</p><ol><li>loginPageメソッドを呼び出し、ログインフォームを表示するためのパスを指定する<ul><li>匿名のユーザーが認証を必要するリソースにアクセスした場合、ここで指定したパスにリダイレクトしてログインフォームを表示する仕組みになっている。loginPageメソッドに与えられた引数によって、認証パス（loginProcessingUrl）も連動して変わる</li></ul></li><li>permitAll()メソッドを呼び出して、すべてのユーザーに対してログインフォームへのアクセス件を付与する </li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">//    http.addFilter(this.preAuthenticatedProcessingFilter());</span></span><br><span class="line">  <span class="comment">//    http.formLogin();</span></span><br><span class="line">  http.formLogin()</span><br><span class="line">      .loginPage(<span class="string">"/login"</span>) <span class="comment">// 認証を必要とするURLに遷移した場合、このURLにリダイレクトしてログインフォームを表示する仕組み</span></span><br><span class="line">      .permitAll(); <span class="comment">// すべてのユーザーに対してログインフォームへのアクセス件を付与する</span></span><br><span class="line">  http.authorizeRequests()</span><br><span class="line">      .anyRequest()</span><br><span class="line">      .authenticated();</span><br><span class="line">  <span class="comment">// formLoginメソッドを呼び出すと、フォーム認証が有効になり、FormLoginConfigurerのインスタンスが返却される。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>デフォルト動作のカスタマイズ<ul><li>フォーム認証処理のカスタマイズポイントとして<ul><li>認証パス</li><li>資格情報を送るリクエストパラメータ名の変更方法を紹介</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http.formLogin()</span><br><span class="line">    <span class="comment">//.loginPage("/login")</span></span><br><span class="line">    .loginProcessingUrl(<span class="string">"authenticate"</span>)</span><br><span class="line">    .usernameParameter(<span class="string">"uid"</span>)</span><br><span class="line">    .passwordParameter(<span class="string">"pwd"</span>)</span><br><span class="line">    .permitAll();</span><br></pre></td></tr></table></figure><ul><li>loginPageもloginProcessingUrlもやっていることは同じらしい<ul><li><a href="http://www.ne.jp/asahi/hishidama/home/tech/java/spring/boot/web/form-auth.html" target="_blank" rel="noopener">http://www.ne.jp/asahi/hishidama/home/tech/java/spring/boot/web/form-auth.html</a></li></ul></li></ul><h4 id="9-4-3-認証成功時のレスポンス"><a href="#9-4-3-認証成功時のレスポンス" class="headerlink" title="9.4.3 認証成功時のレスポンス"></a>9.4.3 認証成功時のレスポンス</h4><ul><li><p>SpringSecurityは、認証成功時のレスポンスを制御するためのコンポーネントとして、AuthenticationSuccessHandlerというインターフェースと実装クラスを提供している</p></li><li><p>AuthenticationSuccessHandlerの実装クラス</p><ul><li>SavedRequestAwareAuthenticationSuccessHanlder: 認証前にアクセスを試みたURLにリダイレクト（デフォルト）</li><li>SimpleUrlAuthenticastionSuccessHandler: コンストラクタに指定したURLにリダイレクトまたはフォワードする</li></ul></li><li><p>デフォルトの動作</p><ul><li>認証前にアクセスを拒否したリクエストをHTTPセッションに保存しておいて、認証が成功した際にアクセスを拒否したリクエストを復元してリダイレクトする仕組みになっている</li></ul></li><li><p>デフォルト動作のカスタマイズ</p><ul><li>認証成功時のレスポンスのカスタマイズポイントとして、認証成功時に遷移するデフォルトのパスの変更方法を紹介</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http.formLogin()</span><br><span class="line">    .loginPage(<span class="string">"/login"</span>) <span class="comment">// 認証を必要とするURLに遷移した場合、このURLにリダイレクトしてログインフォームを表示する仕組み</span></span><br><span class="line">    .defaultSuccessUrl(<span class="string">"/menu"</span>) <span class="comment">// 認証成功時のデフォルトアクセスはルート。カスタマイズするために記載</span></span><br><span class="line">    .permitAll(); <span class="comment">// すべてのユーザーに対してログインフォームへのアクセス件を付与する</span></span><br></pre></td></tr></table></figure><h4 id="9-4-5-データベース認証"><a href="#9-4-5-データベース認証" class="headerlink" title="9.4.5 データベース認証"></a>9.4.5 データベース認証</h4><ul><li><p>データベース認証の仕組み</p><ul><li>SpringSecurityはクライアントからの認証依頼を受け、DaoAuthenticationProviderの認証処理を呼び出す</li><li>DaoAuthenticationProviderは、UserDetailsServiceのユーザー情報取得処理を呼び出す</li><li>UserDetailsServiceの実装クラスは、データストアからユーザー情報を取得する</li><li>UserDetailsServiceの実装クラスは、データストアから取得したユーザー情報からUserDetailsを生成する</li><li>DaoAuthenticationProviderは、UserDetailsServiceから返却されたUserDetailsとクライアントが指定した認証情報との照合を行い、クライアントが指定したユーザーの正当性をチェックする。クライアントが指定したユーザーが正当なユーザーでない場合は、認証例外をスローする</li></ul></li><li><p>メモ</p><ul><li>SpringSecurityはユーザー情報をリレーショナルデータベースからJDBC経由で取得するための実装クラスを提供しているが、最低限の認証処理しか行わないため、そのまま利用できるケースは少ないと思われる</li><li>そのため本書では、UserDetailsとUserDetailsServiceの実装クラスを作成する方法を紹介します。</li></ul></li><li><p>UserDetailsの作成</p><ul><li>MEMO:※細かいのでソースを確認 後で追記</li></ul></li><li><p>認証処理の適用</p></li></ul><h4 id="9-4-6-パスワードのハッシュ化"><a href="#9-4-6-パスワードのハッシュ化" class="headerlink" title="9.4.6 パスワードのハッシュ化"></a>9.4.6 パスワードのハッシュ化</h4><ul><li>いくつか、パスワードを扱う実装クラスが提供されている</li><li>MEMO:※細かいのでソースを確認 後で追記</li></ul><h4 id="9-4-7-認証イベントのハンドリング"><a href="#9-4-7-認証イベントのハンドリング" class="headerlink" title="9.4.7 認証イベントのハンドリング"></a>9.4.7 認証イベントのハンドリング</h4><ul><li>SpringSecurityは、SpringFrameworkが提供しているイベント通知の仕組みを利用して、</li><li>認証処理の結果を他のコンポーネントへ連携する仕組みを提供しています</li><li>この仕組を利用すると以下のようなセキュリティ要件をSpringSecurityの認証機能に組み込むことができます<ul><li>認証成功、失敗などの認証履歴をデータベースやログに保存したい</li><li>パスワードを連続して誤った場合にアカウントをロックしたい</li></ul></li><li><p>認証イベントの通知は以下のような仕組みで行われる</p></li><li><p>認証イベントの通知の流れ</p><ol><li>SpringSecurityの認証機能は、認証結果をAuthenticationEventPublisherに渡して認証イベントの通知依頼を行う</li><li>AuthenticationEventPublisherインターフェースのデフォルトの実装クラスは、認証結果に対応する認証イベントクラスのインスタンスを生成し、ApplicationEventPublisherに渡してイベントの通知依頼を行う</li><li>ApplicationEventPublisherインターフェースの実測クラスは、ApplicationListenerインターフェースの実装クラスにイベントを通知する</li><li>ApplicationListenerの実装クラスの１つであるApplicationListenerMethodAdaptorは、<a href="mailto:`@org.springframework.context.event.EventLintener" target="_blank" rel="noopener">`@org.springframework.context.event.EventLintener</a>`が付与されているメソッドを呼び出してイベントを通知する</li></ol></li><li><p>メモ</p><ul><li>Spring4.1まではApplicationListenerインターフェースの実装クラスを作成して、イベントを受け取る必要があった</li><li>Spring4.2からは、POJOに<code>@EventListener</code>を付与したメソッドを実装するだけでイベントを受け取ることができる</li><li>Spring4.2以降も、従来と同じ用にApplicationListenerインターフェースの実装クラスを作成してイベントを受け取ることができる</li></ul></li><li><p>認証成功イベント</p><ul><li>認証が成功したときにSpringSecurityが通知する主なイベントは以下の３つです。</li><li>この３つのイベントは途中でエラーが発生しなければ、以下の順番ですべて通知されます<ul><li>AuthenticationSuccessEvent<ul><li>AuthenticationProviderによる認証処理が成功したことを通知する。</li><li>このイベントをハンドリングすると、クライアントが正しい認証情報を指定したことを検知することができるが、後続の認証処理でエラーになる可能性がある</li></ul></li><li>SessionFixationProtectionEvent<ul><li>セッション固定攻撃対策の処理（セッションIDの変更処理）が成功したことを通知する。このイベントをハンドリングすると、変更後のセッションIDを検知することができる</li></ul></li><li>InteractiveAuthenticationSuccessEvent<ul><li>認証処理がすべて成功したことを通知する。このイベントをハンドリングすると、画面遷移を除くすべての認証処理が成功したことを検知することができる</li></ul></li></ul></li></ul></li><li><p>認証失敗イベント</p><ul><li>認証が失敗したときにSpringSecurityが通知する主なイベントは以下の通り</li><li>認証に失敗した場合は、以下のいずれか１つのイベントが通知される<ul><li>AuthenticationFailureBadCredentialsEvent</li><li>AuthenticationFailureDisabledEvent</li><li>AuthenticationFailureLockedEvent</li><li>AuthenticationFailureExpiredEvent</li><li>AuthenticationFailureCredentialsExpiredEvent</li><li>AuthenticationFailureServiceExceptionEvent</li></ul></li></ul></li><li><p>イベントリスナの作成</p><ul><li>認証イベントの通知を受け取って処理を行いたい場合、<code>@EventListener</code>を付与したメソッドを実装したクラスを作成し、DIコンテナに登録するだけ</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * - 認証イベントの通知の流れ</span></span><br><span class="line"><span class="comment"> *    1. SpringSecurityの認証機能は、認証結果をAuthenticationEventPublisherに渡して認証イベントの通知依頼を行う</span></span><br><span class="line"><span class="comment"> *    2. AuthenticationEventPublisherインターフェースのデフォルトの実装クラスは、認証結果に対応する認証イベントクラスのインスタンスを生成し、ApplicationEventPublisherに渡してイベントの通知依頼を行う</span></span><br><span class="line"><span class="comment"> *    3. ApplicationEventPublisherインターフェースの実測クラスは、ApplicationListenerインターフェースの実装クラスにイベントを通知する</span></span><br><span class="line"><span class="comment"> *    4. ApplicationListenerの実装クラスの１つであるApplicationListenerMethodAdaptorは、`<span class="doctag">@org</span>.springframework.context.event.EventLintener`が付与されているメソッドを呼び出してイベントを通知する</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - `<span class="doctag">@EventLitener</span>`を付与したメソッドを実装するだけで認証成功/失敗時の処理を実装できる仕組み</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Tomo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppSecurityEventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ==============================</span></span><br><span class="line">  <span class="comment">//  SUCCESS EVENT HANDLERS</span></span><br><span class="line">  <span class="comment">// ==============================</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * AuthenticationProviderによる認証処理が成功したことを通知する。</span></span><br><span class="line"><span class="comment">   * このイベントをハンドリングすると、クライアントが正しい認証情報を指定したことを検知することができるが、</span></span><br><span class="line"><span class="comment">   * 後続の認証処理でエラーになる可能性がある。</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@EventListener</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleAuthenticationSuccess</span><span class="params">(AuthenticationSuccessEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * セッション固定攻撃対策の処理（セッションIDの変更処理）が成功したことを通知する。</span></span><br><span class="line"><span class="comment">   * このイベントをハンドリングすると、変更後のセッションIDを検知することができる。</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@EventListener</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleSessionFixationProtection</span><span class="params">(SessionFixationProtectionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 認証処理がすべて成功したことを通知する。</span></span><br><span class="line"><span class="comment">   * このイベントをハンドリングすると、画面遷移を除くすべての認証処理が成功したことを検知することができる。</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@EventListener</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleInteractiveAuthenticationSuccess</span><span class="params">(InteractiveAuthenticationSuccessEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ==============================</span></span><br><span class="line">  <span class="comment">//  FAILURE EVENT HANDLERS</span></span><br><span class="line">  <span class="comment">// ==============================</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@EventListener</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleBadCredentials</span><span class="params">(AuthenticationFailureBadCredentialsEvent event)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"BAD Credentials is detected. username : &#123;&#125;"</span>, event.getAuthentication().getName());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@EventListener</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDisabled</span><span class="params">(AuthenticationFailureDisabledEvent event)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"Disabled user is detected. username : &#123;&#125;"</span>, event.getAuthentication().getName());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@EventListener</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleLocked</span><span class="params">(AuthenticationFailureLockedEvent event)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"Locked user is detected. username : &#123;&#125;"</span>, event.getAuthentication().getName());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@EventListener</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleExpired</span><span class="params">(AuthenticationFailureExpiredEvent event)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"Expired user is detected. username : &#123;&#125;"</span>, event.getAuthentication().getName());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@EventListener</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleCredentialsExpired</span><span class="params">(AuthenticationFailureCredentialsExpiredEvent event)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"CredentialsExpired is detected. username : &#123;&#125;"</span>, event.getAuthentication().getName());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@EventListener</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleServiceException</span><span class="params">(AuthenticationFailureServiceExceptionEvent event)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"ServiceException is detected. username : &#123;&#125;"</span>, event.getAuthentication().getName());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-4-8-ログアウト"><a href="#9-4-8-ログアウト" class="headerlink" title="9.4.8 ログアウト"></a>9.4.8 ログアウト</h4><ul><li><p>SpringSecurityは以下のような流れでログアウト処理を行う</p><ol><li>クライアントは、ログアウト処理を行うためのパスにリクエストを送信する</li><li>LogoutFilterは、LogoutHandlerのメソッドを呼び出してログアウト処理を行う</li><li>LogoutFilterは、LogoutSuccessHandlerのメソッドを呼び出して画面遷移を行う</li></ol></li><li><p>LogoutHandlerの実装クラス</p><ul><li>SecurityContextLogoutHandler: 認証情報のクリアとセッションの破棄を行う</li><li>CookieClearingLogoutHandler: 指定したクッキーの削除するためのレスポンスを行う</li><li>CsrfLogoutHandler: CSRF対策用のトークンの破棄を行う</li></ul></li><li><p>こららのLogoutHandlerは、SpringSecurityが提供しているBean定義をサポートするクラスが自動でLogoutFilterに設定する仕組みになっているので、基本的にはアプリケーションの開発者が直接意識する必要はない</p></li><li><p>ログアウト処理の適用</p><ul><li>ログアウト処理を適用するには、以下のようなBean定義を行う必要がある</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">http.authorizeRequests()</span><br><span class="line">    .antMatchers(<span class="string">"/"</span>, <span class="string">"/find"</span>, <span class="string">"/login"</span>, <span class="string">"/signup"</span>, <span class="string">"/error"</span>, <span class="string">"/login-error"</span>).permitAll()</span><br><span class="line">    .anyRequest().authenticated()</span><br><span class="line">    .and()</span><br><span class="line">    <span class="comment">// Login処理</span></span><br><span class="line">    .formLogin()</span><br><span class="line">    .loginPage(<span class="string">"/login"</span>) <span class="comment">// 認証を必要とするURLに遷移した場合、このURLにリダイレクトしてログインフォームを表示する仕組み</span></span><br><span class="line">    .defaultSuccessUrl(<span class="string">"/menu"</span>) <span class="comment">// 認証成功時のデフォルトアクセスはルート。カスタマイズするために記載</span></span><br><span class="line">    .failureUrl(<span class="string">"/login"</span>) <span class="comment">// 認証失敗時ログイン画面に戻す</span></span><br><span class="line">    .usernameParameter(<span class="string">"id"</span>)</span><br><span class="line">    .passwordParameter(<span class="string">"password"</span>)</span><br><span class="line">    .and()</span><br><span class="line">    <span class="comment">// Logout処理</span></span><br><span class="line">    .logout()</span><br><span class="line">    .logoutRequestMatcher(<span class="keyword">new</span> AntPathRequestMatcher(<span class="string">"logout**"</span>))</span><br><span class="line">    .logoutSuccessUrl(<span class="string">"/login"</span>)</span><br><span class="line">    .permitAll(); <span class="comment">// すべてのユーザーに対してログインフォームへのアクセス件を付与する</span></span><br></pre></td></tr></table></figure><ul><li>デフォルトの動作のカスタマイズ<ul><li>遷移先を変える <code>logoutSuccessUrl</code>の引数を変えてあげる</li></ul></li></ul><h4 id="9-4-10-認証情報へのアクセス"><a href="#9-4-10-認証情報へのアクセス" class="headerlink" title="9.4.10 認証情報へのアクセス"></a>9.4.10 認証情報へのアクセス</h4><ul><li>認証済みのユーザーの認証情報は、SpringSecurityのデフォルト実装では、セッションに格納される</li><li>セッションに格納された認証情報は、リクエストごとにSecurityContextPersistenceFilterクラスによって</li><li><p>SecurityContextHolderというクラスに格納され、同一スレッド内であればどこからでもアクセスすることができる用になる</p></li><li><p>Javaからのアクセス</p><ul><li>一般的な業務アプリケーションでは、「いつ」「誰が」「どのデータに」「どのようなアクセスをしたか」を</li><li>記録する監査ログを取得することがある。この要件を実現する際の、「誰が」は、認証情報から取得できる</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 認証情報（Authenticationオブジェクト）を取得する</span></span><br><span class="line">Authentication authentication =</span><br><span class="line">    SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line"></span><br><span class="line">String userUuid = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// Authentication#getPrincipal()メソッドを呼び出して、UserDetailsオブジェクトを取得する</span></span><br><span class="line"><span class="comment">// 認証済みでない場合は、匿名ユーザーを表す文字列が返却されるので注意</span></span><br><span class="line"><span class="keyword">if</span> (authentication.getPrincipal() <span class="keyword">instanceof</span> AccountUserDetails) &#123;</span><br><span class="line">    AccountUserDetails userDetails = AccountUserDetails.class.cast(authentication.getPrincipal());</span><br><span class="line">    <span class="comment">// UserDetailsから処理に必要な情報を取得する</span></span><br><span class="line">    userUuid = userDetails.getAccount().getUserUuid();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>アノテーションでアクセスした方が良さそう</p><ul><li><a href="https://qiita.com/Hyuga-Tsukui/items/81990938e43c7dff35cf" target="_blank" rel="noopener">https://qiita.com/Hyuga-Tsukui/items/81990938e43c7dff35cf</a></li></ul></li><li><p>JSPからのアクセス</p><ul><li>一般的なWebアプリケーションでは、ログインユーザーのユーザー情報などを画面に表示することがある。</li></ul></li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;% taglib prefix=<span class="string">"sec"</span> uri=<span class="string">"http://www.springframework.org/security/tags"</span> %&gt;</span><br><span class="line">&lt;%-- ... --%&gt;</span><br><span class="line">ようこそ</span><br><span class="line">&lt;sec:authentication property=<span class="string">"principal.account.lastName"</span> /&gt;</span><br><span class="line">さん。</span><br></pre></td></tr></table></figure><ul><li>追記：thymeleafからのアクセス</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:sec</span>=<span class="string">"http://www.thymeleaf.org/thymeleaf-extras-springsecurity4"</span>&gt;</span> <span class="comment">&lt;!-- これを追加してThymeleafからSpringSecurityを利用 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 省略 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>こんにちは、<span class="tag">&lt;<span class="name">span</span> <span class="attr">sec:authentication</span>=<span class="string">"principal.userId"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>さん<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> <span class="comment">&lt;!-- principal.メンバ変数名　で参照できる　--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="9-4-11-認証処理とSpringMVCの連携"><a href="#9-4-11-認証処理とSpringMVCの連携" class="headerlink" title="9.4.11 認証処理とSpringMVCの連携"></a>9.4.11 認証処理とSpringMVCの連携</h4><ul><li>SpringSecurityは、SpringMVCと連携するためのコンポーネントをいくつか提供している</li><li>ここでは、認証処理と連携するためのコンポーネントの使い方を紹介</li><li>SpringSecurityは認証情報（UserDetails）をSpringMVCのコントローラーのメソッドに引き渡すためのコンポーネントとして、AuthenticationPrincipalArgumentResolverというクラスを提供している</li><li>これを使用すると、コントローラーのメソッド引数として、UserDetailsインターフェースまたはその実装クラスのインスタンスを受け取ることができる</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">index</span><span class="params">(@AuthenticationPrincipal UserDetailsImpl userDetails)</span> </span>&#123;</span><br><span class="line">        System.out.println(userDetails.getUserId) <span class="comment">// userId</span></span><br><span class="line">        System.out.println(userDetails.getPassword) <span class="comment">//password</span></span><br><span class="line">        System.out.println(userDetails.getHoge) <span class="comment">//hoge</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="9-4-12-エラーメッセージ"><a href="#9-4-12-エラーメッセージ" class="headerlink" title="9.4.12 エラーメッセージ"></a>9.4.12 エラーメッセージ</h4><ul><li>認証に失敗した場合、SpringSecurityが用意しているエラーメッセージが表示されます</li><li><p>このエラーメッセージは内容を変更したり、表示しないようにすることができます。</p></li><li><p>エラーメッセージの変更</p><ul><li>認証失敗時に表示されるエラーメッセージを変更したい場合は、MessageSourceで読み込んでいるプロパティファイルに</li><li>SpringSecurityが用意しているメッセージの定義を追加してください</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AbstractUserDetailsAuthenticationProvider.badCredentials = 入力した認証情報に誤りがあります。</span><br><span class="line">AbstractUserDetailsAuthenticationProvider.credentialsExpired = 認証情報の利用期限が切れています。</span><br><span class="line">AbstractUserDetailsAuthenticationProvider.disabled = 無効なアカウントです。</span><br><span class="line">AbstractUserDetailsAuthenticationProvider.expired = アカウントの期限が切れています。</span><br><span class="line">AbstractUserDetailsAuthenticationProvider.locked = アカウントがロックされています。</span><br></pre></td></tr></table></figure><ul><li>この他にも多数のメッセージが用意されている</li><li><p>種類を確認するには、<code>spring-security-core</code>モジュールのjarファイルの中の<code>org/springframework/security/message.properties</code>ファイルを確認してください</p></li><li><p>メッセージ定義定数クラスは自動生成するべきな件</p><ul><li><a href="https://terasolunaorg.github.io/guideline/1.0.x/ja/ArchitectureInDetail/MessageManagement.html" target="_blank" rel="noopener">https://terasolunaorg.github.io/guideline/1.0.x/ja/ArchitectureInDetail/MessageManagement.html</a></li></ul></li><li><p>メモ</p><ul><li>MessageSourceの中でプロパティファイルをISO 8859-1(デフォルト)で読み込んでいる場合は、マルチバイト文字は</li><li>Unicodeコード（\udddd表記）形式に変換する必要がある。</li><li>なお、プロパティファイルを任意の文字コードで読み込む場合は、MessageSourceのdefaultEncodingプロパティに文字コードを指定してください。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageSource <span class="title">messageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ResourceBundleMessageSource messageSource = <span class="keyword">new</span> ResourceBundleMessageSource();</span><br><span class="line">  messageSource.setBasenames(<span class="string">"i18n/messages"</span>); <span class="comment">// クラスパス上に格納されているプロパティファイル（拡張子は除く）を指定する</span></span><br><span class="line">  messageSource.setDefaultEncoding(<span class="string">"UTF-8"</span>); <span class="comment">// ★ここのこと！</span></span><br><span class="line">  <span class="keyword">return</span> messageSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>システムエラー時のメッセージ</p><ul><li>認証処理の中で予期しないエラー（システムエラーなど）が発生した場合、InternalAuthenticationServiceExceptionという例外が発生する。InteractiveAuthenticationServiceExceptionが保持するメッセージには、</li><li>原因例外のメッセージが設定されるため画面にそのまま表示するのは好ましくない</li><li>システムエラーの例外メッセージを画面に表示しない用にするには、ExceptionMappingAuthenticationFailureHandlerやDelegatingAuthenticationFailureHandlerを使用して、InternalAuthenticationServiceExceptionが発生したときの遷移先をシステムエラー画面にするのが良いでしょう。</li></ul></li><li><p>TODO: この辺見て実装する</p><ul><li><a href="https://qiita.com/rubytomato@github/items/6c6318c948398fa62275" target="_blank" rel="noopener">https://qiita.com/rubytomato@github/items/6c6318c948398fa62275</a></li></ul></li></ul><h3 id="9-5-認可処理"><a href="#9-5-認可処理" class="headerlink" title="9.5 認可処理"></a>9.5 認可処理</h3><ul><li>認可処理は、アプリケーションの利用者がアクセスできるリソースを制御するための処理</li><li>最も標準的な方法は、リソース毎にアクセスポリシーを定義しておいて、利用者がリソースにアクセスしようとしたときにアクセスポリシーを調べて制御する方法</li><li>アクセスポリシーには、どのリソースにどのユーザーからのアクセスを許可するかを定義します</li><li>SpringSecurityでは、Webリソース、Javaメソッド、ドメインオブジェクトに対してアクセスポリシーを定義できる</li></ul><p>※ドメインオブジェクトに関する認可処理は本書では扱わない<br>興味がある場合は、下記参照<br><a href="http://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#domain-acls" target="_blank" rel="noopener">http://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#domain-acls</a></p><h4 id="9-5-1-認可処理の仕組み"><a href="#9-5-1-認可処理の仕組み" class="headerlink" title="9.5.1 認可処理の仕組み"></a>9.5.1 認可処理の仕組み</h4><ul><li>SpringSecrityが提供する認証処理の仕組みを理解しましょう</li><li><p>以下のような流れで認可処理を行います</p><ol><li>クライアントが任意のリソースにアクセスする</li><li>FilterSecurityInterceptorクラスは、AccessDecisionManagerインターフェースのメソッドを呼び出し、リソースへのアクセス権の有無をチェックする</li><li>AffirmativeBasedクラス（デフォルトで使用されるAccessDecisionManagerの実装クラス）は、AccessDecisionVoterインターフェースのメソッドを呼び出し、アクセス件の有無を投票してもらう</li><li>FilterSecurityInterceptorは、AccessDecisionManagerによってアクセス権が付与された場合に限り、リソースへアクセスする</li></ol></li><li><p>ExceptionTranslationFilter</p><ul><li>認可処理（AccessDecisionManager）で発生した例外をハンドリングし、</li><li>クライアントに適切なレスポンスを行うためのサーブレットフィルタ</li><li>デフォルトの実装では、未認証ユーザーからのアクセスの場合は、認証を促すレスポンス、認証済みユーザーからのアクセスの場合は、認可エラーを通知するレスポンスを返却する</li></ul></li><li><p>FilterSecurityInterceptor</p><ul><li>HTTPリクエストに対して認可処理を適用するためのサーブレットフィルタで、実際の認可処理はAccessDecisionManagerに移譲しています。</li><li>AccessDecisionManagerインターフェースのメソッドを呼び出す際には、クライアントがアクセスしようとしたWebリソースに指定されているアクセスポリシーを連携します。</li></ul></li><li><p>AccessDecisionManager</p><ul><li>アクセスしようとしたリソースに対してアクセス権があるかチェックを行うためのインターフェース</li><li>SpringSecurityが提供する実装クラスでは、このあと紹介するAccessDecisionVoterというインターフェースのメソッドを呼び出してアクセス権を付与するか否かを投票するしくみになっており、デフォルトで適用されるクラスはAffirmativeBasedクラスです。AffirmativeBasedクラスは、いずれかのAccessDecisionVoterが付与を投票した場合にアクセス権を与える実装クラス</li></ul></li><li><p>AccessDecisionVoter</p><ul><li>アクセスしようとしたリソースに指定されているアクセスポリシーを参照し、アクセス権を付与するか否かを投票する（付与、拒否、棄権）するためのインターフェース</li><li>SpringSecurityではいくつかの実装クラスを提供しているが、4.0からデフォルトで適用されるクラスは、<code>WebExpressionVoter</code>に統一されている</li><li>WebExpressionVoterはSpring Expression Languageを使用して、利用者が持つ、権限情報とリクエスト情報を参照して投票を行う実装クラス</li></ul></li></ul><h4 id="9-5-2-アクセスポリシーの記述方法"><a href="#9-5-2-アクセスポリシーの記述方法" class="headerlink" title="9.5.2 アクセスポリシーの記述方法"></a>9.5.2 アクセスポリシーの記述方法</h4><ul><li>SpringSecurityは、アクセスポリシーを指定する記述方法として、SpringExpressionLanguage（SpEL）をサポート</li><li><p>SpELを使わない方法もあるが、本書では、Expressionを使ってアクセスポリシーを指定する方法で解説する</p></li><li><p>CommonExpressions</p><ul><li>※割愛</li></ul></li></ul><h4 id="9-5-3-Webリソースへの認可（JavaConfig編）"><a href="#9-5-3-Webリソースへの認可（JavaConfig編）" class="headerlink" title="9.5.3 Webリソースへの認可（JavaConfig編）"></a>9.5.3 Webリソースへの認可（JavaConfig編）</h4><ul><li><p>JavaConfigを使用して、Webリソースに対してアクセスポリシーを定義する方法について説明</p></li><li><p>アクセスポリシーを適用するWebリソースの指定</p><ul><li>まずは、アクセスポリシーを適用するリソースを指定</li><li>アクセスポリシーを適用するリソースの指定は、ExpressionInterceptUrlRegistryクラスの以下のメソッドを呼び出して行います。<ul><li>antMatchers</li><li>regexMatchers</li><li>requestMatchers</li><li>anyRequests</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">//    http.addFilter(this.preAuthenticatedProcessingFilter());</span></span><br><span class="line">  <span class="comment">//    http.formLogin();</span></span><br><span class="line">  http.authorizeRequests()</span><br><span class="line">      .antMatchers(<span class="string">"/"</span>, <span class="string">"/find"</span>, <span class="string">"/login"</span>, <span class="string">"/signup"</span>, <span class="string">"/error"</span>, <span class="string">"/login-error"</span>).permitAll()</span><br><span class="line">      <span class="comment">// ★記載順には気をつける必要がある</span></span><br><span class="line">      .antMatchers(<span class="string">"/admin/accounts/***"</span>).hasRole(<span class="string">"ACCOUNT_MANAGER"</span>)</span><br><span class="line">      .antMatchers(<span class="string">"/admin/***"</span>).hasRole(<span class="string">"ADMIN"</span>)</span><br><span class="line">      .anyRequest().authenticated()</span><br></pre></td></tr></table></figure><ul><li>アクセスポリシーの指定<ul><li>次に、アクセスポリシーを指定します。</li><li>アクセスポリシーの指定は、AuthorizedUrlクラスのメソッドを使用して行います。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http.authorizeRequests()</span><br><span class="line">    .antMatchers(<span class="string">"/"</span>, <span class="string">"/find"</span>, <span class="string">"/login"</span>, <span class="string">"/signup"</span>, <span class="string">"/error"</span>, <span class="string">"/login-error"</span>).permitAll()</span><br><span class="line">    <span class="comment">//        .antMatchers("/admin/accounts/***").hasRole("ACCOUNT_MANAGER")</span></span><br><span class="line">    <span class="comment">//        .antMatchers("/admin/***").hasRole("ADMIN")</span></span><br><span class="line">    .antMatchers(<span class="string">"/admin/***"</span>).access(<span class="string">"hasIpAddress('127.0.0.1') and hasRole('CONFIGURATION_MANAGER')"</span>)</span><br><span class="line">    .antMatchers(<span class="string">"/admin/***"</span>).hasRole(<span class="string">"ADMIN"</span>)</span><br><span class="line">    .anyRequest().authenticated()</span><br></pre></td></tr></table></figure><h4 id="9-5-4-Webリソースへの認可（XMLファイル編）"><a href="#9-5-4-Webリソースへの認可（XMLファイル編）" class="headerlink" title="9.5.4 Webリソースへの認可（XMLファイル編）"></a>9.5.4 Webリソースへの認可（XMLファイル編）</h4><ul><li>割愛</li></ul><h4 id="9-5-5-メソッドへの認可"><a href="#9-5-5-メソッドへの認可" class="headerlink" title="9.5.5 メソッドへの認可"></a>9.5.5 メソッドへの認可</h4><ul><li><p>SpringSecurityは、SpringAOPの仕組みを利用して、アプリケーションコンテキスト内で管理しているBeanのメソッド呼び出しに対して認可処理を行う仕組みを提供しています。</p><ul><li>メソッドに対応する認可処理を使用すると、メソッドの引数や戻り値のオブジェクトの状態を参照できるため、よりきめ細かいアクセスポリシーの定義が行える</li><li>メソッドへの認可を使用する場合は、メソッド呼び出しに対して認可処理を行うためのコンポーネント（AOP）を有効にしてから、アクセスポリシーをクラスやメソッドのアノテーションに定義します。<ul><li>つまり<ul><li>AOP有効化</li><li>メソッドにアノテーション定義</li></ul></li></ul></li></ul></li><li><p>SpringSecurityがサポートしているアノテーションは以下</p><ul><li>@PreAuthorize,@PostAuthorize,@PreFilter,@PostFilter: SpringSecurityのアノテーション</li><li>@Secured: SpringSecurityのアノテーション</li><li>JSR250(javax.annotation.securityパッケージ)のアノテーション（@RolesAllowedなど）</li></ul></li><li><p>本書では、アクセスポリシーの指定にExpressionを使用することができる <code>@PreAuthorize</code>と<code>@PostAuthorize</code>を紹介する</p></li><li><p>メソッド認可の有効化</p><ul><li>まず、メソッドに対して認可処理を行うAOPを有効化します</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="keyword">true</span>) <span class="comment">// メソッドに対して認可処理を行うAOPを有効化 prePostEnabled属性にtrueを指定すると、Expressionを使用してアクセスポリシーを定義することができるアノテーションが有効になる</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>メソッド実行前に適用するアクセスポリシーの指定<ul><li>メソッドの実行前に適用するアクセスポリシーを指定する場合は<code>@PreAuthorize</code>を使用する</li><li><code>@PreAuthorize</code>のvalue属性に指定したExpressionの結果がtrueになるとメソッドの実行が許可される</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管理者以外の人間が他人のアカウント情報にアクセスできないように定義している</span></span><br><span class="line"><span class="meta">@PreAuthorize</span>(<span class="string">"hasRole('ADMIN') or (#username == principal.username)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Account <span class="title">findOne</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> accountRepository.findOne(username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ここでポイントになるのが、Expressionの中からメソッドの引数にアクセスしている部分</li><li>具体的には、#usernameの部分が引数にアクセスしている部分になる</li><li><p>Expression内で「# + 引数名」形式のExpressionを指定するとメソッドの引数にアクセスすることができる</p></li><li><p>メモ</p><ul><li>SpringSecurityは、クラスに出力されているデバッグ情報から引数名を解決する仕組みになっているが、</li><li>アノテーション（<code>@P</code>）を使用して明示的に引数名を指定することもできる</li><li>以下の場合は、明示的に引数名を指定してあげる必要がある<ul><li>引数のデバッグ情報を出力しない</li><li>Expressionの中から実際の引数名とは別の名前を使ってアクセスする（例：短縮した名前）</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize</span>(<span class="string">"hasRole('ADMIN') or (#username == principal.username)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Account <span class="title">findOne</span><span class="params">(@P(<span class="string">"username"</span>)</span> String username) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> accountRepository.findOne(username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>JavaSE8から追加されたコンパイルオプション（-parameters）を使用すると、メソッドパラメータにリフレクション用のメタデータが生成されるため、アノテーションを指定しなくても引数名を解決してくれる</p></li><li><p>メソッド実行後に適用するアクセスポリシーの指定</p><ul><li><code>@PostAuthorize</code>を使用する</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize</span>(<span class="string">"hasRole('DEPARTMENT_MANAGER')"</span>)</span><br><span class="line"><span class="meta">@PostAuthorize</span>(<span class="string">"(returnObject == null) or (returnObject.departmentCode == principal.account.departmentCode)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Account <span class="title">findOne</span><span class="params">(@P(<span class="string">"username"</span>)</span> String username) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> accountRepository.findOne(username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-5-6-JSPの画面項目への認可"><a href="#9-5-6-JSPの画面項目への認可" class="headerlink" title="9.5.6 JSPの画面項目への認可"></a>9.5.6 JSPの画面項目への認可</h4><p>SpringSecurityはJSPタグライブラリを使用してJSPの画面項目に対して認可処理を適用することができる</p><ul><li>※管理者の場合、この項目を表示するなどの制御<ul><li>このURLへ遷移させるなどの制御</li></ul></li></ul><h4 id="9-5-7-認可エラー時のレスポンス"><a href="#9-5-7-認可エラー時のレスポンス" class="headerlink" title="9.5.7 認可エラー時のレスポンス"></a>9.5.7 認可エラー時のレスポンス</h4><ul><li><p>SpringSecurityはリソースへのアクセスを拒否した場合、以下のような流れでエラーハンドリング、レスポンスを行う</p><ol><li>SpringSecurityは、リソースやメソッドへのアクセスを拒否するために、AccessDeniedExceptionをスローする</li><li>ExceptionTranslationFilterクラスは、AccessDeniedExceptionを捕捉し、AccessDeniedHandlerまたは、AuthenticationEntryPointインターフェースのメソッドを呼び出してエラー応答を行う</li><li>認証済みのユーザーからのアクセスの場合は、AccessDeniedHandlerインターフェースのメソッドを呼び出してエラー応答を行う</li><li>未認証ユーザーからのアクセスの場合は、AuthenticationEntryPointインターフェースのメソッドを呼び出してエラー応答を行う</li></ol></li><li><p>AccessDeniedHandler</p></li><li><p>AuthenticationEntryPoint</p></li><li><p>認可エラー時の遷移先</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.exceptionHandling().accessDeniedPage(<span class="string">"/accessDeniedError"</span>);</span><br></pre></td></tr></table></figure><ul><li>デフォルト動作のカスタマイズ<ul><li>TODO: 認証エラー時にメッセージを出す処理を作るときに記述しないと行けない気がする</li></ul></li></ul><h3 id="9-6-CSRF対策"><a href="#9-6-CSRF対策" class="headerlink" title="9.6 CSRF対策"></a>9.6 CSRF対策</h3><h4 id="9-6-1-Spring-SecurityのCSRF対策"><a href="#9-6-1-Spring-SecurityのCSRF対策" class="headerlink" title="9.6.1 Spring SecurityのCSRF対策"></a>9.6.1 Spring SecurityのCSRF対策</h4><ul><li>Spring Securityはセッション単位にランダムなトークン値(CSRFトークン)を払い出し、払い出されたCSRFトークンをリクエストパラメータ（HTMLフォームのhidden項目）として送信することで、そのリクエストが正規のWebページからなのか、それとも攻撃者が用意したWebページからなのかを判断する機能がある</li><li>SpringSecurityのデフォルト実装では、POST,PUT,DELETE,PATCHのHTTPメソッドを使用したリクエストに対して、CSRFトークンチェックを行います</li></ul><h4 id="9-6-2-CSRF対策機能の適用"><a href="#9-6-2-CSRF対策機能の適用" class="headerlink" title="9.6.2 CSRF対策機能の適用"></a>9.6.2 CSRF対策機能の適用</h4><ul><li>CSRF対策機能はSpring3.2から追加された機能で、SpringSecurity4.0からデフォルトで適用されるようになりました。</li><li>そのため、CSRF対策機能を有効にするための特別な定義はありません。</li><li>なおCSRF機能を適用したくない場合は、明示的に無効にする必要がある</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  http.csrf().disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>HTMLフォーム使用時のトークン値の連携</p><ul><li>JSPでの設定を紹介しているため割愛</li><li>Thymeleafだとこんな感じ<a href="https://qiita.com/nenokido2000/items/22a97a26a5858ddb164f" target="_blank" rel="noopener">https://qiita.com/nenokido2000/items/22a97a26a5858ddb164f</a></li></ul></li><li><p>Ajax使用時の連携</p><ul><li>Ajaxを使ってリクエストを送信する場合は、SpringSecurityから提供されている<code>&lt;sec:csrfMetaTag&gt;</code>要素を使用して、HTMLの<code>&lt;meta&gt;</code>要素としてCSRFトークンの情報を出力し<code>&lt;meta&gt;</code>要素から取得したトークン値をAjax通信時のリクエストヘッダーに設定して連携します。</li><li>Thymeleafの場合、以下を参考に、Cookieからcsrfトークンを取り出して、詰めて送る<ul><li><a href="https://qiita.com/nenokido2000/items/22a97a26a5858ddb164f" target="_blank" rel="noopener">https://qiita.com/nenokido2000/items/22a97a26a5858ddb164f</a></li><li>CookieにCSRFトークンを詰める処理は以下で行えるようになっている</li><li><code>http.csrf().csrfTokenRepository(new CookieCsrfTokenRepository());</code></li></ul></li></ul></li></ul><h4 id="9-6-3-トークンチェックエラー時のレスポンス"><a href="#9-6-3-トークンチェックエラー時のレスポンス" class="headerlink" title="9.6.3 トークンチェックエラー時のレスポンス"></a>9.6.3 トークンチェックエラー時のレスポンス</h4><ul><li><p>CSRFトークンチェックでエラーが発生した場合、SpringSecurityはAccessDeniedHandlerインターフェースを使用してエラーのレスポンスを行う</p></li><li><p>CSRFトークンチェックでエラーが発生したときに専用のエラーページに遷移させる場合は、SpringSecurityから提供されているDelegatingAuthenticationFailureHandlerクラスを利用して、それぞれの例外にAccessDeniedHandlerインターフェースの実装クラスを指定してください</p></li><li><p>CSRFトークンチェックで使用される例外クラス</p><ul><li>InvalidCsrfTokenException</li><li>MissingCsrfTokenException<ul><li>TODO: この例外処理を実装する必要がある XMLで記載している例はあるけど、Javaで書いている例がない..</li></ul></li></ul></li></ul><h4 id="9-6-4-CSRF対策機能とSpringMVCとの連携"><a href="#9-6-4-CSRF対策機能とSpringMVCとの連携" class="headerlink" title="9.6.4 CSRF対策機能とSpringMVCとの連携"></a>9.6.4 CSRF対策機能とSpringMVCとの連携</h4><ul><li>自動でFormにcsrfトークンが入りますよという説明</li></ul><h3 id="9-7-セッション管理"><a href="#9-7-セッション管理" class="headerlink" title="9.7 セッション管理"></a>9.7 セッション管理</h3><h4 id="9-7-1-セッション管理機能の適用"><a href="#9-7-1-セッション管理機能の適用" class="headerlink" title="9.7.1 セッション管理機能の適用"></a>9.7.1 セッション管理機能の適用</h4><ul><li>セッション管理機能を使用するには、以下のようなBean定義を行う</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  http.sessionManagement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>sessionManagementメソッドを呼び出し、SessionManagementConfigurerのインスタンスを取得する</li><li><p>SessionManagementConfigurerには、セッション管理機能のコンポーネントの動作をカスタマイズするためのメソッドが定義されている。なお、WebSecurityConfigurerAdapterを継承して、コンフィギュレーションクラスを作成している場合は、sessionManagementメソッドは親クラスの処理で呼び出されるため、デフォルトでセッション管理機能が適用されている</p></li><li><p>RESTAPIなどセッションを使用しない場合は、セッションの作成方式を stateless に変更する必要がある</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br></pre></td></tr></table></figure><ul><li>セッションの作成方式は以下のオプションから選択することができる<ul><li>always</li><li>ifRequired (デフォルト)</li><li>never</li><li>stateless</li></ul></li></ul><h4 id="9-7-2-URL-Rewriting抑止機能"><a href="#9-7-2-URL-Rewriting抑止機能" class="headerlink" title="9.7.2 URL Rewriting抑止機能"></a>9.7.2 URL Rewriting抑止機能</h4><p>URL Rewritingが行われると、URL内にセッションIDが露出してしまうため、セッションIDを盗まれるリスクが高くなります。</p><p>SpringSecurityでは、URL Rewritingを抑止するための仕組みも提供しており、この機能はSpringSecurity4.0以上ではデフォルトで適用されます。</p><ul><li>TODO: Cookieを許可しない設定になっているとどのような挙動になる？クエリに埋め込まれない？</li></ul><h4 id="9-7-3-セッション固定攻撃対策機能"><a href="#9-7-3-セッション固定攻撃対策機能" class="headerlink" title="9.7.3 セッション固定攻撃対策機能"></a>9.7.3 セッション固定攻撃対策機能</h4><ul><li>セッション管理機能を適用すると、デフォルトでセッション固定攻撃機能が有効になる</li><li><p>セッション固定攻撃対策機能を使用すると、ログイン成功時に新たセッションIDを払い直すため、攻撃者が事前に払い出したセッションIDが使われることはありません。</p></li><li><p>セッション固定攻撃への対策オプション</p><ul><li>changeSessionId: Servlet3.1で追加されたHttpServletRequest#changeSessionIdメソッドを使用してセッションIDを変更する（Servlet3.1以上のコンテナでのデフォルト動作）</li><li>migrateSession: ログイン前に使用していたセッションを破棄し、新たにセッションを作成する。ログイン前にセッションに格納されていたオブジェクトは新しいセッションに引き継がれる</li><li>newSession: migrateSessionと同じ方法でセッションIDを変更するが、ログイン前に格納されていたオブジェクトは新しいセッションには引き継がれない</li><li>none: SpringSecurityはセッションIDを変更しない</li></ul></li><li><p>指定方法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">http.sessionManagement().sessionFixation().newSession();</span><br></pre></td></tr></table></figure><h4 id="9-7-4-多重ログインの制御"><a href="#9-7-4-多重ログインの制御" class="headerlink" title="9.7.4 多重ログインの制御"></a>9.7.4 多重ログインの制御</h4><ul><li>SpringSecurityは同じユーザー名（ログインID）を使った多重ログインを制御する機能を提供しているが、</li><li>SpringSecurityが提供しているデフォルト実装にはいくつかの制約や注意事項がある</li><li><p>本書では、これらの制約と注意事項について紹介するが、具体的な使い方は扱わない、リファレンス参照</p></li><li><p>SpringSecurityが提供しているデフォルト実装では、ユーザー毎にセッション情報をアプリケーションサーバーのメモリ内で管理します。</p></li><li>そのため、複数のアプリケーションサーバーを同時に実行するシステムでは利用することができません。</li><li>また、アプリケーションサーバーを停止または再起動するとメモリ内で管理していたセッション情報はクリアされます。</li><li><p>使用するアプリケーションサーバーによっては、停止または再起動時のセッション状態を復元する機能を持っているため、実際のセッション状態とSpringSecurityが管理しているセッション情報に不整合が生じる可能性がある</p></li><li><p>TODO: Redisで管理する方法探る</p></li></ul><h4 id="9-7-5-無効なセッションを使ったリクエストの検知"><a href="#9-7-5-無効なセッションを使ったリクエストの検知" class="headerlink" title="9.7.5 無効なセッションを使ったリクエストの検知"></a>9.7.5 無効なセッションを使ったリクエストの検知</h4><ul><li>SpringSecurityは無効なセッションを使ったリクエストを検知する機能を提供している</li><li>無効なセッションとして扱われるリクエストの大部分は、セッションタイムアウト後のリクエストです。</li><li>以下の例では、無効なセッションを検知した際の遷移先として <code>&quot;/error/invalidSession&quot;</code>を指定することで、この機能を有効化している</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">http.sessionManagement().invalidSessionUrl(<span class="string">"/error/invalidSession"</span>);</span><br></pre></td></tr></table></figure><h3 id="9-8-ブラウザのセキュリティ対策機能との連携"><a href="#9-8-ブラウザのセキュリティ対策機能との連携" class="headerlink" title="9.8 ブラウザのセキュリティ対策機能との連携"></a>9.8 ブラウザのセキュリティ対策機能との連携</h3><ul><li>ブラウザが提供するセキュリティ対策機能の一部は、サーバー側で、HTTPのレスポンスヘッダーを出力することで動作を制御することができる</li></ul><h4 id="9-8-1-セキュリティヘッダー出力機能の適用"><a href="#9-8-1-セキュリティヘッダー出力機能の適用" class="headerlink" title="9.8.1 セキュリティヘッダー出力機能の適用"></a>9.8.1 セキュリティヘッダー出力機能の適用</h4><ul><li>Spring3.2から追加された機能で、Spring4.0からデフォルトで適用されるようになった</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 無効にする方法</span></span><br><span class="line">    http.headers().disable();</span><br></pre></td></tr></table></figure><h4 id="9-8-2-デフォルトでサポートしているセキュリティヘッダー"><a href="#9-8-2-デフォルトでサポートしているセキュリティヘッダー" class="headerlink" title="9.8.2 デフォルトでサポートしているセキュリティヘッダー"></a>9.8.2 デフォルトでサポートしているセキュリティヘッダー</h4><ul><li><p>SpringSecurityがデフォルトでサポートしているレスポンスヘッダーは以下の５つ</p><ul><li>Cache-Control（Pragma, Expires）<ul><li>コンテンツのキャッシュ方法を支持するヘッダー</li><li>保護されたコンテンツがブラウザにキャッシュされないようにすることで、権限のないユーザーが保護されたコンテンツを閲覧できてしまうリスクを減らすことができる</li></ul></li><li>X-Frame-Options<ul><li>フレーム（<code>&lt;frame&gt;</code>または<code>&lt;iframe&gt;</code>要素）内でコンテンツの表示を許可するか否かを支持するためのヘッダー</li><li>フレーム内でコンテンツが表示されないようにすることで、クリックジャッキングと呼ばれる攻撃手法を使って機密情報を盗み取られるリスクを無くすことができる</li></ul></li><li>X-Content-Type-Options<ul><li>コンテンツの種類の決定方法を指示するためのヘッダー</li><li>一部のブラウザでは、Content-Typeヘッダーの値を無視して、コンテンツの内容を見て決定します。</li><li>コンテンツの種類を決定する際にコンテンツの内容を見ないようにすることで、クロスサイトスクリプティングを使った攻撃を受ける可能性をへらすことができます。</li></ul></li><li>X-XSS-Protection<ul><li>ブラウザのXSSフィルタ機能を使って有害なスクリプトを検知する方法を支持するためのヘッダー</li><li>XSSフィルタ機能を有効にして有害なスクリプトを検知するようにすれば、クロスサイトスクリプティングを使った攻撃を受ける可能性をへらすことができる。</li></ul></li><li>Strict-Transport-Security<ul><li>HTTPSを使ったアクセスをしたあとに、HTTPを使ってアクセスしようとした際に、HTTPSに置き換えてからアクセスすることを支持するためのヘッダー</li><li>HTTPSでアクセスした後に、HTTPが使われないようにすることで、中間者攻撃と呼ばれる攻撃手法を使って悪意のあるサイトに誘導されるリスクをへらすことができる</li></ul></li></ul></li><li><p>TODO: 攻撃手法と対策について再度整理する必要あり</p></li></ul><h4 id="9-8-3-セキュリティヘッダーの選択"><a href="#9-8-3-セキュリティヘッダーの選択" class="headerlink" title="9.8.3 セキュリティヘッダーの選択"></a>9.8.3 セキュリティヘッダーの選択</h4><ul><li>出力するセキュリティヘッダーを選択したい場合は、以下のようなBean定義を行います。</li><li>ここではSpringSecurityが提供するすべてのセキュリティヘッダーを出力する例になっていますが、実際は必要なものだけ指定する</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http.headers()</span><br><span class="line">    .defaultsDisabled()</span><br><span class="line">    .cacheControl().and()</span><br><span class="line">    .frameOptions().and()</span><br><span class="line">    .contentTypeOptions().and()</span><br><span class="line">    .xssProtection().and()</span><br><span class="line">    .httpStrictTransportSecurity();</span><br></pre></td></tr></table></figure><ul><li>不要なものだけ無効化する方法もある</li></ul><h3 id="9-9-Spring-Securityのテスト"><a href="#9-9-Spring-Securityのテスト" class="headerlink" title="9.9 Spring Securityのテスト"></a>9.9 Spring Securityのテスト</h3><ul><li>MockMvcを使用して「認証処理」や「認可処理」などのテストを行うための機能</li><li>テスト時に適用する認証情報をアノテーションで指定できる機能</li></ul><h4 id="9-9-1-Spring-Security-Testのセットアップ"><a href="#9-9-1-Spring-Security-Testのセットアップ" class="headerlink" title="9.9.1 Spring Security Testのセットアップ"></a>9.9.1 Spring Security Testのセットアップ</h4><ul><li>依存ライブラリーの追加</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// build.gradle</span></span><br><span class="line">  testImplementation <span class="string">'org.springframework.security:spring-security-test'</span></span><br></pre></td></tr></table></figure><ul><li><p>SpringSecurityのサーブレットフィルタの追加</p></li><li><p>TODO: テスト環境が作れて無いため一旦スキップする</p></li></ul><h2 id="第10章-Spring-Data-JPA"><a href="#第10章-Spring-Data-JPA" class="headerlink" title="第10章　Spring Data JPA"></a>第10章　Spring Data JPA</h2><h3 id="10-6-Repositoryの作成と利用"><a href="#10-6-Repositoryの作成と利用" class="headerlink" title="10.6 Repositoryの作成と利用"></a>10.6 Repositoryの作成と利用</h3><h4 id="10-6-4-ページネーション"><a href="#10-6-4-ページネーション" class="headerlink" title="10.6.4 ページネーション"></a>10.6.4 ページネーション</h4><ul><li>TODO: DOMAにあるかどうか</li></ul><h4 id="10-6-6-監査情報の付与"><a href="#10-6-6-監査情報の付与" class="headerlink" title="10.6.6 監査情報の付与"></a>10.6.6 監査情報の付与</h4><ul><li>TODO: DOMAにあるかどうか</li></ul><h2 id="第11章-Spring-＋-MyBatis"><a href="#第11章-Spring-＋-MyBatis" class="headerlink" title="第11章　Spring ＋ MyBatis"></a>第11章　Spring ＋ MyBatis</h2><ul><li>XMLに記述しないといけないので採用したくない</li></ul><h2 id="第12章-Spring＋Thymeleaf"><a href="#第12章-Spring＋Thymeleaf" class="headerlink" title="第12章　Spring＋Thymeleaf"></a>第12章　Spring＋Thymeleaf</h2><ul><li>SpringBootを始め、ViewにJSPではなくテンプレートエンジンであるThymeleafを使用するケースが増えている</li><li>まずはThymeleaf自体や、Springとセットで開発する際に欠かせない連携ライブラリーの概要を紹介</li></ul><h3 id="12-1-Thymeleafとは"><a href="#12-1-Thymeleafとは" class="headerlink" title="12.1 Thymeleafとは"></a>12.1 Thymeleafとは</h3><ul><li>Thymeleafは、Webアプリケーションと親和性の高いテンプレートエンジン</li><li><p>テンプレートエンジンとは</p><ul><li>雛形となるドキュメント（テンプレート）に対して、可変データを埋め込むことで動的にドキュメントを生成する仕組み</li><li>この仕組は、MVCフレームワークのModelとViewを分割する考え方と親和性が高く、しばしばMVCフレームワークのVIEWとし利用される</li></ul></li><li><p>特徴</p><ul><li>XHTMLやHTML5に準拠した形で記述できること</li></ul></li><li><p>JSPはブラウザが認識できないタグライブラリなどが含まれるため、開発中のJSPを直接ブラウザ上で正確に表示させることが難しいという問題があった</p></li><li><p>一方ThymeleafのテンプレートはHTML5に準拠しているため、テンプレートをブラウザで直接表示させたり。HTMLをデザイナーとプログラマの間で共有することができる</p></li><li><p>MEMO: パーツをIncludeする際はうまく表示できない問題はあると思う</p></li></ul><h4 id="12-1-1-Thymeleafのテンプレート"><a href="#12-1-1-Thymeleafのテンプレート" class="headerlink" title="12.1.1 Thymeleafのテンプレート"></a>12.1.1 Thymeleafのテンプレート</h4><p>ThymeleafはXHTMLやHTML5などで書かれたテンプレートをDOMに変換してから処理を行う仕組みになっている<br>「処理対象のDOMノード」と「DOMノードに適用する処理」をthネームスペースの属性（th属性）を使用して指定します。</p><p>th属性が指定されているDOMノードは「プロセッサ」と呼ばれるコンポーネントによってDOM操作（追加、削除、変更）が行われる。th属性の属性値には、OGNL（Object-Graph Navigation Language）と呼ばれる式言語を指定でき、式の中から、ユーザー定義のオブジェクトやThymeleafが提供する暗黙オブジェクトにアクセスすることができる</p><ul><li><p>以下３つのことをDialectと呼ぶ</p><ul><li>DOM操作を行うプロセッサ</li><li>th属性の属性値に指定された式を解釈するコンポーネント</li><li>暗黙オブジェクトを生成するコンポーネント<ul><li>→デフォルトでは、StandardDialectクラスが使用される</li></ul></li></ul></li><li><p>Dialectは拡張可能な仕組みになっており、本書で紹介するthymeleaf-spring4を使う場合は、StandardDiarectクラスを継承した、SpringStandardDialectクラスが使用される</p></li></ul><h4 id="12-1-2-ThymeleafとSpringの連携"><a href="#12-1-2-ThymeleafとSpringの連携" class="headerlink" title="12.1.2 ThymeleafとSpringの連携"></a>12.1.2 ThymeleafとSpringの連携</h4><ul><li>連携する場合、Thymeleafが提供するthymeleaf-spring4モジュールを利用</li><li><p>SpringMVCがJSP向けに提供しているタグライブラリと同様の機能を、Thymeleafで利用することができる</p></li><li><p>実現できる機能</p><ul><li>Thymeleafが管理するテンプレートをSpringMVCのViewとして扱うことができる</li><li>テンプレート内でSpringELを利用することができる</li><li>テンプレートと、フォームクラスおよび入力値チェック結果のバインドが可能となる</li><li>Springが管理するメッセージリソースを利用し、国際化対応のメッセージを表示することができる</li></ul></li></ul><h3 id="12-2-Spring-Thymeleafのセットアップ"><a href="#12-2-Spring-Thymeleafのセットアップ" class="headerlink" title="12.2 Spring + Thymeleafのセットアップ"></a>12.2 Spring + Thymeleafのセットアップ</h3><h4 id="12-2-1-ライブラリのセットアップ"><a href="#12-2-1-ライブラリのセットアップ" class="headerlink" title="12.2.1 ライブラリのセットアップ"></a>12.2.1 ライブラリのセットアップ</h4><ul><li>thymeleaf-spring4を入れる</li></ul><h4 id="12-2-2-SpringとThymeleafを連携するための設定"><a href="#12-2-2-SpringとThymeleafを連携するための設定" class="headerlink" title="12.2.2 SpringとThymeleafを連携するための設定"></a>12.2.2 SpringとThymeleafを連携するための設定</h4><ul><li>SringBootだと書かなくても動くっぽいけど明示する意味で</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(ThymeleafConfig.class) <span class="comment">// Thymeleafを使用することを明示</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThymeleafConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ClassLoaderTemplateResolver <span class="title">templateResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ClassLoaderTemplateResolver resolver = <span class="keyword">new</span> ClassLoaderTemplateResolver();</span><br><span class="line">    resolver.setPrefix(<span class="string">"/WEB-INF/templates/"</span>);</span><br><span class="line">    resolver.setSuffix(<span class="string">".html"</span>);</span><br><span class="line">    resolver.setTemplateMode(<span class="string">"HTML5"</span>);</span><br><span class="line">    resolver.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">    <span class="keyword">return</span> resolver;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SpringTemplateEngine <span class="title">templateEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SpringTemplateEngine templateEngine = <span class="keyword">new</span> SpringTemplateEngine();</span><br><span class="line">    templateEngine.setTemplateResolver(templateResolver());</span><br><span class="line">    <span class="keyword">return</span> templateEngine;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ViewResolver <span class="title">viewResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThymeleafViewResolver viewResolver = <span class="keyword">new</span> ThymeleafViewResolver();</span><br><span class="line">    viewResolver.setTemplateEngine(templateEngine());</span><br><span class="line">    viewResolver.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">    <span class="keyword">return</span> viewResolver;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-3-Thymeleafを利用したViewの実装"><a href="#12-3-Thymeleafを利用したViewの実装" class="headerlink" title="12.3 Thymeleafを利用したViewの実装"></a>12.3 Thymeleafを利用したViewの実装</h3><h4 id="12-3-1-はじめてのThymeleaf"><a href="#12-3-1-はじめてのThymeleaf" class="headerlink" title="12.3.1 はじめてのThymeleaf"></a>12.3.1 はじめてのThymeleaf</h4><ul><li>Thymeleafを利用したViewへの変更</li><li>テンプレートの実装</li></ul><h4 id="12-3-2-テキストの出力"><a href="#12-3-2-テキストの出力" class="headerlink" title="12.3.2 テキストの出力"></a>12.3.2 テキストの出力</h4><ul><li>th:text — 属性値に指定した値をXHTMLサニタイジングして出力する<ul><li>ユーザからの入力を表示する際はこちら</li></ul></li><li>th:utext — 属性値に指定した値をXHTMLサニタイジングせずに出力する<ul><li>プロパティファイルでHTML要素を使用して意図的に装飾しているような場合は、th:utext属性を使用してXHTMLサニタイジングせずに出力する必要がある</li></ul></li></ul><h4 id="12-3-3-式の構文"><a href="#12-3-3-式の構文" class="headerlink" title="12.3.3 式の構文"></a>12.3.3 式の構文</h4><ul><li>基本的な式<ul><li>変数式</li><li>選択変数式</li><li>メッセージ式：これは利用しておきたい</li><li>リンクURL式</li></ul></li><li>リテラル</li><li>基本的な演算子</li><li>テキスト演算子</li><li>条件演算子</li></ul><h4 id="12-3-4-th属性による属性値の設定"><a href="#12-3-4-th属性による属性値の設定" class="headerlink" title="12.3.4 th属性による属性値の設定"></a>12.3.4 th属性による属性値の設定</h4><ul><li><p>Thymeleafのテンプレートエンジンとしての機能は、th属性に指定された式を解釈し、HTMLの各要素の属性値を設定または上書きすることです。</p></li><li><p>特定の属性に値を設定する方法</p></li><li>現在の属性値の前後に値を追加する方法</li><li>存在有無が重要な属性の出力を制御する方法</li><li>複数の属性に同じ値を設定する方法：AltとTitleに同じ値を入れたりとか</li><li>任意の属性に値を設定する方法：独自データ属性に値を設定したい場合に使用する<ul><li><code>&lt;button th:attr=&quot;data-product-id=${product.id}&quot;&gt;削除&lt;/button&gt;</code></li></ul></li></ul><h4 id="12-3-5-HTML要素の出力制御"><a href="#12-3-5-HTML要素の出力制御" class="headerlink" title="12.3.5 HTML要素の出力制御"></a>12.3.5 HTML要素の出力制御</h4><p>ここまでth属性を使ってHTML属性の属性値を動的に設定する方法を見てきましたが、<br>動的にHTML要素の出力を制御する必要が出てくる場合がある</p><ul><li>例えば、特定の条件下の場合のみメッセージを表示したり、</li><li>データの件数だけ行を追加して出力したりする場合などです。</li><li><p>JSPでは、それらの専用タグライブラリが用意されていましたが、Thymeleafでも相当する機能がth属性として提供されている</p></li><li><p>条件による出力有無の制御</p><ul><li>th:if</li><li>th:unless</li><li>th:switch</li><li>th:case</li></ul></li><li><p>繰り返し出力の制御</p><ul><li>th:each<ul><li>java.util.Listの実装クラス</li><li>java.util.Iterableの実装クラス</li><li>java.util.Mapの実装クラス</li><li>配列</li></ul></li></ul></li></ul><h4 id="12-3-6-インライン記述"><a href="#12-3-6-インライン記述" class="headerlink" title="12.3.6 インライン記述"></a>12.3.6 インライン記述</h4><p>th属性を利用しない方法であるインライン記述について説明</p><ul><li><p><code>[[ ${user.name} ]]</code>でかけるよ</p></li><li><p>インライン記述はデフォルトで無効になっている</p></li><li><p>有効にするには、 <code>th:inline</code>属性をインライン記述を利用する要素、もしくは親要素に付与する必要がある</p></li><li><p>インライン記述のでメリット</p><ul><li>テンプレートファイルをブラウザ上で直接表示した際に、インライン記述のテキストがそのまま表示されてしまう点</li><li>th:textの用にサンプルデータを表示することができないため、デザイナーとの分業に支障をきたす可能性がある</li></ul></li><li><p>メモ</p><ul><li>インライン記述はJavascriptなどのスクリプト内でも利用することができる</li><li>これを利用すると、テンプレートをブラウザで静的に表示した場合や、アプリケーションサーバーにデプロイして動的に表示した場合、その両方においてスクリプトを正常に動作させられる。</li></ul></li><li><p>MEMO: 結論（個人的な）</p><ul><li>インライン記述は原則禁止したほうがよいと思う（コーディング規約などで明記すべき）</li></ul></li></ul><h4 id="12-3-7-コメント"><a href="#12-3-7-コメント" class="headerlink" title="12.3.7 コメント"></a>12.3.7 コメント</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">  このブロックはThymeleafの処理後もテンプレートに残ります。</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--/*</span></span><br><span class="line"><span class="comment">  このブロックはThymeleafの処理後に削除される。</span></span><br><span class="line"><span class="comment">*/--&gt;</span></span><br></pre></td></tr></table></figure><h4 id="12-3-8-Springとの連携"><a href="#12-3-8-Springとの連携" class="headerlink" title="12.3.8 Springとの連携"></a>12.3.8 Springとの連携</h4><p>本項では、thymleaf-springが提供しているSpringとの連携機能に焦点を当てる</p><ul><li><p>フォームオブジェクトのバインディング</p><ul><li>th:object属性</li><li>th:field属性</li></ul></li><li><p>入力エラーの表示</p><ul><li>SpringMVCの入力チェック機能で発生したエラーの表示は、<ul><li>th:errors属性 — エラーメッセージの出力対象を指定するための属性</li><li>th:errorclass属性 — エラー時に適用するCSSを指定するための属性</li><li>th:fieldsオブジェクト — エラー情報にアクセスするための便利なメソッドを提供するオブジェクト<ul><li>を使用して行う</li></ul></li></ul></li></ul></li><li><p>TODO: エラー処理について設計する必要あり</p></li><li><p>SpELの利用</p><ul><li>Thymeleafは数式をOGNLとして解釈しますが、thymeleaf-springを利用すると、</li><li>変数式はSpELとして解釈されます。</li><li>これにより、テンプレート内から、DIコンテナ内に登録されているBeanにアクセスできるようになる</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;@appSettings.passwordValidDays&#125;"</span>&gt;</span>60<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- @Bean名でアクセスできる --&gt;</span></span><br></pre></td></tr></table></figure><ul><li>ConversionServiceとの連携<ul><li>SpringMVCに適用されているConversionServiceと連携して、値の型変換を行うことができる</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppSettings</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Value</span>(<span class="string">"$&#123;vasicPostage:1250&#125;"</span>)</span><br><span class="line">  <span class="meta">@NumberFormat</span>(style = NumberFormat.Style.NUMBER)</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> basicOneDayCost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;@appSettings.basicOneDayCost&#125;"</span>&gt;</span>1300<span class="tag">&lt;/<span class="name">span</span>&gt;</span>円</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;&#123;@appSettings.basicOneDayCost&#125;&#125;"</span>&gt;</span>1300<span class="tag">&lt;/<span class="name">span</span>&gt;</span>円</span><br></pre></td></tr></table></figure><h4 id="12-3-9-テンプレートの共通化"><a href="#12-3-9-テンプレートの共通化" class="headerlink" title="12.3.9 テンプレートの共通化"></a>12.3.9 テンプレートの共通化</h4><ul><li>テンプレートのフラグメント化<ul><li>共通な内容を別ファイルに切り出す</li></ul></li><li><p>テンプレートのレイアウト化</p><ul><li>複数のテンプレートで同じデザインレイアウトを適用する場合は、通常、共通的なレイアウトを定義して共有することになる。このような場合に有効なライブラリとして、<code>Thymeleaf Layout Dialect</code>がある</li></ul></li><li><p>テンプレートのフラグメント化</p><ul><li>テンプレートの一部を分割して別ファイルに切り出すことができる</li><li>ヘッダー、フッター、メニューがフラグメントとしてよく利用されるが、特定のUIコンポーネントをフラグメントとして切り出すことも可能<ul><li>フラグメントの利用方法<ul><li>フラグメントの定義と参照という２つの作業が必要になる</li><li>定義方法には以下の２つの方法がある<ul><li>Thymeleafのth:fragment属性を利用したフラグメント定義　★個人的にこっちがわかりやすくていいと思う</li><li>CSSセレクタと同様、id属性を利用したフラグメント定義</li></ul></li><li>定義したフラグメントを読み込む方法として以下の２つ<ul><li>Thymeleafのth:include属性を利用したフラグメントのインクルード</li><li>Thymeleafのth:replace属性を利用したフラグメントのち缶</li></ul></li></ul></li></ul></li></ul></li><li><p>テンプレートのレイアウト化</p><ul><li>Thymeleaf Layout Dialectを利用したテンプレートのレイアウト化について説明</li></ul></li><li><p>セットアップ</p><ul><li><code>thymeleaf-layout-dialect</code>のリポジトリ追加</li><li>コンフィギュレーションクラスの実装</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SpringTemplateEngine <span class="title">templateEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  SpringTemplateEngine templateEngine = <span class="keyword">new</span> SpringTemplateEngine();</span><br><span class="line">  templateEngine.setDialect(<span class="keyword">new</span> LayoutDialect());</span><br><span class="line">  templateEngine.setTemplateResolver(templateResolver());</span><br><span class="line">  <span class="keyword">return</span> templateEngine;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Thymeleaf Layout DialectによるViewの実装</p><ul><li>共通レイアウトとなるテンプレートを「Decorator」</li><li>共通レイアウトを適用する側の個別のテンプレートを「Fragment」と呼ぶ</li></ul></li><li><p>MEMO: 画面の全体像がわかりづらくなりやすいので、この方法は採用したくないため割愛</p></li></ul><h4 id="12-3-10-SpringSecurityとの連携"><a href="#12-3-10-SpringSecurityとの連携" class="headerlink" title="12.3.10 SpringSecurityとの連携"></a>12.3.10 SpringSecurityとの連携</h4><ul><li>SpringSecurityが提供する画面表示に関する機能をThymeleafで利用するためには、</li><li>SpringSecurityDialectを利用します。</li><li><p>以下の機能</p><ul><li>認証情報にアクセスする機能を持つ sec:authentication属性を提供</li><li>SpringSecurity expression を利用した認可処理と同等の機能を持つ sec:authorize属性を提供</li><li>URLベースの認可処理を行う sec:authorize-ur属性を提供する</li><li>ACL(Access Control List)を利用した認可処理を行う sec:authorize-acl属性を提供</li><li>CSRFトークンにアクセスする機能を提供</li></ul></li><li><p>SpringSecurityDialectのセットアップ</p><ul><li><code>thymeleaf-extras-springsecurity4</code></li></ul></li><li><p>認証情報へのアクセス</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:sec</span>=<span class="string">"http://www.thymeleaf.ort/extras/spring-security"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">th:with</span>=<span class="string">"title=トップページ"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">sec:authentication</span>=<span class="string">"principal.username"</span>&gt;</span>テストユーザ名<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>画面項目への認可</p><ul><li>適用する画面項目とアクセスポリシーの指定<ul><li><code>sec:authorize=&quot;hasRole(&#39;ADMIN&#39;)&quot;</code>属性を付与</li><li>Trueの場合、HTMLを表示</li></ul></li><li>Webリソースとして指定したアクセスポリシーとの連動<ul><li><code>sec:authorize-url=&quot;/admin/accounts&quot;</code>にアクセスできることを条件として表示非表示を設定している</li></ul></li></ul></li><li><p>CSRFトークンへのアクセス</p><ul><li>Spring Security Dialectを適用するだけでOK hidden項目としてHTMLに埋め込まれます</li><li>ajax通信の際は取得してあげる必要がある<ul><li>headerのmeta要素に設定しといて、JSで取得してあげる感じにする<ul><li>TODO: 取得してPOSTする処理は実装考えてみる</li></ul></li></ul></li></ul></li></ul><h4 id="12-3-11-JSR-310-Date-and-Time-APIの利用"><a href="#12-3-11-JSR-310-Date-and-Time-APIの利用" class="headerlink" title="12.3.11 JSR 310: Date and Time APIの利用"></a>12.3.11 JSR 310: Date and Time APIの利用</h4><ul><li><p>Thymeleafは、テンプレート内でJSR310:Date and TimeAPIのオブジェクトを操作するための機能を標準ではサポートしておらず、Thymeleafが提供する拡張ライブラリが必要になる</p></li><li><p>依存ライブラリの追加</p><ul><li>thymeleaf-extras-java8timeを利用する</li><li>なお、thymeleaf-extras-java8timeはSpringIO Platformで管理されていないため、バージョンの指定が必要</li></ul></li><li><p>Bean定義の追加</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SpringTemplateEngine <span class="title">templateEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  SpringTemplateEngine templateEngine = <span class="keyword">new</span> SpringTemplateEngine();</span><br><span class="line">  templateEngine.setDialect(<span class="keyword">new</span> Java8TimeDialect());</span><br><span class="line">  templateEngine.setTemplateResolver(templateResolver());</span><br><span class="line">  <span class="keyword">return</span> templateEngine;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ユーティリティオブジェクト（temporals）を利用</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span> <span class="attr">th:text</span>=<span class="string">"|$&#123;#temporals.format(date, 'yyyy/mm/dd')&#125;の会議室|"</span>&gt;</span>2020/05/19の会議室<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="第13章-Spring-Boot"><a href="#第13章-Spring-Boot" class="headerlink" title="第13章　Spring Boot"></a>第13章　Spring Boot</h2><p>機能が豊富な事による課題がある<br>どう組み合わせていいかわからなかったり、ちょっとしたWebアプリケーションを作成するだけでも、数多くの設定が必要であったりする点です。</p><p>SpringBootを利用することでこられの課題を解決することができる</p><h3 id="13-1-SpringBootとは"><a href="#13-1-SpringBootとは" class="headerlink" title="13.1 SpringBootとは"></a>13.1 SpringBootとは</h3><ul><li><p>SpringBoot</p><ul><li>２０１３年　　：開発開始</li><li>２０１４年４月：1.0リリース</li><li>２０１６年６月：1.3.5</li><li>２０２０年５月：2.3.0</li></ul></li><li><p>SpringBootを使えば、何も設定しなくてもデフォルトで様々な機能が利用可能</p></li><li>XMLまたはJavaConfigによるBean定義、ログの設定、Servletの設定などが不要になる</li><li>アプリケーションサーバーをデプロイする必要もなくなり、Javaのmainメソッドを実行すればアプリケーションを実行できる</li></ul><h4 id="13-1-1-SpringBootで作るHello-Worldアプリケーション"><a href="#13-1-1-SpringBootで作るHello-Worldアプリケーション" class="headerlink" title="13.1.1 SpringBootで作るHello Worldアプリケーション"></a>13.1.1 SpringBootで作るHello Worldアプリケーション</h4><h4 id="13-1-2-AutoConfigureに夜自動設定"><a href="#13-1-2-AutoConfigureに夜自動設定" class="headerlink" title="13.1.2 AutoConfigureに夜自動設定"></a>13.1.2 AutoConfigureに夜自動設定</h4><ul><li>自動設定の詳細を知りたい場合は、spring-boot-autoconfigureプロジェクトの◯◯AutoConfigurationクラスのソースを読むことをおすすめします。</li></ul><h4 id="13-1-3-Starterによる依存ライブラリの解決"><a href="#13-1-3-Starterによる依存ライブラリの解決" class="headerlink" title="13.1.3 Starterによる依存ライブラリの解決"></a>13.1.3 Starterによる依存ライブラリの解決</h4><ul><li>starterライブラリの説明</li></ul><h4 id="13-1-4-実行可能jarの作成"><a href="#13-1-4-実行可能jarの作成" class="headerlink" title="13.1.4 実行可能jarの作成"></a>13.1.4 実行可能jarの作成</h4><ul><li>実行可能jarとしてパッケージングされる</li></ul><h3 id="13-2-SpringBootでSpringMVC"><a href="#13-2-SpringBootでSpringMVC" class="headerlink" title="13.2 SpringBootでSpringMVC"></a>13.2 SpringBootでSpringMVC</h3><h4 id="13-2-1-RESTful-Webサービスの作成"><a href="#13-2-1-RESTful-Webサービスの作成" class="headerlink" title="13.2.1 RESTful Webサービスの作成"></a>13.2.1 RESTful Webサービスの作成</h4><h4 id="13-2-2-画面遷移型アプリケーションの作成"><a href="#13-2-2-画面遷移型アプリケーションの作成" class="headerlink" title="13.2.2 画面遷移型アプリケーションの作成"></a>13.2.2 画面遷移型アプリケーションの作成</h4><ul><li>SpringBootの自動設定では、TemplateResolverがビュー名につけるプレフィックスとサフィックスのデフォルト値は、</li><li><p>それぞれ、<code>classpath:/templates/</code>と<code>.html</code>になる</p></li><li><p>テンプレートからメッセージを取得する方法</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span> <span class="attr">th:text</span>=<span class="string">"#&#123;app.title&#125;"</span>&gt;</span> <span class="comment">&lt;!-- $&#123;変数名&#125;ではなく#&#123;メッセージキー名&#125;--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="13-3-SpringBootでデータアクセス"><a href="#13-3-SpringBootでデータアクセス" class="headerlink" title="13.3 SpringBootでデータアクセス"></a>13.3 SpringBootでデータアクセス</h3><h4 id="13-3-1-SpringJDBC"><a href="#13-3-1-SpringJDBC" class="headerlink" title="13.3.1 SpringJDBC"></a>13.3.1 SpringJDBC</h4><ul><li><p>これまで必要だったがSpringJDBCでは不要な定義</p><ul><li>データソースの定義</li><li>トランザクションマネージャの定義</li><li>JdbcTemplateの定義</li></ul></li><li><p>SpringBootのデフォルトの挙動としてクラスパス直下に<code>schema.sql</code>が存在すると起動時にそのSQLファイルを実行</p></li></ul><h4 id="13-3-2-Spring-Data-JPA"><a href="#13-3-2-Spring-Data-JPA" class="headerlink" title="13.3.2 Spring Data JPA"></a>13.3.2 Spring Data JPA</h4><h4 id="13-3-3-MyBatis"><a href="#13-3-3-MyBatis" class="headerlink" title="13.3.3 MyBatis"></a>13.3.3 MyBatis</h4><h4 id="13-3-4-コネクションプールライブラリの変更"><a href="#13-3-4-コネクションプールライブラリの変更" class="headerlink" title="13.3.4 コネクションプールライブラリの変更"></a>13.3.4 コネクションプールライブラリの変更</h4><ul><li><p>SpringBootではDatasourceを定義する必要はなく、自動で生成されます。コネクションプーリングの仕組みも自動で決まり、以下のライブラリのうちクラスパス上にあるものが利用されます。</p><ul><li>TomcatJDBC</li><li>HikariCP</li><li>Commons DBCP</li><li>Commons DBCP2</li></ul></li><li><p>TODO: HikariCPが一番速いとのこと</p></li></ul><h3 id="13-4-SpringBootでSpring-Security"><a href="#13-4-SpringBootでSpring-Security" class="headerlink" title="13.4 SpringBootでSpring Security"></a>13.4 SpringBootでSpring Security</h3><ul><li>Spring Security用のプロジェクトも当然用意されています。</li></ul><h4 id="13-4-1-Basic認証"><a href="#13-4-1-Basic認証" class="headerlink" title="13.4.1 Basic認証"></a>13.4.1 Basic認証</h4><ul><li>デフォルトで有効になるらしい</li><li>デフォルトユーザーはuser</li><li>パスワードはランダムに設定される</li></ul><h4 id="13-4-2-認証・認可のカスタマイズ"><a href="#13-4-2-認証・認可のカスタマイズ" class="headerlink" title="13.4.2 認証・認可のカスタマイズ"></a>13.4.2 認証・認可のカスタマイズ</h4><ul><li>SpringSecruityの認証・認可の設定は<code>org.springframework.security.config.annotation.web.configuration.WebSecrityConfigurerAdapter</code>を用いて行う</li></ul><h3 id="13-5-Spring-Bootで型安全なプロパティ設定"><a href="#13-5-Spring-Bootで型安全なプロパティ設定" class="headerlink" title="13.5 Spring Bootで型安全なプロパティ設定"></a>13.5 Spring Bootで型安全なプロパティ設定</h3><p>application.propertiesから値を取得できる</p><ul><li>TODO: EnumによるConst管理とどっちがいいか<ul><li>メッセージのとり方確認</li><li>定数管理方法のベストプラクティス</li></ul></li></ul><h4 id="13-5-1-ConfigurationPropertiesを用いたプロパティの設定"><a href="#13-5-1-ConfigurationPropertiesを用いたプロパティの設定" class="headerlink" title="13.5.1 @ConfigurationPropertiesを用いたプロパティの設定"></a>13.5.1 @ConfigurationPropertiesを用いたプロパティの設定</h4><ul><li>プロパティを多用するSpringBootでは、安全にプロパティを扱うための仕組みとして、</li><li><p><code>@ConfigurationProperties</code>アノテーションが用意されている</p></li><li><p>TODO: プロパティ管理はこれが良さそう</p></li></ul><h4 id="13-5-2-Bean-Validationに夜プロパティ値のチェック"><a href="#13-5-2-Bean-Validationに夜プロパティ値のチェック" class="headerlink" title="13.5.2 Bean Validationに夜プロパティ値のチェック"></a>13.5.2 Bean Validationに夜プロパティ値のチェック</h4><ul><li>プロパティ値も、起動時にBindされる際、<code>@NotEmpty</code>などで値の検証ができる</li></ul><h4 id="13-5-3-IDEによるプロパティの補完"><a href="#13-5-3-IDEによるプロパティの補完" class="headerlink" title="13.5.3 IDEによるプロパティの補完"></a>13.5.3 IDEによるプロパティの補完</h4><ul><li><code>@ConfigurationProperties</code>を用いて定義したプロパティはIDEで補完が効く</li><li><p>補完させるためにプロパティのメタ情報を生成する必要がある</p></li><li><p>spring-boot-configuration-processorの説明</p></li><li>SpringBootでプロパティを外部化する際は積極的に使用していくとよい</li></ul><h3 id="13-6-SpringBootAcruatorで運用機能強化"><a href="#13-6-SpringBootAcruatorで運用機能強化" class="headerlink" title="13.6 SpringBootAcruatorで運用機能強化"></a>13.6 SpringBootAcruatorで運用機能強化</h3><ul><li>SpringBootでは開発を容易にする機能が提供されるだけでなく、アプリケーションの運用面を考慮した機能も提供されている</li><li><p>これを提供するのがSpringBootActuator</p></li><li><p>これだけでアプリケーションの状態を検査するためのエンドポイント（HTTP,JMX,SSH）が追加されたり、ヘルスチェック機能やメトリクス取得機能が有効になる</p></li><li><p>TODO: 有効にして活用したい</p></li></ul><h4 id="13-6-1-HTTPエンドポイントの追加"><a href="#13-6-1-HTTPエンドポイントの追加" class="headerlink" title="13.6.1 HTTPエンドポイントの追加"></a>13.6.1 HTTPエンドポイントの追加</h4><ul><li><p>HTTPエンドポイント</p><ul><li>/autoconfig</li><li>/beans</li><li>/env</li><li>/configprops</li><li>/dump</li><li>/health</li><li>/info</li><li>/logfile</li><li>/metrics</li><li>/mappings</li><li>/shutdown</li><li>/trace</li><li>/flyway</li><li>/liquibase</li></ul></li><li><p>エンドポイントのコンテキストパスやポート番号などはプロパティを使用して変更できる</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">management.context-path=/manage</span><br><span class="line">management.port=8081</span><br><span class="line">management.address=127.0.0.1 # localhostからのみアクセスを許可する</span><br><span class="line"></span><br><span class="line"># 個別のエンドポイントの有効無効を次のプロパティで設定</span><br><span class="line">endpoints.shutdown.enabled=true</span><br><span class="line">endpoints.mapping.enabled=false</span><br><span class="line">endpoints.trace.enabled=false</span><br><span class="line"></span><br><span class="line"># エンドポイントはHTTPだけでなくJMXでもアクセスできる これらの無効にもできる</span><br><span class="line">management.port=-1 # HTTPエンドポイントを無効にする</span><br><span class="line">endpoints.jmx.enabled=false # JMXエンドポイントを無効にする</span><br></pre></td></tr></table></figure><h4 id="13-6-2-ヘルスチェック"><a href="#13-6-2-ヘルスチェック" class="headerlink" title="13.6.2 ヘルスチェック"></a>13.6.2 ヘルスチェック</h4><ul><li>SpringBootActuatorはヘルスチェック機能を持っている</li></ul><h4 id="13-6-3-メトリクス"><a href="#13-6-3-メトリクス" class="headerlink" title="13.6.3 メトリクス"></a>13.6.3 メトリクス</h4><ul><li>SpringBootActuatorはメトリクス取得機能も備えている</li><li><p>次の２つのメトリクスがサポートされている</p><ul><li>gauge: 絶対値を記録する</li><li>counter: 差分値を記録する</li></ul></li><li><p>TODO: メトリクスは収集して管理できる用にしておく</p></li></ul><h2 id="第14章-チュートリアル"><a href="#第14章-チュートリアル" class="headerlink" title="第14章　チュートリアル"></a>第14章　チュートリアル</h2><ul><li>会議室予約システムを作成していく手順を記載</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring徹底入門&quot;&gt;&lt;a href=&quot;#Spring徹底入門&quot; class=&quot;headerlink&quot; title=&quot;Spring徹底入門&quot;&gt;&lt;/a&gt;Spring徹底入門&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;目次&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第1章　Spring Fr
      
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="教科書" scheme="http://yoursite.com/tags/%E6%95%99%E7%A7%91%E6%9B%B8/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/uncategorized/2020-04_Java%E3%81%AB%E3%82%88%E3%82%8B%E9%96%A2%E6%95%B0%E5%9E%8B%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0Java8%E3%83%A9%E3%83%A0%E3%83%80%E5%BC%8F%E3%81%A8Stream/"/>
    <id>http://yoursite.com/uncategorized/2020-04_Javaによる関数型プログラミングJava8ラムダ式とStream/</id>
    <published>2020-04-26T04:00:25.602Z</published>
    <updated>2020-04-29T15:07:44.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Javaによる関数型プログラミングJava8ラムダ式とStream"><a href="#Javaによる関数型プログラミングJava8ラムダ式とStream" class="headerlink" title="Javaによる関数型プログラミングJava8ラムダ式とStream"></a>Javaによる関数型プログラミングJava8ラムダ式とStream</h1><ul><li>著者：vankat subramaniam</li><li>訳：株式会社プログラミングシステム社</li><li>2014年10月 発行</li><li>オライリー本</li></ul><h2 id="まえがき"><a href="#まえがき" class="headerlink" title="まえがき"></a>まえがき</h2><h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><h3 id="対象者"><a href="#対象者" class="headerlink" title="対象者"></a>対象者</h3><ul><li>Java5経験者</li><li>他の言語で関数型プログラミングを行っていて、Javaで実施したい人</li><li>すでにラムダ式に詳しい人は、チームメンバーのトレーニングに使用できる</li></ul><h3 id="本書の内容"><a href="#本書の内容" class="headerlink" title="本書の内容"></a>本書の内容</h3><ul><li>最初から最後まで通して読むことをおすすめする（前の章で紹介した内容を後ろの章で使ってる）</li></ul><h3 id="使用するJavaのバージョン"><a href="#使用するJavaのバージョン" class="headerlink" title="使用するJavaのバージョン"></a>使用するJavaのバージョン</h3><ul><li><code>Java8</code>が必要</li></ul><h3 id="サンプルコードの読み方"><a href="#サンプルコードの読み方" class="headerlink" title="サンプルコードの読み方"></a>サンプルコードの読み方</h3><ul><li>サンプル<ul><li><a href="https://pragprog.com/titles/vsjava8/source_code" target="_blank" rel="noopener">https://pragprog.com/titles/vsjava8/source_code</a></li></ul></li></ul><h3 id="オンラインリソース"><a href="#オンラインリソース" class="headerlink" title="オンラインリソース"></a>オンラインリソース</h3><ul><li>サンプルコード<ul><li><a href="https://pragprog.com/book/vsjava8/functional-programming-in-java" target="_blank" rel="noopener">https://pragprog.com/book/vsjava8/functional-programming-in-java</a></li></ul></li></ul><h2 id="1章-Hello、ラムダ式"><a href="#1章-Hello、ラムダ式" class="headerlink" title="1章　Hello、ラムダ式"></a>1章　Hello、ラムダ式</h2><h3 id="1-1-考え方を変える"><a href="#1-1-考え方を変える" class="headerlink" title="1.1 考え方を変える"></a>1.1 考え方を変える</h3><ul><li>ラムダ式の紹介</li></ul><h3 id="1-2-関数型のコードによる大きな利益"><a href="#1-2-関数型のコードによる大きな利益" class="headerlink" title="1.2 関数型のコードによる大きな利益"></a>1.2 関数型のコードによる大きな利益</h3><h3 id="1-3-なぜ関数型で記述するのか"><a href="#1-3-なぜ関数型で記述するのか" class="headerlink" title="1.3 なぜ関数型で記述するのか"></a>1.3 なぜ関数型で記述するのか</h3><h3 id="1-4-革命ではなく、進化"><a href="#1-4-革命ではなく、進化" class="headerlink" title="1.4 革命ではなく、進化"></a>1.4 革命ではなく、進化</h3><h3 id="1-5-簡単にするためのほんの少しの砂糖"><a href="#1-5-簡単にするためのほんの少しの砂糖" class="headerlink" title="1.5 簡単にするためのほんの少しの砂糖"></a>1.5 簡単にするためのほんの少しの砂糖</h3><h3 id="1-6-まとめ"><a href="#1-6-まとめ" class="headerlink" title="1.6 まとめ"></a>1.6 まとめ</h3><ul><li>第一章はラムダ式の紹介をしていたので流し読み</li></ul><h2 id="2章-コレクションの使用"><a href="#2章-コレクションの使用" class="headerlink" title="2章　コレクションの使用"></a>2章　コレクションの使用</h2><h3 id="2-1-リストをイテレート"><a href="#2-1-リストをイテレート" class="headerlink" title="2.1 リストをイテレート"></a>2.1 リストをイテレート</h3><ul><li>今までの書き方から徐々にエレガントに進化させていく</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自殺点パターンと呼ぶ</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; friends.size(); i++) &#123;</span><br><span class="line">      System.out.println(friends.get(i));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 冗長でエラーが発生しやすいから</span></span><br><span class="line"><span class="comment">// &lt;i だったかな？ &lt;=i だったかな？と悩む</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上記よりは儀式が少なくなっている</span></span><br><span class="line"><span class="comment">// 特定のインデックスに対する操作がなければ、上記より優れているパターン</span></span><br><span class="line">    <span class="keyword">for</span>(String name : friends) &#123;</span><br><span class="line">      System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// これら両方とも命令形のコードであり、モダンなJavaでは捨て去ることができる</span></span><br></pre></td></tr></table></figure><ul><li><p>関数型へ移行を進める理由</p><ul><li>forループは本質的にシーケンシャルであり、並列化が極めて難しい</li><li>このようなループはポリモーフィックではなく、命令した通りのことを実行される。コレクションに対して（ポリモーフィックな処理を行う）メソッドを呼び出すのではなく、forループに渡している</li><li>設計レベルで、コードは「伝えろ、聞くな」という原則を破っている。forループではイテレーションの詳細をライブラリに任せるのではなく、特定のイテレーション処理を実行するよう要求している</li></ul></li><li><p>Tell, Don’t Ask <a href="https://www.jabba.cloud/20150912232135/" target="_blank" rel="noopener">https://www.jabba.cloud/20150912232135/</a></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"//"</span> + <span class="string">"START:INTERNAL_OUTPUT"</span>);</span><br><span class="line">friends.forEach((<span class="keyword">final</span> String name) -&gt; System.out.println(name));</span><br><span class="line">System.out.println(<span class="string">"//"</span> + <span class="string">"END:INTERNAL_OUTPUT"</span>);</span><br><span class="line"></span><br><span class="line">friends.forEach((name) -&gt; System.out.println(name));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 型推論されたパラメータはfinalが保証されなくなる</span></span><br><span class="line"><span class="comment">// 引数を変更しない習慣を開発者自身が身につける必要がある</span></span><br><span class="line">friends.forEach(name -&gt; System.out.println(name));</span><br><span class="line"></span><br><span class="line">friends.forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="2-2-リストの変換"><a href="#2-2-リストの変換" class="headerlink" title="2.2 リストの変換"></a>2.2 リストの変換</h3><h4 id="2-2-1-ラムダ式を使う"><a href="#2-2-1-ラムダ式を使う" class="headerlink" title="2.2.1 ラムダ式を使う"></a>2.2.1 ラムダ式を使う</h4><ul><li>map()メソッドについて：連続した入力を連続した出力に変換します</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// こうじゃなくて</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;String&gt; uppercaseNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    friends.forEach(name -&gt; uppercaseNames.add(name.toUpperCase()));</span><br><span class="line">    System.out.println(uppercaseNames);</span><br><span class="line"></span><br><span class="line"><span class="comment">// こう書く</span></span><br><span class="line">    friends.stream()</span><br><span class="line">           .map(name -&gt; name.toUpperCase())</span><br><span class="line">           .forEach(name -&gt; System.out.print(name + <span class="string">" "</span>));</span><br></pre></td></tr></table></figure><h4 id="2-2-2-メソッド参照を使用"><a href="#2-2-2-メソッド参照を使用" class="headerlink" title="2.2.2 メソッド参照を使用"></a>2.2.2 メソッド参照を使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">friends.stream()</span><br><span class="line">       .map(String::toUpperCase)</span><br><span class="line">       .forEach(name -&gt; System.out.println(name));</span><br></pre></td></tr></table></figure><ul><li>メソッド参照の使い所<ul><li>ラムダ式が非常に短い場合や、ラムダ式がインスタンスメソッドやstaticメソッドをシンプルで直接的に呼び出している場合における優れた代替手段</li><li>映画「Offiece Space」のTom Smykowskiのようなもの…　著者が例えている</li><li>→個人的に「Offiece-spaceパターン」とよんでいる</li></ul></li></ul><h3 id="2-3-要素の検索"><a href="#2-3-要素の検索" class="headerlink" title="2.3 要素の検索"></a>2.3 要素の検索</h3><ul><li>fileter()<ul><li>コレクションから要素を抜き出すために用いる</li><li>map()メソッドと同様にイテレーターを返すが、同じ要素数返すとは限らない</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;String&gt; startsWithN = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String name : friends) &#123;</span><br><span class="line">      <span class="keyword">if</span>(name.startsWith(<span class="string">"N"</span>)) &#123;</span><br><span class="line">        startsWithN.add(name);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(String.format(<span class="string">"Found %d names"</span>, startsWithN.size()));</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;String&gt; startsWithN =</span><br><span class="line">      friends.stream()</span><br><span class="line">             .filter(name -&gt; name.startsWith(<span class="string">"N"</span>))</span><br><span class="line">             .collect(Collectors.toList());</span><br><span class="line">    System.out.println(String.format(<span class="string">"Found %d names"</span>, startsWithN.size()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-ラムダ式の再利用"><a href="#2-4-ラムダ式の再利用" class="headerlink" title="2.4 ラムダ式の再利用"></a>2.4 ラムダ式の再利用</h3><ul><li>ラムダ式を定義しておいて重複をなくそうという説明</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Predicate&lt;String&gt; startsWithN = name -&gt; name.startsWith(<span class="string">"N"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> countFriendsStartN =</span><br><span class="line">  friends.stream()</span><br><span class="line">         .filter(startsWithN)</span><br><span class="line">         .count();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> countEditorsStartN =</span><br><span class="line">  editors.stream()</span><br><span class="line">         .filter(startsWithN)</span><br><span class="line">         .count();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> countComradesStartN =</span><br><span class="line">  comrades.stream()</span><br><span class="line">          .filter(startsWithN)</span><br><span class="line">          .count();</span><br></pre></td></tr></table></figure><ul><li>DRYの原則</li></ul><h3 id="2-5-静的スコープとクロージャ"><a href="#2-5-静的スコープとクロージャ" class="headerlink" title="2.5 静的スコープとクロージャ"></a>2.5 静的スコープとクロージャ</h3><ul><li><p>ラムダ式内は実質的にfinalな変数しか使えない</p></li><li><p><code>Predicate&lt;T&gt;</code>は<code>T</code>型を引数に取り、関数が行う検査の結果として<code>boolean</code>を返却。候補値の取捨選択を行う際に利用できる。</p></li><li><p><code>Function&lt;T,R&gt;</code>は<code>T</code>型の引数を取り、<code>R</code>型の結果を返す関数。常に<code>boolean</code>を返却する<code>Predicate&lt;T&gt;</code>より汎用的。</p></li><li><p><code>Optional</code>クラスは、結果が存在しない可能性がある場合に便利</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Function&lt;String, Predicate&lt;String&gt;&gt; startsWithLetter =</span><br><span class="line">  letter -&gt; name -&gt; name.startsWith(letter);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> countFriendsStartN =</span><br><span class="line">  friends.stream()</span><br><span class="line">         .filter(startsWithLetter.apply(<span class="string">"N"</span>)).count();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> countFriendsStartB =</span><br><span class="line">  friends.stream()</span><br><span class="line">         .filter(startsWithLetter.apply(<span class="string">"B"</span>)).count();</span><br></pre></td></tr></table></figure><ul><li>MEMO: Functionで囲うメリットがいまいち理解できていない（2020-04-26 14:52:51）</li></ul><h3 id="2-6-要素を-1つ選択"><a href="#2-6-要素を-1つ選択" class="headerlink" title="2.6 要素を 1つ選択"></a>2.6 要素を 1つ選択</h3><ul><li>Null初期化は、Nullであることを確認する作業が必要になって来る<ul><li>これを忘れるとNullpointerExcepiton</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// エレガントな例</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pickName</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> List&lt;String&gt; names, <span class="keyword">final</span> String startingLetter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Optional&lt;String&gt; foundName = </span><br><span class="line">      names.stream()</span><br><span class="line">           .filter(name -&gt;name.startsWith(startingLetter))</span><br><span class="line">           .findFirst();</span><br><span class="line">    System.out.println(String.format(<span class="string">"A name starting with %s: %s"</span>,</span><br><span class="line">      startingLetter, foundName.orElse(<span class="string">"No name found"</span>)));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>OptionalはNull脱臭剤</li></ul><h3 id="2-7-コレクションを単一の値に集約（reduce）"><a href="#2-7-コレクションを単一の値に集約（reduce）" class="headerlink" title="2.7 コレクションを単一の値に集約（reduce）"></a>2.7 コレクションを単一の値に集約（reduce）</h3><ul><li>本節では、要素の比較や計算状態をコレクションに渡って持ち越して使用する方法を学ぶ</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"//"</span> + <span class="string">"START:SUM_OUTPUT"</span>);</span><br><span class="line">      System.out.println(<span class="string">"Total number of characters in all names: "</span> +</span><br><span class="line">        friends.stream()</span><br><span class="line">               .mapToInt(name -&gt; name.length())</span><br><span class="line">               .sum());</span><br><span class="line">    &#125;</span><br><span class="line">System.out.println(<span class="string">"//"</span> + <span class="string">"END:SUM_OUTPUT"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"//"</span> + <span class="string">"END:AVERAGE_OUTPUT"</span>);</span><br><span class="line">System.out.println(<span class="string">"//"</span> + <span class="string">"START:REDUCE_OUTPUT"</span>);</span><br><span class="line">    <span class="keyword">final</span> Optional&lt;String&gt; aLongName =</span><br><span class="line">      friends.stream()</span><br><span class="line">             .reduce((name1, name2) -&gt;</span><br><span class="line">                name1.length() &gt;= name2.length() ? name1 : name2);</span><br><span class="line">    aLongName.ifPresent(name -&gt;</span><br><span class="line">      System.out.println(String.format(<span class="string">"A longest name: %s"</span>, name)));</span><br><span class="line">System.out.println(<span class="string">"//"</span> + <span class="string">"END:REDUCE_OUTPUT"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String steveOrLonger =</span><br><span class="line">      friends.stream()</span><br><span class="line">             .reduce(<span class="string">"Steve"</span>, (name1, name2) -&gt;</span><br><span class="line">                name1.length() &gt;= name2.length() ? name1 : name2);</span><br><span class="line"></span><br><span class="line">    System.out.println(steveOrLonger);</span><br></pre></td></tr></table></figure><h3 id="2-8-要素の結合"><a href="#2-8-要素の結合" class="headerlink" title="2.8 要素の結合"></a>2.8 要素の結合</h3><ul><li>StringJoinerの説明</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"//"</span> + <span class="string">"START:MAP_JOIN_OUTPUT"</span>);</span><br><span class="line">    System.out.println(</span><br><span class="line">      friends.stream()</span><br><span class="line">             .map(String::toUpperCase)</span><br><span class="line">             .collect(joining(<span class="string">", "</span>)));</span><br><span class="line">System.out.println(<span class="string">"//"</span> + <span class="string">"END:MAP_JOIN_OUTPUT"</span>);</span><br></pre></td></tr></table></figure><h3 id="2-9-まとめ"><a href="#2-9-まとめ" class="headerlink" title="2.9 まとめ"></a>2.9 まとめ</h3><ul><li>コレクションはプログラムにおいてはありふれたもので、</li><li>ラムダ式によりJavaにおけるコレクションの利用は従来よりも遥かに簡単で単純になりました</li><li>記述するコード量が減少し、保守性が高くなる</li></ul><h2 id="3章-文字列、コンパレータ、フィルタ"><a href="#3章-文字列、コンパレータ、フィルタ" class="headerlink" title="3章　文字列、コンパレータ、フィルタ"></a>3章　文字列、コンパレータ、フィルタ</h2><ul><li>ラムダ式とメソッド参照を使用してSringをいてレートし、Comparatorを実装し、ディレクトリのファイルリストを取得し、</li><li>そしてファイルやディレクトリを監視します</li></ul><h3 id="3-1-文字列のイテレーション"><a href="#3-1-文字列のイテレーション" class="headerlink" title="3.1 文字列のイテレーション"></a>3.1 文字列のイテレーション</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"//"</span> + <span class="string">"START:ITERATE_OUTPUT"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> String str = <span class="string">"w00t"</span>;</span><br><span class="line"></span><br><span class="line">str.chars()</span><br><span class="line">   .forEach(ch -&gt; System.out.println(ch));</span><br><span class="line">System.out.println(<span class="string">"//"</span> + <span class="string">"END:ITERATE_OUTPUT"</span>);</span><br><span class="line"></span><br><span class="line">str.chars()</span><br><span class="line">   .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"//"</span> + <span class="string">"START:FIX_OUTPUT"</span>);</span><br><span class="line">str.chars()</span><br><span class="line">   .forEach(IterateString::printChar);</span><br><span class="line">System.out.println(<span class="string">"//"</span> + <span class="string">"END:FIX_OUTPUT"</span>);</span><br><span class="line"></span><br><span class="line">    str.chars()</span><br><span class="line">       .mapToObj(ch -&gt; Character.valueOf((<span class="keyword">char</span>)ch))</span><br><span class="line">       .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"//"</span> + <span class="string">"START:FILTER_OUTPUT"</span>);</span><br><span class="line">str.chars()</span><br><span class="line">   .filter(ch -&gt; Character.isDigit(ch))</span><br><span class="line">   .forEach(ch -&gt; printChar(ch));</span><br><span class="line">System.out.println(<span class="string">""</span>);</span><br><span class="line">System.out.println(<span class="string">"//"</span> + <span class="string">"END:FILTER_OUTPUT"</span>);</span><br><span class="line"></span><br><span class="line">str.chars()</span><br><span class="line">   .filter(ch -&gt; Character.isDigit(ch));</span><br><span class="line"></span><br><span class="line">str.chars()</span><br><span class="line">   .filter(Character::isDigit);</span><br><span class="line"></span><br><span class="line">str.chars()</span><br><span class="line">   .filter(Character::isDigit)</span><br><span class="line">   .forEach(IterateString::printChar);</span><br></pre></td></tr></table></figure><ul><li>インスタンスメソッドのメソッド参照（String::toUppercase）と、staticメソッドのメソッド参照（Character::isDigit）は構造的に同じように見えるが異なる</li><li>インスタンスメソッド： <code>引数.toUppercase();</code></li><li><p>staticメソッド： <code>Character.isDigit(引数);</code></p></li><li><p>インスタンスメソッドとstaticメソッドの定義が衝突すると、</p></li><li>どちらを使用していいかコンパイラが判断できなくなりコンパイルエラーとなる<ul><li>→この場合はラムダ式を使う！</li><li>ラムダ式とメソッド参照を自由自在に切り替えられるようになる</li></ul></li></ul><h3 id="3-2-Comparatorインタフェースを実装"><a href="#3-2-Comparatorインタフェースを実装" class="headerlink" title="3.2 Comparatorインタフェースを実装"></a>3.2 Comparatorインタフェースを実装</h3><ul><li><code>List</code>の<code>sort()メソッド</code>だと戻り値が<code>void</code>なので、リスト本体が変更されてしまう</li><li>コピーを取得した上で、変更する必要があったが、面倒</li><li>代わりにStreamの力を借りて処理する方法を考える</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">people.sorted((person1,person2) -&gt; person1.ageDifference(person2)).collect(toList());</span><br><span class="line"><span class="comment">// ↓改善</span></span><br><span class="line">people.stream().sorted(Person::ageDifference).collect(toList());</span><br></pre></td></tr></table></figure><ul><li>逆順にしたい場合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">people.stream().sorted((person1, person2) -&gt; person2.ageDifference(person1)).collect(toList());</span><br><span class="line"><span class="comment">// パラメータの順番が引数受け渡しの規約に従っていないため、メソッド参照を使うようにリファクタリングすることはできません。</span></span><br></pre></td></tr></table></figure><ul><li>事前に<code>Comparator</code>を定義しておいて、使用することで簡潔に記載できる</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;Person&gt; people = Arrays.asList(</span><br><span class="line">      <span class="keyword">new</span> Person(<span class="string">"John"</span>, <span class="number">20</span>),</span><br><span class="line">      <span class="keyword">new</span> Person(<span class="string">"Sara"</span>, <span class="number">21</span>),</span><br><span class="line">      <span class="keyword">new</span> Person(<span class="string">"Jane"</span>, <span class="number">21</span>),</span><br><span class="line">      <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">35</span>));</span><br><span class="line"></span><br><span class="line">&#123;  </span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"START:AGE_ASCEND_OUTPUT"</span>);</span><br><span class="line">    List&lt;Person&gt; ascendingAge = </span><br><span class="line">      people.stream()</span><br><span class="line">            .sorted((person1, person2) -&gt; person1.ageDifference(person2))</span><br><span class="line">            .collect(toList());</span><br><span class="line">    printPeople(<span class="string">"Sorted in ascending order by age: "</span>, ascendingAge);</span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"END:AGE_ASCEND_OUTPUT"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;  </span><br><span class="line">  <span class="comment">// メソッド参照（Method Reference）</span></span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"START:AGE_ASCEND_MR_OUTPUT"</span>);</span><br><span class="line">    List&lt;Person&gt; ascendingAge = </span><br><span class="line">      people.stream()</span><br><span class="line">            .sorted(Person::ageDifference)</span><br><span class="line">            .collect(toList());</span><br><span class="line"></span><br><span class="line">    printPeople(<span class="string">"Sorted in ascending order by age: "</span>, ascendingAge);</span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"END:AGE_ASCEND_MR_OUTPUT"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"START:AGE_DESCEND_OUTPUT"</span>);</span><br><span class="line">    printPeople(<span class="string">"Sorted in descending order by age: "</span>,</span><br><span class="line">      people.stream()</span><br><span class="line">            .sorted((person1, person2) -&gt; person2.ageDifference(person1))</span><br><span class="line">            .collect(toList()));</span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"END:AGE_DESCEND_OUTPUT"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"START:REVERSE_ORDER_OUTPUT"</span>);</span><br><span class="line">    Comparator&lt;Person&gt; compareAscending = </span><br><span class="line">      (person1, person2) -&gt; person1.ageDifference(person2);</span><br><span class="line">      <span class="comment">// reversed()を使うことで降順の関数を事前に用意できる</span></span><br><span class="line">    Comparator&lt;Person&gt; compareDescending = compareAscending.reversed();</span><br><span class="line"></span><br><span class="line">    printPeople(<span class="string">"Sorted in ascending order by age: "</span>,</span><br><span class="line">      people.stream()</span><br><span class="line">            .sorted(compareAscending)</span><br><span class="line">            .collect(toList())</span><br><span class="line">    );</span><br><span class="line">    printPeople(<span class="string">"Sorted in descending order by age: "</span>,</span><br><span class="line">      people.stream()</span><br><span class="line">            .sorted(compareDescending)</span><br><span class="line">            .collect(toList())</span><br><span class="line">    );</span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"END:REVERSE_ORDER_OUTPUT"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 名前の昇順に並び替え</span></span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"START:NAME_ASCEND_OUTPUT"</span>);</span><br><span class="line">    printPeople(<span class="string">"Sorted in ascending order by name: "</span>,</span><br><span class="line">      people.stream()</span><br><span class="line">            .sorted((person1, person2) -&gt; </span><br><span class="line">               person1.getName().compareTo(person2.getName()))</span><br><span class="line">            .collect(toList()));</span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"END:NAME_ASCEND_OUTPUT"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// min()メソッドはOptionalを返す！</span></span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"START:YOUNGEST_OUTPUT"</span>);</span><br><span class="line">    people.stream()</span><br><span class="line">          .min(Person::ageDifference)</span><br><span class="line">          .ifPresent(youngest -&gt; System.out.println(<span class="string">"Youngest: "</span> + youngest));</span><br><span class="line">System.out.println(<span class="string">"//"</span> + <span class="string">"END:YOUNGEST_OUTPUT"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"START:ELDEST_OUTPUT"</span>);</span><br><span class="line">    people.stream()</span><br><span class="line">          .max(Person::ageDifference)</span><br><span class="line">          .ifPresent(eldest -&gt; System.out.println(<span class="string">"Eldest: "</span> + eldest));</span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"END:ELDEST_OUTPUT"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-複数のプロパティによる流暢な比較"><a href="#3-3-複数のプロパティによる流暢な比較" class="headerlink" title="3.3 複数のプロパティによる流暢な比較"></a>3.3 複数のプロパティによる流暢な比較</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 名前のアルファベット順にするために以下の関数を用意した</span></span><br><span class="line">    <span class="comment">// 従来の内部クラス構文と比較すると非常に簡潔</span></span><br><span class="line">    people.stream()</span><br><span class="line">          .sorted((person1, person2) -&gt; </span><br><span class="line">             person1.getName().compareTo(person2.getName()));</span><br><span class="line"></span><br><span class="line">    printPeople(<span class="string">"Sorted in ascending order by name: "</span>,</span><br><span class="line">    people.stream()</span><br><span class="line">          .sorted(comparing((Person person) -&gt; person.getName()))</span><br><span class="line">          .collect(toList()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Comparatorインターフェースのコンビニエンス関数を使用することで、より自由にコードの目的を表現できる</span></span><br><span class="line">    <span class="comment">// Comparaotrインターフェースのcomparing()メソッドを静的にインポートしました。comparing()メソッドは与えられた</span></span><br><span class="line">    <span class="comment">// ラムダ式のロジックを使用してComparatorを生成する！</span></span><br><span class="line">    <span class="comment">// つまり、関数（Function）を引数に取り、関数（Comparator）を返す高階関数</span></span><br><span class="line">    <span class="keyword">final</span> Function&lt;Person, String&gt; byName = person -&gt; person.getName();</span><br><span class="line">    people.stream()</span><br><span class="line">          .sorted(comparing(byName));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"START:SORT_NAME_AND_AGE_OUTPUT"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> Function&lt;Person, Integer&gt; byAge = person -&gt; person.getAge();</span><br><span class="line">    <span class="keyword">final</span> Function&lt;Person, String&gt; byTheirName = person -&gt; person.getName();</span><br><span class="line">    </span><br><span class="line">    printPeople(<span class="string">"Sorted in ascending order by age and name: "</span>,</span><br><span class="line">      people.stream()</span><br><span class="line">            .sorted(comparing(byAge).thenComparing(byTheirName))</span><br><span class="line">            .collect(toList()));</span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"END:SORT_NAME_AND_AGE_OUTPUT"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>このように、Comparatorの実装をラムダ式やJDKの新たなユーティリティクラスを使用して簡単に合成できる<ul><li>MEMO: 少し納得してないので再度確認</li></ul></li></ul><h3 id="3-4-collectメソッドとCollectorsクラスの使用"><a href="#3-4-collectメソッドとCollectorsクラスの使用" class="headerlink" title="3.4 collectメソッドとCollectorsクラスの使用"></a>3.4 collectメソッドとCollectorsクラスの使用</h3><ul><li>これまでに、Streamの要素をArrayListに変換する例でcollect()メソッドを数回使用している<ul><li>このメソッドは、あるコレクションを可変コレクションなど他のデータ型へ変換する際に便利な集約処理を行います</li><li>collect()関数はCollectorsクラスのユーティリティメソッドと組み合わせるととても便利</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 20歳以上の人を抽出してリストを取得する</span></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">// 従来の書き方</span></span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"START:MUTABLE_OUTPUT"</span>);</span><br><span class="line">    List&lt;Person&gt; olderThan20 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      people.stream()</span><br><span class="line">            .filter(person -&gt; person.getAge() &gt; <span class="number">20</span>)</span><br><span class="line">            .forEach(person -&gt; olderThan20.add(person));</span><br><span class="line">    System.out.println(<span class="string">"People older than 20: "</span> + olderThan20);</span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"END:MUTABLE_OUTPUT"</span>);</span><br><span class="line">    <span class="comment">// 問題点：</span></span><br><span class="line">    <span class="comment">// ターゲットとするコレクションに要素を１つずつ追加する保s理はとても低レベルなもので、宣言型ではなく命令形のコード</span></span><br><span class="line">    <span class="comment">// 並列に実行させる場合にはスレッドセーフ問題を適切に処理しなければならない</span></span><br><span class="line">    <span class="comment">// 可変性を持つコードを並列化するのは難しいものです。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// この問題はcollect()を使うことで緩和できる</span></span><br><span class="line"><span class="comment">// collect()メソッドの以下の３つについて知っておく</span></span><br><span class="line"><span class="comment">// サプライヤ　　：結果を収めるコンテナの精製方法（例えば、ArrayList::new）</span></span><br><span class="line"><span class="comment">// アキュムレータ：結果コンテナに単一の要素を追加する方法（例えばArrayList::add）</span></span><br><span class="line"><span class="comment">// コンバイナ　　：結果コンテナを他のコンテナと結合する方法（例えばArrayList::addAll）</span></span><br><span class="line"></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">// 便利な書き方！</span></span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"START:COLLECT_OUTPUT"</span>);</span><br><span class="line">    List&lt;Person&gt; olderThan20 = </span><br><span class="line">      people.stream()</span><br><span class="line">            .filter(person -&gt; person.getAge() &gt; <span class="number">20</span>)</span><br><span class="line">            .collect(ArrayList::<span class="keyword">new</span>, ArrayList::add, ArrayList::addAll);</span><br><span class="line">    System.out.println(<span class="string">"People older than 20: "</span> + olderThan20);</span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"END:COLLECT_OUTPUT"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// メリット：</span></span><br><span class="line"><span class="comment">// より明確で意図を持ったプログラミングを行っている→ArrayListに処理結果を集めることがこのコードの目的</span></span><br><span class="line"><span class="comment">// コード内で状態変更を行っていないため、イテレーションを簡単に並列化できる</span></span><br></pre></td></tr></table></figure><ul><li>次は基本の<code>collect()</code>メソッドよりも簡潔で便利な、オーバーロードされたcollect()メソッドを見ていく</li><li>このメソッドはCollectorを引数に取ります</li><li>Collectorはcollect()メソッドに設定された３つの異なるパラメータをカプセル化した、より簡単で再利用可能なインターフェース</li><li>様々なCollectorの実装を提供するCollectorsクラスにtoList()というコンビニエンスメソッドがある</li><li>このメソッドはArrayListに要素を蓄積するメソッドで、Collectorインターフェースの実装</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"START:COLLECT_TO_LIST_OUTPUT"</span>);</span><br><span class="line">    List&lt;Person&gt; olderThan20 = </span><br><span class="line">      people.stream()</span><br><span class="line">            .filter(person -&gt; person.getAge() &gt; <span class="number">20</span>)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    System.out.println(<span class="string">"People older than 20: "</span> + olderThan20);</span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"END:COLLECT_TO_LIST_OUTPUT"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>他にも色々集計できるよっていう説明!<ul><li><a href="https://docs.oracle.com/javase/jp/8/docs/api/java/util/stream/Collectors.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/jp/8/docs/api/java/util/stream/Collectors.html</a></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;  </span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"START:GROUP_BY_OUTPUT"</span>);</span><br><span class="line">    Map&lt;Integer, List&lt;Person&gt;&gt; peopleByAge = </span><br><span class="line">      people.stream()</span><br><span class="line">            .collect(Collectors.groupingBy(Person::getAge));</span><br><span class="line">    System.out.println(<span class="string">"Grouped by age: "</span> + peopleByAge);</span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"END:GROUP_BY_OUTPUT"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;  </span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"START:GROUP_BY_AGE_NAME_OUTPUT"</span>);</span><br><span class="line">    Map&lt;Integer, List&lt;String&gt;&gt; nameOfPeopleByAge = </span><br><span class="line">      people.stream()</span><br><span class="line">            .collect(</span><br><span class="line">              groupingBy(Person::getAge, mapping(Person::getName, toList())));</span><br><span class="line">    System.out.println(<span class="string">"People grouped by age: "</span> + nameOfPeopleByAge);</span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"END:GROUP_BY_AGE_NAME_OUTPUT"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;  </span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"START:OLDEST_IN_EACH_LETTER_OUTPUT"</span>);</span><br><span class="line">    Comparator&lt;Person&gt; byAge = Comparator.comparing(Person::getAge);</span><br><span class="line">    Map&lt;Character, Optional&lt;Person&gt;&gt; oldestPersonOfEachLetter = </span><br><span class="line">      people.stream()</span><br><span class="line">            .collect(groupingBy(person -&gt; person.getName().charAt(<span class="number">0</span>),</span><br><span class="line">               reducing(BinaryOperator.maxBy(byAge))));</span><br><span class="line">    System.out.println(<span class="string">"Oldest person of each letter:"</span>);</span><br><span class="line">    System.out.println(oldestPersonOfEachLetter);</span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"END:OLDEST_IN_EACH_LETTER_OUTPUT"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>MEMO: 集計関数を実際に色々使ってみる！！</li></ul><h3 id="3-5-ディレクトリの全ファイルをリスト"><a href="#3-5-ディレクトリの全ファイルをリスト" class="headerlink" title="3.5 ディレクトリの全ファイルをリスト"></a>3.5 ディレクトリの全ファイルをリスト</h3><ul><li><code>File</code>クラスの<code>list()</code>メソッドを使うと、ディレクトリにある全ファイル名を簡単にリスト化できる</li><li><p>ファイル名だけでなくすべてのファイルを取得する場合は<code>listFiles()</code>メソッドが使える</p></li><li><p>ファイルを取得したあとの処理が大変</p></li><li>ここでは、従来のくどい外部イテレータを使用するのではなく、エレガントな関数型スタイルの機能を使ってリストをイテレートしていく</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下の２つとも古いjavaより格段にシンプル</span></span><br><span class="line">Files.list(Paths.get(<span class="string">"."</span>))</span><br><span class="line">     .forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line">Files.list(Paths.get(<span class="string">"."</span>))</span><br><span class="line">     .filter(Files::isDirectory) <span class="comment">// filterはPredicateを期待する</span></span><br><span class="line">     .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-ディレクトリの特定のファイルだけをリスト"><a href="#3-6-ディレクトリの特定のファイルだけをリスト" class="headerlink" title="3.6 ディレクトリの特定のファイルだけをリスト"></a>3.6 ディレクトリの特定のファイルだけをリスト</h3><ul><li>特定のファイル名取得のためにオーバーロードされたFileクラスのlist()メソッドを提供してきました</li><li>このlist()メソッドはFilenameFilterインターフェースを引数に取ります</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String[] files =</span><br><span class="line">  <span class="keyword">new</span> File(<span class="string">"fpij"</span>).list(<span class="keyword">new</span> java.io.FilenameFilter() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(<span class="keyword">final</span> File dir, <span class="keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name.endsWith(<span class="string">".java"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><ul><li>これをラムダ式に置き換える！</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  Files.newDirectoryStream(</span><br><span class="line">       Paths.get(<span class="string">"fpij"</span>), path -&gt; path.toString().endsWith(<span class="string">".java"</span>))</span><br><span class="line">   .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7-flatMapで直下のサブディレクトリをリスト"><a href="#3-7-flatMapで直下のサブディレクトリをリスト" class="headerlink" title="3.7 flatMapで直下のサブディレクトリをリスト"></a>3.7 flatMapで直下のサブディレクトリをリスト</h3><ul><li>与えられたディレクトリ直下のサブディレクトリを探索する方法を解説する</li><li>最初に原始的な方法を説明し、次により便利なflatMap()メソッド（Streamクラス）を使用する</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listTheHardWay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  List&lt;File&gt; files = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  File[] filesInCurrentDir = <span class="keyword">new</span> File(<span class="string">"."</span>).listFiles();</span><br><span class="line">  <span class="keyword">for</span>(File file : filesInCurrentDir) &#123;</span><br><span class="line">    File[] filesInSubDir = file.listFiles();</span><br><span class="line">    <span class="keyword">if</span>(filesInSubDir != <span class="keyword">null</span>) &#123;</span><br><span class="line">      files.addAll(Arrays.asList(filesInSubDir));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      files.add(file);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"Count: "</span> + files.size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">betterWay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  List&lt;File&gt; files =</span><br><span class="line">    Stream.of(<span class="keyword">new</span> File(<span class="string">"."</span>).listFiles())</span><br><span class="line">          .flatMap(file -&gt; file.listFiles() == <span class="keyword">null</span> ? </span><br><span class="line">              Stream.of(file) : Stream.of(file.listFiles()))</span><br><span class="line">          .collect(toList());</span><br><span class="line">  System.out.println(<span class="string">"Count: "</span> + files.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>MEMO: モナド合成という言葉が出てきたが、いまいち意味がわからない</li></ul><h3 id="3-8-ファイルの変更を監視"><a href="#3-8-ファイルの変更を監視" class="headerlink" title="3.8 ファイルの変更を監視"></a>3.8 ファイルの変更を監視</h3><ul><li>ファイルが生成・変更・削除される際のアラートも簡単に実現できる</li><li>Java7で追加されたWatchServiceの機能を紹介</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> Thread(() -&gt; watchFileChange()).start();</span><br><span class="line">  <span class="keyword">final</span> File file = <span class="keyword">new</span> File(<span class="string">"sample.txt"</span>);</span><br><span class="line">  file.createNewFile();</span><br><span class="line">  Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">  file.setLastModified(System.currentTimeMillis());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">watchFileChange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Path path = Paths.get(<span class="string">"."</span>);</span><br><span class="line">    <span class="keyword">final</span> WatchService watchService = </span><br><span class="line">      path.getFileSystem()</span><br><span class="line">          .newWatchService();</span><br><span class="line">      </span><br><span class="line">    path.register(watchService, StandardWatchEventKinds.ENTRY_MODIFY);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"Report any file changed within next 1 minute..."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> WatchKey watchKey = watchService.poll(<span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(watchKey != <span class="keyword">null</span>) &#123;</span><br><span class="line">      watchKey.pollEvents()</span><br><span class="line">              .stream()</span><br><span class="line">              .forEach(event -&gt;</span><br><span class="line">                 System.out.println(event.context()));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(InterruptedException | IOException ex) &#123;</span><br><span class="line">    System.out.println(ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-9-まとめ"><a href="#3-9-まとめ" class="headerlink" title="3.9 まとめ"></a>3.9 まとめ</h3><ul><li>文字列操作やファイル処理、カスタムコンパレータの生成などの定型タスクはラムダ式とメソッド参照によって非常に楽に、簡潔になりました。</li></ul><h2 id="4章-ラムダ式で設計する"><a href="#4章-ラムダ式で設計する" class="headerlink" title="4章　ラムダ式で設計する"></a>4章　ラムダ式で設計する</h2><ul><li>本章では、ラムダ式が巧妙なデザインアイデアに生命を与える</li><li>これまではオブジェクトを使用していた箇所を軽量関数で代用できる</li></ul><h3 id="4-1-ラムダ式を使った関心の分離"><a href="#4-1-ラムダ式を使った関心の分離" class="headerlink" title="4.1 ラムダ式を使った関心の分離"></a>4.1 ラムダ式を使った関心の分離</h3><ul><li>コードの再利用のためにクラスを生成することは良い心がけですが、それが常に正しいとは限らない</li><li>クラスの代わりに高階関数を使うことで、クラス階層を必要とせずに同じことが達成できる</li></ul><h4 id="4-1-1-デザイン問題の探求"><a href="#4-1-1-デザイン問題の探求" class="headerlink" title="4.1.1 デザイン問題の探求"></a>4.1.1 デザイン問題の探求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Asset</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">enum</span> AssetType &#123; BOND, STOCK &#125;; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AssetType type;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Asset</span><span class="params">(<span class="keyword">final</span> AssetType assetType, <span class="keyword">final</span> <span class="keyword">int</span> assetValue)</span> </span>&#123;</span><br><span class="line">    type = assetType;</span><br><span class="line">    value = assetValue;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> AssetType <span class="title">getType</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> type; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Utilクラス</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">totalAssetValues</span><span class="params">(<span class="keyword">final</span> List&lt;Asset&gt; assets)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> assets.stream()</span><br><span class="line">                 .mapToInt(Asset::getValue)</span><br><span class="line">                 .sum();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>ラムダ式を使って、totalAssetValues()メソッドを書き、流暢なイテレータと好むべき不変性を使いました</li><li>しかし今はメソッド自身の設計に目を向けましょう</li><li>このメソッドでは<ul><li>どのようにイテレーションを行うか</li><li>何を合計するか</li><li>どのように合計するか<ul><li>といった３つの問題が絡み合っている</li></ul></li></ul></li></ul><h4 id="4-1-2-問題でがんじがらめ"><a href="#4-1-2-問題でがんじがらめ" class="headerlink" title="4.1.2 問題でがんじがらめ"></a>4.1.2 問題でがんじがらめ</h4><ul><li>資産のうち、債券（bond）だけを合計したい場合を考える</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">totalBondValues</span><span class="params">(<span class="keyword">final</span> List&lt;Asset&gt; assets)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> assets.stream()</span><br><span class="line">               .mapToInt(asset -&gt; </span><br><span class="line">                  asset.getType() == AssetType.BOND ? asset.getValue() : <span class="number">0</span>)</span><br><span class="line">               .sum();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">totalStockValues</span><span class="params">(<span class="keyword">final</span> List&lt;Asset&gt; assets)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> assets.stream()</span><br><span class="line">               .mapToInt(asset -&gt; </span><br><span class="line">                  asset.getType() == AssetType.STOCK ? asset.getValue() : <span class="number">0</span>)</span><br><span class="line">               .sum();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>こんなふうにコピペで増やしていって良いでしょうか？</li><li>DRYの原則に従ってもう少しましな設計をしましょう</li></ul><h4 id="4-1-3-主要な関心の分離"><a href="#4-1-3-主要な関心の分離" class="headerlink" title="4.1.3 主要な関心の分離"></a>4.1.3 主要な関心の分離</h4><ul><li>イテレーションと合計を求める方法は同じですが、「何を」合計するかが異なります</li><li>この「何を合計するか」部分はメソッドから切り離す良い候補</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">totalAssetValues</span><span class="params">(<span class="keyword">final</span> List&lt;Asset&gt; assets,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">final</span> Predicate&lt;Asset&gt; assetSelector)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> assets.stream()</span><br><span class="line">               .filter(assetSelector)</span><br><span class="line">               .mapToInt(Asset::getValue)</span><br><span class="line">               .sum();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</span><br><span class="line">  List&lt;Asset&gt; assets = Arrays.asList(</span><br><span class="line">    <span class="keyword">new</span> Asset(Asset.AssetType.BOND, <span class="number">1000</span>),</span><br><span class="line">    <span class="keyword">new</span> Asset(Asset.AssetType.BOND, <span class="number">2000</span>),</span><br><span class="line">    <span class="keyword">new</span> Asset(Asset.AssetType.STOCK, <span class="number">3000</span>),</span><br><span class="line">    <span class="keyword">new</span> Asset(Asset.AssetType.STOCK, <span class="number">4000</span>)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"Total of all assets: "</span> + </span><br><span class="line">    totalAssetValues(assets, asset -&gt; <span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"Total of bonds: "</span> + </span><br><span class="line">    totalAssetValues(assets, asset -&gt; asset.getType() == AssetType.BOND));</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"Total of stocks: "</span> + </span><br><span class="line">    totalAssetValues(assets, asset -&gt; asset.getType() == AssetType.STOCK));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>個々まではメソッドレベルでの関心の分離を行いましたが、次はクラスレベルで応用します</li></ul><h3 id="4-2-ラムダ式を使った委譲"><a href="#4-2-ラムダ式を使った委譲" class="headerlink" title="4.2 ラムダ式を使った委譲"></a>4.2 ラムダ式を使った委譲</h3><h3 id="4-3-ラムダ式を使ったデコレーション"><a href="#4-3-ラムダ式を使ったデコレーション" class="headerlink" title="4.3 ラムダ式を使ったデコレーション"></a>4.3 ラムダ式を使ったデコレーション</h3><ul><li>Cameraクラスのフィルター設定</li></ul><h3 id="4-4-defaultメソッドを覗く"><a href="#4-4-defaultメソッドを覗く" class="headerlink" title="4.4 defaultメソッドを覗く"></a>4.4 defaultメソッドを覗く</h3><ul><li>interfaceがdefaultメソッドを持てる</li><li><p>実装の衝突を防ぐためにルールが存在する</p></li><li><p>実際にinterfaceにdefaultメソッドが記述できるメリットがあまり浮かばないような気がする</p></li></ul><h3 id="4-5-ラムダ式を使った流暢なインタフェース"><a href="#4-5-ラムダ式を使った流暢なインタフェース" class="headerlink" title="4.5 ラムダ式を使った流暢なインタフェース"></a>4.5 ラムダ式を使った流暢なインタフェース</h3><ul><li>MEMO: ここは参考になる実装だと感じた<ul><li>用途例：メーラの設定、データベース設定パラメータの設定、インスタンスの連続した状態を管理下におきつつ構築する必要のある場合</li><li>ローンパターンと言うらしい</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">FluentMailer</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> FluentMailer <span class="title">from</span><span class="params">(<span class="keyword">final</span> String address)</span> </span>&#123; <span class="comment">/*... */</span>; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> FluentMailer <span class="title">to</span><span class="params">(<span class="keyword">final</span> String address)</span>   </span>&#123; <span class="comment">/*... */</span>; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> FluentMailer <span class="title">subject</span><span class="params">(<span class="keyword">final</span> String line)</span> </span>&#123; <span class="comment">/*... */</span>; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> FluentMailer <span class="title">body</span><span class="params">(<span class="keyword">final</span> String message)</span> </span>&#123; <span class="comment">/*... */</span>; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">final</span> Consumer&lt;FluentMailer&gt; block)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> FluentMailer mailer = <span class="keyword">new</span> FluentMailer();</span><br><span class="line">  block.accept(mailer);</span><br><span class="line">  System.out.println(<span class="string">"sending..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</span><br><span class="line">  FluentMailer.send(mailer -&gt;</span><br><span class="line">    mailer.from(<span class="string">"build@agiledeveloper.com"</span>)</span><br><span class="line">          .to(<span class="string">"venkats@agiledeveloper.com"</span>)</span><br><span class="line">          .subject(<span class="string">"build notification"</span>)</span><br><span class="line">          .body(<span class="string">"...much better..."</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-例外処理"><a href="#4-6-例外処理" class="headerlink" title="4.6 例外処理"></a>4.6 例外処理</h3><ul><li>ラムダ式の例外処理について<ul><li>MEMO: 再読する必要あり</li></ul></li></ul><h3 id="4-7-まとめ"><a href="#4-7-まとめ" class="headerlink" title="4.7 まとめ"></a>4.7 まとめ</h3><h2 id="5章-外部リソースを扱う"><a href="#5章-外部リソースを扱う" class="headerlink" title="5章　外部リソースを扱う"></a>5章　外部リソースを扱う</h2><ul><li>Java仮想マシン（JVM）は、自動的にガベージコレクション（GC）を行っているものだと信じているかもしれません。</li><li>内部リソースだけを扱っている場合はJVMにGCを任せられることは事実</li><li><p>しかし、</p><ul><li>データベース接続</li><li>ファイルやソケット</li><li>ネイティブリソースといった外部リソースを使用する場合は<ul><li>GCは開発者の責任範囲</li></ul></li></ul></li><li><p>本章では、ラムダ式を使って、<code>execute around method(EAM)</code>を実装します。</p></li><li>連続操作をより効率的に制御できます。そしてこのパターンを使ってロック管理と書き込み例外テストを行います</li></ul><h3 id="5-1-リソースの解放"><a href="#5-1-リソースの解放" class="headerlink" title="5.1 リソースの解放"></a>5.1 リソースの解放</h3><ul><li>finalize()なんて使ったらGCされずに貯まるでしょ？</li><li>close()メソッドで閉じる？→閉じ忘れたらどうするの？→エラー発生したらclose()呼ばれないままになるよね？</li><li>try-with-resources構文使う？Java7から追加された便利な構文だけど、開発者が下記忘れたら元も子もない、AutoClosableの実装もしておかないと行けないでしょ？<ul><li>→ラムダ式で解決しましょう！という説明</li></ul></li></ul><h3 id="5-2-ラムダ式でリソース解放"><a href="#5-2-ラムダ式でリソース解放" class="headerlink" title="5.2 ラムダ式でリソース解放"></a>5.2 ラムダ式でリソース解放</h3><ul><li>ラムダ式で設計して、開発者にこれを使うように共有すれば問題なし</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileWriterEAM</span>  </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> FileWriter writer;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">FileWriterEAM</span><span class="params">(<span class="keyword">final</span> String fileName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    writer = <span class="keyword">new</span> FileWriter(fileName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"close called automatically..."</span>);</span><br><span class="line">    writer.close();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeStuff</span><span class="params">(<span class="keyword">final</span> String message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    writer.write(message);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">(<span class="keyword">final</span> String fileName,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> UseInstance&lt;FileWriterEAM, IOException&gt; block)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> FileWriterEAM writerEAM = <span class="keyword">new</span> FileWriterEAM(fileName);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      block.accept(writerEAM);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      writerEAM.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  </span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"START:EAM_USE_OUTPUT"</span>);</span><br><span class="line">    FileWriterEAM.use(<span class="string">"eam.txt"</span>, writerEAM -&gt; writerEAM.writeStuff(<span class="string">"sweet"</span>));</span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"END:EAM_USE_OUTPUT"</span>);</span><br><span class="line"></span><br><span class="line">    FileWriterEAM.use(<span class="string">"eam2.txt"</span>, writerEAM -&gt; &#123;</span><br><span class="line">        writerEAM.writeStuff(<span class="string">"how"</span>);</span><br><span class="line">        writerEAM.writeStuff(<span class="string">"sweet"</span>);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interface</span></span><br><span class="line"><span class="comment">// @FunctionalInterfaceは関数型インターフェースであることの宣言</span></span><br><span class="line"><span class="comment">// 例外を考慮する必要がなければ、Consumerインターフェースを使えばよかったが、ラムダ式は、合成されるabstratメソッドのシグネチャの一部として定義されたチェック例外を投げることができるため実装</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UseInstance</span>&lt;<span class="title">T</span>, <span class="title">X</span> <span class="keyword">extends</span> <span class="title">Throwable</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T instance)</span> <span class="keyword">throws</span> X</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>MEMO: <code>execute around method</code>パターンの構造らしい<ul><li>この仕組はファイル読み込みを行う際に見習うべき</li><li>そもそも標準のjavaでファイル読み込み時に自動的に開放するような書き方ができないか確認すべき</li><li>実際には読み込みファイルと書き込みファイル両方を開いて処理を行う場合が多いのでは？<ul><li>そのような場合どうやって書いていく？</li></ul></li><li>Transactionという形でUTIL作成して、複数ファイルをオープンして操作していけば行ける？</li></ul></li></ul><h3 id="5-3-ロックの管理"><a href="#5-3-ロックの管理" class="headerlink" title="5.3 ロックの管理"></a>5.3 ロックの管理</h3><ul><li>コンカレントなJavaアプリケーションにおいてロックは重要な役割を果たす</li><li>ここでは、ラムダ式を使って細かなロックの制御を行い、重要なセクションの適切なロックの単体テストの可能性を開く</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Locker</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runLocked</span><span class="params">(Lock lock, Runnable block)</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      block.run();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>MEMO: Lockの使い方確認 このロジックレベルでロックする使い所がいまいちピンとこない<ul><li>使い所があれば、synchronizedを使用するより、こちらの方が単体テストもしやすいメリットがあるみたい</li></ul></li></ul><h3 id="5-4-簡潔な例外テストの生成"><a href="#5-4-簡潔な例外テストの生成" class="headerlink" title="5.4 簡潔な例外テストの生成"></a>5.4 簡潔な例外テストの生成</h3><ul><li>Junitフレームワークなどでアノテーションを使用した、例外テストを実施する場合は、</li><li>ラムダ式で書き換えた方が良いという例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RodCutter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> mustFail;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RodCutter</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> fail)</span> </span>&#123; mustFail = fail; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrices</span><span class="params">(<span class="keyword">final</span> List&lt;Integer&gt; prices)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span>(mustFail) </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RodCutterException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> RodCutterException();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RodCutterTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> RodCutter rodCutter;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Integer&gt; prices;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> RodCutter <span class="title">createCutter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RodCutter(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Before</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rodCutter = createCutter();</span><br><span class="line">    prices = Arrays.asList(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">VerboseExceptionTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rodCutter.setPrices(prices);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      rodCutter.maxProfit(<span class="number">0</span>);</span><br><span class="line">      fail(<span class="string">"Expected exception for zero length"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(RodCutterException ex) &#123;</span><br><span class="line">      assertTrue(<span class="string">"expected"</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span>(expected = RodCutterException.class) </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TerseExceptionTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rodCutter.setPrices(prices);</span><br><span class="line">    rodCutter.maxProfit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Lamda式を利用したテスト方法</span></span><br><span class="line">  <span class="meta">@Test</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConciseExceptionTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rodCutter.setPrices(prices);</span><br><span class="line">    assertThrows(RodCutterException.class, () -&gt; rodCutter.maxProfit(<span class="number">0</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    junit.textui.TestRunner.run(<span class="keyword">new</span> JUnit4TestAdapter(RodCutterTest.class));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// HELPERの実装</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHelper</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;X extends Throwable&gt; <span class="function">Throwable <span class="title">assertThrows</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> Class&lt;X&gt; exceptionClass, <span class="keyword">final</span> Runnable block)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      block.run();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">if</span>(exceptionClass.isInstance(ex))</span><br><span class="line">        <span class="keyword">return</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    fail(<span class="string">"Failed to throw expected exception "</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>MEMO: 現在のフレームワークでラムダ式を利用したメソッドが提供されていないかどうか確認する</li></ul><h3 id="5-5-まとめ"><a href="#5-5-まとめ" class="headerlink" title="5.5 まとめ"></a>5.5 まとめ</h3><ul><li>アプリケーションが外部リソースを使用する場合、全面的に自動ガベージコレクションに頼ることはできません。</li><li><code>execute around method</code>パターンは実行フローのきめ細かい制御や外部リソースの開放に役立つ<ul><li>オブジェクト生存期間の制御</li><li>ロック管理</li><li>簡潔な例外テストの記述</li></ul></li></ul><h2 id="6章-「遅延させる」ということ"><a href="#6章-「遅延させる」ということ" class="headerlink" title="6章　「遅延させる」ということ"></a>6章　「遅延させる」ということ</h2><h3 id="6-1-初期化の遅延"><a href="#6-1-初期化の遅延" class="headerlink" title="6.1 初期化の遅延"></a>6.1 初期化の遅延</h3><ul><li>オブジェクト内部に重いリソースが存在する場合、その生成を後回しにできれば有益</li><li>オブジェクトの一部の生成をアトマwしにするという設計上の決断は、オブジェクトを使う開発者にとって重荷になるべきではなく、シームレスであるべき</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Supplier&lt;Heavy&gt; heavy = () -&gt; createAndCacheHeavy();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Holder created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Heavy <span class="title">getHeavy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> heavy.get();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> Heavy <span class="title">createAndCacheHeavy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">HeavyFactory</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Heavy</span>&gt; </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> Heavy heavyInstance = <span class="keyword">new</span> Heavy();</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Heavy <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> heavyInstance; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!HeavyFactory.class.isInstance(heavy)) &#123;</span><br><span class="line">      heavy = <span class="keyword">new</span> HeavyFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> heavy.get();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Holder holder = <span class="keyword">new</span> Holder();</span><br><span class="line">    System.out.println(<span class="string">"deferring heavy creation..."</span>);</span><br><span class="line">    System.out.println(holder.getHeavy());</span><br><span class="line">    System.out.println(holder.getHeavy());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>virtual poroxyパターン</li><li>オブジェクトの生成に１レベル挟む<br>次はラムダ式で実現する</li></ul><h3 id="6-2-遅延評価"><a href="#6-2-遅延評価" class="headerlink" title="6.2 遅延評価"></a>6.2 遅延評価</h3><ul><li>短絡評価： <code>fn1() || fn2()</code></li><li><p>メソッドの引数の場合は渡されたものすべてが評価される</p><ul><li>すべての引数を使用しない場合はその評価に費やした時間とリソースが無駄になる</li><li>ここでもラムダ式を使って任意の引数の評価を遅らせることができる</li></ul></li><li><p>メソッド実行時にある引数が使用されない可能性があることがわかっていれば、いくつかの引数、またはすべての引数を遅延実行するようにメソッドのインターフェースを変更できる</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Evaluation</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">evaluate</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"evaluating ..."</span> + value);</span><br><span class="line">    simulateTimeConsumingOp(<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">return</span> value &gt; <span class="number">100</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">simulateTimeConsumingOp</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> millseconds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">      Thread.sleep(<span class="number">2000</span>); </span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">eagerEvaluator</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">boolean</span> input1, <span class="keyword">final</span> <span class="keyword">boolean</span> input2)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"eagerEvaluator called..."</span>);</span><br><span class="line">    System.out.println(<span class="string">"accept?: "</span> + (input1 &amp;&amp; input2));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 遅延評価のためのメソッド</span></span><br><span class="line"><span class="comment">  * ラムダ式を引数に取り、実行自体はこのメソッドの中で行う</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lazyEvaluator</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> Supplier&lt;Boolean&gt; input1, <span class="keyword">final</span> Supplier&lt;Boolean&gt; input2)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"lazyEvaluator called..."</span>);</span><br><span class="line">    System.out.println(<span class="string">"accept?: "</span> + (input1.get() &amp;&amp; input2.get()));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"START:EAGER_OUTPUT"</span>);</span><br><span class="line">    eagerEvaluator(evaluate(<span class="number">1</span>), evaluate(<span class="number">2</span>));</span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"END:EAGER_OUTPUT"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ４秒かかっていた処理が２秒でfalseを返却するようになる</span></span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"START:LAZY_OUTPUT"</span>);</span><br><span class="line">    lazyEvaluator(() -&gt; evaluate(<span class="number">1</span>), () -&gt; evaluate(<span class="number">2</span>));</span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"END:LAZY_OUTPUT"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>デメリット</p><ul><li>ラムダ式をわざわざ書かないと行けないので面倒（場合によってはメソッド参照を利用できる）</li><li>コード量は多くなる</li></ul></li><li><p>MEMO: フレームワークで遅延処理を行うためにはどのようにするべきか</p></li></ul><h3 id="6-3-Streamの遅延処理を活用"><a href="#6-3-Streamの遅延処理を活用" class="headerlink" title="6.3 Streamの遅延処理を活用"></a>6.3 Streamの遅延処理を活用</h3><ul><li>Streamの遅延評価について説明</li></ul><h4 id="6-3-1-中間処理と終端処理"><a href="#6-3-1-中間処理と終端処理" class="headerlink" title="6.3.1 中間処理と終端処理"></a>6.3.1 中間処理と終端処理</h4><ul><li><p>Streamには２種類のメソッドがある</p><ul><li>中間処理</li><li>終端処理</li></ul></li><li><p>Streamの遅さは複数の中間処理をチェーンし、最後に終端処理を行うことで実現している</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">"Brad"</span>, <span class="string">"Kate"</span>, <span class="string">"Kim"</span>, <span class="string">"Jack"</span>, <span class="string">"Joe"</span>,</span><br><span class="line">  <span class="string">"Mike"</span>, <span class="string">"Susan"</span>, <span class="string">"George"</span>, <span class="string">"Robert"</span>, <span class="string">"Julia"</span>, <span class="string">"Parker"</span>, <span class="string">"Benson"</span>);</span><br><span class="line">System.out.println(<span class="string">"//"</span> + <span class="string">"START:CHAIN_OUTPUT"</span>);</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ここの処理はコレクションの変換に多くの作業を費やしている働き者に見えますが、実は見かけによらず怠け者です。</span></span><br><span class="line"><span class="keyword">final</span> String firstNameWith3Letters = </span><br><span class="line">  names.stream()</span><br><span class="line">        .filter(name -&gt; length(name) == <span class="number">3</span>)</span><br><span class="line">        .map(name -&gt; toUpper(name))</span><br><span class="line">        .findFirst()</span><br><span class="line">        .get();</span><br><span class="line"></span><br><span class="line">System.out.println(firstNameWith3Letters);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"//"</span> + <span class="string">"END:CHAIN_OUTPUT"</span>);</span><br></pre></td></tr></table></figure><ul><li>本当に必要な処理以外は実施していないらしい</li><li><p>その詳細を次で！述べる</p></li><li><p>中間処理、終端処理まで考慮された上で、初めて処理が実行される</p><ul><li>filter 12処理<ul><li>map 2処理<ul><li>findFirst 1処理</li></ul></li></ul></li><li>ではなく！</li><li>filter 3 処理！！<ul><li>map 1処理<ul><li>findFirst 1処理</li></ul></li></ul></li><li>という形で評価される</li></ul></li><li><p>JDKが裏で結合（fusing）処理を行うことで実現している</p></li><li>データの通り道は１本ということ</li><li>要素の抽出、マッピング、選択が１度に行われる</li></ul><h3 id="6-4-無限の「遅い」コレクションを生成"><a href="#6-4-無限の「遅い」コレクションを生成" class="headerlink" title="6.4 無限の「遅い」コレクションを生成"></a>6.4 無限の「遅い」コレクションを生成</h3><ul><li>MEMO: スキップ</li></ul><h3 id="6-5-まとめ"><a href="#6-5-まとめ" class="headerlink" title="6.5 まとめ"></a>6.5 まとめ</h3><h2 id="7章-再帰の最適化"><a href="#7章-再帰の最適化" class="headerlink" title="7章　再帰の最適化"></a>7章　再帰の最適化</h2><ul><li>再帰は魅力的で強力な問題解決方法</li><li><p>再帰はとても表現力に富んでいます</p></li><li><p>大きな問題の再帰処理を可能とする末尾呼び出し最適化（tail-call optimization TCO）を説明</p></li></ul><h3 id="7-1-末尾呼び出し最適化を使う"><a href="#7-1-末尾呼び出し最適化を使う" class="headerlink" title="7.1 末尾呼び出し最適化を使う"></a>7.1 末尾呼び出し最適化を使う</h3><ul><li>再帰を使う上で最も高いハードルは、巨大な入力値によるスタックオーバーフローのリスク</li><li>しかし、末尾呼び出し最適化（TCO）という優れたテクニックがこの心配のタネを取り除く</li><li><p>末尾呼び出しとは</p><ul><li>最後の処理が自身の呼び出しとなるような再帰呼び出しのことを言います</li></ul></li><li><p>JavaはTCOをコンパイラレベルで直接サポートしていませんが、ラムダ式を使って数行で実装できる</p></li><li>このソリューションはトランポリンとも呼ばれrます。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通常の実装</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">factorialRec</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(number == <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span> number;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> number * factorialRec(number - <span class="number">1</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 大きい数を渡すとStackOverflowErrorが発生</span></span><br></pre></td></tr></table></figure><ul><li>この再帰関数は大きな入力値を扱えず、落ちてしまう</li><li>再帰が強力で表現力豊かであっても使えません。</li><li>この問題は再帰そのものにあるわけではない</li><li>再帰の完了を待つ間、部分的な計算結果をすべて保存しているためです。</li><li>スタックに積み上げずに再帰を行う方法が必要</li></ul><h4 id="7-1-2-末尾再帰に変換する"><a href="#7-1-2-末尾再帰に変換する" class="headerlink" title="7.1.2 末尾再帰に変換する"></a>7.1.2 末尾再帰に変換する</h4><ul><li>遅延評価させるために<ul><li>TailCall関数型インターフェース</li><li>TailCallsクラスを設計する</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TailCall&lt;Integer&gt; <span class="title">factorialTailRec</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">final</span> <span class="keyword">int</span> factorial, <span class="keyword">final</span> <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (number == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> done(factorial);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> call(() -&gt; factorialTailRec(factorial * number, number - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>MEMO: TCOについて理解できていない… 再帰処理設計が必要になったら読み返す</li></ul><h3 id="7-2-メモ化でスピードアップ"><a href="#7-2-メモ化でスピードアップ" class="headerlink" title="7.2 メモ化でスピードアップ"></a>7.2 メモ化でスピードアップ</h3><h3 id="7-3-まとめ"><a href="#7-3-まとめ" class="headerlink" title="7.3 まとめ"></a>7.3 まとめ</h3><h2 id="8章-ラムダ式で合成"><a href="#8章-ラムダ式で合成" class="headerlink" title="8章　ラムダ式で合成"></a>8章　ラムダ式で合成</h2><ul><li>Java8には、オブジェクト志向アプローチと関数型スタイルという２つの強力なツールがある</li><li><p>組み合わせて使っていこう！</p></li><li><p>本章では、</p><ul><li>関数合成を詳しく説明し、実践的なMapReduceパターンを例として実装</li><li>MapReduceパターンでは、独立した計算処理を分散し、それらの処理結果を集約して最終的な結果を計算します</li><li>最後はJDKの力を借りて、この計算処理を簡単に並列化します。</li></ul></li></ul><h3 id="8-1-関数合成の利用"><a href="#8-1-関数合成の利用" class="headerlink" title="8.1 関数合成の利用"></a>8.1 関数合成の利用</h3><ul><li>オブジェクト指向＋関数型スタイル複合アプローチでは、状態が変化するのではなく、軽量なオブジェクトが別のオブジェクトに変換される</li><li><p>可変性がないことで、エラー発生の可能性を減らし、並列実行家より簡単</p></li><li><p>リストからStreamを作成し、オリジナルのリストは変更されず、新しくオブジェクトを生成するということが言いたいだけ</p></li></ul><h3 id="8-2-MapReduceの使用"><a href="#8-2-MapReduceの使用" class="headerlink" title="8.2 MapReduceの使用"></a>8.2 MapReduceの使用</h3><ul><li>MapReduceパターンは２つの操作がある<ul><li>コレクションの各要素で実行する操作</li><li>これらの実行結果を組み合わせて最終結果を導き出す</li></ul></li><li><p>このパターンでマルチコアプロセッサを有効活用可能であることから注目をされつつある</p></li><li><p><code>Tickers.symbols.parallelStream()</code>は裏側に隠れているスレッドプールで管理された複数のスレッドで、</p></li><li><p>map()やfilter()のようなメソッドを並列処理します。</p></li><li><p>stream()とparallelStream()のどちらを使用するかを決める際には、いくつかの問題を考えなければいけません</p><ul><li>本当にラムダ式を同時に実行したいのか？</li><li>対象コードは副作用や競合状態が発生しない、独立した動作を行える？</li><li>実行順序に影響を与えることはないか？</li></ul></li><li><p>map()やfilter()のように、計算を行って、その結果を次の処理に回すようなメソッドは並列化に向いている</p></li><li><p>MEMO: 闇雲に並列化はしないほうがよい！！</p></li><li>並列ストリームを選択すべきか？<ul><li>ライブラリは簡単に並列化を行ってくれるが、並列化が常に正しい選択であるとは限らない</li><li>データと、実行する計算内容によっては、並列計算はシーケンシャルな計算より遅くなることもあり得る</li><li>並列化実行処理のためのコストもかかる</li><li>コレクションが小さいのであれば、シーケンシャル実行のほうが早くなるかも</li><li>速度を計測して実装していくべき</li></ul></li></ul><h3 id="8-3-並列化への飛躍"><a href="#8-3-並列化への飛躍" class="headerlink" title="8.3 並列化への飛躍"></a>8.3 並列化への飛躍</h3><h3 id="8-4-まとめ"><a href="#8-4-まとめ" class="headerlink" title="8.4 まとめ"></a>8.4 まとめ</h3><h2 id="9章-すべてをまとめて"><a href="#9章-すべてをまとめて" class="headerlink" title="9章　すべてをまとめて"></a>9章　すべてをまとめて</h2><ul><li>本書を通してJava8のラムダ式を紹介しました</li><li>コレクションのイテレーションを行い</li><li>軽量でよりよい設計を実現し、コードを簡単に合成、そして並列化しました。</li><li>この最終章ではまとめとして、関数型スタイルのプログラミングを使って、最大の効果を上げるために</li><li>磨いておくべきことを説明し、関数型スタイルを採用して成功するための推奨事項を最後に取り上げる</li></ul><h3 id="9-1-関数型スタイルで成功するために実践すべきこと"><a href="#9-1-関数型スタイルで成功するために実践すべきこと" class="headerlink" title="9.1 関数型スタイルで成功するために実践すべきこと"></a>9.1 関数型スタイルで成功するために実践すべきこと</h3><p>新機能のメリットを十分に活かし、簡潔で軽量なアプリケーションを生成するには、設計、コーディング、そして考え方まで変えなければいけません。</p><p>これまでのJavaを使ってきた命令形や、オブジェクト指向のパラダイムとは違うもの</p><p>ここでは根本的に変えるべきアプリケーション開発手法や、その変更によって得られる利点について説明</p><h4 id="9-1-1-宣言的により近く、命令型からより遠く"><a href="#9-1-1-宣言的により近く、命令型からより遠く" class="headerlink" title="9.1.1 宣言的により近く、命令型からより遠く"></a>9.1.1 宣言的により近く、命令型からより遠く</h4><ul><li>価格リストを与えられていて、その中から最大値を選ぶようにと依頼されたとしたときに、</li><li>命令型のfor文で最大値を探すのではなく、ラムダ式を使ってstream経由で取得する</li></ul><h4 id="9-1-2-普遍性の尊重"><a href="#9-1-2-普遍性の尊重" class="headerlink" title="9.1.2 普遍性の尊重"></a>9.1.2 普遍性の尊重</h4><ul><li>状態変更が可能な(mutable)変数はあまり上品とは言えません。</li><li>そしてそのような変数の共有は単なる害悪</li><li>開発者は変数の状態変更によって混乱させられてしまい、時には変更を見逃してしまいます。</li><li>したがって、変更可能な変数が多いほど、より多くのエラーが発生する可能性があるということ</li><li>正確な並列化が非常に難しくなるということもデメリット</li><li>関数型スタイルの導入がそれを簡単にしてくれる</li><li>純粋な関数型言語は値しか持っていません。つまり１回しか書き込みができない、初期化後は全く変更を受け付けない変数です。</li><li>しかしJavaはそのような言語とはことなり、不変性(immutability)を強制しないため、不変性を尊重する責任は開発者にある</li></ul><h4 id="9-1-3-副作用の削減"><a href="#9-1-3-副作用の削減" class="headerlink" title="9.1.3 副作用の削減"></a>9.1.3 副作用の削減</h4><ul><li>副作用を減らそう</li><li>所感：時間や状態などの外部要員によって関数の処理結果が異なることが無いように作成すること</li></ul><h4 id="9-1-4-文より式を優先"><a href="#9-1-4-文より式を優先" class="headerlink" title="9.1.4 文より式を優先"></a>9.1.4 文より式を優先</h4><ul><li>文：アクションを実行するが何も返さない</li><li><p>式：アクションを実行して結果を返す</p></li><li><p>文は何も返さないため、目的を遂行するためには副作用を起こしメモリを書き換える必要がある</p></li><li><p>一方式は、参照透明性を保つように設計できるため、これまでに述べたメリットを得られる</p></li><li><p>式を使うメリット</p><ul><li>関数合成ができるということが挙げられる</li><li>チェーンでコードを記述することで、文章を読むように簡単にコードを読めるようになる</li></ul></li></ul><h4 id="9-1-5-高階関数を利用して設計"><a href="#9-1-5-高階関数を利用して設計" class="headerlink" title="9.1.5 高階関数を利用して設計"></a>9.1.5 高階関数を利用して設計</h4><ul><li>これまでは匿名内部クラスを単一メソッドのインターフェースに渡していたような場所で、</li><li><p>ラムダ式やメソッド参照を渡すことができる様になり、コードがより簡潔になります。</p></li><li><p>メーラーを関数で設計することでローンパターンを適用する例</p></li><li>Colorフィルターを関数で表現する例</li><li>関数を引数に渡してDRYな設計をしよう</li></ul><h3 id="9-2-パフォーマンスの問題"><a href="#9-2-パフォーマンスの問題" class="headerlink" title="9.2 パフォーマンスの問題"></a>9.2 パフォーマンスの問題</h3><ul><li><p>命令型のコードと比較してもパフォーマンスは劣らない</p><ul><li>メリット<ul><li>直感的に見やすい</li><li>並列化も容易</li></ul></li></ul></li><li><p>関数型を採用しましょう</p></li><li><p>MEMO: 処理時間の違いはむやみに信頼できるものではないのでやめましょうと書かれている…</p></li></ul><h3 id="9-3-関数型スタイルを採用"><a href="#9-3-関数型スタイルを採用" class="headerlink" title="9.3 関数型スタイルを採用"></a>9.3 関数型スタイルを採用</h3><ul><li>実際に使ってみて、試して、より良い設計を考えていこう！</li></ul><h2 id="付録A-基本的な関数型インタフェース"><a href="#付録A-基本的な関数型インタフェース" class="headerlink" title="付録A 基本的な関数型インタフェース"></a>付録A 基本的な関数型インタフェース</h2><ul><li>JDK8には様々な関数型インターフェースを持っている</li><li>ここでは頻繁に出現する基本的なインターフェースをいくつか紹介</li></ul><h3 id="A-1-Consumer"><a href="#A-1-Consumer" class="headerlink" title="A.1 Consumer"></a>A.1 Consumer<t></t></h3><ul><li>入力を受け入れ、戻り値を返さない操作を表すインターフェース</li><li><p>有効活用するためには副作用を伴う必要がある</p></li><li><p>抽象メソッド</p><ul><li>accept()</li></ul></li><li>defaultメソッド<ul><li>andThen()</li></ul></li><li>主な利用方法<ul><li>forEach()メソッドの引数</li></ul></li><li>特注なプリミティブ<ul><li>IntConsumer, LongConsumer, DoubleConsumerなど</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java8sample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8Sample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Consumer&lt;String&gt; hoge = string -&gt; System.out.println(<span class="string">"hoge : "</span> + string);</span><br><span class="line">        Consumer&lt;String&gt; fuga = string -&gt; System.out.println(<span class="string">"fuga : "</span> + string);</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; piyo = hoge.andThen(fuga);</span><br><span class="line"></span><br><span class="line">        piyo.accept(<span class="string">"piyo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="A-2-Supplier"><a href="#A-2-Supplier" class="headerlink" title="A.2 Supplier"></a>A.2 Supplier<t></t></h3><ul><li><p>新しいインスタンス、またはあらかじめ生成しておいたインスタンスを返すファクトリ。</p></li><li><p>抽象メソッド</p><ul><li>get()</li></ul></li><li>defaultメソッド<ul><li>なし</li></ul></li><li>主な利用方法<ul><li>遅延実行を行う無限Streamの生成</li><li>OptionalクラスのorElseGet()メソッドの引数</li></ul></li><li>特殊なプリミティブ<ul><li>IntSupplier, LongSupplier, DoubleSupplierなど</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java8sample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8Sample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Supplier&lt;String&gt; supplier = () -&gt; <span class="string">"hoge"</span>;</span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>遅延初期化で少し出てきた程度</li></ul><h3 id="A-3-Predicate"><a href="#A-3-Predicate" class="headerlink" title="A.3 Predicate"></a>A.3 Predicate<t></t></h3><ul><li><p>入力値が何らかの条件に該当するかを確認するために有効。</p></li><li><p>抽象メソッド</p><ul><li>test()</li></ul></li><li>defaultメソッド<ul><li>and(), nagate(), or()</li></ul></li><li>主な利用方法<ul><li>Streamのfilter()やanyMatch()メソッドなどの引数</li></ul></li><li><p>特殊なプリミティブ</p><ul><li>IntPredicate, LongPredicate, DoublePredicateなど</li></ul></li><li><p>anyMatchはリストのStreamのうちどれか１つでも一致する条件であればtrueを返却する動きになるみたい</p><ul><li>→終端操作</li></ul></li><li>filterは中間操作</li></ul><h3 id="A-4-Function-lt-T-R-gt"><a href="#A-4-Function-lt-T-R-gt" class="headerlink" title="A.4 Function&lt;T, R&gt;"></a>A.4 Function&lt;T, R&gt;</h3><ul><li><p>引数をとって適切な結果値を返す操作を表す変換インターフェース</p></li><li><p>抽象メソッド</p><ul><li>apply()</li></ul></li><li>defaultメソッド<ul><li>andThen(), compose()</li></ul></li><li>主な利用方法<ul><li>Streamのmap()メソッドの引数</li></ul></li><li>特殊なプリミティブ<ul><li>IntFunction、LongFunction, DoubleFunction, IntToDoubleFunction, DoubleToIntFunction</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java8sample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8Sample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Function&lt;String, String&gt; wrapDoubleQuotation = str -&gt; <span class="string">"\""</span> + str + <span class="string">"\""</span>;</span><br><span class="line">        Function&lt;String, String&gt; wrapSingleQuotation = str -&gt; <span class="string">"'"</span> + str + <span class="string">"'"</span>;</span><br><span class="line"></span><br><span class="line">        Function&lt;String, String&gt; wrapDoubleAndSingleQuotation = wrapDoubleQuotation.compose(wrapSingleQuotation);</span><br><span class="line">        String result = wrapDoubleAndSingleQuotation.apply(<span class="string">"hoge"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="付録B-構文の基礎"><a href="#付録B-構文の基礎" class="headerlink" title="付録B 構文の基礎"></a>付録B 構文の基礎</h2><ul><li>関数型インターフェスのクイック・リファレンス</li></ul><h3 id="B-1-関数型インタフェースの定義"><a href="#B-1-関数型インタフェースの定義" class="headerlink" title="B.1 関数型インタフェースの定義"></a>B.1 関数型インタフェースの定義</h3><ul><li>関数型インターフェース<ul><li>interface実装して、<code>@FunctionalInterface</code>を付与する</li><li>実装されていないabstractメソッドを必ず１つ持つ</li><li>必要に応じて実装されたdefaultメソッドを持つ</li><li>staticメソッドも持つことができる</li></ul></li></ul><h3 id="B-2-パラメータを持たないラムダ式の生成"><a href="#B-2-パラメータを持たないラムダ式の生成" class="headerlink" title="B.2 パラメータを持たないラムダ式の生成"></a>B.2 パラメータを持たないラムダ式の生成</h3><h3 id="B-3-パラメータ-1つのラムダ式の生成"><a href="#B-3-パラメータ-1つのラムダ式の生成" class="headerlink" title="B.3 パラメータ 1つのラムダ式の生成"></a>B.3 パラメータ 1つのラムダ式の生成</h3><p>型推論は効くが、明示した場合は <code>(final String str) -&gt; System.out.println(str);</code>などとする</p><h3 id="B-4-ラムダ式のパラメータ型を推論する"><a href="#B-4-ラムダ式のパラメータ型を推論する" class="headerlink" title="B.4 ラムダ式のパラメータ型を推論する"></a>B.4 ラムダ式のパラメータ型を推論する</h3><ul><li>通常、型推論されるが、１つでも型を明示的に記載する必要がある場合、</li><li>すべて引数の型を記載する必要がある</li></ul><h3 id="B-5-パラメータ-1つのラムダ式では括弧を省略可能"><a href="#B-5-パラメータ-1つのラムダ式では括弧を省略可能" class="headerlink" title="B.5 パラメータ 1つのラムダ式では括弧を省略可能"></a>B.5 パラメータ 1つのラムダ式では括弧を省略可能</h3><ul><li><code>(name) -&gt; ;</code>とかいても <code>name -&gt; ;</code>とかいてもよい</li></ul><h3 id="B-6-複数パラメータを持つラムダ式の生成"><a href="#B-6-複数パラメータを持つラムダ式の生成" class="headerlink" title="B.6 複数パラメータを持つラムダ式の生成"></a>B.6 複数パラメータを持つラムダ式の生成</h3><ul><li>複数のパラメータを持つ場合はカッコが必須 <code>frinends.stream().reduce((name1,name2) -&gt; name1.length() &gt;= name2.length() ? name1 : name2);</code></li></ul><h3 id="B-7-複数の型のパラメータを持つメソッドを呼び出す"><a href="#B-7-複数の型のパラメータを持つメソッドを呼び出す" class="headerlink" title="B.7 複数の型のパラメータを持つメソッドを呼び出す"></a>B.7 複数の型のパラメータを持つメソッドを呼び出す</h3><ul><li>ラムダ式やメソッド参照を引数に渡せる</li></ul><h3 id="B-8-ラムダ式を変数に格納"><a href="#B-8-ラムダ式を変数に格納" class="headerlink" title="B.8 ラムダ式を変数に格納"></a>B.8 ラムダ式を変数に格納</h3><ul><li>再利用するためにラムダ式を変数に格納できる</li></ul><h3 id="B-9-複数行のラムダ式を生成"><a href="#B-9-複数行のラムダ式を生成" class="headerlink" title="B.9 複数行のラムダ式を生成"></a>B.9 複数行のラムダ式を生成</h3><ul><li>ラムダ式は複数行に渡って記載できる</li><li>必要に応じて、return文を記載しないといけない</li></ul><h3 id="B-10-ラムダ式を返す"><a href="#B-10-ラムダ式を返す" class="headerlink" title="B.10 ラムダ式を返す"></a>B.10 ラムダ式を返す</h3><ul><li>メソッドの戻り値型として関数型インタフェースを指定できる</li></ul><h3 id="B-11-ラムダ式からラムダ式を返す"><a href="#B-11-ラムダ式からラムダ式を返す" class="headerlink" title="B.11 ラムダ式からラムダ式を返す"></a>B.11 ラムダ式からラムダ式を返す</h3><ul><li>ラムダ式を返すラムダ式をかける</li></ul><h3 id="B-12-クロージャにおける静的スコープ"><a href="#B-12-クロージャにおける静的スコープ" class="headerlink" title="B.12 クロージャにおける静的スコープ"></a>B.12 クロージャにおける静的スコープ</h3><h3 id="B-13-インスタンスメソッドのメソッド参照を渡す"><a href="#B-13-インスタンスメソッドのメソッド参照を渡す" class="headerlink" title="B.13 インスタンスメソッドのメソッド参照を渡す"></a>B.13 インスタンスメソッドのメソッド参照を渡す</h3><h3 id="B-14-メソッド参照をstaticメソッドに渡す"><a href="#B-14-メソッド参照をstaticメソッドに渡す" class="headerlink" title="B.14 メソッド参照をstaticメソッドに渡す"></a>B.14 メソッド参照をstaticメソッドに渡す</h3><h3 id="B-15-メソッド参照を他のインスタンスのメソッドに渡す"><a href="#B-15-メソッド参照を他のインスタンスのメソッドに渡す" class="headerlink" title="B.15 メソッド参照を他のインスタンスのメソッドに渡す"></a>B.15 メソッド参照を他のインスタンスのメソッドに渡す</h3><h3 id="B-16-複数の引数を取るメソッドの参照を渡す"><a href="#B-16-複数の引数を取るメソッドの参照を渡す" class="headerlink" title="B.16 複数の引数を取るメソッドの参照を渡す"></a>B.16 複数の引数を取るメソッドの参照を渡す</h3><h3 id="B-17-コンストラクタ参照を使う"><a href="#B-17-コンストラクタ参照を使う" class="headerlink" title="B.17 コンストラクタ参照を使う"></a>B.17 コンストラクタ参照を使う</h3><h3 id="B-18-関数合成"><a href="#B-18-関数合成" class="headerlink" title="B.18 関数合成"></a>B.18 関数合成</h3><h2 id="付録C-Web上のリソース"><a href="#付録C-Web上のリソース" class="headerlink" title="付録C Web上のリソース"></a>付録C Web上のリソース</h2><ul><li><p>Cutting Stock問題</p><ul><li><a href="https://en.wikipedia.org/wiki/Cutting_stock_problem" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Cutting_stock_problem</a></li><li>メモ化テクニックを使って解決できる最適化問題</li></ul></li><li><p>依存関係逆転の原則</p><ul><li>クラスの実装で拡張するのではなく、抽象（インタフェース）とカップリングすることによる拡張方法を説明している</li></ul></li><li><p>DRY原則</p><ul><li><a href="https://ja.wikipedia.org/wiki/Don%27t_repeat_yourself" target="_blank" rel="noopener">https://ja.wikipedia.org/wiki/Don%27t_repeat_yourself</a></li></ul></li><li><p>本質と儀式について（Essence vs. Ceremony）</p><ul><li>→古いからやめようと思う</li></ul></li><li><p>Execute Around Methodパターン</p></li><li><p>ローンパターン(Loan Pattern)</p><ul><li>Scalaにおけるローンパターンの紹介</li><li>記事がなかった<ul><li><a href="https://docs.scala-lang.org/" target="_blank" rel="noopener">https://docs.scala-lang.org/</a></li></ul></li></ul></li><li><p>伝えろ。聞くな。</p><ul><li><a href="https://pragprog.com/articles/tell-dont-asks" target="_blank" rel="noopener">https://pragprog.com/articles/tell-dont-asks</a></li><li>伝えろ、聞くなという原則を説明するコラム</li></ul></li><li><p>書籍サイト</p><ul><li><a href="https://pragprog.com/" target="_blank" rel="noopener">https://pragprog.com/</a></li></ul></li></ul><h2 id="付録D-参考文献"><a href="#付録D-参考文献" class="headerlink" title="付録D 参考文献"></a>付録D 参考文献</h2><h2 id="訳者あとがき"><a href="#訳者あとがき" class="headerlink" title="訳者あとがき"></a>訳者あとがき</h2><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Javaによる関数型プログラミングJava8ラムダ式とStream&quot;&gt;&lt;a href=&quot;#Javaによる関数型プログラミングJava8ラムダ式とStream&quot; class=&quot;headerlink&quot; title=&quot;Javaによる関数型プログラミングJava8ラムダ式
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java EE 7徹底入門 標準Javaフレームワークによる高信頼性Webシステムの構築</title>
    <link href="http://yoursite.com/JAVA/2020-04_JavaEE7%E5%BE%B9%E5%BA%95%E5%85%A5%E9%96%80/"/>
    <id>http://yoursite.com/JAVA/2020-04_JavaEE7徹底入門/</id>
    <published>2020-04-11T15:00:00.000Z</published>
    <updated>2020-04-26T03:36:09.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-EE-7徹底入門-標準Javaフレームワークによる高信頼性Webシステムの構築"><a href="#Java-EE-7徹底入門-標準Javaフレームワークによる高信頼性Webシステムの構築" class="headerlink" title="Java EE 7徹底入門 標準Javaフレームワークによる高信頼性Webシステムの構築"></a>Java EE 7徹底入門 標準Javaフレームワークによる高信頼性Webシステムの構築</h1><ul><li>形式：書籍</li><li>発売日：2015年12月15日</li><li>ISBN：9784798140926</li><li>価格：本体3,800円＋税</li><li>仕様：B5変・584ページ</li><li>分類：プログラミング・開発</li><li><p>シリーズ：徹底入門</p></li><li><p>書籍ページ <a href="https://www.shoeisha.co.jp/book/detail/9784798140926" target="_blank" rel="noopener">https://www.shoeisha.co.jp/book/detail/9784798140926</a></p></li><li><p>サンプルプログラム <a href="https://www.shoeisha.co.jp/book/download/9784798140926/detail" target="_blank" rel="noopener">https://www.shoeisha.co.jp/book/download/9784798140926/detail</a></p></li></ul><h2 id="Chapter-1-Java-EEの基礎知識"><a href="#Chapter-1-Java-EEの基礎知識" class="headerlink" title="Chapter 1 Java EEの基礎知識"></a>Chapter 1 Java EEの基礎知識</h2><h3 id="1-1-Java-EEのこれまで"><a href="#1-1-Java-EEのこれまで" class="headerlink" title="1.1 Java EEのこれまで"></a>1.1 Java EEのこれまで</h3><ul><li>1995年 Sun Microsytems,Inc<ul><li>JDK1.0 α版</li></ul></li><li>1998年 Sun JPEと呼ぶプロジェクトを立ち上げ<ul><li>サーバー側の企業アプリケーション開発にJavaを利用できるようにするために立ち上げ</li></ul></li><li>1999年12月 フレームワーク提供(J2EE 1.2)<ul><li>10個の機能から構成<ul><li>JSP+Servlet → 急速に普及</li><li>EJB</li></ul></li></ul></li><li>2001年 J2EE 1.3</li><li>2003年 J2EE 1.4<ul><li>XML対応</li></ul></li><li><p>このころ、オープンソースのフレームワークも台頭</p></li><li><p>2006年5月 簡単開発(Ease of Development)をテーマに、名前を改名</p><ul><li>Java Platform Enterprise Edition(JavaEE)と改め新バージョンをリリース</li><li>Java EE 5<ul><li>普及には至らず</li><li>改善をすすめる</li></ul></li></ul></li><li>2009年12月 JavaEE5をさらに大幅改善したJavaEE6をリリース<ul><li>CDI</li><li>プロファイル：全仕様に対するサブセットを提供</li><li>プルーニング：使われなくなって古くなった使用を整理するための仕組み</li><li>→ ミッションクリティカルな企業システムでも採用されるようになった</li></ul></li></ul><h4 id="1-1-3-Java-EE-7-へ-—-3つのテーマ"><a href="#1-1-3-Java-EE-7-へ-—-3つのテーマ" class="headerlink" title="1.1.3 Java EE 7 へ — 3つのテーマ"></a>1.1.3 Java EE 7 へ — 3つのテーマ</h4><ul><li><p>JavaEE6のリリース後、すぐに次期バージョンの検討</p><ul><li>目をつけたのは「クラウド」</li><li>より簡単にJavaEEアプリケーションをスケールするような機能を考え、GlassFishというアプリケーション・サーバー上で実際に動作するサンプルも作成<ul><li>外部からのフィードバックやスペックリードが集まって再検討した結果次期が早いと判断し見送り</li></ul></li></ul></li><li><p>Column JavaEE7 におけるクラウド対応の見送り</p><ul><li>2012年8月12日 開発の遅れと、仕様化に対する十分な経験、検討が足りなかったため見送りを決定</li><li>期待があった分失望の声もあったが</li><li>有識者やベンダーの多くはこの決断を支持</li></ul></li><li><p>新しいテーマを考えた</p><ul><li>HTML5対応</li><li>開発用意/生産性の向上</li><li>エンタープライズニーズへの対応</li></ul></li></ul><h3 id="1-2-Java-EEの全体像"><a href="#1-2-Java-EEの全体像" class="headerlink" title="1.2 Java EEの全体像"></a>1.2 Java EEの全体像</h3><ul><li><p>Java EEに含まれる機能の全体像を把握してください</p></li><li><p>JavaEEは企業システムのアプリケーション開発に必要なさまざまな機能を１つにまとめた包括仕様（umbrella specification）の総称</p></li><li><p>大小さまざまな39個の仕様から構成されています。</p></li><li><p>主に</p><ul><li>インテグレーションテクノロジー</li><li>ビジネスロジックテクノロジー</li><li>プレゼンテーションテクノロジー<ul><li>を組み合わせながらシステムを構築する</li></ul></li></ul></li><li><p>インテグレーションテクノロジー</p><ul><li>外部システムと連携するための機能を提供</li><li>外部システム<ul><li>データベース</li><li>メールサーバー</li><li>メッセージングプロバイダ（OpenMQ,WebShereMQ）</li><li>エンタープライズ情報システム（ERP,メインフレーム）等がある</li></ul></li></ul></li><li><p>ビジネスロジックテクノロジー</p><ul><li>外部システムと連携するプログラムの実装とユーザーインターフェースのプログラムの実装の間に入り、企業システムの業務で必要とされる処理を実装<ul><li>トランザクションの処理や業務のフローの実装など</li></ul></li></ul></li><li><p>プレゼンテーションテクノロジー</p><ul><li>様々なデバイスからアクセスされることを考慮する必要がある</li><li>人だけでなく、物も含め、企業システムに対してアクセスするためのインターフェースを提供</li></ul></li></ul><h4 id="1-2-2-Java-EEに含まれる機能"><a href="#1-2-2-Java-EEに含まれる機能" class="headerlink" title="1.2.2 Java EEに含まれる機能"></a>1.2.2 Java EEに含まれる機能</h4><ul><li>Java Persistence API(JPA)<ul><li>ORM機能</li><li>JavaSEでも利用可能</li></ul></li><li>Java Messagge Service(JMS)<ul><li>外部のメッセージングプロバイダを経由して非同期でテキストメッセージやバイナリメッセージを送受信</li><li>JavaSEでも利用可能</li></ul></li><li>Batch Applications for the Java Platform<ul><li>データをまとめて一括処理する場合に利用</li><li>JavaSEでも利用可能</li></ul></li><li>Java Mail API<ul><li>電子メールクライアントを作成するために必要な機能を提供</li></ul></li><li>Java EE Connector Architecture(JCA)<ul><li>EAIを行うために必要な機能を提供</li></ul></li><li>DI/CDI<ul><li>JavaEEに含まれる技術を疎結合で結び合わせるための技術</li></ul></li><li>Enterprise JavaBeans(EJB)<ul><li>もともと、分散コンポーネントを作成するための技術として作られました</li><li>JavaEE5以降、EJBはビジネスロジックを簡単に実装するための技術として大きく生まれ変わりました</li><li>XMLの設定は不要で、クラスに対して宣言的に定義できるようになっています。</li></ul></li><li>Java Transaction API(JTA)<ul><li>トランザクション管理を行うための技術</li></ul></li><li>JavaServer Pages(JSP), JSP Standard Tag Library(JSTL)<ul><li>JSPは動的ページ作成</li><li>JSTLは、ページ内のループ処理やSQLを使用したデータベースアクセスなど、JSPで共通する機能を隠蔽して利用できるようにした専用タグ<ul><li>JSFの導入以降は徐々に置き換えが進む</li></ul></li></ul></li><li>JSON-P<ul><li>JavaEE7から新たに導入されたJavaEEでJSONを扱うための機能</li><li>次期バージョンでは、JSONデータとJavaオブジェクトをマッピングするJSON Bindingの提供も予定されている<ul><li>→ もう対応されている？</li></ul></li></ul></li><li>Expression Language(EL)<ul><li>簡単な式や変数などを用いて、記述内容の評価が行える言語として作られました</li></ul></li><li>Servlet<ul><li>ServletのプログラムはServletコンテナ（Webコンテナとも呼ばれる）と呼ばれる実行環境上でどうsあ</li><li>HTTP/1.0及び1.1のリクエストに応答する</li><li>ServletはHTTP処理に対する低レベルAPIしか提供しないため、現在はServletのAPIだけでプログラミングを行う場面は少ない</li><li>JSFのようなServletコンテナ上で動作する上位フレームワークへ処理を以上するための仲介役として利用されることが多い</li></ul></li><li>WebSocket<ul><li>HTTPプロトコルをアップグレードした、双方向/全二重通信が可能なプロトコル</li><li>HTTPと比べてメッセージ送受信の際のオーバーヘッドが少ないため、効果的にリアルタイムメッセージの送受信ができる</li></ul></li><li>Java API for RESTful Web Services(JAX-RS)<ul><li>RESTアーキテクチャに基づいてWebサービスを実装するための機能を提供</li><li>従来、Webサービスの実装にはSOAP Webサービス(JAX-WS)とXMLを用いるのが主流だった</li><li>現在は、分散システム間連携を行うために、RESTful WebサービスとJSONを組み合わせて実装する場面が多くなっている</li><li>JAX-RSの仕様は、HTTPの仕様と密接に関連しており、HTTPメソッドに対応するアノテーションを用いて処理を実装する<ul><li>JAX-WSからJAX-RSへと主流が変わってきたことを理解した</li></ul></li></ul></li><li><p>JavaServer Faces(JSF)</p><ul><li>コンポーネントベースで開発が可能なWebアプリケーション開発フレームワーク</li><li>画面は、フェースレット（Facelets）と呼ばれるXHTML形式のテキストファイルに、HTMLタグやJSF専用タグを記入してデザイン</li><li>バックエンドの処理はマネージドビーン（Managed Bean）と呼ばれるPOJOクラス、もしくはCDIクラスで処理を実装</li><li>JSFは標準でHTML5やAjaxへも対応しており、Javascriptの知識がなくても簡単にAjaxプログラミングが行えます</li></ul></li><li><p>ビーンバリデーション</p><ul><li>データの整合性を検証するための機能</li></ul></li><li><p>Common Annotation</p><ul><li>JavaEE5でMetadata facility for Javaという機能が追加された</li><li>これに関連して、JavaSE環境、JavaEE環境の両方で共通して利用可能なアノテーションが定期された</li><li>例えば<ul><li>インスタンスの生成時、破棄時になんらかの処理を行うことを規定したもの</li><li>処理に対する実行権限を規定したもの</li><li>データベース設定を規定したもの</li></ul></li><li>これらのアノテーションを利用して宣言的にプログラミングを行う</li></ul></li><li><p>Managed Bean</p><ul><li>Common Annotationの中に、Managed Beanというアノテーションがある</li><li>JavaEE環境で管理されているBeanであることが明示される</li><li>Managed Beanは、アプリケーション・サーバーで管理されているリソースの参照や、インスタンスのライフサイクル管理ができる</li><li><strong>通常、Managed Beanのアノテーションを付加したクラスを実装することはほとんど無い</strong><ul><li>しかし、Managed Beanの機能を持つ上位機能（CDI、EJB）でManaged Beanの機能を利用する</li></ul></li></ul></li><li><p>Interceptors</p><ul><li>複数の機能間で横断的な関心事の実装を行うための機能です。</li><li>例えば<ul><li>ログの出力や各処理時間の計測、セキュリティの検査などは、特定部分の実装に限らず、システムの全体で必要な実装</li></ul></li></ul></li><li><p>Concurrency Utilities for Java EE</p><ul><li>JavaEE環境で新たにスレッドを生成するための機能</li><li>JavaEE6まではサーバー環境上で新たなスレッドを生成することは非推奨でした。なぜならば、作成されたスレッドがアプリケーション・サーバーから管理できないスレッドとして動作するためでした</li><li>たとえば<ul><li>セキュリティ情報や、トランザクション情報、コンテキスト情報などを一切含まないため、アプリケーション・サーバーから制御することは不可能</li></ul></li><li>そこで、サーバーが管理できるスレッドを作るために、JavaEE7からConcurrency Utilities for Java EEが新たに導入された</li></ul></li></ul><h4 id="1-2-3-Java-EE-の仕様策定"><a href="#1-2-3-Java-EE-の仕様策定" class="headerlink" title="1.2.3 Java EE の仕様策定"></a>1.2.3 Java EE の仕様策定</h4><ul><li><p>Javaの仕様はJCP(Java Community Process)という団体で管理</p><ul><li>Java Specification Requests(JSR)と呼ぶ仕様のリクエストに対して、一意の番号を割り当てて管理している</li></ul></li><li><p>JSRをJCPに提出するために必要な成果物について記載（割愛）</p></li></ul><h4 id="1-2-4-Java-EEの実行環境とプロファイル"><a href="#1-2-4-Java-EEの実行環境とプロファイル" class="headerlink" title="1.2.4 Java EEの実行環境とプロファイル"></a>1.2.4 Java EEの実行環境とプロファイル</h4><ul><li>割愛</li></ul><h3 id="1-3-Java-EEアプリケーション開発の基本"><a href="#1-3-Java-EEアプリケーション開発の基本" class="headerlink" title="1.3 Java EEアプリケーション開発の基本"></a>1.3 Java EEアプリケーション開発の基本</h3><h4 id="1-3-1-Java-EEアプリケーションモデル"><a href="#1-3-1-Java-EEアプリケーションモデル" class="headerlink" title="1.3.1 Java EEアプリケーションモデル"></a>1.3.1 Java EEアプリケーションモデル</h4><ul><li>3階層アプリケーションの開発モデルを採用している<ul><li>ビジネスロジックとユーザーインターフェースを切り分けて実装することが大事</li><li>柔軟性の高いシステムを構築していくことが大事</li></ul></li></ul><h3 id="1-4-開発環境の準備"><a href="#1-4-開発環境の準備" class="headerlink" title="1.4 開発環境の準備"></a>1.4 開発環境の準備</h3><ul><li>サンプルアプリケーション<ul><li>JavaSE8</li><li>JavaEE7</li><li>GlassFishv4.1.1 (JavaEE参照実装)</li></ul></li></ul><h4 id="1-4-1-Oracle-JDKのインストール"><a href="#1-4-1-Oracle-JDKのインストール" class="headerlink" title="1.4.1 Oracle JDKのインストール"></a>1.4.1 Oracle JDKのインストール</h4><h4 id="1-4-2-NetBeansのインストール"><a href="#1-4-2-NetBeansのインストール" class="headerlink" title="1.4.2 NetBeansのインストール"></a>1.4.2 NetBeansのインストール</h4><h4 id="1-4-3-NetBeansの起動"><a href="#1-4-3-NetBeansの起動" class="headerlink" title="1.4.3 NetBeansの起動"></a>1.4.3 NetBeansの起動</h4><h3 id="1-5-サンプルアプリケーションの概要"><a href="#1-5-サンプルアプリケーションの概要" class="headerlink" title="1.5 サンプルアプリケーションの概要"></a>1.5 サンプルアプリケーションの概要</h3><h4 id="1-5-1-ナレッジバンク"><a href="#1-5-1-ナレッジバンク" class="headerlink" title="1.5.1 ナレッジバンク"></a>1.5.1 ナレッジバンク</h4><ul><li>個人が保有する知識情報（ナレッジ）を共有するためのWebアプリケーション</li><li><p>JavaEE7で一般的なWebアプリケーションを実装するために必要な機能を使用して構築されている</p></li><li><p>画面遷移などの説明</p></li></ul><h4 id="1-5-2-ナレッジバンクのセットアップ"><a href="#1-5-2-ナレッジバンクのセットアップ" class="headerlink" title="1.5.2 ナレッジバンクのセットアップ"></a>1.5.2 ナレッジバンクのセットアップ</h4><ul><li>プロジェクトを読み込み</li></ul><h3 id="1-6-まとめ"><a href="#1-6-まとめ" class="headerlink" title="1.6 まとめ"></a>1.6 まとめ</h3><ul><li>この章のまとめを記載（割愛）</li></ul><h2 id="Chapter-2-プレゼンテーション層の開発――JSFの基本"><a href="#Chapter-2-プレゼンテーション層の開発――JSFの基本" class="headerlink" title="Chapter 2 プレゼンテーション層の開発――JSFの基本"></a>Chapter 2 プレゼンテーション層の開発――JSFの基本</h2><ul><li>以下の３層に分けて開発を行う<ul><li>プレゼンテーション層</li><li>ビジネスロジック層</li><li>インテグレーション層</li></ul></li></ul><h3 id="2-1-JSF概要"><a href="#2-1-JSF概要" class="headerlink" title="2.1 JSF概要"></a>2.1 JSF概要</h3><h4 id="2-1-1-JavaSErver-Faces-JSF-とは"><a href="#2-1-1-JavaSErver-Faces-JSF-とは" class="headerlink" title="2.1.1 JavaSErver Faces(JSF)とは"></a>2.1.1 JavaSErver Faces(JSF)とは</h4><ul><li><p>JSFとはJavaEE5から追加されたプレゼンテーション層を作成するための仕様</p><ul><li>今まではServletを使用していた<ul><li>サーブレットとは：ブラウザとHTTP通信を行う基礎的な仕様で、最小限の機能を提供<ul><li>入力値とJavaオブジェクトのマッピング</li><li>入力値のチェック</li><li>エラーメッセージのハンドリング<ul><li>など多くの機能が不足していた</li></ul></li></ul></li></ul></li></ul></li><li><p>Column MVC1.0</p><ul><li>次のバージョンのJavaEE8には、「MVC1.0」というプレゼンテーション層を開発する新しい仕様が加わる予定</li><li>Webアプリケーションを開発するフレームワークには、HTTPの通信に紐付けて処理を記述するアクションベースのフレームワーク</li><li>入力フィールドやボタンに紐付けて処理を記述するコンポーネントベースのフレームワークがある</li><li>本書で記述するJSFはコンポーネントベースのフレームワーク</li><li>そのため開発者から、アクションベースの選択肢も必要という意見があがり、JavaEE8でアクションベースのフレームワークである「MVC1.0」を追加することになった</li></ul></li></ul><h3 id="2-2-JSFの構成要素"><a href="#2-2-JSFの構成要素" class="headerlink" title="2.2 JSFの構成要素"></a>2.2 JSFの構成要素</h3><h4 id="2-2-1-画面と処理（フェースレットとマネージドビーン）"><a href="#2-2-1-画面と処理（フェースレットとマネージドビーン）" class="headerlink" title="2.2.1 画面と処理（フェースレットとマネージドビーン）"></a>2.2.1 画面と処理（フェースレットとマネージドビーン）</h4><ul><li><p>フェースレットとは</p><ul><li>画面レイアウトを記述するXHTMLベースのテンプレートエンジン</li><li>XHTMLとは、HTMLをXMLの文法に適合するように定義し直したもの</li></ul></li><li><p>フェースレットとBeanがどのように紐付いているかを確認</p></li><li><p>Column マネージドビーンとバッキングビーン</p><ul><li>フェースレット似バインドするJavaクラスはマネージドビーンといいますが、</li><li>フェースレットの裏側で処理を行うという意味で、バッキングビーンと呼ばれることもあります。</li><li>マネージドビーンがCDIでも代用できるようになった頃からJSFで使用するマネージドビーンをバッキングビーンと呼ぶことが多くなった</li></ul></li></ul><h4 id="2-2-2-マネージドビーンとスコープ"><a href="#2-2-2-マネージドビーンとスコープ" class="headerlink" title="2.2.2 マネージドビーンとスコープ"></a>2.2.2 マネージドビーンとスコープ</h4><ul><li><p>スコープ：マネージドビーンのデータをいつまで保有するかを指定する</p></li><li><p>スコープの一覧の紹介</p></li></ul><h3 id="2-3-JSFの画面遷移"><a href="#2-3-JSFの画面遷移" class="headerlink" title="2.3 JSFの画面遷移"></a>2.3 JSFの画面遷移</h3><h4 id="2-3-1-画面遷移の方法"><a href="#2-3-1-画面遷移の方法" class="headerlink" title="2.3.1 画面遷移の方法"></a>2.3.1 画面遷移の方法</h4><ul><li><p>JSFで次の画面に遷移する場合、遷移先の名前を文字列で指定</p><ul><li>この画面遷移に使用する文字列を「outcome値」といいます</li><li>遷移するフェースレットのパスを指定</li></ul></li><li><p>静的な遷移</p><ul><li>マネージドビーンの処理を行わずに直接次の画面に遷移する方法</li></ul></li><li><p>動的な遷移</p><ul><li>マネージドビーンで処理を行い、その結果を基に任意の画面へ遷移する方法</li><li>EL式でメソッドをバインドしている</li></ul></li></ul><h4 id="2-3-2-画面のリダイレクト"><a href="#2-3-2-画面のリダイレクト" class="headerlink" title="2.3.2 画面のリダイレクト"></a>2.3.2 画面のリダイレクト</h4><ul><li><p>画面遷移</p><ul><li>フォワード：処理後に直接Web画面を生成して結果を返す</li><li>リダイレクト：一度ブラウザに処理を返した後にサーバーに再アクセスしてWeb画面を生成する</li></ul></li><li><p>JSFではリダイレクトを使用して次の画面に遷移する方法を提供している</p><ul><li>１画面前のURLを表示することを避けるためにこの機能を提供<ul><li><code>?faces-redirect=true</code>というパラメータを付与すると動くらしい</li></ul></li><li>問題：リクエストスコープが効かなくなる<ul><li>対策：フラッシュスコープという特別なスコープを提供している</li></ul></li></ul></li></ul><h3 id="2-4-JSFの内部処理"><a href="#2-4-JSFの内部処理" class="headerlink" title="2.4 JSFの内部処理"></a>2.4 JSFの内部処理</h3><h4 id="2-4-1-コンポーネント指向"><a href="#2-4-1-コンポーネント指向" class="headerlink" title="2.4.1 コンポーネント指向"></a>2.4.1 コンポーネント指向</h4><ul><li>JSFではWebアプリケーションをより直感的に開発するためにコンポーネントという考え方を導入している</li><li><p>メリット</p><ul><li>Web画面と処理の紐付けを直感的に行える（HTTPの理解が不要）</li><li>コンポーネントが再利用しやすい</li><li>Web画面のプロトタイプ作成が容易に行える</li></ul></li><li><p>コンポーネントツリーとしてアクセスできるJavaクラスが存在するらしい</p></li></ul><h4 id="2-4-2-ライフサイクル"><a href="#2-4-2-ライフサイクル" class="headerlink" title="2.4.2 ライフサイクル"></a>2.4.2 ライフサイクル</h4><ol><li>ビューの復元(Restore View)</li><li>リクエスト値の適用(Apply Request Values)</li><li>入力チェック(Process Validations)</li><li>モデル値の更新(Update Model Values)</li><li>アプリケーションの実施(Invoke Application)</li><li>画面の生成(REnder Response)</li></ol><ul><li>最初のアクセスの場合<ul><li>①の復元フェーズ終了後に、⑥の画面生成フェーズに進み、画面を表示</li></ul></li><li>ポストバックの場合<ul><li>すでにコンポーネントツリーがあり、値の入力やボタンの操作が実施されているので、</li><li>①→⑥まで順番に実施</li></ul></li></ul><h3 id="2-5-JSFの基本設定"><a href="#2-5-JSFの基本設定" class="headerlink" title="2.5 JSFの基本設定"></a>2.5 JSFの基本設定</h3><h4 id="2-5-1-フォルダ構成"><a href="#2-5-1-フォルダ構成" class="headerlink" title="2.5.1 フォルダ構成"></a>2.5.1 フォルダ構成</h4><ul><li><p>JSFを使用したWebアプリケーションを作成するにはWAR形式のプロジェクトを作成</p></li><li><p>EAR形式もある</p><ul><li>複数のWARファイルやJARファイルを１つにまとめてZIPにしたもの</li></ul></li></ul><h4 id="2-5-2-設定ファイル"><a href="#2-5-2-設定ファイル" class="headerlink" title="2.5.2 設定ファイル"></a>2.5.2 設定ファイル</h4><ul><li><p>必要な設定ファイル</p><ul><li>web.xml</li><li>faces-config.xml</li><li>アプリケーションサーバーの設定ファイル</li></ul></li><li><p>web.xml</p><ul><li>デプロイメントディスクリプタというWebアプリケーションの設定を記述するファイル<ul><li>webアプリケーションの初期設定</li><li>サーブレットの設定</li><li>セキュリティの設定</li></ul></li><li>WebアプリケーションでJSFを使用する場合は、web.xmlにJSFが提供するFacesServletを設定</li></ul></li><li><p>サーブレットの定義</p><ul><li>JSFは内部でサーブレットを使用している</li><li>そのためJSFを使用するにはJSFのサーブレット指定が必要</li><li>ロードオンスタートアップの指定はサーバーの起動時にサーブレットのインスタンス化と初期化を行うという指定</li></ul></li><li><p>サーブレットのマッピング定義</p><ul><li>URLパターンとサーブレットの定義で指定したサーブレット名を指定</li><li>URLパターンは「/faces/*」という指定がJSFでは一般的らしい</li><li>facesで始まっている場合に、JSFのアクセスであるとみなされる</li></ul></li><li><p>faces-config.xml</p><ul><li>JSFの設定を記述するファイル<ul><li>国際化のせてい</li><li>フェーズリスなのクラス指定など</li></ul></li></ul></li><li><p>アプリケーション・サーバー用の設定ファイル</p></li></ul><h4 id="2-5-3-リソースフォルダ"><a href="#2-5-3-リソースフォルダ" class="headerlink" title="2.5.3 リソースフォルダ"></a>2.5.3 リソースフォルダ</h4><ul><li>JSFの仕様で<code>resources</code>フォルダに配置するフォルダ構成が決められているらしい</li><li><code>resouces/[ローカルプレフィックス]/[ライブラリ名]/[ライブラリバージョン]/[リソース名]/[リソースバージョン]</code><ul><li>→わかりにくいと感じた</li></ul></li></ul><h3 id="2-6-フェースレットタグライブラリ"><a href="#2-6-フェースレットタグライブラリ" class="headerlink" title="2.6 フェースレットタグライブラリ"></a>2.6 フェースレットタグライブラリ</h3><h4 id="2-6-1-タグライブラリの種類"><a href="#2-6-1-タグライブラリの種類" class="headerlink" title="2.6.1 タグライブラリの種類"></a>2.6.1 タグライブラリの種類</h4><ul><li><p>タグライブラリ</p><ul><li>画面レイアウトで使用するタグを定義したもの</li></ul></li><li><p>種類</p><ul><li>コアタグライブラリ：他のタグライブラリのサポート的な機能を提供するタグライブラリ</li><li>HTMLタグライブラリ：HTMLのタグを生成するタグライブラリ</li><li>フェースレットテンプレーティングタグライブラリ：画面のテンプレート処理や繰り返し処理などを提供するタグライブラリ</li><li>コンポジットコンポーネントタグライブラリ：コンポジットコンポーネントの作成に使用するタグライブラリ</li><li>JSTLコア/ファンクションタグライブラリ：JSPで使用するタグライブラリ</li></ul></li><li><p>最も使用頻度が高いのは「HTMLタグライブラリ</p></li><li><p>JSTLコア/ファンクションタグライブラリ：JSPというJavaEEの仕様で使用するライブラリでJSFでも使用できるが、他のフェースレットが提供するタグライブラリとの実行タイミングが違うため不具合が発生しやすく、基本的に利用しない</p></li><li><p>※ここで再確認</p><ul><li>JSF<ul><li>フェースレット<ul><li>フェースレットタグライブラリ</li><li>EL式</li></ul></li><li>マネージドビーン</li></ul></li></ul></li><li><p>タグライブラリを利用するには、冒頭でネームスペースの宣言が必要</p></li></ul><h4 id="2-6-2-HTMLタグライブラリ"><a href="#2-6-2-HTMLタグライブラリ" class="headerlink" title="2.6.2 HTMLタグライブラリ"></a>2.6.2 HTMLタグライブラリ</h4><ul><li>一覧を表で記載（割愛）</li></ul><h4 id="2-6-3-ヘッダーとボディ"><a href="#2-6-3-ヘッダーとボディ" class="headerlink" title="2.6.3 ヘッダーとボディ"></a>2.6.3 ヘッダーとボディ</h4><p><code>&lt;h:head&gt;</code><br><code>&lt;h:body&gt;</code></p><h4 id="2-6-4-リソース"><a href="#2-6-4-リソース" class="headerlink" title="2.6.4 リソース"></a>2.6.4 リソース</h4><h4 id="2-6-5-文字の出力"><a href="#2-6-5-文字の出力" class="headerlink" title="2.6.5 文字の出力"></a>2.6.5 文字の出力</h4><h4 id="2-6-6-リンクとボタン"><a href="#2-6-6-リンクとボタン" class="headerlink" title="2.6.6 リンクとボタン"></a>2.6.6 リンクとボタン</h4><p>(割愛)</p><h3 id="2-7-EL（Expression-Language）"><a href="#2-7-EL（Expression-Language）" class="headerlink" title="2.7 EL（Expression Language）"></a>2.7 EL（Expression Language）</h3><h4 id="2-7-1-ELとは"><a href="#2-7-1-ELとは" class="headerlink" title="2.7.1 ELとは"></a>2.7.1 ELとは</h4><ul><li>ELとは、演算の結果や値の参照結果を返却するための簡易記法</li><li><code>#</code>または、<code>$</code>で始まり、波括弧で囲んだ中に式を記述<ul><li><code>$</code>を使用した場合：ページがレンダリングされた時点で即時評価</li><li><code>#</code>を使用した場合：コンポーネントに式として渡され、ライフサイクルのタイミングで遅延評価される<ul><li>JSFでは基本的に<code>$</code>を使用せずに、<code>#</code>を使用する</li></ul></li></ul></li></ul><h4 id="2-7-2-オブジェクトの参照"><a href="#2-7-2-オブジェクトの参照" class="headerlink" title="2.7.2 オブジェクトの参照"></a>2.7.2 オブジェクトの参照</h4><ul><li><code>@Named</code>を付与したマネージドビーンの名前はEL式から参照できる</li></ul><h4 id="2-7-3-暗黙オブジェクト"><a href="#2-7-3-暗黙オブジェクト" class="headerlink" title="2.7.3 暗黙オブジェクト"></a>2.7.3 暗黙オブジェクト</h4><ul><li>暗黙的に参照可能なオブジェクト一覧を記載（割愛）</li></ul><h4 id="2-7-4-演算子"><a href="#2-7-4-演算子" class="headerlink" title="2.7.4 演算子"></a>2.7.4 演算子</h4><ul><li>算術演算子</li><li>関係演算子</li><li>論理演算子</li><li>三項演算子</li><li>空演算子<ul><li><code>empty a</code> : aがNullまたは空文字の場合trueを返す</li></ul></li></ul><h4 id="2-7-5-メソッドの呼び出し"><a href="#2-7-5-メソッドの呼び出し" class="headerlink" title="2.7.5 メソッドの呼び出し"></a>2.7.5 メソッドの呼び出し</h4><ul><li>メソッドも呼び出せるよって言う説明（割愛）</li></ul><h2 id="Chapter-3-プレゼンテーション層の開発――JSFの応用-その1"><a href="#Chapter-3-プレゼンテーション層の開発――JSFの応用-その1" class="headerlink" title="Chapter 3 プレゼンテーション層の開発――JSFの応用 その1"></a>Chapter 3 プレゼンテーション層の開発――JSFの応用 その1</h2><h3 id="3-1-入力チェック"><a href="#3-1-入力チェック" class="headerlink" title="3.1 入力チェック"></a>3.1 入力チェック</h3><h4 id="3-1-1-入力チェック（バリデーション）とは"><a href="#3-1-1-入力チェック（バリデーション）とは" class="headerlink" title="3.1.1 入力チェック（バリデーション）とは"></a>3.1.1 入力チェック（バリデーション）とは</h4><ul><li>JSFのライフサイクルの中にある</li><li>JSFでは入力した値をチェックする機能を提供している</li><li>バリデーションの方法として以下の２つを提供<ul><li>JSFの初期から提供されているJSFのバリデーション</li><li>JavaEE6で導入されたビーンバリデーション★</li></ul></li></ul><h4 id="3-1-2-JSFのバリデーション"><a href="#3-1-2-JSFのバリデーション" class="headerlink" title="3.1.2 JSFのバリデーション"></a>3.1.2 JSFのバリデーション</h4><ul><li>バリデーションタグを利用する（割愛）</li></ul><h4 id="3-1-3-JSFのカスタムバリデータ"><a href="#3-1-3-JSFのカスタムバリデータ" class="headerlink" title="3.1.3 JSFのカスタムバリデータ"></a>3.1.3 JSFのカスタムバリデータ</h4><ul><li>細かなチェックをするために独自でバリデータを作成する方法<ul><li>メソッドを作成する方法</li><li>クラスを作成する方法</li></ul></li></ul><h4 id="3-1-4-ビーンバリデーションとは"><a href="#3-1-4-ビーンバリデーションとは" class="headerlink" title="3.1.4 ビーンバリデーションとは"></a>3.1.4 ビーンバリデーションとは</h4><ul><li>ビーンのフィールドにアノテーションを付与するだけでチェックができる</li></ul><h4 id="3-1-5-ビーンバリデーションのバリデータ"><a href="#3-1-5-ビーンバリデーションのバリデータ" class="headerlink" title="3.1.5 ビーンバリデーションのバリデータ"></a>3.1.5 ビーンバリデーションのバリデータ</h4><ul><li><p>ビーンバリデーションのアノテーション一覧</p><ul><li><code>@NotNull</code></li><li><code>@Null</code></li><li><code>@Max</code></li><li><code>@Min</code></li><li><code>.....</code></li></ul></li><li><p>point: 入力値が空文字の場合NULL値として扱う場合、web.xmlにパラメータを追加する必要がある</p><ul><li><code>javax.faces.INTERPRET_EMPTY_STRING_SUBMITED_VALUES_AS_NULL</code></li></ul></li></ul><h4 id="3-1-6-ビーンバリデーションのエラーメッセージ変更"><a href="#3-1-6-ビーンバリデーションのエラーメッセージ変更" class="headerlink" title="3.1.6 ビーンバリデーションのエラーメッセージ変更"></a>3.1.6 ビーンバリデーションのエラーメッセージ変更</h4><ul><li>メッセージを変更する方法は２つある<ul><li>アノテーションに、<code>message</code>属性を指定する</li><li>propertiesファイルで管理する<ul><li>多言語対応などする場合、こちらが得策</li></ul></li></ul></li></ul><h4 id="3-1-7-ビーンバリデーションのバリデータ統合"><a href="#3-1-7-ビーンバリデーションのバリデータ統合" class="headerlink" title="3.1.7 ビーンバリデーションのバリデータ統合"></a>3.1.7 ビーンバリデーションのバリデータ統合</h4><ul><li>MEMO: ★このテクニックは覚えておきたい</li><li>入力チェックに複数の条件がある場合には、フィールドに標準のアノテーションを複数設定するが、同じような条件を何度も設定するのは面倒なので、アノテーションを作成してまとめる</li></ul><h4 id="3-1-8-ビーンバリデーションのカスタマイズバリデータ"><a href="#3-1-8-ビーンバリデーションのカスタマイズバリデータ" class="headerlink" title="3.1.8 ビーンバリデーションのカスタマイズバリデータ"></a>3.1.8 ビーンバリデーションのカスタマイズバリデータ</h4><ul><li>ビーンバリデーションのカスタマイズも可能<ul><li>MEMO:（実装方法省略）</li></ul></li></ul><h3 id="3-2-コンバータ"><a href="#3-2-コンバータ" class="headerlink" title="3.2 コンバータ"></a>3.2 コンバータ</h3><h4 id="3-2-1-コンバータの役割"><a href="#3-2-1-コンバータの役割" class="headerlink" title="3.2.1 コンバータの役割"></a>3.2.1 コンバータの役割</h4><ul><li>Web画面に表示する文字列とマネージドビーンのプロパティで保持するJavaのオブジェクトを変換するための仕組み</li><li><p>JSFにより自動的に変換されるオブジェクトも存在する</p><ul><li>short</li><li>int</li><li>long</li><li>float</li><li>double</li><li>boolean</li><li>byte</li><li>char</li><li>BigInteger</li><li>BigDecimal</li></ul></li><li><p>JSFでは任意のフォーマットで画面表示を行うため、標準のコンバータを提供している</p></li></ul><h4 id="3-2-2-標準のコンバータ"><a href="#3-2-2-標準のコンバータ" class="headerlink" title="3.2.2 標準のコンバータ"></a>3.2.2 標準のコンバータ</h4><ul><li>JSFが標準で提供するコンバータは、日付や数値とおじ列を相互に変換するコンバータ<ul><li>f:convertDateTime</li><li>f:convertNumber</li></ul></li></ul><h4 id="3-2-3-カスタムコンバータ"><a href="#3-2-3-カスタムコンバータ" class="headerlink" title="3.2.3 カスタムコンバータ"></a>3.2.3 カスタムコンバータ</h4><ul><li><p>独自で作成したクラスなどの標準のコンバータでは対応できないクラスでは、独自にコンバータを作成する</p><ul><li>JSFが提供する<code>javax.faces.convert.Converter</code>インターフェースを実装したクラスを作成する</li></ul></li><li><p>MEMO: 確かに変換が必要な場面は絶対あるはずなので、thymeleafとかがどのように変換を持っているか確認する</p><ul><li>他のフレームワークでも、convertを実装する方法を書いていた<ul><li><a href="https://qiita.com/alpha_pz/items/21c6eda2fe227abfa403" target="_blank" rel="noopener">https://qiita.com/alpha_pz/items/21c6eda2fe227abfa403</a></li></ul></li></ul></li><li><p>MEMO: DBSlectした結果をList(category)にかかえているような書き方をしている</p></li></ul><h3 id="3-3-コンポーネントのカスタマイズ"><a href="#3-3-コンポーネントのカスタマイズ" class="headerlink" title="3.3 コンポーネントのカスタマイズ"></a>3.3 コンポーネントのカスタマイズ</h3><ul><li>JSFではフェースレットが提供するコンポーネントを使用してWeb画面を作成</li><li>独自のコンポーネントを作成することもできる</li><li>方法として２つある<ul><li>コンポーネントクラスを作成するカスタムコンポーネント</li><li>フェースレットでコンポーネントを組み合わせて作成するコンポジットコンポーネント★</li></ul></li></ul><h4 id="3-3-1-コンポジットコンポーネント"><a href="#3-3-1-コンポジットコンポーネント" class="headerlink" title="3.3.1 コンポジットコンポーネント"></a>3.3.1 コンポジットコンポーネント</h4><ul><li>１つのフェースレットファイルを作成するだけで、複数の画面で使い回せるコンポーネントを作成することができる<ul><li>MEMO: thymeleafでincludeしている感じと同じ</li></ul></li></ul><h4 id="3-3-2-より高度なコンポジットコンポーネント"><a href="#3-3-2-より高度なコンポジットコンポーネント" class="headerlink" title="3.3.2 より高度なコンポジットコンポーネント"></a>3.3.2 より高度なコンポジットコンポーネント</h4><figure class="highlight xhtml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- テンプレート側 --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/1999/xhtml"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:h</span>=<span class="string">"http://xmlns.jcp.org/jsf/html"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:knowledge</span>=<span class="string">"http://xmlns.jcp.org/jsf/composite/knowledgecomp"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h:head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h:outputStylesheet</span> <span class="attr">library</span>=<span class="string">"css"</span> <span class="attr">name</span>=<span class="string">"style.css"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h:outputScript</span> <span class="attr">name</span>=<span class="string">"jsf.js"</span> <span class="attr">library</span>=<span class="string">"javax.faces"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h:outputScript</span> <span class="attr">library</span>=<span class="string">"js"</span> <span class="attr">name</span>=<span class="string">"application.js"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Knowledge Bank<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">h:head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h:body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"top_content"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h:form</span> <span class="attr">id</span>=<span class="string">"form"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">h:graphicImage</span> <span class="attr">library</span>=<span class="string">"img"</span> <span class="attr">name</span>=<span class="string">"logo.png"</span> /&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"notice"</span>&gt;</span></span><br><span class="line">                    #&#123;flash.notice&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">knowledge:login</span> <span class="attr">userId</span>=<span class="string">"#&#123;loginBean.userId&#125;"</span> <span class="attr">password</span>=<span class="string">"#&#123;loginBean.password&#125;"</span> <span class="attr">loginButtonAction</span>=<span class="string">"#&#123;loginBean.login()&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">h:link</span> <span class="attr">outcome</span>=<span class="string">"account/register"</span> <span class="attr">value</span>=<span class="string">"アカウント登録"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">h:form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">h:body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xhtml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 利用する側 --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/1999/xhtml"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:h</span>=<span class="string">"http://xmlns.jcp.org/jsf/html"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:knowledge</span>=<span class="string">"http://xmlns.jcp.org/jsf/composite/knowledgecomp"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h:head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h:outputStylesheet</span> <span class="attr">library</span>=<span class="string">"css"</span> <span class="attr">name</span>=<span class="string">"style.css"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h:outputScript</span> <span class="attr">name</span>=<span class="string">"jsf.js"</span> <span class="attr">library</span>=<span class="string">"javax.faces"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h:outputScript</span> <span class="attr">library</span>=<span class="string">"js"</span> <span class="attr">name</span>=<span class="string">"application.js"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Knowledge Bank<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">h:head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h:body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"top_content"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h:form</span> <span class="attr">id</span>=<span class="string">"form"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">h:graphicImage</span> <span class="attr">library</span>=<span class="string">"img"</span> <span class="attr">name</span>=<span class="string">"logo.png"</span> /&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"notice"</span>&gt;</span></span><br><span class="line">                    #&#123;flash.notice&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">knowledge:login</span> <span class="attr">userId</span>=<span class="string">"#&#123;loginBean.userId&#125;"</span> <span class="attr">password</span>=<span class="string">"#&#123;loginBean.password&#125;"</span> <span class="attr">loginButtonAction</span>=<span class="string">"#&#123;loginBean.login()&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">h:link</span> <span class="attr">outcome</span>=<span class="string">"account/register"</span> <span class="attr">value</span>=<span class="string">"アカウント登録"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">h:form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">h:body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Column: コンポーネントで利用可能な暗黙オブジェクト<ul><li>カスタムコンポーネント内でよく利用する暗黙オブジェクト<ul><li>cc: コンポジットコンポーネントの情報が取得できる</li><li>component: 現在のコンポーネントの情報や、親や子のコンポーネントの情報にアクセスすることができる</li></ul></li></ul></li></ul><h3 id="3-4-フェースレットテンプレート"><a href="#3-4-フェースレットテンプレート" class="headerlink" title="3.4 フェースレットテンプレート"></a>3.4 フェースレットテンプレート</h3><h4 id="3-4-1-フェースレットテンプレートの利用"><a href="#3-4-1-フェースレットテンプレートの利用" class="headerlink" title="3.4.1 フェースレットテンプレートの利用"></a>3.4.1 フェースレットテンプレートの利用</h4><ul><li>ヘッダーやサイドバーなどはテンプレート化して管理する説明<ul><li>こっちがthymeleafのincludeに近い</li></ul></li></ul><h3 id="3-5-HTML5フレンドリマークアップ"><a href="#3-5-HTML5フレンドリマークアップ" class="headerlink" title="3.5 HTML5フレンドリマークアップ"></a>3.5 HTML5フレンドリマークアップ</h3><ul><li>JavaEE7(JSF2.2)からHTML5の進化へ対応するためにフレンドリマークアップという機能が導入された<ul><li>以前のJSFでは任意の属性をHTMLとして出力する場合にコンポーネントをカスタマイズして提供していた</li></ul></li><li>画面デザインをWebデザイナーが行い、リッチなWeb画面を作ることが一般化</li></ul><h4 id="3-5-1-パススルーアトリビュート"><a href="#3-5-1-パススルーアトリビュート" class="headerlink" title="3.5.1 パススルーアトリビュート"></a>3.5.1 パススルーアトリビュート</h4><h4 id="3-5-2-パススルーエレメント"><a href="#3-5-2-パススルーエレメント" class="headerlink" title="3.5.2 パススルーエレメント"></a>3.5.2 パススルーエレメント</h4><h3 id="3-6-Ajax"><a href="#3-6-Ajax" class="headerlink" title="3.6 Ajax"></a>3.6 Ajax</h3><h4 id="3-6-1-JSFのAjax対応"><a href="#3-6-1-JSFのAjax対応" class="headerlink" title="3.6.1 JSFのAjax対応"></a>3.6.1 JSFのAjax対応</h4><ul><li>一般的なAjaxの作りでは、データの取得処理や画面の再描画処理をJavascriptで記述する必要がある</li><li><p>JSFのAjax機能を利用するとJavascriptをほとんど記述せずにWeb画面の部分更新が可能</p></li><li><p>Ajax専用のタグを使用して、結果をRenderingしている</p></li><li>MEMO: 専用のタグでAjax処理ができるのは、コンポーネントベースのフレームワークであるJSFの特徴だと感じた</li></ul><h4 id="3-6-2-Ajaxを使用した入力チェック"><a href="#3-6-2-Ajaxを使用した入力チェック" class="headerlink" title="3.6.2 Ajaxを使用した入力チェック"></a>3.6.2 Ajaxを使用した入力チェック</h4><h4 id="3-6-3-Ajaxのイベントハンドリング"><a href="#3-6-3-Ajaxのイベントハンドリング" class="headerlink" title="3.6.3 Ajaxのイベントハンドリング"></a>3.6.3 Ajaxのイベントハンドリング</h4><ul><li>イベント実行中や完了、エラー発生時の処理を記述するための方法</li><li>共通化するための方法を紹介</li></ul><h2 id="Chapter-4-プレゼンテーション層の開発――JSFの応用-その2"><a href="#Chapter-4-プレゼンテーション層の開発――JSFの応用-その2" class="headerlink" title="Chapter 4 プレゼンテーション層の開発――JSFの応用 その2"></a>Chapter 4 プレゼンテーション層の開発――JSFの応用 その2</h2><h3 id="4-1-認証／認可"><a href="#4-1-認証／認可" class="headerlink" title="4.1 認証／認可"></a>4.1 認証／認可</h3><h4 id="4-1-1-認証-認可の仕組み"><a href="#4-1-1-認証-認可の仕組み" class="headerlink" title="4.1.1 認証/認可の仕組み"></a>4.1.1 認証/認可の仕組み</h4><ul><li><p>JavaEEのログイン機能を実現するための認証認可の仕組みについて</p></li><li><p>ログイン機能を利用する手順</p><ol><li>アプリケーションサーバーの認証/認可設定をする。</li><li>アプリケーションの認証/認可設定をする。</li><li>プログラムでログイン/ログアウト機能を作成する。</li></ol></li></ul><h4 id="4-1-2-アプリケーションサーバーの認証設定"><a href="#4-1-2-アプリケーションサーバーの認証設定" class="headerlink" title="4.1.2 アプリケーションサーバーの認証設定"></a>4.1.2 アプリケーションサーバーの認証設定</h4><ul><li>アプリケーション・サーバーに認証の設定を行う必要がある<ul><li>認証データの指定先に<ul><li>ファイル</li><li>データベース</li><li>LDAPサーバー　などを指定する</li></ul></li></ul></li><li>ナレッジバンクではデータベースを指定している</li><li>Glasfishを使用した認証の設定方法を説明</li><li><p>Glasfishの管理コンソール</p><ul><li><code>http://localhost:4848/</code></li></ul></li><li><p>認証設定を行うには</p><ul><li>Configurations＞server-config＞Security＞Realms＞New</li></ul></li><li>ナレッジバンクではJDBCレルムを使用するので<ul><li>ClassNameにJDBCRealmを選択する</li></ul></li></ul><h4 id="4-1-3-アプリケーションの認証設定"><a href="#4-1-3-アプリケーションの認証設定" class="headerlink" title="4.1.3 アプリケーションの認証設定"></a>4.1.3 アプリケーションの認証設定</h4><ul><li>アプリケーションサーバーの認証設定が終了したら、</li><li>今度はアプリケーションの認証設定を行う</li></ul><h4 id="4-1-4-ログイン-ログアウト機能の作成"><a href="#4-1-4-ログイン-ログアウト機能の作成" class="headerlink" title="4.1.4 ログイン/ログアウト機能の作成"></a>4.1.4 ログイン/ログアウト機能の作成</h4><ul><li>Oracle18cで接続を試していたがどうしてもうまく行かなかった</li><li><p>Oracle11gだとすぐにうまく行った</p></li><li><p>ログインの仕組みを作って、</p></li><li>実際にloginのfaceletでコンテキストのログインメソッドを呼び出して、認証を済ませる<ul><li>MEMO: springsecurityみたいなやつ　認証設定は必ず実装しておく</li></ul></li></ul><h3 id="4-2-国際化"><a href="#4-2-国際化" class="headerlink" title="4.2 国際化"></a>4.2 国際化</h3><h4 id="4-2-1-JSFの国際化"><a href="#4-2-1-JSFの国際化" class="headerlink" title="4.2.1 JSFの国際化"></a>4.2.1 JSFの国際化</h4><ul><li>プロパティファイルでロケール管理して、<code>faces-config.xml</code>で切り替え</li><li>UIViewRootクラスのgetLocaleメソッドやsetLocaleメソッドでも切り替えることができるみたい<ul><li>MEMO: ロケール切り替えは実装しておくべき</li></ul></li></ul><h3 id="4-3-ブックマーカビリティ"><a href="#4-3-ブックマーカビリティ" class="headerlink" title="4.3 ブックマーカビリティ"></a>4.3 ブックマーカビリティ</h3><h4 id="4-3-1-ブックマーカビリティとは"><a href="#4-3-1-ブックマーカビリティとは" class="headerlink" title="4.3.1 ブックマーカビリティとは"></a>4.3.1 ブックマーカビリティとは</h4><ul><li>JSFでは最初にブラウザからアクセスが来た際に、処理をせずに画面を表示する</li><li><p>しかし、Webアプリケーションでデータの一覧や詳細を表示する画面では、なにかしらの事前処理やデータの取得処理が必要</p><ul><li>そこで、JSFでは初回アクセス時に処理を実施する機能を提供している</li></ul></li><li><p>使い方について説明（割愛）</p></li></ul><h3 id="4-4-フェーズリスナ"><a href="#4-4-フェーズリスナ" class="headerlink" title="4.4 フェーズリスナ"></a>4.4 フェーズリスナ</h3><ul><li><p>JSFのライフサイクル</p><ol><li>ビューの復元(Restore View)</li><li>リクエスト値の適用(Apply Request Values)</li><li>入力チェック(Process Validations)</li><li>モデル値の更新(Update Model Values)</li><li>アプリケーションの実施(Invoke Application)</li><li>画面の生成(REnder Response)</li></ol></li><li><p>フェーズ前後で横断的に行う処理はフェーズリスナを使用する</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> knowledgebank.web.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"><span class="keyword">import</span> javax.faces.event.PhaseEvent;</span><br><span class="line"><span class="keyword">import</span> javax.faces.event.PhaseId;</span><br><span class="line"><span class="keyword">import</span> javax.faces.event.PhaseListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KnowledgePhaseListener</span> <span class="keyword">implements</span> <span class="title">PhaseListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Logger logger = Logger.getLogger(KnowledgePhaseListener.class.getName());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforePhase</span><span class="params">(PhaseEvent event)</span> </span>&#123;</span><br><span class="line">        logger.info(event.getPhaseId() + <span class="string">" beforePhase"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPhase</span><span class="params">(PhaseEvent event)</span> </span>&#123;</span><br><span class="line">        logger.info(event.getPhaseId() + <span class="string">" afterPhase"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PhaseId <span class="title">getPhaseId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PhaseId.ANY_PHASE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-Java-EE-7で導入されたJSFの機能"><a href="#4-5-Java-EE-7で導入されたJSFの機能" class="headerlink" title="4.5 Java EE 7で導入されたJSFの機能"></a>4.5 Java EE 7で導入されたJSFの機能</h3><h4 id="4-5-1-JSF-2-2-の追加機能"><a href="#4-5-1-JSF-2-2-の追加機能" class="headerlink" title="4.5.1 JSF 2.2 の追加機能"></a>4.5.1 JSF 2.2 の追加機能</h4><ul><li>JSF2.2の仕様には大きな特徴として以下の４つが紹介されている<ul><li>HTML5フレンドリマークアップ（パススルーアトリビュートと、パススルーエレメント）</li><li>リソース・ライブラリコントラクト</li><li>Faces Flows</li><li>ステートレスビュー</li></ul></li></ul><h4 id="4-5-2-リソース・ライブラリコントラクト"><a href="#4-5-2-リソース・ライブラリコントラクト" class="headerlink" title="4.5.2 リソース・ライブラリコントラクト"></a>4.5.2 リソース・ライブラリコントラクト</h4><p>リソースの塊を簡単に切り替えることができる仕組み</p><ul><li>あまり便利に思わなかった</li></ul><h4 id="4-5-3-Faces-Flows"><a href="#4-5-3-Faces-Flows" class="headerlink" title="4.5.3 Faces Flows"></a>4.5.3 Faces Flows</h4><ul><li>フロー処理について記載されている</li><li>スコープを設定ファイルやJavaアノテーションで保持できるみたい<ul><li>MEMO: 他のフレームワークではどのようにスコープ持っているのか確認</li></ul></li></ul><h4 id="4-5-4-ステートレスビュー"><a href="#4-5-4-ステートレスビュー" class="headerlink" title="4.5.4 ステートレスビュー"></a>4.5.4 ステートレスビュー</h4><ul><li><p>状態を保持しないビューを作成する機能</p></li><li><p>JSFでは画面を表示する際にサーバー側似コンポーネントツリーを作成し、同一画面を表示している間はそのコンポーネントツリーを保持していると説明しました。</p></li><li><p>ステートレスビューを使用すると、そのコンポーネントツリーを毎回破棄市、アクセスが来るたびに再作成する動きに変わる</p></li><li><p>ステートレスなアプリを作る上で欠かせない</p><ul><li>MEMO: 他のフレームワークの場合は、redisなどでセッション管理している</li></ul></li></ul><h3 id="4-6-まとめ"><a href="#4-6-まとめ" class="headerlink" title="4.6 まとめ"></a>4.6 まとめ</h3><ul><li>ここまでの内容を理解していれば、十分JSFを使用してWebアプリケーションを作成することができる</li><li><p>紹介していないライブラリ</p><ul><li>PrimeFaces</li><li>RichFaces</li><li>OmniFaces</li></ul></li><li><p>MEMO: 時間があれば見てみる程度で良いかも</p></li></ul><h2 id="Chapter-5-ビジネスロジック層の開発――CDIの利用"><a href="#Chapter-5-ビジネスロジック層の開発――CDIの利用" class="headerlink" title="Chapter 5 ビジネスロジック層の開発――CDIの利用"></a>Chapter 5 ビジネスロジック層の開発――CDIの利用</h2><ul><li><p>本章と次章ではCDIとEJBについて解説</p></li><li><p>本章ではCDI</p><ul><li>CDIとEJBの違いについて解説</li><li>CDIがJavaEEに採用された経緯</li><li>CDIの機能　について解説</li></ul></li></ul><h3 id="5-1-CDIとEJB"><a href="#5-1-CDIとEJB" class="headerlink" title="5.1 CDIとEJB"></a>5.1 CDIとEJB</h3><h4 id="5-1-1-ビジネスロジック層の部品"><a href="#5-1-1-ビジネスロジック層の部品" class="headerlink" title="5.1.1 ビジネスロジック層の部品"></a>5.1.1 ビジネスロジック層の部品</h4><ul><li><p>CDI,EJB</p><ul><li>いずれも「ビジネスロジック」を記述するための部品である</li></ul></li><li><p>CDI</p><ul><li>JavaEE6から採用された新しい技術</li></ul></li><li>EJB<ul><li>Java2Enterprise Edition（J2EE）の頃から存在する歴史ある技術</li></ul></li></ul><h4 id="5-1-2-CDIとEJBの違い"><a href="#5-1-2-CDIとEJBの違い" class="headerlink" title="5.1.2 CDIとEJBの違い"></a>5.1.2 CDIとEJBの違い</h4><ul><li>CDIとEJBの違いは「設計の柔軟性」</li><li>CDIの方が自由度が高い</li></ul><h3 id="5-2-DI（Dependency-Injection）"><a href="#5-2-DI（Dependency-Injection）" class="headerlink" title="5.2 DI（Dependency Injection）"></a>5.2 DI（Dependency Injection）</h3><ul><li>CDIについて知る前にDIについて理解しておく必要がある</li><li>DIが考案された歴史的な背景をたどって、CDIの意義について知ることにする</li></ul><h4 id="5-2-1-DIとは"><a href="#5-2-1-DIとは" class="headerlink" title="5.2.1 DIとは"></a>5.2.1 DIとは</h4><ul><li><p>DI</p><ul><li>部品間の依存関係を少なくすることで、部品の分離と結合をコントロールするための考え方、及びその仕組みのこと</li></ul></li><li><p>「依存」とは、クラス同士が強いつながりを持つことを意味している</p></li><li>直接クラスを宣言し、インスタンス化している強い依存関係は、それ自体で処理が完結しているプログラムモジュール、例えば、</li><li>ビジネスロジック層でしか動かないクラス間の依存については問題ありません。</li><li>一方で各層をまたがる依存関係はできる限り弱い方がよいという考えがある</li><li>依存関係を弱く保つことができれば、変更点は少なくてすむ</li></ul><h4 id="5-2-2-DIによる依存関係の解消"><a href="#5-2-2-DIによる依存関係の解消" class="headerlink" title="5.2.2 DIによる依存関係の解消"></a>5.2.2 DIによる依存関係の解消</h4><ul><li>DIコンテナがあれば、実行時に動的にクラスを選択できる</li><li><p>用途としては以下</p><ul><li>ある条件において別の実装クラスを必要とするケース<ul><li>処理の流れ自体は変わらないが、ユーザーやリクエストの状況に応じて手続きが異なる、あるいは出力先が異なる</li></ul></li><li>テストや開発中のモック入れ替え<ul><li>層をまたぐ処理や開発中のクラスを利用しなければならないときに、仮となるモックを利用し、将来的に完成したクラスを入れ替える場合。</li><li>あるいはテストデータを返却するテスト用のモックと完成したクラスを入れ替える場合</li></ul></li></ul></li><li><p>COLUMN ファクトリメソッドパターン</p><ul><li>DIが実現している実装の入れ替えは、ファクトリメソッドパターンと呼ばれるデザインパターンを採用することでも実現可能</li><li>ファクトリメソッドパターンはオブジェクトの生成を管理するクラスを設けることで、任意の振る舞いを持つオブジェクトを取得する方式</li><li>ただし、ファクトリメソッドパターンを利用していても、結局返却するインスタンスを選択する処理をソースコードに記述しておく必要があり、</li><li>インスタンスをソースコード外で管理するには、プロパティファイルなどを用いる必要があるので、そうするよりはDIコンテナを利用するほうが楽</li><li>MEMO: 再読</li></ul></li></ul><h4 id="5-2-3-JavaEEへのDI取り込み"><a href="#5-2-3-JavaEEへのDI取り込み" class="headerlink" title="5.2.3 JavaEEへのDI取り込み"></a>5.2.3 JavaEEへのDI取り込み</h4><p>(<br>  割愛<br>)</p><h3 id="5-3-CDI"><a href="#5-3-CDI" class="headerlink" title="5.3 CDI"></a>5.3 CDI</h3><ul><li><p>CDIとはJavaEE6から導入されたJavaEEアプリケーションサーバー上でDI機能を提供するための仕様</p></li><li><p>CDIを使用するために必要な定義</p><ul><li>インジェクションポイント：<code>@Inject</code>が指定された変数</li><li>CDIビーン：スコープに関するアノテーションが付与されたクラス</li></ul></li><li><p>Column 設定ファイル beans.xml</p><ul><li>JavaEE7 からCDIを使うための設定ファイルであるbeans.xmlは特定の用途を除き不要になりました</li><li>beanx.xmlはインジェクションポイントとCDIビーンの関係性を記述するためのものでしたが、現在では自動的に解決する用になっている</li></ul></li><li><p>CDIの利点</p><ul><li>インジェクションを行うのが簡単（アノテーションのみで設定ファイル不要）</li><li>DIを基礎とした様々な機能があらかじめ準備されている</li></ul></li></ul><h3 id="5-4-CDI基本編"><a href="#5-4-CDI基本編" class="headerlink" title="5.4 CDI基本編"></a>5.4 CDI基本編</h3><ul><li>CDI限定子：複数のインジェクション候補クラスが存在する場合に、クラスを特定するためのアノテーション <code>javax.inject.Qualifier</code></li></ul><h4 id="5-4-1-CDIコンテナによるインジェクション"><a href="#5-4-1-CDIコンテナによるインジェクション" class="headerlink" title="5.4.1 CDIコンテナによるインジェクション"></a>5.4.1 CDIコンテナによるインジェクション</h4><ul><li>CDIコンテナに存在するスコープを過ぎたオブジェクトは破棄される</li></ul><h4 id="5-4-2-CDIの型解決方法"><a href="#5-4-2-CDIの型解決方法" class="headerlink" title="5.4.2 CDIの型解決方法"></a>5.4.2 CDIの型解決方法</h4><ul><li><p>CDIがインジェクションポイントに対して注入する対象となるインスタンスを解決する方法は２通りある</p><ul><li>インジェクションポイントと対象インスタンスが１対１の場合（自動解決）</li><li>CDI限定子もしくは、beans.xml(@Alternative)で解決する方法</li></ul></li><li><p>結論：CDI限定子（Qualifier）を使用して書いていくのがよい</p><ul><li>設定ファイルも必要ないし、ソースコードを柔軟に変更しながら開発ができるため</li></ul></li><li><p>Column インターフェースを利用するべきか</p><ul><li>結論：インターフェースは準備しておくべき</li></ul></li></ul><h3 id="5-5-CDI応用編"><a href="#5-5-CDI応用編" class="headerlink" title="5.5 CDI応用編"></a>5.5 CDI応用編</h3><ul><li>CDIに関わる応用的な利用方法について記述</li><li>CDIの付加機能<ul><li>イベント処理：CDIビーン上である条件を満たした場合に、別のクラスに対して通知を行う機能</li><li>ステレオタイプ：複数アノテーションをまとめて定義する機能</li><li>プロデューサ/ディスポーザ：クラスではなく、フィールドそのものやメソッドの戻り値をインジェクションポイントに注入する機能</li><li>インターセプター/デコレータ：処理の前後に別の処理を入れ込んだり、追加したりする機能</li></ul></li></ul><h4 id="5-5-1-イベント処理"><a href="#5-5-1-イベント処理" class="headerlink" title="5.5.1 イベント処理"></a>5.5.1 イベント処理</h4><ul><li><p>イベント処理とは</p><ul><li>設定した閾値を超えるなど、特定の条件を満たす情報が発生したとき、その通知と情報をやりとりすることを指す</li><li>CDIではイベント発火はCDIビーン上で行い、それを処理するクラスを特別な呼び方として「オブザーバ」と呼ぶ</li></ul></li><li><p>イベント処理の実装</p><ul><li>イベント情報を格納するクラスを準備する</li><li>イベントを発火するCDIビーンを作成する</li><li>オブザーバクラスを作成する</li></ul></li><li><p>イベント処理の留意事項</p><ul><li>イベント発火からオブザーバの処理までがすべて同期で実行される</li><li>非同期だと勘違いしないように</li><li>参照関係を持たず、プログラムモジュール間似おける情報のやり取りを非同期で実行したい場合には、次章で説明するJMSを利用するなど別の方法を検討する必要がある</li></ul></li></ul><h4 id="5-5-2-ステレオタイプの利用"><a href="#5-5-2-ステレオタイプの利用" class="headerlink" title="5.5.2 ステレオタイプの利用"></a>5.5.2 ステレオタイプの利用</h4><ul><li>複数のアノテーション定義をまとめて管理できる</li><li><code>@StereoType</code>を付与してまとめていく</li><li><p>上書きもできるが、あまり上書きしすぎると良くない</p></li><li><p>MEMO: 管理方法について</p><ul><li>パッケージ名を<code>stereotype</code>で切って管理する</li><li>クラス名称の接尾字に<code>Type</code>をつけておくとアノテーションがステレオタイプで有ることを明示できる</li></ul></li><li><p>MEMO: Springでもまとめていくアノテーションあるか</p></li></ul><h4 id="5-5-3-プロデューサ-ディスポーザの利用"><a href="#5-5-3-プロデューサ-ディスポーザの利用" class="headerlink" title="5.5.3 プロデューサ/ディスポーザの利用"></a>5.5.3 プロデューサ/ディスポーザの利用</h4><ul><li>プロデューサを利用すると、インジェクションポイントに注入するオブジェクトをプログラム上で動的に変更することができる</li><li><p>プロデューサにより作成されたオブジェクトが終了処理の必要なオブジェクトである場合、ディスポーザを利用することで終了処理を記述することができる</p></li><li><p>プロデューサアノテーションをメソッドに付与して戻り値に<code>@Inject</code>指定した変数と同じ型を指定してあげる</p></li><li>メソッドで処理されたあとのオブジェクトがDIコンテナに格納され、インジェクションされる</li><li><p>Disposesアノテーションは、Producerメソッドで提供されたクラスの終了処理を行うためのディスポーザ</p></li><li><p>MEMO: Springにもこの概念があるかどうか確認</p></li></ul><h4 id="5-5-4-インターセプタとデコレータ"><a href="#5-5-4-インターセプタとデコレータ" class="headerlink" title="5.5.4 インターセプタとデコレータ"></a>5.5.4 インターセプタとデコレータ</h4><ul><li><p>インターセプターとデコレータについて解説</p><ul><li>すでに作成済みのメソッドの処理に対して、外部のクラスを用いてその処理の前後や、処理内容に変更を加えることができる技術</li></ul></li><li><p>インターセプター：対象となる処理の前後やライフサイクルに応じて処理を行うための仕組み</p></li><li><p>定義方法</p><ul><li><code>@Interceptor</code>を付与したクラスを作成、メソッドに特定のアノテーション付与して機能に関与しない処理を実装</li><li>利用側のメソッドで<code>@Interceptors()</code>の引数に作成したインターセプタークラスを追加する</li><li>または、beans.xmlに使用するインターセプターを定義する</li></ul></li><li><p>Column どこでインターセプターを定義する？</p><ul><li>機能処理内にインターセプター（非機能処理）を記載するのはナンセンス</li><li>beans.xmlで管理する方が良いのではという意見が記載されている</li></ul></li><li><p>デコレータ：機能追加をするための仕組み</p><ul><li>共通のインターフェースを実装したクラスに処理を委譲する</li></ul></li><li><p>MEMO: デコレータの使い所について確認</p><ul><li>Springで同様の機能あるかどうか</li><li>インターセプター＝AOP？こちらも使い所についてまとめておく</li></ul></li></ul><h3 id="5-6-まとめ"><a href="#5-6-まとめ" class="headerlink" title="5.6 まとめ"></a>5.6 まとめ</h3><p>機能が非常に豊富であることと、ルール似基づいた設計と実装が必要であることをご理解いただけたと思います。</p><h2 id="Chapter-6-ビジネスロジック層の開発――EJBの利用"><a href="#Chapter-6-ビジネスロジック層の開発――EJBの利用" class="headerlink" title="Chapter 6 ビジネスロジック層の開発――EJBの利用"></a>Chapter 6 ビジネスロジック層の開発――EJBの利用</h2><h3 id="6-1-Enterprise-Java-Beans（EJB）"><a href="#6-1-Enterprise-Java-Beans（EJB）" class="headerlink" title="6.1 Enterprise Java Beans（EJB）"></a>6.1 Enterprise Java Beans（EJB）</h3><h4 id="6-1-1-EJBとは"><a href="#6-1-1-EJBとは" class="headerlink" title="6.1.1 EJBとは"></a>6.1.1 EJBとは</h4><ul><li>アプリケーションサーバー上で動作するJavaのプログラムのうち、特に「ビジネスロジック」を担当する部品を指す</li><li><p>EJBは</p><ul><li>サーブレットやJSF、Webサーバーなどアプリケーションサーバー外からのリクエストを受け付ける層と</li><li>データベースなどへ情報の永続化を行う層の中間の層の部品として機能する</li></ul></li><li><p>機能 EJB3.2</p><ul><li>トランザクション制御</li><li>Java Persistence APIを介した永続化処理</li><li>Java Messageing Serviceを介したメッセージ駆動処理</li><li>非同期実行制御</li><li>同期実行制御</li><li>スケジュールに基づいた実行</li><li>JNDIを介したインスタンス取得（現在はアノテーションを利用）</li><li>リモートクライアントからの実行</li><li>セキュリティ</li></ul></li></ul><h4 id="6-1-2-EJBの利点"><a href="#6-1-2-EJBの利点" class="headerlink" title="6.1.2 EJBの利点"></a>6.1.2 EJBの利点</h4><ul><li>JavaEETutorialを参考</li><li>EJBの利点<ul><li>EJBコンテナがシステムレベルのサービスを提供してくれるため、開発者はビジネスロジックの構築に集中できる</li><li>クライアントとの分離。クライアントにはビジネスロジックを実装する必要がない</li><li>JavaEE準拠のアプリケーションサーバー上であればどこでも動く</li></ul></li></ul><h4 id="6-1-3-EJBの種類"><a href="#6-1-3-EJBの種類" class="headerlink" title="6.1.3 EJBの種類"></a>6.1.3 EJBの種類</h4><ul><li>３種類ある<ul><li>セッションビーン</li><li>メッセージドリブンビーン</li><li>タイマー</li></ul></li></ul><h3 id="6-2-セッションビーン"><a href="#6-2-セッションビーン" class="headerlink" title="6.2 セッションビーン"></a>6.2 セッションビーン</h3><h4 id="6-2-1-セッションビーンとは"><a href="#6-2-1-セッションビーンとは" class="headerlink" title="6.2.1 セッションビーンとは"></a>6.2.1 セッションビーンとは</h4><ul><li>EJBの中核を成すコンポーネント</li></ul><h4 id="6-2-2-セッションビーンの種類"><a href="#6-2-2-セッションビーンの種類" class="headerlink" title="6.2.2 セッションビーンの種類"></a>6.2.2 セッションビーンの種類</h4><ul><li>セッションビーンの種類<ul><li>ステートレスセッションビーン</li><li>ステートフルセッションビーン</li><li>シングルトン</li><li>タイマー</li></ul></li></ul><h4 id="6-2-3-ステートレスセッションビーン"><a href="#6-2-3-ステートレスセッションビーン" class="headerlink" title="6.2.3 ステートレスセッションビーン"></a>6.2.3 ステートレスセッションビーン</h4><ul><li>一番良く利用されるEJBであり、ごくシンプルで基本的なEJB</li><li>ステートレスセッションビーンのクラスに<code>@Stateless</code>を付与</li><li><p>利用側は<code>@EJB</code>を付与して使用する</p></li><li><p><code>@Stateful</code>アノテーションを利用する</p></li><li><p>留意点</p><ul><li>クライアントごとにステートフルセッションビーンのインスタンスが作成される</li></ul></li><li><p>サーブレットからステートフルセッションビーンを呼び出す場合、</p></li><li>通常サーブレットは１リクエストスレッドにより１つのインスタンスが利用されるモデルであるため、</li><li><p>状態を保持できない</p></li><li><p>ライフサイクルの制御</p><ul><li>生成</li><li>活性化</li><li>非活性化</li><li>破棄</li></ul></li><li><p>非活性化されると、メモリ外にシリアライズ処理され出力される。</p></li><li>必要になるとデシリアライズされ、メモリ上に復帰する</li></ul><h4 id="6-2-5-シングルトンセッションビーン"><a href="#6-2-5-シングルトンセッションビーン" class="headerlink" title="6.2.5 シングルトンセッションビーン"></a>6.2.5 シングルトンセッションビーン</h4><ul><li><code>@Singleton</code>アノテーションを付与</li><li><p>設定ファイルの読み出しの管理などで使う</p></li><li><p>COLUMN <code>@Startup</code>アノテーション</p><ul><li>デプロイされたアプリケーションが有効化されたタイミングですぐにオブジェクトを生成するよう、アプリケーションサーバーに支持するもの</li><li><code>@DependsOn</code>というアノテーションもある<ul><li>初期化の依存関係を解消するためのもの</li></ul></li><li>MEMO: Springの場合初期化のアノテーションは何を使っているか</li></ul></li></ul><h4 id="6-2-6-非同期処理"><a href="#6-2-6-非同期処理" class="headerlink" title="6.2.6 非同期処理"></a>6.2.6 非同期処理</h4><ul><li>実装には「<code>@Asynchronous</code>アノテーション」を使用</li><li><p>クラスかメソッドに定義する</p><ul><li>クラスの場合はすべてのメソッドが非同期になる</li><li>メソッドの場合は対象メソッドのみ非同期になる</li></ul></li><li><p>MEMO: Futureインターフェースを介した操作について理解する</p></li><li><p>Column 非同期処理の再実行</p><ul><li>EJBの非同期実行には処理の再投入（再実行）のためのAPIは定義されていないので</li><li>自前で実装するか、他のアーキテクチャを利用する方法も検討する</li><li>キューを利用して後述のメッセージドリブンビーンを使うなどが考えられる</li></ul></li></ul><h4 id="6-2-7-トランザクション"><a href="#6-2-7-トランザクション" class="headerlink" title="6.2.7 トランザクション"></a>6.2.7 トランザクション</h4><ul><li><code>@TransactionManagement</code>アノテーション</li><li><code>@TransactionAttribute</code>アノテーションを使用するらしい</li></ul><p>詳しい使い方については割愛</p><h3 id="6-3-メッセージドリブンビーン"><a href="#6-3-メッセージドリブンビーン" class="headerlink" title="6.3 メッセージドリブンビーン"></a>6.3 メッセージドリブンビーン</h3><ul><li>メッセージドリブンビーン（Message Driven Bean: MDB）について解説していく<ul><li>メッセージと呼ばれるものを受け取ることで起動するという用途が限定的なコンポーネント</li></ul></li></ul><h4 id="6-3-1-メッセージドリブン便とは"><a href="#6-3-1-メッセージドリブン便とは" class="headerlink" title="6.3.1 メッセージドリブン便とは"></a>6.3.1 メッセージドリブン便とは</h4><ul><li><p>MEMO: JMSも理解を深める必要あり</p></li><li><p>JMS</p><ul><li>キューまたはトピックと呼ばれる方式を利用して、主にシステム間やアプリケーション間の情報を受け渡しを行うための仕組み</li></ul></li><li><p>Column キューとトピック</p><ul><li>キューとトピックの違いは、送信元と受取側の数の違いにある<ul><li>キュー：１対１</li><li>トピック：N対M（多対多）</li></ul></li></ul></li><li><p>メッセージの受取を担当するのがメッセージドリブンビーン</p></li><li>MDBは常にキューまたはトピックにメッセージが配信されるのを待機し、監視している</li></ul><h4 id="6-3-2-実装例"><a href="#6-3-2-実装例" class="headerlink" title="6.3.2 実装例"></a>6.3.2 実装例</h4><p>割愛</p><ul><li>MEMO: JMSの使用方法とSpringJMSを使う</li></ul><h3 id="6-4-タイマー"><a href="#6-4-タイマー" class="headerlink" title="6.4 タイマー"></a>6.4 タイマー</h3><h4 id="6-4-1-タイマーとは"><a href="#6-4-1-タイマーとは" class="headerlink" title="6.4.1 タイマーとは"></a>6.4.1 タイマーとは</h4><ul><li>EJBには時間を指定して起動するための「タイマーサービス」というものが定義されている</li></ul><p>タイマーはバッチ処理とは異なるので、むやみに使用するべきではない</p><ul><li>使用方法は以下の２種類存在する<ul><li>TimerServiceAPIから登録する</li><li><code>@Schedule</code>を使って登録する</li></ul></li></ul><h4 id="6-4-2-タイマーサービスのサンプル"><a href="#6-4-2-タイマーサービスのサンプル" class="headerlink" title="6.4.2 タイマーサービスのサンプル"></a>6.4.2 タイマーサービスのサンプル</h4><p>割愛</p><h4 id="6-4-3-Scheduleの実装サンプル"><a href="#6-4-3-Scheduleの実装サンプル" class="headerlink" title="6.4.3 @Scheduleの実装サンプル"></a>6.4.3 @Scheduleの実装サンプル</h4><p>割愛</p><h3 id="6-5-EJBの設計"><a href="#6-5-EJBの設計" class="headerlink" title="6.5 EJBの設計"></a>6.5 EJBの設計</h3><ul><li>EJBというのはあくまでビジネスロジックの実装を任されているコンポーネント</li><li>アプリケーションはビジネスロジックだけでは成り立たない</li><li>ブラウザの画面などのプレゼンテーション層</li><li>Webサービスなどのロジック呼び出し部分、データベース接続などの永続化層、外部サービスの呼び出しなどもある</li><li><p>EJBはこれらの処理の中間に位置することになる</p></li><li><p>EJBを設計する上でまず考える必要があるのは、この「外部の層との接点」</p></li></ul><h4 id="6-5-1-EJBメソッドの呼び出しに関する設計"><a href="#6-5-1-EJBメソッドの呼び出しに関する設計" class="headerlink" title="6.5.1 EJBメソッドの呼び出しに関する設計"></a>6.5.1 EJBメソッドの呼び出しに関する設計</h4><ul><li>（１）やり取りする情報を保持するクラスを作成し、サーブレットとEJB双方から共通のクラスとして参照する<ul><li>あまりにも多くの情報を保持し、データベースへの永続化が終わるリクエストの最後まで保持し続けるような長寿クラスにならないように注意する必要</li></ul></li><li><p>（２）引数が増えた分についてはメソッドをオーバーロードして対応する</p><ul><li>注意：公開するメソッドが増えて、Webサービスのエンドポイントになるような場合はWSDLの変更が発生するため注意</li></ul></li><li><p>Column JSPからのEJB呼び出し</p><ul><li>画面生成とビジネスロジックの分離ができないためやめた方がいい</li></ul></li></ul><h4 id="6-5-2-ローカル呼び出しとリモート呼び出し"><a href="#6-5-2-ローカル呼び出しとリモート呼び出し" class="headerlink" title="6.5.2 ローカル呼び出しとリモート呼び出し"></a>6.5.2 ローカル呼び出しとリモート呼び出し</h4><ul><li><p>リモート呼び出しは可能な限り使わないことをおすすめする</p></li><li><p>リモート呼び出しが必要なパターン</p><ul><li>バッチの実装</li><li>GUIを持つクライアントからのビジネスロジック呼び出し</li><li>多段アプリケーションサーバー構成（処理量による業務分離、接続形態によるレイヤー分割）</li></ul></li><li><p>代替手段としてはEJBはローカル使用のみにしておき</p><ul><li>JAX-RSなどを使用した層を準備することが考えられる</li></ul></li><li><p>MEMO: JAX-RS層について深堀り</p></li></ul><h4 id="6-5-3-同期-非同期"><a href="#6-5-3-同期-非同期" class="headerlink" title="6.5.3 同期/非同期"></a>6.5.3 同期/非同期</h4><ul><li>基本的に非同期にするメソッドはいかに絞るとよい<ul><li>すぐに結果を必要としないもの</li><li>結果を得るのに相応の時間がかかる処理</li></ul></li></ul><h4 id="6-5-4-負荷量"><a href="#6-5-4-負荷量" class="headerlink" title="6.5.4 負荷量"></a>6.5.4 負荷量</h4><ul><li>MEMO: 設計する際の負荷について考えるべき</li></ul><h4 id="6-5-5-データベースアクセス"><a href="#6-5-5-データベースアクセス" class="headerlink" title="6.5.5 データベースアクセス"></a>6.5.5 データベースアクセス</h4><ul><li>JPA</li><li>JPA以外のO/RマッピングもしくはDAOフレームワーク</li><li><p>JDBCの直接呼び出し</p></li><li><p>通常はEJBと親和性が高いJPAをEJBトランザクション管理下に置くのが容易</p></li></ul><h3 id="6-6-EJBのテスト"><a href="#6-6-EJBのテスト" class="headerlink" title="6.6 EJBのテスト"></a>6.6 EJBのテスト</h3><h4 id="6-6-1-EJBのテストの必要性と難しさ"><a href="#6-6-1-EJBのテストの必要性と難しさ" class="headerlink" title="6.6.1 EJBのテストの必要性と難しさ"></a>6.6.1 EJBのテストの必要性と難しさ</h4><ul><li><p>EJBの最大の弱点はテストがしづらいものであった</p></li><li><p>JavaSEでも必要な資材を準備すれば動くようになったが、一部対応していないらしい</p></li></ul><h4 id="6-6-2-EJBテストの準備"><a href="#6-6-2-EJBテストの準備" class="headerlink" title="6.6.2 EJBテストの準備"></a>6.6.2 EJBテストの準備</h4><ul><li>EJBContainerからEJBモジュールを取得し、Junitなどでテストを実施する説明</li></ul><h3 id="6-7-まとめ"><a href="#6-7-まとめ" class="headerlink" title="6.7 まとめ"></a>6.7 まとめ</h3><p>CDIとEJBをうまく組み合わせて設計していこうという説明</p><h2 id="Chapter-7-データアクセス層の開発――JPAの基本"><a href="#Chapter-7-データアクセス層の開発――JPAの基本" class="headerlink" title="Chapter 7 データアクセス層の開発――JPAの基本"></a>Chapter 7 データアクセス層の開発――JPAの基本</h2><p>本章と次章では、JavaEEのにおけるデータベースへのアクセス方法であるJPAについて解説</p><p>エンティティやクエリといったJPAの構成要素と、JPQLとCriteriaAPIの２種類のクエリについて説明</p><h3 id="7-1-JPAの基礎知識"><a href="#7-1-JPAの基礎知識" class="headerlink" title="7.1 JPAの基礎知識"></a>7.1 JPAの基礎知識</h3><ul><li>永続化：Javaのプロセスが終了しても、データが消えずに残るような状態にすること</li></ul><h4 id="7-1-1-JPAの構成要素"><a href="#7-1-1-JPAの構成要素" class="headerlink" title="7.1.1 JPAの構成要素"></a>7.1.1 JPAの構成要素</h4><ul><li>エンティティクラス（データのレイアウトを規定）とエンティティオブジェクト（データを保持）</li><li>エンティティマネージャ<ul><li>エンティティオブジェクトとレコードの紐付けを管理</li></ul></li><li>クエリ<ul><li>データを操作</li></ul></li><li>永続化ユニット<ul><li>データベースへの接続情報などJPAの設定を記述する</li></ul></li></ul><h4 id="7-1-2-エンティティクラスとエンティティオブジェクト"><a href="#7-1-2-エンティティクラスとエンティティオブジェクト" class="headerlink" title="7.1.2 エンティティクラスとエンティティオブジェクト"></a>7.1.2 エンティティクラスとエンティティオブジェクト</h4><ul><li>そのまま、クラスとオブジェクトという理解</li><li>テーブルとレコード　になぞらえて考えられる</li></ul><h4 id="7-1-3-エンティティマネージャ"><a href="#7-1-3-エンティティマネージャ" class="headerlink" title="7.1.3 エンティティマネージャ"></a>7.1.3 エンティティマネージャ</h4><ul><li>エンティティオブジェクトを取得したり、データベースへ反映、削除したりする</li><li>永続化コンテキストの配下にないものは、データベースへは反映されない</li><li><code>persist()</code>メソッドで管理下におくみたい</li></ul><h4 id="7-1-4-クエリ"><a href="#7-1-4-クエリ" class="headerlink" title="7.1.4 クエリ"></a>7.1.4 クエリ</h4><ul><li><p>エンティティマネージャが持つ基本的なメソッドを利用する他に、より自由度の高いクエリを用いる方法がある</p></li><li><p>JPAが用意しているクエリの定義方法</p><ul><li>JPQL: SQLに似た記法で記載でき、DBMSを意識しなくて良い</li><li>Criteria API: APIを使ってクエリを組み立てて行く手法。DBMSを意識しなくて良い</li><li>ネイティブクエリ: SQL文をかいていく必要があるので、DBMSが変わればここも変更しないと行けない</li></ul></li><li><p>理由がなければJPQLを用いるのが良いだろう</p></li></ul><h4 id="7-1-5-永続化ユニット"><a href="#7-1-5-永続化ユニット" class="headerlink" title="7.1.5 永続化ユニット"></a>7.1.5 永続化ユニット</h4><ul><li><p>永続化似関する設定をまとめたもので、実態は<code>persistence.xml</code>という名前のXMLファイル</p></li><li><p>設定項目としては以下のようなものがある</p><ul><li>永続化ユニットの名前</li><li>トランザクションマネージャの設定</li><li>永続化プロバイダ（JPAの実行エンジン）のクラス名</li><li>永続化プロバイダに与えるプロパティ</li><li>接続先データソースの名前★</li><li>エンティティクラスの名前★</li></ul></li><li><p>データベースの接続先を設定する方法</p><ul><li>アプリケーションサーバーで定義されているデータソースの名前を指定する方法</li><li>永続化プロバイダのプロパティとして、接続先アドレスやユーザー名、パスワードなどを設定する方法　が挙げられる</li></ul></li><li><p>JPAの実行エンジンにどれがエンティティクラスなのか検知してもらう設定も入れる</p></li></ul><h4 id="7-1-6-JPAのメリット"><a href="#7-1-6-JPAのメリット" class="headerlink" title="7.1.6 JPAのメリット"></a>7.1.6 JPAのメリット</h4><ul><li>ResultSetからDTOにうつして..という処理を記述しなくてよい</li><li>メソッドかクエリでアクセスできる</li><li>コード量が従来よりも少ない</li><li>メモリ上にキャッシュされたエンティティオブジェクトを利用できる<ul><li>アプリ開発者はキャッシュの有無を意識する必要はない</li></ul></li></ul><h3 id="7-2-エンティティの基本"><a href="#7-2-エンティティの基本" class="headerlink" title="7.2 エンティティの基本"></a>7.2 エンティティの基本</h3><p>（割愛）</p><h4 id="7-2-1-エンティティクラスの実装"><a href="#7-2-1-エンティティクラスの実装" class="headerlink" title="7.2.1 エンティティクラスの実装"></a>7.2.1 エンティティクラスの実装</h4><ul><li>エンティティクラスには<code>@Entity</code>を付与する</li><li><p>publicでなければならず、finalであってはならない</p></li><li><p>引数のないコンストラクタを作成しとくべき</p></li><li><p>Column Serializableについて</p><ul><li>EJBのリモート呼び出し</li><li>複数のアプリケーションサーバーでJPAの２次キャッシュを構成する場合</li><li>MEMO: 他のORMはSerializableに定義しているか確認</li></ul></li></ul><h4 id="7-2-2-ID"><a href="#7-2-2-ID" class="headerlink" title="7.2.2 ID"></a>7.2.2 ID</h4><ul><li>エンティティクラスはIDとして定義したフィールドを使用して<code>hashCode</code>メソッド、</li><li><code>equals(Object)</code>メソッドを実装しなければ行けない→通常IDEで自動生成できる</li><li><code>toString()</code>をオーバーライドしておくとデバッグに役立つ！</li><li>MEMO: 他のORMでも<code>toString()</code>オーバーライドしたりしてるか確認</li></ul><h4 id="7-2-3-リレーション"><a href="#7-2-3-リレーション" class="headerlink" title="7.2.3 リレーション"></a>7.2.3 リレーション</h4><ul><li><code>@OneToMany</code>等によるエンティティの紐付け型を説明</li><li><p>MEMO: 他のORMでも存在するか確認</p></li><li><p>１対１のリレーションについて</p><ul><li>通常１対１のリレーションだと、同一エンティティに保持してしまうことが望ましい</li><li>ただし、ライフサイクルが異なるデータだと、別のエンティティに分けた方が良いケースがある</li><li>例）アカウント情報とアカウントに紐づく会社情報<ul><li>アカウント情報：作成されてから削除されるまで</li><li>会社情報：入社して初めてできる、会社に所属しなければレコードがない<ul><li>などのような状況</li></ul></li></ul></li></ul></li></ul><h3 id="7-3-エンティティマネージャの基本"><a href="#7-3-エンティティマネージャの基本" class="headerlink" title="7.3 エンティティマネージャの基本"></a>7.3 エンティティマネージャの基本</h3><ul><li>エンティティマネージャの実態は <code>javax.persistence.EntityManager</code>インターフェース</li><li>このインターフェースに用意されているメソッドを通してエンティティを操作する</li><li><p>EntityManagerのインスタンスはCDIを用いてアプリケーションサーバーからインジェクションで取得する</p></li><li><p><code>@PersistenceContext</code>アノテーションを付与し、属性似unitNameを指定</p></li><li><code>persistence.xml</code>の<code>&lt;persistence-unit&gt;</code>タグのname属性と一致した名前を指定</li></ul><h4 id="7-3-1-エンティティのライフサイクル"><a href="#7-3-1-エンティティのライフサイクル" class="headerlink" title="7.3.1 エンティティのライフサイクル"></a>7.3.1 エンティティのライフサイクル</h4><ul><li>ライフサイクル<ul><li>NEW</li><li>MANAGED</li><li>REMOVED</li><li>DETACHED</li></ul></li></ul><h4 id="7-3-2-エンティティオブジェクトの作成と永続化"><a href="#7-3-2-エンティティオブジェクトの作成と永続化" class="headerlink" title="7.3.2 エンティティオブジェクトの作成と永続化"></a>7.3.2 エンティティオブジェクトの作成と永続化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NEW状態でまだ永続化コンテキストと紐付いてない</span></span><br><span class="line">Account account = <span class="keyword">new</span> Account();</span><br><span class="line"></span><br><span class="line"><span class="comment">// MANAGED状態になる 次のコミットのタイミングでデータベースに反映される</span></span><br><span class="line">EntiryManager em = xxx;</span><br><span class="line">em.persist(account);</span><br></pre></td></tr></table></figure><h4 id="7-3-3-エンティティオブジェクトの取得と更新"><a href="#7-3-3-エンティティオブジェクトの取得と更新" class="headerlink" title="7.3.3 エンティティオブジェクトの取得と更新"></a>7.3.3 エンティティオブジェクトの取得と更新</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得したいEntityクラスとIDを指定</span></span><br><span class="line"><span class="comment">// MANAGED状態で取得される</span></span><br><span class="line">Account account = em.find(Account.class, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// setter経由で値を設定するとデータベースに反映される（コミットしたタイミングで）</span></span><br><span class="line">account.setName(<span class="string">'てらだよしお'</span>);</span><br></pre></td></tr></table></figure><h4 id="7-3-4-エンティティの削除"><a href="#7-3-4-エンティティの削除" class="headerlink" title="7.3.4 エンティティの削除"></a>7.3.4 エンティティの削除</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">em.remove(account);</span><br></pre></td></tr></table></figure><h4 id="7-3-5-デタッチ"><a href="#7-3-5-デタッチ" class="headerlink" title="7.3.5 デタッチ"></a>7.3.5 デタッチ</h4><p>EJBのメソッドの外へ出るとDETACHED状態になる</p><ul><li>MEMO: 通常アプリでEntityクラスをそのまま画面で使用することは良くないと考える</li></ul><h3 id="7-4-クエリAPI"><a href="#7-4-クエリAPI" class="headerlink" title="7.4 クエリAPI"></a>7.4 クエリAPI</h3><p>JPQLとCriteriaAPIを使ったQuery作成方法を記載</p><h4 id="7-4-1-パラメータ"><a href="#7-4-1-パラメータ" class="headerlink" title="7.4.1 パラメータ"></a>7.4.1 パラメータ</h4><p>JPQLとCriteriaAPIはパラメータを取ることができる<br>パラメータは位置で指定する方法と名前で指定する方法があるが通常は名前で指定した方がよい</p><ul><li>MEMO: 名前で指定するルールを作った方が良さそう</li></ul><h4 id="7-4-2-サンプルデータ"><a href="#7-4-2-サンプルデータ" class="headerlink" title="7.4.2 サンプルデータ"></a>7.4.2 サンプルデータ</h4><p>ダウンロードデータの中にあるサンプルデータについての説明</p><h3 id="7-5-JPQL"><a href="#7-5-JPQL" class="headerlink" title="7.5 JPQL"></a>7.5 JPQL</h3><ul><li>JPQL(Java Persistence Query Language)</li></ul><h4 id="7-5-1-JPQLの基本構文"><a href="#7-5-1-JPQLの基本構文" class="headerlink" title="7.5.1 JPQLの基本構文"></a>7.5.1 JPQLの基本構文</h4><h4 id="7-5-5-フェッチ"><a href="#7-5-5-フェッチ" class="headerlink" title="7.5.5 フェッチ"></a>7.5.5 フェッチ</h4><ul><li>取得するエンティティにリレーションが定義されている場合、リレーション先のエンティティを</li><li><p>どのタイミングでデータベースから取得するかを決めることができる</p></li><li><p>これを「フェッチ戦略」という</p><ul><li>Eagerフェッチ</li><li>Lazyフェッチ</li></ul></li><li><p>Eagerフェッチ</p><ul><li>findメソッド実行時に、リレーション定義されている参照先のオブジェクトも取得する</li><li>リレーション先のエンティティオブジェクトを同時に使用することの多い場合は、</li><li>Eagerフェッチを使用する</li></ul></li><li><p>Lazyフェッチ</p><ul><li>取得処理時には、リレーション先のエンティティオブジェクトを取得せず、</li><li>リレーション先にはじめてアクセスする際に取得する</li><li>リレーション先のエンティティオブジェクトを頻繁に使用しない場合はLazyにすべき</li><li>デメリット<ul><li>どこでエンティティの取得が行われたか分かりづらい</li><li>性能の劣化の場所を特定しづらい</li></ul></li></ul></li><li><p>N+1問題とJOINフェッチ</p><ul><li>１回のクエリを発行したあとにN回のクエリの発行を必要とすることをN+1問題という</li><li>リレーションが増えるほど、発行するクエリの数が増える</li><li>これに対応するためにJOIN FETCH節を利用する</li><li>JOIN句の後ろにFETCHがつくだけ</li></ul></li></ul><h4 id="7-5-6-エンティティオブジェクトの集計"><a href="#7-5-6-エンティティオブジェクトの集計" class="headerlink" title="7.5.6 エンティティオブジェクトの集計"></a>7.5.6 エンティティオブジェクトの集計</h4><ul><li>シンプルにCountなどを使う方法</li><li>型を意識する必要がある場合、コンストラクタ式を利用する必要があるらしい<ul><li>割愛））</li></ul></li></ul><h4 id="7-5-7-名前付きクエリ"><a href="#7-5-7-名前付きクエリ" class="headerlink" title="7.5.7 名前付きクエリ"></a>7.5.7 名前付きクエリ</h4><ul><li>開発者はJPQLのクエリに名前をつけることができる</li><li><p>名前をつけられたJPQLのクエリを「名前付きクエリ」と呼ぶ</p></li><li><p><code>@NamedQueries</code>と<code>@NamedQuery</code>を使って名前定義しておく方法</p><ul><li>MEMO: 他のORMはSQLファイルで管理するのではと思う</li></ul></li></ul><h3 id="7-6-CriteriaAPI"><a href="#7-6-CriteriaAPI" class="headerlink" title="7.6 CriteriaAPI"></a>7.6 CriteriaAPI</h3><ul><li>Criteriaクエリを利用してクエリを構築していく</li><li>JPQLと役割は同じであるため、JPQL同様に以下の要素から構成<ul><li>SELECT</li><li>FROM</li><li>JOIN</li><li>WHERE</li><li>ORDERBY</li></ul></li></ul><h4 id="7-6-1-Criteria-APIの基本構文"><a href="#7-6-1-Criteria-APIの基本構文" class="headerlink" title="7.6.1 Criteria APIの基本構文"></a>7.6.1 Criteria APIの基本構文</h4><p>（割愛）</p><ul><li>利用のメリットがあまりわかない<ul><li>発行されているSQLが分かりづらい</li><li>SQLNativeでかけない</li><li>メソッドなど覚えなくては行けない</li></ul></li></ul><h2 id="Chapter8-データアクセス層の開発-JPAの応用"><a href="#Chapter8-データアクセス層の開発-JPAの応用" class="headerlink" title="Chapter8 データアクセス層の開発 JPAの応用"></a>Chapter8 データアクセス層の開発 JPAの応用</h2><ul><li>エンティティとデータベースの関連付け</li><li>キャッシュなどJPAの応用的な使い方について紹介</li></ul><h3 id="8-1-高度なエンティティの利用方法"><a href="#8-1-高度なエンティティの利用方法" class="headerlink" title="8.1 高度なエンティティの利用方法"></a>8.1 高度なエンティティの利用方法</h3><ul><li>日時を指定する日時型、</li><li>連続した一意の数字を設定するシーケンス、</li><li>リレーション先のエンティティへ処理を伝播するカスケードを紹介</li></ul><h4 id="8-1-1-フィールドに関する応用"><a href="#8-1-1-フィールドに関する応用" class="headerlink" title="8.1.1 フィールドに関する応用"></a>8.1.1 フィールドに関する応用</h4><ul><li><p>日時</p><ul><li>JPAで日時を使用するには、エンティティクラスのフィールドに<code>java.util.Date型</code>を指定</li><li><code>@Temporal</code>アノテーションを付与して、引数にTemporalTypeを指定</li></ul></li><li><p>シーケンス</p><ul><li>エンティティのIDにはサロゲートキーを使用するのが　一般的</li><li>サロゲートキーは人工的に作成されたキーであり、業務上の意味がないもの</li><li>MEMO: 一般的にサロゲートキーが使われているのか確認</li><li><code>@SequenceGenerator</code>アノテーションを付与し、作成したシーケンスからエンティティフィールドに自動で値を設定するには</li><li><code>@GeneratedValue</code>アノテーションを使用する</li><li>MEMO: DBとどのように絡んでくるのか、DB定義側も自動的にシーケンス定義が作成されるのか<ul><li>どのDBもだいたいシーケンス定義を作成できるのか</li></ul></li></ul></li><li><p>カスケード</p><ul><li>エンティティオブジェクトに任意の操作をしたあと、リレーション先までその操作を反映させるための機能</li><li>MEMO: 他のORMはどのようにこの機能を持っているか確認</li></ul></li><li><p>複合ID</p><ul><li><code>@IdClass</code>か<code>@EmbeddedId</code>を使用して実装する<ul><li>どちらも主キークラスとして定義する必要あり</li></ul></li></ul></li></ul><h3 id="8-2-ライフサイクルコールバック"><a href="#8-2-ライフサイクルコールバック" class="headerlink" title="8.2 ライフサイクルコールバック"></a>8.2 ライフサイクルコールバック</h3><ul><li>JPAではコールバックメソッドを使用することで、エンティティオブジェクトの操作に対応した処理を実行することができる</li><li>実装方法は２種類<ul><li>エンティティクラスに実装<ul><li>エンティティの値を変更する場合にとどめてく</li></ul></li><li>エンティティリスナに実装<ul><li>エンティティの値を変更する処理は実装せず、共通で使用するような処理にとどめておく</li></ul></li><li>→あまり複雑にならないように注意</li></ul></li><li>MEMO: 他のORMにはコールバックメソッドの仕組みある？どんな処理を実装するのがベター？</li></ul><h3 id="8-3-エンティティクラスとテーブル構造"><a href="#8-3-エンティティクラスとテーブル構造" class="headerlink" title="8.3 エンティティクラスとテーブル構造"></a>8.3 エンティティクラスとテーブル構造</h3><p>Javaアプリケーション開発者がエンティティクラスを作成すると、JPAはエンティティクラスの定義を読み込み、<br>データベースへテーブルを作成する</p><ul><li>MEMO: 他のORMはテーブル自動作成とかされるのか確認</li></ul><h4 id="8-3-1-テーブル名とカラム名"><a href="#8-3-1-テーブル名とカラム名" class="headerlink" title="8.3.1 テーブル名とカラム名"></a>8.3.1 テーブル名とカラム名</h4><p>エンティティの変数とカラム名を変更する方法について記載</p><ul><li>多対多の中間表の名前の付け方</li><li>LOB定義 <code>@Lob</code></li></ul><h4 id="8-3-2-索引"><a href="#8-3-2-索引" class="headerlink" title="8.3.2 索引"></a>8.3.2 索引</h4><ul><li>索引を作成する方法について記載<ul><li><code>@Index(columnList =  &quot;xxxxx,xxxxx,xxxxxx&quot;)</code></li></ul></li></ul><h4 id="8-3-3-制約"><a href="#8-3-3-制約" class="headerlink" title="8.3.3 制約"></a>8.3.3 制約</h4><ul><li><p>精度とスケール、長さ</p><ul><li><code>@Column(precision=15, scale=0)</code></li><li><code>@Column(length=500)</code></li></ul></li><li><p>一意制約</p></li><li><p>MEMO: 他のORMでもDBMSの方言を吸収しながらテーブル定義ができるか確認、できなければJPAってすごい</p><ul><li>他のシステムも同じDBを参照していた場合、衝突する可能性あるので、AP:DBが対になるようなシステムであればよいかも</li></ul></li></ul><h3 id="8-4-トランザクション"><a href="#8-4-トランザクション" class="headerlink" title="8.4 トランザクション"></a>8.4 トランザクション</h3><ul><li>JavaEEには<ul><li>EJBコンテナにより自動的に開始されるトランザクション</li><li>Java開発者が任意で開始するトランザクション<ul><li>がある</li></ul></li></ul></li></ul><h3 id="8-5-キャッシュ"><a href="#8-5-キャッシュ" class="headerlink" title="8.5 キャッシュ"></a>8.5 キャッシュ</h3><h4 id="8-5-1-これまでのデータアクセス"><a href="#8-5-1-これまでのデータアクセス" class="headerlink" title="8.5.1 これまでのデータアクセス"></a>8.5.1 これまでのデータアクセス</h4><h4 id="8-5-2-キャッシュを使用したデータアクセス"><a href="#8-5-2-キャッシュを使用したデータアクセス" class="headerlink" title="8.5.2 キャッシュを使用したデータアクセス"></a>8.5.2 キャッシュを使用したデータアクセス</h4><ul><li>Column 複数アプリケーションによるデータ更新<ul><li>複数のアプリケーションが同一のデータベースを更新する場合や他のノードやデータベースでデータが更新されると、</li><li>キャッシュされているエンティティに伝播されないので、整合性が取れなくなる</li><li>MEMO: かなり致命的な問題だと思う… マスタテーブルに使うとか？</li><li>MEMO: 今キャッシュされているエンティティ情報をログに出力する方法などがあれば可視化されてわかりやすいが、ある？</li></ul></li></ul><h4 id="8-5-5-プリロード"><a href="#8-5-5-プリロード" class="headerlink" title="8.5.5 プリロード"></a>8.5.5 プリロード</h4><ul><li>EJBの<code>@Startup</code>などを利用してアプリケーション起動時に１回だけSQLを実行したり、</li><li>JSFやWebサービスを利用して外から初期化処理を起動できるようにすること<ul><li>１回読み込んでおくことでキャッシュに乗せて処理を早くする</li></ul></li></ul><h4 id="8-5-6-EclipseLink"><a href="#8-5-6-EclipseLink" class="headerlink" title="8.5.6 EclipseLink"></a>8.5.6 EclipseLink</h4><ul><li>GlassFishではJPAの実行エンジンとして、EclipseLinkを使用している</li><li><p>EclipseLinkには</p><ul><li>エンティティキャッシュ<ul><li>エンティティオブジェクトをキャッシュする機能</li></ul></li><li>問い合わせキャッシュ　の２種類が存在する<ul><li>クエリの結果をキャッシュする機能</li></ul></li></ul></li><li><p>MEMO: EcllipseLink以外の実行エンジンなどが存在する？</p></li></ul><h3 id="8-6-永続化ユニット"><a href="#8-6-永続化ユニット" class="headerlink" title="8.6 永続化ユニット"></a>8.6 永続化ユニット</h3><ul><li><a href="http://itdoc.hitachi.co.jp/manuals/link/cosmi_v0870/APKC/EU070266.HTM" target="_blank" rel="noopener">http://itdoc.hitachi.co.jp/manuals/link/cosmi_v0870/APKC/EU070266.HTM</a></li></ul><p>アプリケーションからJPAを使用する場合，次のような情報を定義する必要があります。</p><p>アプリケーション内のエンティティクラスの情報<br>エンティティクラスとデータベーステーブルとのマッピング情報<br>JPAプロバイダがデータベースコネクションを取得するためのデータソースの情報<br>これらの情報を定義したものを永続化ユニットといいます。</p><ul><li>APサーバーにJNDIを定義し、APサーバー経由で接続→こちらを推奨しますとのこと</li><li><p>設定ファイルをアプリケーションに保持して直接接続</p></li><li><p>Column JavaSEでJPAを使う</p><ul><li>jarファイルをクラスパスに追加して、persistence.xmlを用意すれば使えますとのこと</li><li>EJBコンテナがないので、EntityManagerFactory経由でEntityManagerオブジェクトを取得する</li></ul></li></ul><h3 id="8-7-環境構築手順"><a href="#8-7-環境構築手順" class="headerlink" title="8.7 環境構築手順"></a>8.7 環境構築手順</h3><p>割愛</p><h3 id="8-8-アプリケーション開発手順"><a href="#8-8-アプリケーション開発手順" class="headerlink" title="8.8 アプリケーション開発手順"></a>8.8 アプリケーション開発手順</h3><h4 id="8-8-2-JPQLの開発"><a href="#8-8-2-JPQLの開発" class="headerlink" title="8.8.2 JPQLの開発"></a>8.8.2 JPQLの開発</h4><p>IDE上で試しにSQL流せる機能</p><ul><li>MEMO: 他のORMにも同様の機能あるか確認する</li></ul><h2 id="Chapter9-RESTful-Webサービスの開発"><a href="#Chapter9-RESTful-Webサービスの開発" class="headerlink" title="Chapter9 RESTful Webサービスの開発"></a>Chapter9 RESTful Webサービスの開発</h2><h3 id="9-1-Webサービスの基礎"><a href="#9-1-Webサービスの基礎" class="headerlink" title="9.1 Webサービスの基礎"></a>9.1 Webサービスの基礎</h3><h4 id="9-1-1-Webサービスとは"><a href="#9-1-1-Webサービスとは" class="headerlink" title="9.1.1 Webサービスとは"></a>9.1.1 Webサービスとは</h4><ul><li><p>サーバーで行われたなんらかの処理の結果をHTMLではなく、処理結果だけで返すものをWebサービスと呼びます</p></li><li><p>Webサービスを実現するために使われる技術</p><ul><li>SOAP: 信頼性を必要とする企業間でのWebサービスで多用されている</li><li>REST: 一般に公開されているWebサービスでよく使用されている<ul><li>RESTベースのWebサービスをRESTfulWebサービスと呼ぶ</li></ul></li></ul></li><li><p>JavaEEでもSOAPとRESTを利用したWebサービスを作成するためのAPIを提供している</p><ul><li>SOAPを使用したWebサービスを作成するAPIがJAX-WS</li><li>RESTful Webサービスを作成するAPIが、JAX-RS</li></ul></li></ul><h4 id="9-1-2-RESTful-Webサービスとは"><a href="#9-1-2-RESTful-Webサービスとは" class="headerlink" title="9.1.2 RESTful Webサービスとは"></a>9.1.2 RESTful Webサービスとは</h4><ul><li>RESTful Webサービスとは、RESTに則ったWebサービス</li><li><p>REST原則</p><ul><li>a.すべてのリソースに一意なアドレス（URI）を与える</li><li>b.情報の操作には予め定義された命令体型（統一インターフェイスという）を使用する</li><li>c.プラットフォームに応じて複数の表現（データ形式）を使用する</li><li>d.セッションなどの状態管理を行わず、ステートレスに通信する</li><li>e.アプリケーションはリンクによって、次の状態に遷移する</li></ul></li><li><p>上記のすべてを守る必要はないが、少なくとも、aとbは守っておくべき</p></li><li>制約がゆるいので、かんたんに実装できる</li><li>一方、SOAPは定義が厳密なので実装ハードルが高い</li></ul><h4 id="9-1-3-RESTとHTTP"><a href="#9-1-3-RESTとHTTP" class="headerlink" title="9.1.3 RESTとHTTP"></a>9.1.3 RESTとHTTP</h4><ul><li>HTTPヘッダー</li><li>HTTPメソッド<ul><li>GET</li><li>POST</li><li>PUT</li><li>DELETE</li></ul></li><li>URI<ul><li>MEMO: マトリックスパラメータは初めて聞いた</li></ul></li><li>ステータスコード</li></ul><h3 id="9-2-JAX-RSの基本"><a href="#9-2-JAX-RSの基本" class="headerlink" title="9.2 JAX-RSの基本"></a>9.2 JAX-RSの基本</h3><h4 id="9-2-1-JAX-RSとは"><a href="#9-2-1-JAX-RSとは" class="headerlink" title="9.2.1 JAX-RSとは"></a>9.2.1 JAX-RSとは</h4><ul><li><p>リクエストパラメータ</p><ul><li>マーシャル：XML形式やJSON形式→Javaオブジェクト</li><li>アンマーシャル：Javaオブジェクト→XML形式やJSON形式</li><li>JAX-RS2.0仕様の参照実装はJersey</li><li>JerseyはGlassFishサーバーでも使用されている</li></ul></li><li><p>主に５つの機能を提供</p><ul><li>１．HTTPメソッド/URIパターンとリソースメソッドとのバインド機能</li><li>２．メッセージボディのデータ形式指定機能</li><li>３．リクエスト情報のインジェクション機能</li><li>４．リクエスト/レスポンスのメッセージボディの変換機能</li><li>５．例外のレスポンスマッピング機能</li></ul></li></ul><h4 id="9-2-2-サンプルアプリケーションにおけるJAX-RSの機能"><a href="#9-2-2-サンプルアプリケーションにおけるJAX-RSの機能" class="headerlink" title="9.2.2 サンプルアプリケーションにおけるJAX-RSの機能"></a>9.2.2 サンプルアプリケーションにおけるJAX-RSの機能</h4><h3 id="9-3-RESTful-Webサービス作成のための事前準備"><a href="#9-3-RESTful-Webサービス作成のための事前準備" class="headerlink" title="9.3 RESTful Webサービス作成のための事前準備"></a>9.3 RESTful Webサービス作成のための事前準備</h3><h4 id="9-3-1-RESTful-Webサービスの認証方式"><a href="#9-3-1-RESTful-Webサービスの認証方式" class="headerlink" title="9.3.1 RESTful Webサービスの認証方式"></a>9.3.1 RESTful Webサービスの認証方式</h4><ul><li>ナレッジバンクのRESTサービス機能ではWEBアプリケーション機能で採用しているFORM認証ではなく</li><li><p>BASIC認証で認証を行う</p></li><li><p>BASIC認証を行うための設定を記載</p><ul><li>web.xmlに追記するみたい</li></ul></li><li>MEMO: 他のフレームワークでBASIC認証を行う方法について整理</li></ul><h4 id="9-3-2-データクラス（DTO）"><a href="#9-3-2-データクラス（DTO）" class="headerlink" title="9.3.2 データクラス（DTO）"></a>9.3.2 データクラス（DTO）</h4><ul><li>クライアントからのリクエストをJavaオブジェクトに変換する際に受け皿クラスを作成<ul><li><code>@XMLRootElementアノテーション</code>などを不要しないと行けないらしく、不便そう</li></ul></li></ul><h4 id="9-3-3-Application-サブクラス"><a href="#9-3-3-Application-サブクラス" class="headerlink" title="9.3.3 Application サブクラス"></a>9.3.3 Application サブクラス</h4><ul><li>作成するリソースクラスなど、JAX-RSで使用する一連のファイルをJAX-RSランタイムに通知するためにApplicationサブクラスをクラスパス上に配置</li><li>このファイルの存在により、作成するリソースクラスをRESTful Webサービスとして公開できる</li><li><code>ApplicationConfig.java</code>に<code>@ApplicationPath(&quot;xxxxxx&quot;)</code>を指定することでOK</li></ul><h3 id="9-4-RESTサービスクラス（サーバー側）の作成"><a href="#9-4-RESTサービスクラス（サーバー側）の作成" class="headerlink" title="9.4 RESTサービスクラス（サーバー側）の作成"></a>9.4 RESTサービスクラス（サーバー側）の作成</h3><h4 id="9-4-1-リソースクラスの構成要素"><a href="#9-4-1-リソースクラスの構成要素" class="headerlink" title="9.4.1 リソースクラスの構成要素"></a>9.4.1 リソースクラスの構成要素</h4><ul><li>RESTful Webサービスで提供する処理を定義するRESTサービスクラスを作成します。</li><li>RESTではすべてをリソースとして扱うため、リソースクラスとも呼ばれる<ul><li>MEMO: Springの場合、Controller</li></ul></li></ul><h4 id="9-4-2-エンドポイントURIの設定"><a href="#9-4-2-エンドポイントURIの設定" class="headerlink" title="9.4.2 エンドポイントURIの設定"></a>9.4.2 エンドポイントURIの設定</h4><ul><li><code>@Path(&quot;{id}&quot;)</code></li><li>などと指定</li></ul><h4 id="9-4-3-HTTPメソッドとリソースメソッドのバインド"><a href="#9-4-3-HTTPメソッドとリソースメソッドのバインド" class="headerlink" title="9.4.3 HTTPメソッドとリソースメソッドのバインド"></a>9.4.3 HTTPメソッドとリソースメソッドのバインド</h4><ul><li><code>@GET</code>,<code>@POST</code>などを指定</li></ul><h4 id="9-4-4-メッセージボディのデータ形式指定"><a href="#9-4-4-メッセージボディのデータ形式指定" class="headerlink" title="9.4.4 メッセージボディのデータ形式指定"></a>9.4.4 メッセージボディのデータ形式指定</h4><ul><li><code>@Consumes({})</code>: クライアントから受け取るデータ形式</li><li><p><code>@Produces({})</code>: クライアントに返却するデータ形式</p></li><li><p>MINEタイプの抽象化：<code>javax.ws.rs.core.MediaType</code></p><ul><li><code>APPLICATION_XML = &quot;application/xml&quot;;</code></li><li>などの定義がある</li></ul></li><li><p>Column コンテンツネゴシエーション</p><ul><li>クライアントがサーバーにリクエストする際に、返してもらいたいメッセージボディのデータ形式やエンコード方式などをリクエストヘッダーで要求できる</li><li>これを「HTTPコンテンツネゴシエーション」といいます。</li><li>コンテンツネゴシエーションはAcceptヘッダーに要求するデータ形式を指定して行う</li><li>要求されたデータ形式をサーバーが提供できない場合、「406 Not Acceptable」のステータスコードをクライアントに返す<ul><li><code>Accept-Charset</code>ヘッダー、<code>Accept-Language</code>ヘッダー、<code>Accept-Encoding</code>ヘッダーなど</li></ul></li></ul></li><li><p>MEMO: 見たことはあったが用語として抑えれてなかったので覚えておく</p></li><li><p>メッセージボディとJavaオブジェクトとのマッピング</p><ul><li>アンマーシャル：<code>javax.ws.rs.ext.MessageBodyReader</code></li><li>マーシャル：<code>javax.ws.rs.ext.MessageBodyWriter</code></li></ul></li></ul><h4 id="9-4-5-リクエスト情報のインジェクション"><a href="#9-4-5-リクエスト情報のインジェクション" class="headerlink" title="9.4.5 リクエスト情報のインジェクション"></a>9.4.5 リクエスト情報のインジェクション</h4><ul><li><a href="mailto:`@javax.ws.rs.PathParam" target="_blank" rel="noopener">`@javax.ws.rs.PathParam</a>`アノテーション：{id}などのパスパラメータを取得</li><li><a href="mailto:`@javax.ws.rs.QueryParam" target="_blank" rel="noopener">`@javax.ws.rs.QueryParam</a>`アノテーション：クエリパラメータを取得</li><li><a href="mailto:`@javax.ws.rs.MatrixParam" target="_blank" rel="noopener">`@javax.ws.rs.MatrixParam</a>`アノテーション：URIのマトリクスパラメータを取得する</li><li><a href="mailto:`@javax.ws.rs.FormParam" target="_blank" rel="noopener">`@javax.ws.rs.FormParam</a>`アノテーション：HTMLのフォームから送信された情報を取得する</li><li><a href="mailto:`@javax.ws.rs.HeaderParam" target="_blank" rel="noopener">`@javax.ws.rs.HeaderParam</a>`アノテーション：リクエストヘッダーから値を取得する</li><li><a href="mailto:`@javax.ws.rs.CookieParam" target="_blank" rel="noopener">`@javax.ws.rs.CookieParam</a>`アノテーション：リクエストのCookieヘッダーから値を取得する</li><li><a href="mailto:`@javax.ws.rs.core.Context" target="_blank" rel="noopener">`@javax.ws.rs.core.Context</a>`アノテーション：リクエストURIやリクエストヘッダー、セキュリティ情報などのコンテキスト情報を取得する汎用的なアノテーション</li><li><a href="mailto:`@javax.ws.rs.BeanParam" target="_blank" rel="noopener">`@javax.ws.rs.BeanParam</a>`アノテーション：リクエストのパラメータ一式をビーンとして取得する</li><li><a href="mailto:`@javax.ws.rs.DefaultValue" target="_blank" rel="noopener">`@javax.ws.rs.DefaultValue</a>`アノテーション：対象に値が入らなかった場合、デフォルト値を指定するアノテーション</li></ul><h4 id="9-4-6-リクエストのメッセージボディの受取"><a href="#9-4-6-リクエストのメッセージボディの受取" class="headerlink" title="9.4.6 リクエストのメッセージボディの受取"></a>9.4.6 リクエストのメッセージボディの受取</h4><ul><li>リクエストの引数にアノテーションを付与しなければ、メッセージボディを受け取れる</li></ul><h4 id="9-4-7-入力チェック"><a href="#9-4-7-入力チェック" class="headerlink" title="9.4.7 入力チェック"></a>9.4.7 入力チェック</h4><ul><li>リクエストのメッセージボディにマッピングしているJavaオブジェクトをバリデーションするには<code>@Valid</code>アノテーションを使用する</li></ul><h4 id="9-4-8-レスポンスの定義"><a href="#9-4-8-レスポンスの定義" class="headerlink" title="9.4.8 レスポンスの定義"></a>9.4.8 レスポンスの定義</h4><ul><li>return する時に <code>javax.ws.rs.core.Response</code>クラスを用意している</li><li><p><code>Response.created(URI.create(&quot;/knowledge&quot; + knowledge.getId())).build()</code></p><ul><li>みたいな感じで生成して返却する</li></ul></li><li><p>レスポンスメッセージボディのみを指定するときは、Response型以外のオブジェクトを戻り値にするとよい</p></li><li>エンティティプロバイダ（<code>MessageBodyWriter</code>インターフェース実装クラス）がリクエストのAcceptヘッダーに指定されているデータ形式に変換し、レスポンスのメッセージボディに書き出します</li><li>成功時のレスポンスにメッセージボディが含まれている場合、「200 OK」</li><li>メッセージボディが含まれていない場合、「204 No Content」<ul><li>MEMO: レスポンスの 204 No Contentは覚えておく</li></ul></li></ul><h3 id="9-5-HTTPメソッドに応じた処理"><a href="#9-5-HTTPメソッドに応じた処理" class="headerlink" title="9.5 HTTPメソッドに応じた処理"></a>9.5 HTTPメソッドに応じた処理</h3><h4 id="9-5-1-ナレッジの検索（GETメソッドによる操作）"><a href="#9-5-1-ナレッジの検索（GETメソッドによる操作）" class="headerlink" title="9.5.1 ナレッジの検索（GETメソッドによる操作）"></a>9.5.1 ナレッジの検索（GETメソッドによる操作）</h4><h4 id="9-5-2-ナレッジの登録（POSTメソッドによる操作）"><a href="#9-5-2-ナレッジの登録（POSTメソッドによる操作）" class="headerlink" title="9.5.2 ナレッジの登録（POSTメソッドによる操作）"></a>9.5.2 ナレッジの登録（POSTメソッドによる操作）</h4><h4 id="9-5-3-ナレッジの更新（PUTメソッドによる操作）"><a href="#9-5-3-ナレッジの更新（PUTメソッドによる操作）" class="headerlink" title="9.5.3 ナレッジの更新（PUTメソッドによる操作）"></a>9.5.3 ナレッジの更新（PUTメソッドによる操作）</h4><h4 id="9-5-4-ナレッジの削除（DELETEメソッドによる操作）"><a href="#9-5-4-ナレッジの削除（DELETEメソッドによる操作）" class="headerlink" title="9.5.4 ナレッジの削除（DELETEメソッドによる操作）"></a>9.5.4 ナレッジの削除（DELETEメソッドによる操作）</h4><h4 id="9-5-5-例外クラス"><a href="#9-5-5-例外クラス" class="headerlink" title="9.5.5 例外クラス"></a>9.5.5 例外クラス</h4><ul><li>JAX-RSの例外クラスを使用する</li><li><p>JAX-RS2.0の例外体系</p><ul><li>非チェック例外である、<code>WebApplicationException</code>を用意している<ul><li>コンストラクタにステータスコードを指定すると、アプリケーションからスローされた際にステータスコードを含んだResponseインスタンスをクライントに返す</li><li>何も指定しなかったら 500 Internal Server Error</li></ul></li><li>JAX-RS2.0ではこのクラスを継承した例外クラスが追加された</li></ul></li><li><p>ClientErrorExceptionを継承した例外クラス</p><ul><li>BadRequestException(400)</li><li>NotAuthorizedException(401)</li></ul></li><li><p>ServerErrorExceptionを継承した例外クラス</p><ul><li>InternalServerErrorException(500)</li><li>ServiceUnavailableException(503)</li></ul></li><li><p>MEMO: 他のフレームワークでもこの標準エラーを使用しているような気がする。あとで確認しておく</p></li><li><p>独自例外の作成方法</p><ul><li>RuntimeExceptionを継承して例外クラスを作成</li><li>マッパークラスを作成し、JAX-RSに認識させる</li></ul></li><li><p>MEMO: 独自例外を作成することは必ず必要になってくるので、ここ後で見返しておく</p><ul><li>Responseが持っているステータスについても覚えておく</li></ul></li><li><p>MEMO: 標準提供の例外をマッピングすることも可能！</p><ul><li>標準のExceptionはステータスコードしかクライアントに返却しないため、ここでマッピングして再定義しておくと、メッセージも合わせて返却できるということ</li></ul></li></ul><h3 id="9-6-RESTクライアントクラス（クライアント側）の作成"><a href="#9-6-RESTクライアントクラス（クライアント側）の作成" class="headerlink" title="9.6 RESTクライアントクラス（クライアント側）の作成"></a>9.6 RESTクライアントクラス（クライアント側）の作成</h3><h4 id="9-6-1-データクラス（DTO）"><a href="#9-6-1-データクラス（DTO）" class="headerlink" title="9.6.1 データクラス（DTO）"></a>9.6.1 データクラス（DTO）</h4><h4 id="9-6-2-RESTクライアントクラス"><a href="#9-6-2-RESTクライアントクラス" class="headerlink" title="9.6.2 RESTクライアントクラス"></a>9.6.2 RESTクライアントクラス</h4><ul><li>MEMO: Javaクライアント側でJAX-RSのWebサービスを利用したい場合の実装方法<ul><li>BASIC認証にサードパーティのクラスを使う</li></ul></li></ul><h3 id="9-7-メッセージフィルタクラス"><a href="#9-7-メッセージフィルタクラス" class="headerlink" title="9.7 メッセージフィルタクラス"></a>9.7 メッセージフィルタクラス</h3><h4 id="9-7-1-メッセージフィルタとエンティティインターセプタ"><a href="#9-7-1-メッセージフィルタとエンティティインターセプタ" class="headerlink" title="9.7.1 メッセージフィルタとエンティティインターセプタ"></a>9.7.1 メッセージフィルタとエンティティインターセプタ</h4><ul><li>JAX-RS2.0では新たに、<ul><li>メッセージフィルタ：リクエスト/レスポンスヘッダーの編集などに使用</li><li>エンティティボディインターセプター：エンティティボディの編集などに使用</li></ul></li></ul><p>割愛</p><ul><li>MEMO: Logging用のフィルタの実装について考える ベストプラクティスは？<ul><li>FileterとInterceptorの違い<a href="https://meetup-jp.toast.com/698" target="_blank" rel="noopener">https://meetup-jp.toast.com/698</a></li></ul></li></ul><h3 id="9-8-まとめ"><a href="#9-8-まとめ" class="headerlink" title="9.8 まとめ"></a>9.8 まとめ</h3><ul><li>JAX-RS<ul><li>アノテーションでRESTful-Webサービスを作成できる</li></ul></li></ul><h2 id="Chapter10-バッチアプリケーションの開発"><a href="#Chapter10-バッチアプリケーションの開発" class="headerlink" title="Chapter10 バッチアプリケーションの開発"></a>Chapter10 バッチアプリケーションの開発</h2><p>JavaEE7では、Javaにおけるバッチ処理の標準化仕様が盛り込まれました。</p><p>この仕様はJSR352(Batch Applications for the Java Platform)で規定されている</p><p>通称「jBatch」と呼ばれている</p><h3 id="10-1-jBatchの基本"><a href="#10-1-jBatchの基本" class="headerlink" title="10.1 jBatchの基本"></a>10.1 jBatchの基本</h3><h4 id="10-1-1-バッチ処理とその特徴"><a href="#10-1-1-バッチ処理とその特徴" class="headerlink" title="10.1.1 バッチ処理とその特徴"></a>10.1.1 バッチ処理とその特徴</h4><ul><li><p>バッチ処理とは</p><ul><li>複数のデータや複数の処理を一括して実行する方式のこと</li><li>一方、Webブラウザなどの画面を介して入力と応答が繰り返される処理をリアルタイム処理、オンライン処理と呼ぶ</li></ul></li><li><p>特徴</p><ul><li>一度に多くのデータが処理される</li><li>実行時間が長い</li><li>非対話型（人間による画面での入出力操作を伴わない）</li><li>リクエストに従って起動されることよりも、実行する時刻を指定して起動されることが多い</li></ul></li></ul><h4 id="10-1-2-jBatchとは"><a href="#10-1-2-jBatchとは" class="headerlink" title="10.1.2 jBatchとは"></a>10.1.2 jBatchとは</h4><ul><li><p>jBatchとは</p><ul><li>前項で述べたような特徴を持つバッチ処理をJava言語で実装するためのフレームワーク</li><li>業務システムにおけるバッチ処理は、全体的な処理の流れや設計時に注意すべきポイントなど、</li><li>時代や言語を伴わない共通点が多く見られる</li><li>jBatchはこうした業務システムのバッチ処理似求められる要素を盛り込んだ「以前から培われている雛形」を標準として提供</li><li>jBatchを使わなくてもバッチ処理を実現できるが、活用することで、理解が容易で考慮漏れの少ないバッチ処理を効率よく提供刷ることができる</li></ul></li><li><p>jBatchの機能と構成要素</p><ul><li>大まかに言うと<ul><li>ジョブ</li><li>ステップ<ul><li>で構成される</li></ul></li></ul></li><li>ジョブ：全体の流れを記述</li><li>ステップ：ここの処理を実装する</li><li>ジョブとステップの分離により、業務の変更に対して柔軟に対応できる仕組みになっている</li></ul></li><li><p>jBatchのアーキテクチャはオープンソースのSpringBatchから多くを受け継いでいるが</p></li><li>ジョブとステップの分離は、メインフレーム時代から受け継がれているもの</li><li>メインフレームでは、全体の流れはジョブとしてJCLによって記述され、</li><li><p>業務ロジックはステップとして、COBOLやPL/Iなどの言語で記述されたプログラムを用いて実装される</p></li><li><p>jBatchの機能と構成要素</p></li><li><p>jBatchにはジョブとステップ以外にいくつか保s所的な機能がある</p><ul><li>リスナ：ジョブやステップの開始直前または終了直後に処理を差し込む</li><li>ジョブリポジトリ：ジョブやステップの状態を永続的に保持する</li><li>コンテキスト：一時的に保持する</li><li>メトリック：統計的な情報を確認刷る</li></ul></li></ul><h4 id="10-1-3-ジョブ"><a href="#10-1-3-ジョブ" class="headerlink" title="10.1.3 ジョブ"></a>10.1.3 ジョブ</h4><ul><li><p>ジョブはステップの入れ物</p><ul><li>１つのジョブの中には１つ以上のステップが必要</li><li>XMLで記述する<ul><li>各ステップの呼び出し先クラス</li><li>実行順序</li><li>ジョブ全体や各ステップに対する設定、エラー発生時の挙動なども記述</li><li>記述のルールを示した仕様は、JSL(Job Specification Language)と呼ばれる</li><li>ジョブを記述したXMLファイルはJob XMLファイルと呼ばれる</li></ul></li><li>JSLには処理の実行順序を制御するために、以下のXML要素が用意されている<ul><li>フロー（flow）</li><li>スプリット（split）</li><li>デシジョン（decision）</li><li>遷移要素（Transition Elements）</li></ul></li></ul></li><li><p>全体図が記載されている（書籍を見たほうが良い）</p></li><li><p>フロー：複数のステップをまとめる要素</p></li><li>スプリット：複数のフローを同時実行させることができる</li><li>デシジョン：ジョブ内部で次の遷移先を細かくカスタマイズするための機能</li><li><p>遷移要素</p><ul><li>next: 遷移先には、ステップ、フロー、スプリット、デシジョンが指定できる</li><li>end: 正常終了</li><li>stop: 中断</li><li>fail: 異常終了</li></ul></li><li><p>リトライとスキップ</p><ul><li>リトライ：チャンク型ステップの処理中に特定の例外が発生した場合に、再度そのデータの処理を試みる</li><li>スキップ：チャンク型ステップの処理中に特定の例外が発生した場合に、データを飛ばして次に進む</li><li>リトライもしくはスキップ対象の例外クラスをJob XMLの中に定義</li></ul></li><li><p>ジョブオペレータ</p><ul><li>ジョブ自体の開始や停止の全体的な制御を行う</li></ul></li><li><p>ジョブオペレータの呼び出し方法</p><ul><li>バッチ処理の特徴として、「実行する時刻を指定して起動されることが多い」という点をあげたが、</li><li>jBatchの仕様にはバッチを決まった時間に起動する方式に関する規定や、それを実現するAPIも含まれていない</li><li>この部分に関しては、ジョブスケジューラを連携させる方式が一般的に<ul><li>Linuxなどであればcron</li><li>Windowsであればタスクスケジューラ</li><li>その他市販のジョブスケジューラを使用する…など</li></ul></li><li>ジョブを臨時で実行したい場合や、何らかの異常が発生し、人間が介入して原因を取り除いたあとに再実行する場合は、リクエストに従って起動することになります。（これを「アドホックな実行」と呼びます）<ul><li>そういった場合、画面などのユーザーインターフェースがあると便利だが、この点に関してもjBatchは規定ない</li></ul></li><li>実装する際には、オペレータの運用も考える必要がある</li></ul></li><li><p>MEMO: 手動実行されたジョブか、スケジュールで実行されたジョブかを識別する方法を仕込んでおいた方が良いと思った</p></li></ul><h4 id="10-1-4-ステップ"><a href="#10-1-4-ステップ" class="headerlink" title="10.1.4 ステップ"></a>10.1.4 ステップ</h4><ul><li>バッチ内部の個々の処理を実装する部分<ul><li>ステップの実態は、jBatchのAPIの中で定義されているJavaインターフェースであり、実装テンプレートを提供している</li></ul></li><li>ステップには２種類ある<ul><li>チャンク型：複数のデータを逐次的に処理するために使われる<ul><li><code>ItemReader</code>,<code>ItemProcessor</code>,<code>ItemWriter</code>の３つで構成される</li><li>ItemReaderとItemProcessorを繰り返したあと、ItemWriterが呼ばれる（デフォルトで１０回）</li><li>この塊（１０回などの処理の塊）をチャンクと呼ぶ</li></ul></li><li>バッチレット型：単体で完結する処理で使われます<ul><li>データの加工や計算を１件ずつ繰り返すような処理ではなく、データに依存しない処理やコマンド実行などの処理を担います。</li><li>例えば、ディレクトリ作成やファイル圧縮、送受信処理などの処理</li><li>「タスク志向のステップ」と呼ばれる場合もある</li><li>MEMO: このような単純な処理であれば、スクリプトで完結しそうな気もする..</li></ul></li></ul></li></ul><h4 id="10-1-5-補助機能"><a href="#10-1-5-補助機能" class="headerlink" title="10.1.5 補助機能"></a>10.1.5 補助機能</h4><ul><li>リスナ<ul><li>リスナを用いることで、バッチ処理の進行に応じた特定のタイミングで任意の処理を実行することができる</li><li>「特定のタイミング」には、ジョブやステップの開始及び終了、リトライやスキップの発生などがある</li></ul></li><li>各処理のタイミングごとにリスナが用意されている</li><li><p>リスナの設置は任意で、設置したい場合、リスナのクラス名をJob XMLの中で記述</p></li><li><p>ジョブリポジトリ：開発者が意識して操作したりしない部分みたい</p><ul><li>実行中のジョブの情報や、実行が終わったジョブに関する情報が保存される</li><li>情報の更新はコンテナによって自動的に行われ、情報の取得は、前述のジョブオペレータや、後述するコンテキスト、メトリックAPIを利用する</li></ul></li><li><p>コンテキスト</p><ul><li>種類<ul><li>ジョブコンテキスト</li><li>ステップコンテキスト</li></ul></li><li>それぞれ、実行中のジョブやステップに関する情報を提供する役割を担う<ul><li>名前やID、ステータスなどがある</li><li>コンテキストへのアクセスは、jBatchAPIのJobContext、StepContextインターフェースを経由して行います</li></ul></li></ul></li><li><p>メトリック</p><ul><li>チャンク型のステップに対して、実行時の統計情報を提供するのがメトリック</li><li>情報<ul><li>読み取りレコード数</li><li>書き込みレコード数</li><li>スキップが発生した数</li><li>など、処理量に関するもの</li></ul></li><li>メトリックへのアクセスには、jBatchAPI似あるMetricインターフェースを経由して行う</li></ul></li></ul><h3 id="10-2-jBatchの利用――基本編"><a href="#10-2-jBatchの利用――基本編" class="headerlink" title="10.2 jBatchの利用――基本編"></a>10.2 jBatchの利用――基本編</h3><ul><li>実際に実装してみる<ul><li>JobXMLの実装</li><li>チャンク型ステップの実装</li><li>バッチレット型ステップの実装</li><li>ジョブ実行部分の実装</li><li>実行結果の確認</li></ul></li></ul><h4 id="10-2-1-JobXMLの実装"><a href="#10-2-1-JobXMLの実装" class="headerlink" title="10.2.1 JobXMLの実装"></a>10.2.1 JobXMLの実装</h4><ul><li>バッチの全体を表すJobXMLを作成刷る</li><li>ファイル名から拡張子を取り除いた部分がそのままジョブの名前となります。</li><li><p>ジョブの名前は実行時にJobOperatorクラスのメソッドにわたす形で利用される</p></li><li><p>それぞれの要素説明</p><ul><li>job</li><li>step</li><li>chunk</li><li>batchlet</li></ul></li></ul><h4 id="10-2-2-チャンク型ステップの実装"><a href="#10-2-2-チャンク型ステップの実装" class="headerlink" title="10.2.2 チャンク型ステップの実装"></a>10.2.2 チャンク型ステップの実装</h4><h4 id="10-2-5-バッチレット型ステップの実装"><a href="#10-2-5-バッチレット型ステップの実装" class="headerlink" title="10.2.5 バッチレット型ステップの実装"></a>10.2.5 バッチレット型ステップの実装</h4><ul><li>Batchletを実装<ul><li>prosess,stopを実装して処理を書くだけ</li><li>保守性を高い状態に保つためにも、１機能の実装にとどめておくべき</li></ul></li></ul><h4 id="10-2-6-ジョブ実行部分の実装"><a href="#10-2-6-ジョブ実行部分の実装" class="headerlink" title="10.2.6 ジョブ実行部分の実装"></a>10.2.6 ジョブ実行部分の実装</h4><ul><li><p>JobInstanceとJobExecution</p><ul><li>最初にジョブを実行すると、コンテナ内部ではこの２つのインスタンスが生成ｓ荒れる<ul><li>JobInstanceはジョブの１回分を表現</li><li>JobExecutionはジョブの実行そのものを表現している</li></ul></li></ul></li><li><p>パッケージング</p><ul><li>jBatchでもWebアプリケーションと同様に、構成するファイル群をwarファイル形式にまとめてコンテナにデプロイ刷る</li><li>ここで注意が必要なのは、JobXMLファイルの配置場所<ul><li>JobXMLは、warファイル内部の<code>WEB-INF/classes/META-INF/batch-jobs</code>ディレクトリの配下に「ジョブ名.xml」という名前で配置しなければ行けない</li></ul></li></ul></li><li><p>MEMO: パッケージングする際には一般的にどのようにしているか確認、Gradleとかの前処理で調整している？</p></li></ul><h4 id="10-2-7-実行結果の確認"><a href="#10-2-7-実行結果の確認" class="headerlink" title="10.2.7 実行結果の確認"></a>10.2.7 実行結果の確認</h4><p>バッチログを掲載</p><h3 id="10-3-jBatchの利用――応用編"><a href="#10-3-jBatchの利用――応用編" class="headerlink" title="10.3 jBatchの利用――応用編"></a>10.3 jBatchの利用――応用編</h3><h4 id="10-3-1-サンプル概要"><a href="#10-3-1-サンプル概要" class="headerlink" title="10.3.1 サンプル概要"></a>10.3.1 サンプル概要</h4><ul><li>ナレッジ件数ランキング集計バッチ</li><li><p>コメント件数ランキング集計バッチ</p></li><li><p>Column キーブレイク処理について</p><ul><li>マスタ表から１件読み込み、トランザクション表を操作して処理するという一連の流れ</li><li>業務におけるバッチ処理では大変多く見られるパターンの１つ</li><li>jBatchのチャンク形式のステップは、このようなキーブレイク処理を念頭においたものと言えるので、本書でも取り上げた</li><li>MEMO: チャンク形式が業務で応用されている例を確認しておくべき<ul><li>SQL一本で済ませる場合が多いのでは？</li></ul></li></ul></li></ul><h3 id="10-4-ジョブの作成"><a href="#10-4-ジョブの作成" class="headerlink" title="10.4 ジョブの作成"></a>10.4 ジョブの作成</h3><h4 id="10-4-1-Job-XMLの実装"><a href="#10-4-1-Job-XMLの実装" class="headerlink" title="10.4.1 Job XMLの実装"></a>10.4.1 Job XMLの実装</h4><ul><li>property要素を利用する方法を記載<ul><li>感覚的にはmavenみたいな感じ</li></ul></li></ul><h4 id="10-4-2-チャンクの実装"><a href="#10-4-2-チャンクの実装" class="headerlink" title="10.4.2 チャンクの実装"></a>10.4.2 チャンクの実装</h4><p>※実際に実装刷る際に必要なった時に見返す</p><h3 id="10-5-ジョブのフロー制御"><a href="#10-5-ジョブのフロー制御" class="headerlink" title="10.5 ジョブのフロー制御"></a>10.5 ジョブのフロー制御</h3><p>※実際に実装刷る際に必要なった時に見返す</p><h3 id="10-6-まとめ"><a href="#10-6-まとめ" class="headerlink" title="10.6 まとめ"></a>10.6 まとめ</h3><ul><li>終了！</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-EE-7徹底入門-標準Javaフレームワークによる高信頼性Webシステムの構築&quot;&gt;&lt;a href=&quot;#Java-EE-7徹底入門-標準Javaフレームワークによる高信頼性Webシステムの構築&quot; class=&quot;headerlink&quot; title=&quot;Java
      
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="教科書" scheme="http://yoursite.com/tags/%E6%95%99%E7%A7%91%E6%9B%B8/"/>
    
  </entry>
  
  <entry>
    <title>Web製作者のためのSassの教科書</title>
    <link href="http://yoursite.com/CSS/2020-04_Web%E8%A3%BD%E4%BD%9C%E8%80%85%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AESass%E3%81%AE%E6%95%99%E7%A7%91%E6%9B%B8/"/>
    <id>http://yoursite.com/CSS/2020-04_Web製作者のためのSassの教科書/</id>
    <published>2020-04-08T15:00:00.000Z</published>
    <updated>2020-04-26T03:36:09.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Web製作者のためのSassの教科書"><a href="#Web製作者のためのSassの教科書" class="headerlink" title="Web製作者のためのSassの教科書"></a>Web製作者のためのSassの教科書</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">・Sassって聞いたことはあるけど、導入が面倒そう</span><br><span class="line">・Sassをはじめたいけど、あと一歩が踏み出せない</span><br><span class="line">・勉強コストとの天秤にかけて、Sassのメリットが見えない</span><br><span class="line">・周りでSassを使いはじめた人がいて、焦りを感じている</span><br><span class="line">・CSSを今よりも効率的に書きたいと思っている</span><br><span class="line"></span><br><span class="line">こうした方がSassを導入するきっかけとなり、</span><br><span class="line">ひと通りSassの機能を使いこなせるようになるのが本書の目標です。</span><br><span class="line"></span><br><span class="line">本書では、HTML+CSSの基本的な知識は必須ですが、</span><br><span class="line">Sassにまったく触れたことがない方も対象としています。</span><br><span class="line"></span><br><span class="line">CSSをHTMLの構造に合わせて入れ子で書いていく「ネスト」や</span><br><span class="line">便利な「変数」や「演算」などのSassの基本機能はもちろん、</span><br><span class="line"></span><br><span class="line">筆者が実際に仕事の現場で使っている実践的なテクニックから</span><br><span class="line">新機能もカバーした全機能リファレンスまで、この一冊で網羅しています。</span><br></pre></td></tr></table></figure><ul><li>発売日：2017/9/15</li><li>ページ数：296</li><li>サイズ：B5変形判</li><li>著者：平澤 隆（Latele）　著/森田 壮　著</li><li><p>ISBN：9784295002352</p></li><li><p>URL: <a href="https://book.impress.co.jp/books/1117101020" target="_blank" rel="noopener">https://book.impress.co.jp/books/1117101020</a></p></li><li><p>目次</p><ul><li>第1章 Sassのキホン</li><li>第2章 Sassの利用環境を整えよう</li><li>第3章 これだけはマスターしたいSassの基本機能</li><li>第4章 高度な機能を覚えてSassを使いこなそう</li><li>第5章 現場で使える実践Sassコーディング</li><li>第6章 もっとSassを便利にするフレームワークやツール</li><li>第7章 Sass全機能リファレンス</li></ul></li><li><p>公式サポートサイト：<a href="https://book2.scss.jp/" target="_blank" rel="noopener">https://book2.scss.jp/</a></p></li></ul><h2 id="第1章-Sassのキホン"><a href="#第1章-Sassのキホン" class="headerlink" title="第1章 Sassのキホン"></a>第1章 Sassのキホン</h2><h3 id="1-1-まずはSassって何なのかを知ろう"><a href="#1-1-まずはSassって何なのかを知ろう" class="headerlink" title="1-1 まずはSassって何なのかを知ろう"></a>1-1 まずはSassって何なのかを知ろう</h3><ul><li><p>Sassは学習コストもあるけれど、CSSを覚え始めた頃のワクワク感や楽しさを思い出させてくれるよっている説明</p></li><li><p>Sass＝CSSを拡張したメタ言語</p></li><li><p>Sass(Syntactically Awesome Strylesheets)</p></li><li><p>Sassには２つの記法がある</p><ul><li>SASS記法：CSSと互換性が無い。インデントの深さで分ける</li><li>SCSS記法：CSSと互換性がある。ネストで記載</li></ul></li><li><p>SCSSファイルはコンパイルが必要だよという説明</p></li><li><p>魅力的な機能</p><ul><li>記述の簡略化（<strong>ネスト</strong>）</li><li>コメントに、<code>//</code>が使える！</li><li><strong>変数定義</strong>で同じ値を使い回すことができる</li><li>１度使ったセレクタを使い回せる（<strong>エクステンド</strong>）</li><li>コードの再利用が可能<ul><li>スタイルをまとめてテンプレートやモジュールのように定義し、簡単に読み込んで使うことができる</li><li><strong>ミックスイン</strong>と呼ばれており、Sassの中でも最も強力な機能の１つ</li></ul></li><li>１つのCSSファイルにまとめることができる（<strong>パーシャル</strong>）</li><li>条件分岐などの<strong>プログラム的な処理</strong>ができる</li><li><strong>関数で様々な処理を実行</strong>できる<ul><li>Sassにはかなり多くの関数が用意されている</li></ul></li><li>CSSファイルを圧縮できる</li><li>他にも魅力が沢山</li></ul></li><li><p>Sassの歴史について説明（割愛）</p></li></ul><h3 id="1-2-Sassを導入する前の疑問や不安"><a href="#1-2-Sassを導入する前の疑問や不安" class="headerlink" title="1-2 Sassを導入する前の疑問や不安"></a>1-2 Sassを導入する前の疑問や不安</h3><ul><li>環境構築に黒い画面を操作することに対しての不安説明</li><li>運用時にSassは導入ハードルが高いのではという不安説明<ul><li>expandedというフォーマットがあり、これを指定してコンパイルすると、普通にCSS書いたみたいになる</li><li><code>//</code>コメントは削除されてしまう</li><li>なので納品後はCSS編集という運用でも問題ない</li></ul></li></ul><h3 id="1-3-何はともあれSassを触ってみよう"><a href="#1-3-何はともあれSassを触ってみよう" class="headerlink" title="1-3 何はともあれSassを触ってみよう"></a>1-3 何はともあれSassを触ってみよう</h3><ul><li><p>使ってみる</p><ul><li>「SassMeister」で検索</li><li><a href="https://www.sassmeister.com" target="_blank" rel="noopener">https://www.sassmeister.com</a></li></ul></li><li><p>meister = 師匠</p></li></ul><p>Sassを入力するとCSSが出力されるプレイグラウンド</p><ul><li>Sassに対応しているソースコード共有サービス<ul><li>CodePen</li><li>Create a new Fiddle - jsFiddle</li><li>jsdo.it Share Javascript, HTML5 and CSS</li><li>HTML5, CSS3, JS Demos, Creations and Experiments | CSSDeck</li></ul></li></ul><h2 id="第2章-Sassの利用環境を整えよう"><a href="#第2章-Sassの利用環境を整えよう" class="headerlink" title="第2章 Sassの利用環境を整えよう"></a>第2章 Sassの利用環境を整えよう</h2><h3 id="2-1-本書で使用する環境について"><a href="#2-1-本書で使用する環境について" class="headerlink" title="2-1 本書で使用する環境について"></a>2-1 本書で使用する環境について</h3><ul><li><p>本書では、node-sasssを使用する</p></li><li><p>Sassは大きく分けて２つのSassが存在する</p><ul><li>Ruby Sass：Rubyで開発されたもの</li><li>LibSass：C/C++で開発されたもの</li></ul></li><li><p>node-sass</p><ul><li>LibSassをNode.jsで動作できるようにしたライブラリ</li></ul></li><li><p>Node.jsについて：Javascriptで作られたサーバーサイド環境</p></li><li>Gulp: タスクランナー</li></ul><h3 id="2-2-Node-jsをインストールする"><a href="#2-2-Node-jsをインストールする" class="headerlink" title="2-2 Node.jsをインストールする"></a>2-2 Node.jsをインストールする</h3><ul><li>Webからインストールする手順を記載</li><li>バージョン管理ツールの説明<ul><li>Windowsならnodist</li><li>Macならndenv</li></ul></li></ul><h3 id="2-3-黒い画面を使ってみよう"><a href="#2-3-黒い画面を使ってみよう" class="headerlink" title="2-3 黒い画面を使ってみよう"></a>2-3 黒い画面を使ってみよう</h3><ul><li>コマンドプロンプトを開く手順を記載しているだけ（割愛）</li></ul><h3 id="2-4-セットアップ済みの環境をインストールする"><a href="#2-4-セットアップ済みの環境をインストールする" class="headerlink" title="2-4 セットアップ済みの環境をインストールする"></a>2-4 セットアップ済みの環境をインストールする</h3><ul><li><p>サンプルファイルコピー</p><ul><li><a href="https://book2.scss.jp/dl/c2/" target="_blank" rel="noopener">https://book2.scss.jp/dl/c2/</a></li></ul></li><li><p>gulp-cliをインストール</p><ul><li><code>npm install --global gulp-cli</code></li></ul></li><li><p>モジュールをインストールする</p><ul><li><code>npm install</code></li></ul></li></ul><h3 id="2-5-Sass-をコンパイルする"><a href="#2-5-Sass-をコンパイルする" class="headerlink" title="2-5 Sass をコンパイルする"></a>2-5 Sass をコンパイルする</h3><ul><li><p><code>gulpfile.js</code>に記載された処理を実行</p><ul><li><code>gulp sass</code></li></ul></li><li><p>アウトプットスタイルを指定</p><ul><li>Nested</li><li>Expanded</li><li>Compact</li><li>Compressed</li></ul></li><li><p>ファイルの更新を監視する</p><ul><li><code>gulp.watch(&#39;./sass/**/*.scss&#39;,[&#39;sass&#39;]);</code></li></ul></li></ul><h3 id="2-6-セットアップ済みの環境を作成する方法"><a href="#2-6-セットアップ済みの環境を作成する方法" class="headerlink" title="2-6 セットアップ済みの環境を作成する方法"></a>2-6 セットアップ済みの環境を作成する方法</h3><ul><li><p>npm と gulp の説明(割愛)</p></li><li><p>gulpfile.jsのジェネレータについて</p><ul><li><a href="https://steelydylan.github.io/gulp-generator/" target="_blank" rel="noopener">https://steelydylan.github.io/gulp-generator/</a></li></ul></li></ul><h3 id="2-7-GUIコンパイラ（Prepros）でSassを使う"><a href="#2-7-GUIコンパイラ（Prepros）でSassを使う" class="headerlink" title="2-7 GUIコンパイラ（Prepros）でSassを使う"></a>2-7 GUIコンパイラ（Prepros）でSassを使う</h3><ul><li><a href="https://prepros.io/" target="_blank" rel="noopener">https://prepros.io/</a></li><li>割愛する</li></ul><h3 id="2-8-DreamweaverでSassを使う"><a href="#2-8-DreamweaverでSassを使う" class="headerlink" title="2-8 DreamweaverでSassを使う"></a>2-8 DreamweaverでSassを使う</h3><ul><li>割愛する</li></ul><h2 id="第3章-これだけはマスターしたいSassの基本機能"><a href="#第3章-これだけはマスターしたいSassの基本機能" class="headerlink" title="第3章 これだけはマスターしたいSassの基本機能"></a>第3章 これだけはマスターしたいSassの基本機能</h2><h3 id="3-1-ルールのネスト（Nested-Rules）"><a href="#3-1-ルールのネスト（Nested-Rules）" class="headerlink" title="3-1 ルールのネスト（Nested Rules）"></a>3-1 ルールのネスト（Nested Rules）</h3><ul><li>ネストでCSS定義ができる</li><li>セレクタも使える</li><li>使いすぎるとインデントが深くなり可読性が悪くなる</li><li><code>@media</code>のネストもできる</li></ul><h3 id="3-2-親セレクタの参照-amp-（アンパサンド）"><a href="#3-2-親セレクタの参照-amp-（アンパサンド）" class="headerlink" title="3-2 親セレクタの参照&amp;（アンパサンド）"></a>3-2 親セレクタの参照&amp;（アンパサンド）</h3><ul><li><code>&amp;</code>を使えば親セレクタを参照できる</li><li>BEMやMindBEMingなどBEMの設計思想に近いCSS設計を行っている場合、記述量が大幅に削減される</li></ul><h3 id="3-3-プロパティのネスト（Nested-Properties）"><a href="#3-3-プロパティのネスト（Nested-Properties）" class="headerlink" title="3-3 プロパティのネスト（Nested Properties）"></a>3-3 プロパティのネスト（Nested Properties）</h3><ul><li>プロパティもネストさせてかけるよっていう説明</li><li>ショートハンドでかけるところをネストさせる</li><li>慣れないうちは可読性が下がる原因にもなるので、普通に書いたほうが無難</li><li>Column: -(ハイフン)があるプロパティはすべてネストできる</li></ul><h3 id="3-4-Sassで使えるコメント"><a href="#3-4-Sassで使えるコメント" class="headerlink" title="3-4 Sassで使えるコメント"></a>3-4 Sassで使えるコメント</h3><ul><li>javascriptのコメント<code>//</code>が使える</li><li>通常のCSSコメント <code>/* */</code> だとコンパイルされても残る</li><li>スタイルが「compressed」だとコメントは残らない<ul><li>「compressed」でも残るコメント<ul><li><code>/*! */</code> <code>!</code>を追加すれば残るらしい</li></ul></li></ul></li></ul><h3 id="3-5-変数（Variables）"><a href="#3-5-変数（Variables）" class="headerlink" title="3-5 変数（Variables）"></a>3-5 変数（Variables）</h3><ul><li>変数宣言ができる</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赤色の変数を宣言</span></span><br><span class="line"><span class="variable">$red</span>: <span class="number">#cf2d3a</span>;</span><br></pre></td></tr></table></figure><ul><li>変数名で使える文字と使えない文字</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$width10</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="variable">$w-10</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="variable">$w_10</span>: <span class="number">10px</span>;</span><br><span class="line">$Ｗｉｄｔｈ１０: <span class="number">10px</span>;</span><br><span class="line">$横幅10px: <span class="number">10px</span>;</span><br><span class="line">$１０px: <span class="number">10px</span>;</span><br><span class="line">$___w10___: <span class="number">10px</span>;</span><br><span class="line"><span class="variable">$-_-______----w</span>:<span class="number">10px</span>;</span><br><span class="line">$変数はSassの便利な機能の１つです:black;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使えない文字</span></span><br><span class="line">$10width: <span class="number">10px</span>; <span class="comment">// 数字から始まっている</span></span><br><span class="line">$@width10: 10px; <span class="comment">// @など使えない記号</span></span><br><span class="line"><span class="variable">$--width</span>: <span class="number">10px</span>; <span class="comment">// 連続したハイフンから始まっている</span></span><br></pre></td></tr></table></figure><ul><li><p>ルールセット内で変数を宣言することもできる</p></li><li><p>変数を参照できる場所</p><ul><li>セレクタから参照したり、他の文字列と結合してパスを作成したい場合などに気をつける必要あり</li></ul></li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$セレクタ名: <span class="string">'.pickupContentsArea, section.main'</span>;</span><br><span class="line"><span class="variable">$IMG_PATH</span>: <span class="string">'../img/bg/'</span>;</span><br><span class="line"></span><br><span class="line">#&#123;$セレクタ名&#125; &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: url(#&#123;<span class="variable">$IMG_PATH</span>&#125;pickup.png);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-演算"><a href="#3-6-演算" class="headerlink" title="3-6 演算"></a>3-6 演算</h3><ul><li><code>+ - * %</code>などの演算子が使える</li><li>コンパイル後は、演算結果が出力される</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// paddingの値が変わった時に変数として持っておくとwidthに反映できる</span></span><br><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">  <span class="variable">$padding</span>: <span class="number">7px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="variable">$main_width</span> - <span class="variable">$padding</span> * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>色の演算も算術演算子でできるが将来的には廃止予定らしい<ul><li><code>rgba()</code>を使おうとのこと</li></ul></li></ul><h3 id="3-7-Sassの-import"><a href="#3-7-Sassの-import" class="headerlink" title="3-7 Sassの@import"></a>3-7 Sassの@import</h3><ul><li><p>SassではCSSで使える<code>@import</code>の他に、Sass独自の<code>@import</code>機能がある</p></li><li><p>CSSファイルを生成しないパーシャル</p><ul><li>importしたSassファイルなど、特定のSassファイルをCSSファイルとして生成したくない場合、</li><li>Sassファイルのファイル名の最初に<code>_</code>アンダースコアをつけることで、コンパイルしてもCSSファイルが生成されなくなる</li><li>この機能のことをパーシャル(partial)という</li></ul></li></ul><h2 id="第4章-高度な機能を覚えてSassを使いこなそう"><a href="#第4章-高度な機能を覚えてSassを使いこなそう" class="headerlink" title="第4章 高度な機能を覚えてSassを使いこなそう"></a>第4章 高度な機能を覚えてSassを使いこなそう</h2><h3 id="4-1-スタイルの継承ができるエクステンド（-extend）"><a href="#4-1-スタイルの継承ができるエクステンド（-extend）" class="headerlink" title="4-1 スタイルの継承ができるエクステンド（@extend）"></a>4-1 スタイルの継承ができるエクステンド（@extend）</h3><ul><li><p>エクステンド＝指定したセレクタのスタイルを継承することができる機能</p></li><li><p>あまり継承しすぎると、プロパティがバッティングしてしまう可能性が高くなる</p></li><li><p>エクステンドの連鎖</p><ul><li>継承を連鎖して記載可能</li></ul></li><li><p>エクステンドが使えないセレクタの紹介</p><ul><li><code>.item p</code> 子孫セレクタ</li><li><code>#main &gt; article</code> 子セレクタ</li><li><code>h2 + h3</code> 隣接セレクタ</li><li><code>h3 ~ h3</code> 間接セレクタ</li></ul></li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子孫セレクタ</span></span><br><span class="line"><span class="selector-class">.item</span> <span class="selector-tag">p</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子セレクタ</span></span><br><span class="line"><span class="selector-id">#main</span> &gt; <span class="selector-tag">article</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隣接セレクタ</span></span><br><span class="line"><span class="selector-tag">h2</span> + <span class="selector-tag">h3</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 間接セレクタ</span></span><br><span class="line"><span class="selector-tag">h3</span> ~ <span class="selector-tag">h3</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><ul><li>エクステンド専用のプレースホルダーセレクタ</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// エクステンド専用のプレースホルダーセレクタ</span></span><br><span class="line">%boxBase &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#999</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// プレースホルダーセレクタを継承</span></span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    @<span class="keyword">extend</span> %boxBase;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">section</span> &#123;</span><br><span class="line">    @<span class="keyword">extend</span> %boxBase;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">60px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@media</code>内ではエクステンドは使用できない</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// これはコンパイルエラーになってしまう</span></span><br><span class="line">%btnBase &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#eee</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">media</span> all and (orientation:landscape) &#123;</span><br><span class="line">    <span class="selector-tag">a</span> &#123;</span><br><span class="line">        @<span class="keyword">extend</span> %btnBase;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// こちらに書き直すとうまくいく</span></span><br><span class="line">@<span class="keyword">media</span> all and (orientation:landscape) &#123;</span><br><span class="line">    %btnBase &#123;</span><br><span class="line">        <span class="attribute">display</span>: inline-block;</span><br><span class="line">        <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">10px</span>;</span><br><span class="line">        <span class="attribute">background</span>: <span class="number">#eee</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">a</span> &#123;</span><br><span class="line">        @<span class="keyword">extend</span> %btnBase;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>警告を抑止する <code>!optional</code>フラグ</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">    @<span class="keyword">extend</span> %btnBase !optional;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-柔軟なスタイルの定義が可能なミックスイン（-mixin）"><a href="#4-2-柔軟なスタイルの定義が可能なミックスイン（-mixin）" class="headerlink" title="4-2 柔軟なスタイルの定義が可能なミックスイン（@mixin）"></a>4-2 柔軟なスタイルの定義が可能なミックスイン（@mixin）</h3><ul><li>スタイルの集まりを定義しておき、それを他の場所で呼び出して使うことができる</li><li>また、引数を指定することで、定義したミックスインの値を一部変更して使うといった、非常に柔軟で強力な処理が可能</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ミックスインを定義</span></span><br><span class="line">@<span class="keyword">mixin</span> boxSet &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#999</span>;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定義したミックスインを呼び出し</span></span><br><span class="line"><span class="selector-class">.relatedArea</span> &#123;</span><br><span class="line">    @<span class="keyword">include</span> boxSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>エクステンドと違ってコンパイル後に、展開されて出力されることを確認</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定義したミックスインを呼び出し</span></span><br><span class="line"><span class="selector-class">.relatedArea</span> &#123;</span><br><span class="line">    @<span class="keyword">include</span> boxSet;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 別のルールセットでも呼び出し</span></span><br><span class="line"><span class="selector-class">.pickupArea</span> &#123;</span><br><span class="line">    @<span class="keyword">include</span> boxSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.relatedArea</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#999</span>;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.pickupArea</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#999</span>;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>引数を使ったミックスイン</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引数を使ったミックスインを定義</span></span><br><span class="line">@<span class="keyword">mixin</span> kadomaru(<span class="variable">$value</span>) &#123;</span><br><span class="line">    -moz-<span class="attribute">border-radius</span>: <span class="variable">$value</span>;</span><br><span class="line">    -webkit-<span class="attribute">border-radius</span>: <span class="variable">$value</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="variable">$value</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    @<span class="keyword">include</span> kadomaru(<span class="number">3px</span>);</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#eee</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#999</span>;</span><br><span class="line">    @<span class="keyword">include</span> kadomaru(<span class="number">5px</span> 10px);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可変でプロパティを定義できる</span></span><br></pre></td></tr></table></figure><ul><li>引数に初期値を設定することもできる</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> kadomaru(<span class="variable">$value</span>: 3px) &#123;</span><br><span class="line">    -moz-<span class="attribute">border-radius</span>: <span class="variable">$value</span>;</span><br><span class="line">    -webkit-<span class="attribute">border-radius</span>: <span class="variable">$value</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="variable">$value</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.boxA</span> &#123;</span><br><span class="line">    @<span class="keyword">include</span> kadomaru;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#eee</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.boxB</span> &#123;</span><br><span class="line">    @<span class="keyword">include</span> kadomaru();</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#f1f1f1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.boxA</span> &#123;</span><br><span class="line">  <span class="attribute">-moz-border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">  <span class="attribute">-webkit-border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#eee</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.boxB</span> &#123;</span><br><span class="line">  <span class="attribute">-moz-border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">  <span class="attribute">-webkit-border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f1f1f1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>引数を複数指定することもできる</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> boxBase(<span class="variable">$margin</span>: 30px 0, <span class="variable">$padding</span>: 10px) &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="variable">$margin</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="variable">$padding</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.boxA</span> &#123;</span><br><span class="line">    @<span class="keyword">include</span> boxBase;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#eee</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.boxB</span> &#123;</span><br><span class="line">    @<span class="keyword">include</span> boxBase(<span class="number">0</span> 0 50px, 20px);</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#f1f1f1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>,(カンマ)を使うプロパティには可変長引数を利用する</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> shadow(<span class="variable">$value</span>...) &#123;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="variable">$value</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">    @<span class="keyword">include</span> shadow(<span class="number">8px</span> 8px 0 <span class="number">#999</span>, 15px -10px 0 <span class="number">#eee</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>複数の引数があるミックスインを読み込む際に可変長引数を使う</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> boxBase(<span class="variable">$w</span>: 250px, <span class="variable">$pd</span>: 15px, <span class="variable">$bg_c</span>: <span class="number">#fff</span>, <span class="variable">$bd_c</span>: <span class="number">#ccc</span>) &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$w</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="variable">$pd</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="variable">$bg_c</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="variable">$bd_c</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$values</span>: <span class="number">300px</span>, <span class="number">20px</span>; <span class="comment">// こういう変数定義もできるんだと知った</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    @<span class="keyword">include</span> boxBase(<span class="variable">$values</span>...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ミックスインのスコープ（利用できる範囲）を制限する</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    @<span class="keyword">mixin</span> margin &#123;</span><br><span class="line">        <span class="attribute">margin</span>: <span class="number">50px</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.item</span> &#123;</span><br><span class="line">        @<span class="keyword">include</span> margin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// あまりスコープを制限する例は無いが一応覚えておく</span></span><br></pre></td></tr></table></figure><ul><li>ミックスインにコンテントブロックを渡す <code>@content</code><ul><li>→これは便利！</li></ul></li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> media(<span class="variable">$width-media</span>: 768px) &#123;</span><br><span class="line">    @<span class="keyword">media</span> only screen and (max-width: <span class="variable">$width-media</span>) &#123;</span><br><span class="line">        @<span class="keyword">content</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="selector-class">.image</span> &#123;</span><br><span class="line">        <span class="attribute">float</span>: left;</span><br><span class="line">        @<span class="keyword">include</span> media &#123;</span><br><span class="line">            <span class="attribute">float</span>: none;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.text</span> &#123;</span><br><span class="line">        <span class="attribute">overflow</span>: hidden;</span><br><span class="line">        <span class="attribute">margin-left</span>: <span class="number">15px</span>;</span><br><span class="line">        @<span class="keyword">include</span> media &#123;</span><br><span class="line">            <span class="attribute">margin-left</span>: <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> <span class="selector-class">.image</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">media</span> only screen and (max-width: <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.item</span> <span class="selector-class">.image</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item</span> <span class="selector-class">.text</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">media</span> only screen and (max-width: <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.item</span> <span class="selector-class">.text</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ミックスイン名で使える文字と使えない文字</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> shadow1 &#123; ～ &#125;</span><br><span class="line">@<span class="keyword">mixin</span> shadow-1 &#123; ～ &#125;</span><br><span class="line">@<span class="keyword">mixin</span> shadow_1 &#123; ～ &#125;</span><br><span class="line">@<span class="keyword">mixin</span> 影 &#123; ～ &#125;</span><br><span class="line">@<span class="keyword">mixin</span> ｓｈａｄｏw &#123; ～ &#125;</span><br><span class="line">@<span class="keyword">mixin</span> _shadow &#123; ～ &#125;</span><br><span class="line">@<span class="keyword">mixin</span> -shadow &#123; ～ &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使えない文字</span></span><br><span class="line">@<span class="keyword">mixin</span> 01shadow &#123; ～ &#125; <span class="comment">// 数字から始まっている</span></span><br><span class="line">@<span class="keyword">mixin</span> shadow@<span class="number">2</span> &#123; ～ &#125; <span class="comment">// @など使えない記号</span></span><br><span class="line">@<span class="keyword">mixin</span> --shadow &#123; ～ &#125; <span class="comment">// 連続したハイフンから始まっている</span></span><br></pre></td></tr></table></figure><h3 id="4-3-ネストしているセレクタをルートに戻せる-at-root"><a href="#4-3-ネストしているセレクタをルートに戻せる-at-root" class="headerlink" title="4-3 ネストしているセレクタをルートに戻せる @at-root"></a>4-3 ネストしているセレクタをルートに戻せる @at-root</h3><ul><li>あまり使い所が無いと感じたが、使える場面があるらしい</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.block</span> &#123;</span><br><span class="line">    <span class="selector-class">.element-A</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">80%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @at-root .element-B &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.block</span> <span class="selector-class">.element-A</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">80%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.element-B</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使い所は５章で確認する</li></ul><h3 id="4-4-Sassのデータタイプについて"><a href="#4-4-Sassのデータタイプについて" class="headerlink" title="4-4 Sassのデータタイプについて"></a>4-4 Sassのデータタイプについて</h3><ul><li>Sassのデータ・タイプについて</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.DataTypes</span> &#123;</span><br><span class="line">    <span class="comment">/* Number型 */</span></span><br><span class="line">    property: type-of(<span class="number">10%</span>);</span><br><span class="line">    <span class="comment">/* Color型 */</span></span><br><span class="line">    property: type-of(red);</span><br><span class="line">    <span class="comment">/* String型 */</span></span><br><span class="line">    property: type-of(sans-serif);</span><br><span class="line">    <span class="comment">/* Boolean型 */</span></span><br><span class="line">    property: type-of(true);</span><br><span class="line">    <span class="comment">/* Null型 */</span></span><br><span class="line">    property: type-of(null);</span><br><span class="line">    <span class="comment">/* List型 */</span></span><br><span class="line">    property: type-of(<span class="number">1.5em</span> <span class="number">1em</span> <span class="number">0</span> <span class="number">2em</span>);</span><br><span class="line">    <span class="comment">/* Map型 */</span></span><br><span class="line">    <span class="variable">$map</span>:(key1: value1, key2: value2);</span><br><span class="line">    property: type-of(<span class="variable">$map</span>);</span><br><span class="line">    <span class="comment">/* Function型 */</span></span><br><span class="line">    property: type-of(get-function(<span class="string">"lighten"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.DataTypes</span> &#123;</span><br><span class="line">  <span class="comment">/* Number型 */</span></span><br><span class="line">  <span class="attribute">property</span>: number;</span><br><span class="line">  <span class="comment">/* Color型 */</span></span><br><span class="line">  <span class="attribute">property</span>: color;</span><br><span class="line">  <span class="comment">/* String型 */</span></span><br><span class="line">  <span class="attribute">property</span>: string;</span><br><span class="line">  <span class="comment">/* Boolean型 */</span></span><br><span class="line">  <span class="attribute">property</span>: bool;</span><br><span class="line">  <span class="comment">/* Null型 */</span></span><br><span class="line">  <span class="attribute">property</span>: null;</span><br><span class="line">  <span class="comment">/* List型 */</span></span><br><span class="line">  <span class="attribute">property</span>: list;</span><br><span class="line">  <span class="comment">/* Map型 */</span></span><br><span class="line">  <span class="attribute">property</span>: map;</span><br><span class="line">  <span class="comment">/* Function型 */</span></span><br><span class="line">  <span class="attribute">property</span>: function;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@function example(<span class="variable">$value</span>) &#123;</span><br><span class="line">    @<span class="keyword">if</span> type-of(<span class="variable">$value</span>) == number &#123;</span><br><span class="line">        処理</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// typeで判断して関数を作れますよという説明</span></span><br></pre></td></tr></table></figure><h3 id="4-5-制御構文で条件分岐や繰り返し処理を行う"><a href="#4-5-制御構文で条件分岐や繰り返し処理を行う" class="headerlink" title="4-5 制御構文で条件分岐や繰り返し処理を行う"></a>4-5 制御構文で条件分岐や繰り返し処理を行う</h3><ul><li><code>@if</code>,<code>@for</code>,<code>@while</code>,<code>@each</code>を使って表現</li></ul><h3 id="4-6-関数を使ってさまざまな処理を実行する"><a href="#4-6-関数を使ってさまざまな処理を実行する" class="headerlink" title="4-6 関数を使ってさまざまな処理を実行する"></a>4-6 関数を使ってさまざまな処理を実行する</h3><ul><li>Sassには予め用意された関数がある</li><li><p>使用頻度の高いものをピックアップして紹介</p></li><li><p>参照 <a href="https://book2.scss.jp/code/c4/06.html" target="_blank" rel="noopener">https://book2.scss.jp/code/c4/06.html</a></p></li></ul><h3 id="4-7-自作関数を定義する-function"><a href="#4-7-自作関数を定義する-function" class="headerlink" title="4-7 自作関数を定義する@function"></a>4-7 自作関数を定義する@function</h3><ul><li>自作関数の定義方法 そんなに変わったことはしていない</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$width</span>: <span class="number">105px</span>;</span><br><span class="line">@function halfSize(<span class="variable">$value</span>:<span class="variable">$width</span>) &#123;</span><br><span class="line">    @return round(<span class="variable">$value</span> / 2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.boxA</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: halfSize();</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.boxB</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: halfSize(<span class="number">200px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-8-テストやデバックで使える-debug、-warn、-error"><a href="#4-8-テストやデバックで使える-debug、-warn、-error" class="headerlink" title="4-8 テストやデバックで使える@debug、@warn、@error"></a>4-8 テストやデバックで使える@debug、@warn、@error</h3><ul><li>変数のデバッグに使用できる機能もある</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">debug</span> 10em + 12em;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test.scss:1 DEBUG: 22em</span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WARNで警告</span></span><br><span class="line"><span class="variable">$value</span>: <span class="number">1000px</span>;</span><br><span class="line">@function warnTest()&#123;</span><br><span class="line">    @<span class="keyword">if</span> unitless(<span class="variable">$value</span>) &#123;</span><br><span class="line">        <span class="variable">$value</span>: <span class="variable">$value</span> + px;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="keyword">else</span> &#123;</span><br><span class="line">    @<span class="keyword">warn</span> <span class="string">"#&#123;$value&#125;は駄目！$valueに単位は入れないで！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @return <span class="variable">$value</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: warnTest();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ERROR で処理を中断</span></span><br><span class="line"><span class="variable">$value</span>: <span class="number">1000px</span>;</span><br><span class="line">@function errorTest()&#123;</span><br><span class="line">    @<span class="keyword">if</span> unitless(<span class="variable">$value</span>) &#123;</span><br><span class="line">        <span class="variable">$value</span>: <span class="variable">$value</span> + px;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="keyword">else</span> &#123;</span><br><span class="line">    @error <span class="string">"#&#123;$value&#125;は駄目！$valueに単位は入れないで！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @return <span class="variable">$value</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: errorTest();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-9-使いどころに合わせて補完（インターポレーション）してくれる"><a href="#4-9-使いどころに合わせて補完（インターポレーション）してくれる" class="headerlink" title="4-9 使いどころに合わせて補完（インターポレーション）してくれる#{}"></a>4-9 使いどころに合わせて補完（インターポレーション）してくれる#{}</h3><ul><li><p>インターポレーションとは</p><ul><li>変数が参照できない場所でも使うことができるようにする機能</li><li><code>#{}</code>←これ</li></ul></li><li><p>演算しないようにする</p><ul><li><code>font: #{$font-size}/#{$line-height}</code></li></ul></li><li><p>演算できない場所で演算する</p><ul><li><code>.mt#{$i * 5} {</code></li></ul></li></ul><h3 id="4-10-変数の振る舞いをコントロールする-default-と-global"><a href="#4-10-変数の振る舞いをコントロールする-default-と-global" class="headerlink" title="4-10 変数の振る舞いをコントロールする !default と !global"></a>4-10 変数の振る舞いをコントロールする !default と !global</h3><ul><li><p><code>!default</code>フラグ</p><ul><li>デフォルト値とは上書きされることを前提にした変数の初期値</li><li>このフラグを使用していると、先に宣言されている変数が優先される<ul><li>→ライブラリで使用しているの確認済み。よく使われる</li></ul></li></ul></li><li><p><code>!global</code>フラグ</p><ul><li>ローカル変数をグローバル変数にするフラグ</li><li>グローバル変数とはドキュメントルートで宣言した、どこからでも参照できる変数のこと</li><li>ネスト内からグローバル変数を上書きしたい場合や、ローカル変数をスコープ外から参照したい場合などに使用する</li></ul></li></ul><h2 id="第5章-現場で使える実践Sassテクニック"><a href="#第5章-現場で使える実践Sassテクニック" class="headerlink" title="第5章 現場で使える実践Sassテクニック"></a>第5章 現場で使える実践Sassテクニック</h2><h3 id="5-1-管理／運用・設計で使えるテクニック"><a href="#5-1-管理／運用・設計で使えるテクニック" class="headerlink" title="5-1 管理／運用・設計で使えるテクニック"></a>5-1 管理／運用・設計で使えるテクニック</h3><ul><li><p>ネストが深すぎると生じる問題を把握して、バランスを見ながら利用する</p></li><li><p>ネストが深すぎて可読性が落ちてしまう</p></li><li><p>セレクタが長くなってしまうことの弊害</p><ul><li>CSSが肥大化する</li></ul></li><li><p>Column: ネストは何階層までがよいか</p><ul><li>2～3階層程度にするのがよい</li><li>HTMLのツリー構造に沿った形でCSSを指定するストラクチャタイプの設計の場合は、</li><li>ある程度ネストを深くしたほうがよい</li></ul></li><li><p>CSSとは違うパーシャルによるSassファイルの分割</p><ul><li><code>_mixin.scss</code>など分けて作成して、<code>@import</code>でまとめる</li></ul></li><li><p>サイトの基本設定を変数にして一元管理する</p></li><li><p>複数人で制作する場合は各自のSassファイルを用意する</p><ul><li>Gitなどが汚れるのではとも感じる…</li></ul></li><li><p>コメントを活用してソースをわかりやすくする</p></li><li><p>大規模サイトで活用できる<code>@import</code>のネスト</p></li><li><p>&amp;(アンパサンド)を活用してBEM的な設計を快適に</p></li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.navigation</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    &amp;__item &#123;</span><br><span class="line">        <span class="attribute">color</span>: <span class="number">#666</span>;</span><br><span class="line">        &amp;_state_active &#123;</span><br><span class="line">            <span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@keyframes</code>をルールセット内に書いて関係性をわかりやすくする</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.example</span> &#123;</span><br><span class="line">    @keyframes anima-example &#123;</span><br><span class="line">        0% &#123;</span><br><span class="line">            <span class="attribute">transform</span>: translate(<span class="number">0%</span>, -<span class="number">100%</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        100% &#123;</span><br><span class="line">            <span class="attribute">transform</span>: translate(<span class="number">0%</span>, <span class="number">0%</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">animation</span>: anima-example <span class="number">0.9s</span> linear <span class="number">500ms</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@keyframes</code>はルートに書き出してくれる</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.example</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: anima-example <span class="number">0.9s</span> linear <span class="number">500ms</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">keyframes</span> anima-example &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(0%, -100%);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(0%, 0%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>EditorConfigとStylelintでコーディングルールを統一する</p><ul><li>EditorConfig：拡張機能を入れて、<code>.editorconfig</code>ファイルを作成</li><li>Stylelint：拡張機能を入れる<ul><li><code>npm install --global stylelint</code></li><li><code>.stylelintrc</code>という設定ファイルをおけばOK</li></ul></li></ul></li><li><p>Column: 他の人を思いやってSass設計をしよう</p><ul><li>本書のシリーズ「Web製作者のためのCSS設計の教科書」はFLOCSS（フロックス）を提唱しているらしい</li></ul></li></ul><h3 id="5-2-レイアウト・パーツで使えるテクニック"><a href="#5-2-レイアウト・パーツで使えるテクニック" class="headerlink" title="5-2 レイアウト・パーツで使えるテクニック"></a>5-2 レイアウト・パーツで使えるテクニック</h3><ul><li>clearfixをミックスインで活用する</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> clearfix &#123;</span><br><span class="line">    &amp;::after &#123;</span><br><span class="line">        <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">        <span class="attribute">display</span>: block;</span><br><span class="line">        <span class="attribute">clear</span>: both;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// include</span></span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  @<span class="keyword">include</span> .clearfix;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#eee</span>;</span><br><span class="line">  <span class="selector-class">.image</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.text</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>変数を使って、サイドバーの幅を自動的に計算する</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全体の幅</span></span><br><span class="line"><span class="variable">$wrap-width</span>: <span class="number">960px</span>;</span><br><span class="line"><span class="comment">// メインエリアの幅</span></span><br><span class="line"><span class="variable">$main-width</span>: <span class="number">640px</span>;</span><br><span class="line"><span class="comment">// サイドバーの幅</span></span><br><span class="line"><span class="variable">$side_width</span>: <span class="variable">$wrap_width</span> - <span class="variable">$main_width</span> - <span class="number">20</span>;</span><br><span class="line"><span class="selector-id">#contents</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$wrap_width</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$main_width</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#side</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$side_width</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>nullで簡単に条件分岐してレイアウトする</p><ul><li>nullを指定するとコンパイルした時にプロパティごと生成されない</li></ul></li><li><p>calc と Sass を組み合わせて四則演算を便利に使う</p><ul><li>calcと組み合わせる際の注意点について</li></ul></li><li><p><code>@for</code>を使って余白調整用のclassを生成する</p></li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$spaceClass</span>: true !default;</span><br><span class="line"><span class="variable">$spacePadding</span>: false !default;</span><br><span class="line"><span class="variable">$endValue</span>: <span class="number">10</span> !default;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">if</span> <span class="variable">$spaceClass</span> &#123;</span><br><span class="line">    @<span class="keyword">for</span> <span class="variable">$i</span> from 0 through <span class="variable">$space_endValue</span> &#123;</span><br><span class="line">        <span class="selector-class">.mt</span>#&#123;<span class="variable">$i</span> * 5&#125; &#123;</span><br><span class="line">            <span class="attribute">margin-top</span>: <span class="number">5px</span> * <span class="variable">$i</span> <span class="meta">!important</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-class">.mb</span>#&#123;<span class="variable">$i</span> * 5&#125; &#123;</span><br><span class="line">            <span class="attribute">margin-bottom</span>: <span class="number">5px</span> * <span class="variable">$i</span> <span class="meta">!important</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        @<span class="keyword">if</span> <span class="variable">$spacePadding</span> &#123;</span><br><span class="line">            <span class="selector-class">.pt</span>#&#123;<span class="variable">$i</span> * 5&#125; &#123;</span><br><span class="line">                <span class="attribute">padding-top</span>: <span class="number">5px</span> * <span class="variable">$i</span> <span class="meta">!important</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="selector-class">.pb</span>#&#123;<span class="variable">$i</span> * 5&#125; &#123;</span><br><span class="line">                <span class="attribute">padding-bottom</span>: <span class="number">5px</span> * <span class="variable">$i</span> <span class="meta">!important</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.mt0</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">0px</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.mb0</span> &#123;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">0px</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.mt5</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">5px</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.mb5</span> &#123;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">5px</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line">...（略）...</span><br><span class="line"><span class="selector-class">.mt50</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">50px</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.mb50</span> &#123;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">50px</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line">// あまり作成しすぎるとCSSコード量も増えるので程々に</span><br></pre></td></tr></table></figure><ul><li>リストマーカー用の連番を使った class名 を作成する</li><li><p>連番を使ったclass名のゼロパディング（0埋め）をする</p></li><li><p>文字リンクカラーのミックスインを作る</p></li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> link-color2(<span class="variable">$n</span>) &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$n</span>;</span><br><span class="line">    &amp;:hover &#123;</span><br><span class="line">        <span class="attribute">color</span>: lighten(<span class="variable">$n</span>, <span class="number">30%</span>);</span><br><span class="line">        <span class="attribute">text-decoration</span>: none;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  @<span class="keyword">include</span> link-color2(<span class="number">#f00</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>複数の値を<code>@each</code>でループし、ページによって背景を変更する</li><li>シンプルなグラデーションのミックスインを作る</li><li><p>Map型と<code>@each</code>を使ってSNSアイコンを管理する</p></li><li><p>値が比較しづらい <code>z-index</code> をMap型で一括管理する</p></li><li><p>メディアクエリ用のミックスインを作成して楽々レスポンシブ対応</p></li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$breakpoints</span>: (</span><br><span class="line">    xs: <span class="string">"only screen and (max-width: 320px)"</span>,</span><br><span class="line">    s: <span class="string">"only screen and (max-width: 575px)"</span>,</span><br><span class="line">    m: <span class="string">"only screen and (max-width: 767px)"</span>,</span><br><span class="line">    l: <span class="string">"only screen and (max-width: 991px)"</span>,</span><br><span class="line">    xl: <span class="string">"only screen and (max-width: 1199px)"</span>,</span><br><span class="line">);</span><br><span class="line">@<span class="keyword">mixin</span> media(<span class="variable">$breakpoint</span>) &#123;</span><br><span class="line">    @<span class="keyword">media</span> #&#123;<span class="selector-tag">map</span>-get(<span class="variable">$breakpoints</span>, <span class="variable">$breakpoint</span>)&#125; &#123;</span><br><span class="line">        @<span class="keyword">content</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: white;</span><br><span class="line">    @<span class="keyword">include</span> media(l) &#123;</span><br><span class="line">        <span class="attribute">background-color</span>: blue;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="keyword">include</span> media(m) &#123;</span><br><span class="line">        <span class="attribute">background-color</span>: green;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="keyword">include</span> media(xs) &#123;</span><br><span class="line">        <span class="attribute">background-color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-スマホ・マルチデバイス、ブラウザで使えるテクニック"><a href="#5-3-スマホ・マルチデバイス、ブラウザで使えるテクニック" class="headerlink" title="5-3 スマホ・マルチデバイス、ブラウザで使えるテクニック"></a>5-3 スマホ・マルチデバイス、ブラウザで使えるテクニック</h3><h3 id="5-4-gulpのタスクを追加してもっと便利な環境にする"><a href="#5-4-gulpのタスクを追加してもっと便利な環境にする" class="headerlink" title="5-4 gulpのタスクを追加してもっと便利な環境にする"></a>5-4 gulpのタスクを追加してもっと便利な環境にする</h3><ul><li>パーシャルファイルを一括で読み込む</li><li>ソースマップでコンパイル前のソース場所を知る</li><li>エラー時にWatchを停止させずに、自動コンパイルを継続させる</li><li>エラーに気づきやすくするために通知を出す</li></ul><h3 id="5-5-PostCSSでSassをさらに便利にする"><a href="#5-5-PostCSSでSassをさらに便利にする" class="headerlink" title="5-5 PostCSSでSassをさらに便利にする"></a>5-5 PostCSSでSassをさらに便利にする</h3><ul><li><p>PostCSSとは</p><ul><li>Node.js製のCSSの変換ツール</li></ul></li><li><p>ベンダープレフィックスを自動付与する</p><ul><li>対象ブラウザを確認するには<ul><li><a href="https://browserl.ist/" target="_blank" rel="noopener">https://browserl.ist/</a></li></ul></li></ul></li><li><p>画像名だけで画像のパスやサイズを取得する</p></li><li><p>CSSプロパティの記述順を自動でソートする</p><ul><li>並び替えオーダーの種類<ul><li>alphabetically</li><li>smacss</li><li>concentric-css</li></ul></li></ul></li><li><p>バラバラになったメディアクエリをまとめてコード量を削減してスッキリさせる</p></li></ul><h2 id="第6章-もっとSassを便利にするフレームワークやツール"><a href="#第6章-もっとSassを便利にするフレームワークやツール" class="headerlink" title="第6章 もっとSassを便利にするフレームワークやツール"></a>第6章 もっとSassを便利にするフレームワークやツール</h2><h3 id="6-1-Sassのフレームワーク紹介"><a href="#6-1-Sassのフレームワーク紹介" class="headerlink" title="6-1 Sassのフレームワーク紹介"></a>6-1 Sassのフレームワーク紹介</h3><h3 id="6-2-SassのGUIコンパイラ"><a href="#6-2-SassのGUIコンパイラ" class="headerlink" title="6-2 SassのGUIコンパイラ"></a>6-2 SassのGUIコンパイラ</h3><h2 id="第7章-Sass全機能リファレンス"><a href="#第7章-Sass全機能リファレンス" class="headerlink" title="第7章 Sass全機能リファレンス"></a>第7章 Sass全機能リファレンス</h2><h3 id="7-1-Sassの基本と高度な機能"><a href="#7-1-Sassの基本と高度な機能" class="headerlink" title="7-1 Sassの基本と高度な機能"></a>7-1 Sassの基本と高度な機能</h3><h3 id="7-2-Sassの関数一覧"><a href="#7-2-Sassの関数一覧" class="headerlink" title="7-2 Sassの関数一覧"></a>7-2 Sassの関数一覧</h3><h3 id="7-3-Sassの拡張"><a href="#7-3-Sassの拡張" class="headerlink" title="7-3 Sassの拡張"></a>7-3 Sassの拡張</h3><h2 id="付録"><a href="#付録" class="headerlink" title="付録"></a>付録</h2><h2 id="コマンド一覧"><a href="#コマンド一覧" class="headerlink" title="コマンド一覧"></a>コマンド一覧</h2><h2 id="用語集"><a href="#用語集" class="headerlink" title="用語集"></a>用語集</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Web製作者のためのSassの教科書&quot;&gt;&lt;a href=&quot;#Web製作者のためのSassの教科書&quot; class=&quot;headerlink&quot; title=&quot;Web製作者のためのSassの教科書&quot;&gt;&lt;/a&gt;Web製作者のためのSassの教科書&lt;/h1&gt;&lt;figure c
      
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="教科書" scheme="http://yoursite.com/tags/%E6%95%99%E7%A7%91%E6%9B%B8/"/>
    
  </entry>
  
  <entry>
    <title>１分で話せ</title>
    <link href="http://yoursite.com/EX/2020-03_%EF%BC%91%E5%88%86%E3%81%A7%E8%A9%B1%E3%81%9B/"/>
    <id>http://yoursite.com/EX/2020-03_１分で話せ/</id>
    <published>2020-02-29T15:00:00.000Z</published>
    <updated>2020-04-26T03:36:09.875Z</updated>
    
    <content type="html"><![CDATA[<h1 id="１分で話せ"><a href="#１分で話せ" class="headerlink" title="１分で話せ"></a>１分で話せ</h1><ul><li>立ち読みレベル</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">プレゼンのゴールを設定する</span><br><span class="line">相手に動いて欲しいのか？</span><br><span class="line">相手に賛成、許可をして欲しいのか</span><br><span class="line">意見が欲しいのか、教えて欲しいのか</span><br><span class="line"></span><br><span class="line">ロジカルな１分ストーリーを考える</span><br><span class="line">主張　結論がある</span><br><span class="line">複数の根拠がある　意味が結論に通じている</span><br><span class="line"></span><br><span class="line">根拠は３つ必要</span><br><span class="line">あのお店美味しいから行こう！</span><br><span class="line">じゃあ、美味しいお店は他にもあるよ、、</span><br><span class="line">あのお店美味しくて、安くて、雰囲気いいから行こう！</span><br><span class="line">そこまでいうなら行ってみようか！</span><br><span class="line"></span><br><span class="line">より聞き手に伝わるように削った文章を話す</span><br><span class="line">基本的に、は、例外を離さないならいらない</span><br><span class="line">念頭に、は、~すべく</span><br><span class="line">横文字は伝わりやすいか考える</span><br><span class="line">先ほど述べたように、も、いらない</span><br><span class="line"></span><br><span class="line">頑張ったことは話すな</span><br><span class="line">結論だけ話すこと！</span><br><span class="line"></span><br><span class="line">聞き手の数や会議室の広さを考えて</span><br><span class="line">パワポの文字サイズを考える</span><br><span class="line">1番後ろの席の人が見えるように</span><br><span class="line"></span><br><span class="line">聞き手が行動するもう一歩をイメージさせる</span><br><span class="line">ポイントについての深掘りをするために</span><br><span class="line">たとえば、具体的に、などで繋げて話す</span><br><span class="line"></span><br><span class="line">人は80%のことを聞いていない</span><br><span class="line">キチリクルンの例</span><br><span class="line">私という人間はどういう人間かを伝えることが大事</span><br><span class="line">覚えてもらうことが大事</span><br><span class="line">会社の上司に説明してもらうことが大事</span><br><span class="line">そのためには短い言葉で印象に残らせる必要がある</span><br><span class="line"></span><br><span class="line">人前で話すときの4つのポイント</span><br><span class="line">視線　しっかり相手を見る</span><br><span class="line">手振り　多少、動きをつける</span><br><span class="line">声　相手と対話するように声を届ける</span><br><span class="line">間合い　話の区切りで普段より3秒ほど長く間をとってみる</span><br><span class="line"></span><br><span class="line">メタ認知は優秀なビジネスパーソンに共通するスキル</span><br><span class="line"></span><br><span class="line">■人から話しかけられた時</span><br><span class="line">◯状況判断</span><br><span class="line">・目的は何なのか（連絡されるのか、相談されるのか、何かしてほしいのか）</span><br><span class="line">・相手の目的を満たす回答をする</span><br><span class="line">・この話はどれくらいかかるのかを考える（場合によっては後に回してもらう）</span><br><span class="line"></span><br><span class="line">■人に話しかける時</span><br><span class="line">◯目的別</span><br><span class="line">・報告、連絡</span><br><span class="line">・相談、解決策やアドバイスが欲しい</span><br><span class="line">・依頼、何かをして欲しい</span><br><span class="line">・説得、自分はこう思う、理由はこうです</span><br><span class="line">・雑談</span><br><span class="line">◯ジェスチャー、振る舞い</span><br><span class="line">・視線 しっかり相手の目を見る</span><br><span class="line">・手振り 多少動きをつける</span><br><span class="line">・声 相手に声を確実に届ける、聞こえているか、理解しているかを確認しないままだらだら話さない</span><br><span class="line">・間合い 話の区切りで3秒ほど長く間をとる</span><br><span class="line">◯構成</span><br><span class="line">・結論ファースト</span><br><span class="line">・要点をまとめておく</span><br><span class="line">◯振り返り</span><br><span class="line">・メタ認知</span><br><span class="line">・反省</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;１分で話せ&quot;&gt;&lt;a href=&quot;#１分で話せ&quot; class=&quot;headerlink&quot; title=&quot;１分で話せ&quot;&gt;&lt;/a&gt;１分で話せ&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;立ち読みレベル&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="EX" scheme="http://yoursite.com/categories/EX/"/>
    
    
      <category term="教科書" scheme="http://yoursite.com/tags/%E6%95%99%E7%A7%91%E6%9B%B8/"/>
    
  </entry>
  
  <entry>
    <title>AngularWebアプリ開発スタートブック</title>
    <link href="http://yoursite.com/EX/2020-02_Angular%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0/"/>
    <id>http://yoursite.com/EX/2020-02_Angularアプリケーションプログラミング/</id>
    <published>2020-02-14T15:00:00.000Z</published>
    <updated>2020-02-24T12:31:34.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Angularアプリケーションプログラミング"><a href="#Angularアプリケーションプログラミング" class="headerlink" title="Angularアプリケーションプログラミング"></a>Angularアプリケーションプログラミング</h1><ul><li><p>電子書籍購入</p></li><li><p>説明書</p></li><li><p><a href="/pdf/Angularアプリケーションプログラミング.pdf">学習ログ</a></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">こちらの書籍は 2019/06/19 紙版の3刷に対応するため更新をおこないました。</span><br><span class="line">（概要）</span><br><span class="line">本書は，JavaScriptの定番SPA開発フレームワーク「Angular」の解説書です。データバインディング，コンポーネント，依存性注入といったAngularを理解するための基本要素をはじめ，ディレクティブ／パイプ，フォーム，ルーティング，モジュール／コンポーネントの技術解説，ディレクティブ／パイプ／サービスの自作やテストなどの応用的なテーマまでを網羅。また，Angular 4に対応し，5以降のアップグレードにも留意した解説を行っています。Angularによる動的Webアプリケーション開発に必要となる知識が，この1冊で身に付きます！</span><br><span class="line"></span><br><span class="line">（こんな方におすすめ）</span><br><span class="line">・Angularを利用したSPAアプリケーション開発に興味のある人</span><br><span class="line"></span><br><span class="line">（目次）</span><br><span class="line">導入編</span><br><span class="line">第1章イントロダクション</span><br><span class="line"></span><br><span class="line">第2章Angular の基本</span><br><span class="line"></span><br><span class="line">第3章データバインディング</span><br><span class="line"></span><br><span class="line">基本編</span><br><span class="line">第4章標準パイプ／ディレクティブ</span><br><span class="line"></span><br><span class="line">第5章フォーム開発</span><br><span class="line"></span><br><span class="line">第6章コンポーネント開発</span><br><span class="line"></span><br><span class="line">第7章サービス開発</span><br><span class="line"></span><br><span class="line">応用編</span><br><span class="line">第8章ルーティング</span><br><span class="line"></span><br><span class="line">第9章パイプ／ディレクティブの自作</span><br><span class="line"></span><br><span class="line">第10章テスト</span><br><span class="line"></span><br><span class="line">第11章関連ライブラリ／ツール</span><br><span class="line"></span><br><span class="line">AppendixTypeScript簡易リファレンス</span><br><span class="line"></span><br><span class="line">フォーマット： Kindle版</span><br><span class="line">ファイルサイズ： 56752 KB</span><br><span class="line">推定ページ数： 838 ページ</span><br><span class="line">出版社: 技術評論社 (2017/8/4)</span><br><span class="line">販売： Amazon Services International, Inc.</span><br><span class="line">言語: 日本語</span><br><span class="line">ASIN: B074M54GM5</span><br><span class="line">Text-to-Speech（テキスト読み上げ機能）: 有効 </span><br><span class="line">X-Ray:</span><br><span class="line">有効</span><br><span class="line">Word Wise: 有効にされていません</span><br><span class="line">カスタマーレビュー: 5つ星のうち 4.7   14件のカスタマーレビュー</span><br><span class="line">Amazon 売れ筋ランキング: Kindleストア 有料タイトル - 21,411位 (Kindleストア 有料タイトルの売れ筋ランキングを見る)</span><br><span class="line">1165位 ─ 工学 (Kindleストア)</span><br></pre></td></tr></table></figure><ul><li>書籍情報ページ<a href="https://wings.msn.to/index.php/-/A-03/978-4-7741-9130-0/" target="_blank" rel="noopener">https://wings.msn.to/index.php/-/A-03/978-4-7741-9130-0/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Angularアプリケーションプログラミング&quot;&gt;&lt;a href=&quot;#Angularアプリケーションプログラミング&quot; class=&quot;headerlink&quot; title=&quot;Angularアプリケーションプログラミング&quot;&gt;&lt;/a&gt;Angularアプリケーションプログラミ
      
    
    </summary>
    
      <category term="EX" scheme="http://yoursite.com/categories/EX/"/>
    
    
      <category term="教科書" scheme="http://yoursite.com/tags/%E6%95%99%E7%A7%91%E6%9B%B8/"/>
    
  </entry>
  
  <entry>
    <title>AngularWebアプリ開発スタートブック</title>
    <link href="http://yoursite.com/EX/2019-12_AngularWeb%E3%82%A2%E3%83%97%E3%83%AA%E9%96%8B%E7%99%BA%E3%82%B9%E3%82%BF%E3%83%BC%E3%83%88%E3%83%96%E3%83%83%E3%82%AF/"/>
    <id>http://yoursite.com/EX/2019-12_AngularWebアプリ開発スタートブック/</id>
    <published>2019-12-28T15:00:00.000Z</published>
    <updated>2020-02-24T12:29:25.706Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AngularWebアプリ開発スタートブック"><a href="#AngularWebアプリ開発スタートブック" class="headerlink" title="AngularWebアプリ開発スタートブック"></a>AngularWebアプリ開発スタートブック</h1><ul><li><p>電子書籍購入</p></li><li><p><a href="/pdf/AngularWebアプリ開発スタートブック.pdf">学習ログ</a></p></li></ul><h2 id="書籍情報"><a href="#書籍情報" class="headerlink" title="書籍情報"></a>書籍情報</h2><ul><li>著者<ul><li>大澤 文孝</li></ul></li><li>出版社<ul><li>ソーテック社; B5変形版 (2018/4/7)</li></ul></li><li>定価<ul><li>3,025円</li></ul></li><li>発売日<ul><li>2018/4/7</li></ul></li><li>ISBN-13<ul><li>978-4-8026-1185-5</li></ul></li><li><p>ISBN-10</p><ul><li>4800711975</li></ul></li><li><p>目次</p><ul><li>Chapter1 Angularって何?</li><li>Chapter2 開発環境を整えよう</li><li>Chapter3 Angularプロジェクトを作ろう</li><li>Chapter4 Angularの基本</li><li>Chapter5 入力フォームを作ってみよう</li><li>Chapter6 入力エラーを検知するバリデータ</li><li>Chapter7 リアクティブフォーム入門</li><li>Chapter8 さまざまな入力コントロール</li><li>Chapter9 ページの割り当てと遷移</li><li>Chapter10 検索機能を実装する</li><li>Chapter11 Webサーバで動かす</li></ul></li><li><p>サンプルプログラム</p><ul><li><a href="http://www.sotechsha.co.jp/sp/1197/" target="_blank" rel="noopener">http://www.sotechsha.co.jp/sp/1197/</a></li></ul></li><li><p>こんな方に</p><ul><li>○「将来、Webアプリ開発に取り組みたい」</li><li>○「Angular特有の機能について学びたい」</li><li>○「TypeScriptの作法について学びたい」</li><li>○「新しいフレームワークの作法をざっと知りたい」</li></ul></li><li><p>はじめに</p><ul><li>次の２点を重点的に解説<ul><li>Angularの動作の仕組み</li><li>何をどのような書式で記述しなければならないのか</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;AngularWebアプリ開発スタートブック&quot;&gt;&lt;a href=&quot;#AngularWebアプリ開発スタートブック&quot; class=&quot;headerlink&quot; title=&quot;AngularWebアプリ開発スタートブック&quot;&gt;&lt;/a&gt;AngularWebアプリ開発スタートブ
      
    
    </summary>
    
      <category term="EX" scheme="http://yoursite.com/categories/EX/"/>
    
    
      <category term="教科書" scheme="http://yoursite.com/tags/%E6%95%99%E7%A7%91%E6%9B%B8/"/>
    
  </entry>
  
  <entry>
    <title>コンサル一年目が学ぶこと</title>
    <link href="http://yoursite.com/EX/2019_11_%E3%82%B3%E3%83%B3%E3%82%B5%E3%83%AB%E4%B8%80%E5%B9%B4%E7%9B%AE%E3%81%8C%E5%AD%A6%E3%81%B6%E3%81%93%E3%81%A8/"/>
    <id>http://yoursite.com/EX/2019_11_コンサル一年目が学ぶこと/</id>
    <published>2019-11-02T15:00:00.000Z</published>
    <updated>2020-02-24T12:12:16.697Z</updated>
    
    <content type="html"><![CDATA[<h1 id="コンサル一年目が学ぶこと"><a href="#コンサル一年目が学ぶこと" class="headerlink" title="コンサル一年目が学ぶこと"></a>コンサル一年目が学ぶこと</h1><div style="text-align:center; margin-bottom: 40px"><br><img src="/img/cover/2019_11_consone.jpg" alt="2019_11_consone" title="2019_11_consone" style="width:980px"><br></div><ul><li><a href="/pdf/コンサル一年目が学ぶこと.pdf">学習ログ</a></li></ul><h2 id="学んだこと"><a href="#学んだこと" class="headerlink" title="学んだこと"></a>学んだこと</h2><ul><li>結論ファースト、PREP法で話す、言い訳から取り繕った話し方をしない（Talk Straight）</li><li>出来ないときは出来る方法を提案することが大事（何があればできるのか、何人いればできるのか、いつまでならできるのか）</li><li>相手の期待値を把握することの重要性</li><li>数値を用いて説明する</li><li>考えてから仕事を進める（道筋決めてから）</li><li>ロジックツリーを使いこなす（ケース問題の紐解き方法と同じだと感じた）</li><li>「雲雨傘」提案法 事実、解釈、アクションの区別をつける</li><li>議事録のエッセンス（日時・場所・参加者・アジェンダ・決まったこと・決まらなかったこと・確認が必要な事・次回TODO・キーパーソンの意見）</li><li>説明資料はワンスライド・ワンメッセージの構成にすること</li><li>余計なことをやらない・価値のあることだけする</li><li>しゃべらないなら会議に出るな</li><li>コミットメント力の高い人の傍にいること</li><li>フォロワーシップは部下としてのリーダーシップ</li></ul><h2 id="手に取った理由"><a href="#手に取った理由" class="headerlink" title="手に取った理由"></a>手に取った理由</h2><ul><li>コンサルタントとしての考え方の基礎的な要素が知りたかった</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;コンサル一年目が学ぶこと&quot;&gt;&lt;a href=&quot;#コンサル一年目が学ぶこと&quot; class=&quot;headerlink&quot; title=&quot;コンサル一年目が学ぶこと&quot;&gt;&lt;/a&gt;コンサル一年目が学ぶこと&lt;/h1&gt;&lt;div style=&quot;text-align:center; ma
      
    
    </summary>
    
      <category term="EX" scheme="http://yoursite.com/categories/EX/"/>
    
    
      <category term="教科書" scheme="http://yoursite.com/tags/%E6%95%99%E7%A7%91%E6%9B%B8/"/>
    
  </entry>
  
  <entry>
    <title>Github実践入門</title>
    <link href="http://yoursite.com/EX/2019_03_Github%E5%AE%9F%E8%B7%B5%E5%85%A5%E9%96%80/"/>
    <id>http://yoursite.com/EX/2019_03_Github実践入門/</id>
    <published>2019-02-28T15:00:00.000Z</published>
    <updated>2019-08-05T15:15:35.106Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Github実践入門"><a href="#Github実践入門" class="headerlink" title="Github実践入門"></a>Github実践入門</h1><div style="text-align:center; margin-bottom: 40px"><br><img src="/img/cover/2019_03_github.jpg" alt="2019_03_github" title="2019_03_github" style="width:980px"><br></div><h2 id="学んだこと"><a href="#学んだこと" class="headerlink" title="学んだこと"></a>学んだこと</h2><ul><li>そもそも「Githubとは」という部分</li><li>Githubの基本的な使い方を手を動かしながら確認できた</li><li>途中、UIがそもそも変わっており、情報として古さを感じたため、さっと確認で済ませている</li></ul><h2 id="手に取った理由"><a href="#手に取った理由" class="headerlink" title="手に取った理由"></a>手に取った理由</h2><ul><li>業務でGitの構成管理方針を決定する立場となったため、今一度基礎から情報を取得する必要があると考えたため</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Github実践入門&quot;&gt;&lt;a href=&quot;#Github実践入門&quot; class=&quot;headerlink&quot; title=&quot;Github実践入門&quot;&gt;&lt;/a&gt;Github実践入門&lt;/h1&gt;&lt;div style=&quot;text-align:center; margin-bot
      
    
    </summary>
    
      <category term="EX" scheme="http://yoursite.com/categories/EX/"/>
    
    
      <category term="教科書" scheme="http://yoursite.com/tags/%E6%95%99%E7%A7%91%E6%9B%B8/"/>
    
  </entry>
  
  <entry>
    <title>Azure実践ガイド</title>
    <link href="http://yoursite.com/Azure/2019_03_Azure%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/"/>
    <id>http://yoursite.com/Azure/2019_03_Azure実践ガイド/</id>
    <published>2019-02-28T15:00:00.000Z</published>
    <updated>2019-07-21T16:44:04.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Azure実践ガイド"><a href="#Azure実践ガイド" class="headerlink" title="Azure実践ガイド"></a>Azure実践ガイド</h1><div style="text-align:center; margin-bottom: 40px"><br><img src="/img/cover/2019_03_azure.jpg" alt="2019_03_azure" title="2019_03_azure" style="width:980px"><br></div><h2 id="学んだこと"><a href="#学んだこと" class="headerlink" title="学んだこと"></a>学んだこと</h2><ul><li><p>※読書中..</p></li><li><p><a href="/pdf/Microsoft-Azure実践ガイド.pdf">学習メモ</a></p></li></ul><h2 id="手に取った理由"><a href="#手に取った理由" class="headerlink" title="手に取った理由"></a>手に取った理由</h2><ul><li>業務でAzure環境を使用することになり、基礎知識を養うために購入</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Azure実践ガイド&quot;&gt;&lt;a href=&quot;#Azure実践ガイド&quot; class=&quot;headerlink&quot; title=&quot;Azure実践ガイド&quot;&gt;&lt;/a&gt;Azure実践ガイド&lt;/h1&gt;&lt;div style=&quot;text-align:center; margin-bot
      
    
    </summary>
    
      <category term="Azure" scheme="http://yoursite.com/categories/Azure/"/>
    
    
      <category term="教科書" scheme="http://yoursite.com/tags/%E6%95%99%E7%A7%91%E6%9B%B8/"/>
    
      <category term="読書中" scheme="http://yoursite.com/tags/%E8%AA%AD%E6%9B%B8%E4%B8%AD/"/>
    
  </entry>
  
  <entry>
    <title>AmazonAlexa開発ガイド</title>
    <link href="http://yoursite.com/AI/2019_01_AmazonAlexa%E9%96%8B%E7%99%BA%E3%82%AC%E3%82%A4%E3%83%89/"/>
    <id>http://yoursite.com/AI/2019_01_AmazonAlexa開発ガイド/</id>
    <published>2018-12-31T15:00:00.000Z</published>
    <updated>2019-07-20T15:44:41.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AmazonAlexa開発ガイド"><a href="#AmazonAlexa開発ガイド" class="headerlink" title="AmazonAlexa開発ガイド"></a>AmazonAlexa開発ガイド</h1><div style="text-align:center; margin-bottom: 40px"><br><img src="/img/cover/2019_01_alexa_handson.jpg" alt="2019_01_alexa_handson" title="2019_01_alexa_handson" style="width:980px"><br></div><ul><li>目次<ul><li>Chapter 1 Amazon AlexaとAmazon Echo</li><li>Chapter 2 Amazon AlexaとAWSの準備</li><li>Chapter 3 スキル開発入門</li><li>Chapter 4 スキルのデバッグから公開</li><li>Chapter 5 Webサービス連携アプリの開発</li><li>Chapter 6 スマートホームスキルの開発</li><li>Chapter 7 AVSを利用したアプリケーションの構築方法</li><li>Appendix SSML/CLI</li></ul></li></ul><h2 id="学んだこと"><a href="#学んだこと" class="headerlink" title="学んだこと"></a>学んだこと</h2><ul><li>AmazonAlexaSkillKitを利用したスキル開発方法</li><li>AWS Lambda にサンプルをデプロイし実際に動作させる方法</li><li>AlexaSkillKitについての基礎知識<ul><li>インテント・スロットなど</li><li>SSML</li></ul></li><li>※本書では、後半、AVSについても述べられているが、直近で必要な知識ではなかったため割愛</li></ul><h2 id="手に取った理由"><a href="#手に取った理由" class="headerlink" title="手に取った理由"></a>手に取った理由</h2><ul><li>Alexaスキル開発の基礎知識を習得するため</li></ul><h2 id="学習メモ"><a href="#学習メモ" class="headerlink" title="学習メモ"></a>学習メモ</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># はじめに</span><br><span class="line"></span><br><span class="line">□付属データ（amazon_alexa_sample.zip）の内容</span><br><span class="line">付属データには、以下の内容が含まれています。</span><br><span class="line"></span><br><span class="line">Chapter2～7、Appendixで紹介しているサンプルデータ</span><br><span class="line">Chapter7の04節のコマンド入力用テキスト（一部修正用テキスト含む）</span><br><span class="line">Chapter5の02節（P.137）：補足資料1「Twitter developer accountへのアプリ登録」（PDFファイル）</span><br><span class="line">Chapter7の04節（P.210）：補足資料2「Raspberry Pi 3の初回起動時のセットアップ」（PDFファイル）</span><br><span class="line">Chapter7の04節（P.248）：補足資料3「Lチカを行うための配線」（PDFファイル）</span><br><span class="line">□付属データのテスト環境</span><br><span class="line">OS：macOS 10.13.5</span><br><span class="line">Node.js：8.11.1</span><br><span class="line">npm：5.6.0</span><br><span class="line">Alexa開発者コンソール</span><br><span class="line">URL https://developer.amazon.com/alexa/console/</span><br><span class="line">AWS</span><br><span class="line">URL https://aws.amazon.com/jp/</span><br><span class="line">ASK SDK for Node.js：2.0.5</span><br><span class="line">Amazon Echoデバイス</span><br><span class="line">Amazon Echo dot</span><br><span class="line">URL https://www.amazon.co.jp/dp/B072B5BTLK</span><br><span class="line">Homebrew: 1.6.7</span><br><span class="line">AVS Device SDK：1.8.1</span><br><span class="line">□Chapter7 04節で利用した機材</span><br><span class="line">サンワサプライUSBマイクロホンMM-MCU02BK</span><br><span class="line">URL https://direct.sanwa.co.jp/のサイトで「MM-MCU02BK」で検索</span><br><span class="line">Raspberry Pi 3（Model B）</span><br><span class="line">Raspberry Pi 3 Model Bケース+ヒートシンク</span><br><span class="line">https://www.physical-computing.jpのサイトで「Raspberry Pi 3」で検索</span><br><span class="line">ブレッドボード　マイコンボード用実験パーツセット　KP-PRTSET01</span><br><span class="line">URL http://eleshop.jp/shop/g/g402534/</span><br><span class="line">※補足1：上記の「ブレッドボード　マイコンボード用実験パーツセット」には、ジャンプワイヤ（オス・オス）しかありませんので、別途ジャンプワイヤ（オス・メス）をご購入ください。</span><br><span class="line">ジャンプワイヤ（オス・メス）の購入先例</span><br><span class="line">例：ELEGOO 50 PCS オスメスジャンパーワイヤ200mm (無料 170 タイポイント ブレッドボード)</span><br><span class="line">URL https://www.amazon.co.jp/dp/B06ZZXH4XT/</span><br><span class="line">□Chapter7 04節に関するコマンドやリンク先（著者提供サイト）</span><br><span class="line">紙面コマンド &amp; リンクまとめ</span><br><span class="line">URL https://gist.github.com/ShinjiKobayashi/1383691df9d43edd60267e44f6e2e923</span><br><span class="line"></span><br><span class="line"># Chapter 1 Amazon AlexaとAmazon Echo</span><br><span class="line"></span><br><span class="line">##### Echo Show</span><br><span class="line">2018/08時点では発売されていないがecho show という製品があったりする（画面がついている）</span><br><span class="line"></span><br><span class="line">スマートフォンやブラウザ上で実行できるAlexaアプリへカードを表示する機能はあるが、別のデバイスに取り出す必要があり、シームレスな体験でない</span><br><span class="line"></span><br><span class="line">##### Echo Look</span><br><span class="line">360度の3Dスキャンが可能な衣装のコーディネートの良し悪しを判断してくれる機能をもつ製品</span><br><span class="line"></span><br><span class="line">##### 車載Alexa</span><br><span class="line">BMWやToyotaがプレスリリース</span><br><span class="line"></span><br><span class="line">手がふさがっていてもVUIであれば操作可能</span><br><span class="line"></span><br><span class="line">##### Alexa Mobile Accessory Kit</span><br><span class="line">スマートフォンのAlexaアプリを介してAlexaの機能を利用できるようにするアプリ</span><br><span class="line"></span><br><span class="line">##### Amazon Lex</span><br><span class="line">AWSサービス</span><br><span class="line"></span><br><span class="line">Alexaに採用されている深層学習の技術と同等の技術を利用できるサービス</span><br><span class="line"></span><br><span class="line">### Alexaスキルキット（ASK）</span><br><span class="line">開発者がAlexaを通じて公開できるアプリケーションのような機能</span><br><span class="line"></span><br><span class="line">### Alexaの特色</span><br><span class="line"></span><br><span class="line">- スキルの種類</span><br><span class="line">    * カスタムスキル</span><br><span class="line">        + 料理レシピやしりとりゲームな一般的なAlexaスキル</span><br><span class="line">        + Alexaを通じて商品の購入ができるようになったりする</span><br><span class="line">    * スマートホームスキル</span><br><span class="line">        + カメラや証明、鍵等のスマートホームデバイスを制御するスキル</span><br><span class="line">    * フラッシュブリーフィングスキル</span><br><span class="line">        + ※言及なし</span><br><span class="line"></span><br><span class="line">## 02カスタムスキルの開発事例</span><br><span class="line">### Alexaスキルの動きを確認する</span><br><span class="line">##### インテント</span><br><span class="line">音声入力の内容を解釈して、キーワードに合わせたタグ付けのようなことを行い、対話モデルを作成</span><br><span class="line"></span><br><span class="line">##### スロット</span><br><span class="line">対話モデルをより柔軟に活用することができる（プログラミングにおける変数に近い役割）</span><br><span class="line"></span><br><span class="line">「*東京タワー*の天気を教えて」という発話があった場合、*東京タワー*がPlaceスロットに格納されて、インテントと同じくタグ付けされる</span><br><span class="line"></span><br><span class="line">この要素を参照すれば、ユーザがどこの天気を知りたいのか把握できる</span><br><span class="line"></span><br><span class="line">##### マルチターン会話とダイアログ</span><br><span class="line"></span><br><span class="line">まるで本当に会話している様に実装できる</span><br><span class="line"></span><br><span class="line">### Alexaスキルの開発事例</span><br><span class="line"></span><br><span class="line">##### 人気のあるスキルについて</span><br><span class="line">スキル順位を記載している</span><br><span class="line"></span><br><span class="line">##### ユーザーストーリーの作成</span><br><span class="line"></span><br><span class="line">##### スキルの目的を決める</span><br><span class="line">##### 明確なユーザ操作をイメージする</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## チャプターまとめ</span><br><span class="line">- Alexaを取り巻く世界観やスキルを用いて実現できること</span><br><span class="line">- Alexaの機能や大まかな挙動</span><br><span class="line">- スキル開発をするときに気をつけておくとよいこと</span><br><span class="line"></span><br><span class="line"># Chapter 2 Amazon AlexaとAWSの準備</span><br><span class="line"></span><br><span class="line">## 01Alexaの開発環境の準備</span><br><span class="line">※割愛</span><br><span class="line">### 全体の構成</span><br><span class="line">### Amazon開発者コンソールの登録方法</span><br><span class="line">### AWSの登録方法</span><br><span class="line"></span><br><span class="line">## 02Amazon Echo を使って Hello World</span><br><span class="line"></span><br><span class="line">### カスタムスキルの開発工程</span><br><span class="line">- Amazon開発者コンソールの設定</span><br><span class="line">- Lambdaの実装及び設定</span><br><span class="line">- 動作確認</span><br><span class="line"></span><br><span class="line">### Amazon 開発者コンソールの設定およびLambdaの実装</span><br><span class="line">1. スキルの基本情報設定</span><br><span class="line">2. Alexaデバイスの応答設定</span><br><span class="line">3. Lambdaの設定及び実装</span><br><span class="line">4. LambdaとAlexaデバイスの応答設定と紐付け</span><br><span class="line"></span><br><span class="line">～実際に操作してハローワールドを表示～</span><br><span class="line"></span><br><span class="line"># Chapter 3 スキル開発入門</span><br><span class="line"></span><br><span class="line">## 01カスタムスキルの開発方法</span><br><span class="line"></span><br><span class="line">### カスタムスキルの開発環境構築</span><br><span class="line">### カスタムスキル開発の基本</span><br><span class="line">- Amazon開発者コンソールの設定</span><br><span class="line">- Lambdaの実装</span><br><span class="line"></span><br><span class="line">### Amazon開発者コンソールの設定方法</span><br><span class="line"></span><br><span class="line">命令文をインテントと呼ばれるものに変換して該当のスキルにわたす</span><br><span class="line"></span><br><span class="line">アニマルブックスという架空のスキルを作成する例</span><br><span class="line"></span><br><span class="line">### Lambdaの実装方法</span><br><span class="line"></span><br><span class="line">npm install --loglevel=error ask-sdk-core ask-sdk-model</span><br><span class="line"></span><br><span class="line">##### 実装について見ていく</span><br><span class="line"></span><br><span class="line">### 対話型のカスタムスキル開発</span><br><span class="line"></span><br><span class="line">repromptを使用して「本のおすすめでよろしいですか？」と聞き返す実装</span><br><span class="line"></span><br><span class="line">### 会話内容の一部を扱うスキル開発</span><br><span class="line"></span><br><span class="line">##### スロットの実装</span><br><span class="line"></span><br><span class="line">## 02Alexaアプリにカードを表示させる</span><br><span class="line">### カードの表示</span><br><span class="line">Alexaではスキルでの発話と同時に発話内容の保管情報としてカードをAlexaアプリに表示することができます。</span><br><span class="line"></span><br><span class="line">- カードの種類</span><br><span class="line">    * シンプルカード</span><br><span class="line">    * スタンダードカード</span><br><span class="line"></span><br><span class="line">## 03AudioPlayerでスキルを開発する</span><br><span class="line">### AudioPlayerとは</span><br><span class="line">- MP3などのオーディオファイルをストリーミング再生するAlexaの仕組み</span><br><span class="line">- 一時停止やシャッフル再生、ループ再生、キューイングなどもサポートしている</span><br><span class="line">- 再生状態をモニタリングするための仕組みもある</span><br><span class="line">- SSMLを用いることでオーディオファイルの再生をすることも可能だが、90秒の制限がある</span><br><span class="line"></span><br><span class="line">### AudioPlayerを使ったスキルを作成する</span><br><span class="line"></span><br><span class="line"># Chapter 4 スキルのデバッグから公開</span><br><span class="line"></span><br><span class="line">## 01Alexaスキルのデバッグ方法</span><br><span class="line">### Alexaスキルのデバッグ方法</span><br><span class="line">- Alexa Skill Testing Toolについての説明</span><br><span class="line"></span><br><span class="line">### Lambdaのデバッグ方法</span><br><span class="line">- Cloud Watchで設定する</span><br><span class="line">- </span><br><span class="line"></span><br><span class="line">## Alexaスキルの公開方法</span><br><span class="line"></span><br><span class="line">## 多言語対応</span><br><span class="line"></span><br><span class="line"># Chapter 5 Webサービス連携アプリの開発</span><br><span class="line"></span><br><span class="line">## 01フラッシュブリーフィングの作り方</span><br><span class="line">### フラッシュブリーフィングスキルとは</span><br><span class="line">- 最新のニュースフィードを提供する機能</span><br><span class="line">- インストールされているフラッシュブリーフィングスキルから提供される最新のニュースフィードをすべて収集し、ユーザに対して収集したニュースを提供する</span><br><span class="line">- 作成手順について</span><br><span class="line">    * フィード提供環境構築</span><br><span class="line">    * フィードの登録</span><br><span class="line"></span><br><span class="line">### フィード提供環境構築</span><br><span class="line"></span><br><span class="line">amzon api gatewayの設定で躓いた！！</span><br><span class="line"></span><br><span class="line">問いかけても「フラッシュニュースです」という内容しか返さない</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 02外部サービス連携アプリの作り方(Twitter連携)</span><br><span class="line">※一旦とばす！</span><br><span class="line"></span><br><span class="line"># Chapter 6 スマートホームスキルの開発</span><br><span class="line">※一旦とばす！</span><br><span class="line"></span><br><span class="line"># Chapter 7 AVSを利用したアプリケーションの構築方法</span><br><span class="line">※一旦とばす！</span><br><span class="line">端末メーカー様のコネクテット製品に、 簡単にAlexaを実装するためのSDK</span><br><span class="line"></span><br><span class="line"># Appendix SSML/CLI</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;AmazonAlexa開発ガイド&quot;&gt;&lt;a href=&quot;#AmazonAlexa開発ガイド&quot; class=&quot;headerlink&quot; title=&quot;AmazonAlexa開発ガイド&quot;&gt;&lt;/a&gt;AmazonAlexa開発ガイド&lt;/h1&gt;&lt;div style=&quot;text-
      
    
    </summary>
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
    
      <category term="教科書" scheme="http://yoursite.com/tags/%E6%95%99%E7%A7%91%E6%9B%B8/"/>
    
  </entry>
  
  <entry>
    <title>徹底攻略AWS認定ソリューションアーキテクト-アソシエイト教科書</title>
    <link href="http://yoursite.com/AWS/2019_01_%E5%BE%B9%E5%BA%95%E6%94%BB%E7%95%A5AWS%E8%AA%8D%E5%AE%9A%E3%82%BD%E3%83%AA%E3%83%A5%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%88-%E3%82%A2%E3%82%BD%E3%82%B7%E3%82%A8%E3%82%A4%E3%83%88%E6%95%99%E7%A7%91%E6%9B%B8/"/>
    <id>http://yoursite.com/AWS/2019_01_徹底攻略AWS認定ソリューションアーキテクト-アソシエイト教科書/</id>
    <published>2018-12-31T15:00:00.000Z</published>
    <updated>2019-07-20T15:41:00.036Z</updated>
    
    <content type="html"><![CDATA[<h1 id="徹底攻略AWS認定ソリューションアーキテクト-アソシエイト教科書"><a href="#徹底攻略AWS認定ソリューションアーキテクト-アソシエイト教科書" class="headerlink" title="徹底攻略AWS認定ソリューションアーキテクト-アソシエイト教科書"></a>徹底攻略AWS認定ソリューションアーキテクト-アソシエイト教科書</h1><div style="text-align:center; margin-bottom: 40px"><br><img src="/img/cover/2019_01_aws_saa_black.JPG" alt="2019_01_aws_saa_black" title="2019_01_aws_saa_black" style="width:980px"><br></div><h2 id="学んだこと"><a href="#学んだこと" class="headerlink" title="学んだこと"></a>学んだこと</h2><ul><li><p>AWS サービスについて、Well-architectedフレームワークに沿った５つの観点から説明されておりとても参考になった。（学習メモ参照）</p></li><li><p><a href="/pdf/徹底攻略AWS認定ソリューションアーキテクト-アソシエイト教科書_marked.pdf">学習メモ</a></p></li></ul><h2 id="手に取った理由"><a href="#手に取った理由" class="headerlink" title="手に取った理由"></a>手に取った理由</h2><ul><li>AWSサービスについて、どんなサービスがあって、どんな使われ方をして、どのように便利なのかなど、基本的な知識を習得するため</li><li>AWS SAA資格取得のため</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;徹底攻略AWS認定ソリューションアーキテクト-アソシエイト教科書&quot;&gt;&lt;a href=&quot;#徹底攻略AWS認定ソリューションアーキテクト-アソシエイト教科書&quot; class=&quot;headerlink&quot; title=&quot;徹底攻略AWS認定ソリューションアーキテクト-アソシエイ
      
    
    </summary>
    
      <category term="AWS" scheme="http://yoursite.com/categories/AWS/"/>
    
    
      <category term="教科書" scheme="http://yoursite.com/tags/%E6%95%99%E7%A7%91%E6%9B%B8/"/>
    
  </entry>
  
  <entry>
    <title>Javascript本格入門</title>
    <link href="http://yoursite.com/Javascript/2019_01_Javascript%E6%9C%AC%E6%A0%BC%E5%85%A5%E9%96%80/"/>
    <id>http://yoursite.com/Javascript/2019_01_Javascript本格入門/</id>
    <published>2018-12-31T15:00:00.000Z</published>
    <updated>2019-07-20T16:01:27.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Javascript本格入門"><a href="#Javascript本格入門" class="headerlink" title="Javascript本格入門"></a>Javascript本格入門</h1><div style="text-align:center; margin-bottom: 40px"><br><img src="/img/cover/2019_01_js_getting_started.jpg" alt="2019_01_js_getting_started" title="2019_01_js_getting_started" style="width:980px"><br></div><h2 id="学んだこと"><a href="#学んだこと" class="headerlink" title="学んだこと"></a>学んだこと</h2><ul><li>Javascript開発の体系的な知識</li><li><p>細かく理解できていなかった構文に関する知識</p></li><li><p><a href="/pdf/javascript本格入門.pdf">学習メモ</a></p></li></ul><h2 id="手に取った理由"><a href="#手に取った理由" class="headerlink" title="手に取った理由"></a>手に取った理由</h2><ul><li>Nodejs環境でがっちりJavascriptを開発していくにあたり、現在の知識確認とより効率的な開発方法の知識を得るため</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Javascript本格入門&quot;&gt;&lt;a href=&quot;#Javascript本格入門&quot; class=&quot;headerlink&quot; title=&quot;Javascript本格入門&quot;&gt;&lt;/a&gt;Javascript本格入門&lt;/h1&gt;&lt;div style=&quot;text-align:ce
      
    
    </summary>
    
      <category term="Javascript" scheme="http://yoursite.com/categories/Javascript/"/>
    
    
      <category term="教科書" scheme="http://yoursite.com/tags/%E6%95%99%E7%A7%91%E6%9B%B8/"/>
    
  </entry>
  
  <entry>
    <title>Googleアシスタントアプリ開発入門</title>
    <link href="http://yoursite.com/AI/2019_01_Google%E3%82%A2%E3%82%B7%E3%82%B9%E3%82%BF%E3%83%B3%E3%83%88%E3%82%A2%E3%83%97%E3%83%AA%E9%96%8B%E7%99%BA%E5%85%A5%E9%96%80/"/>
    <id>http://yoursite.com/AI/2019_01_Googleアシスタントアプリ開発入門/</id>
    <published>2018-12-31T15:00:00.000Z</published>
    <updated>2019-07-20T15:51:52.664Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Googleアシスタントアプリ開発入門"><a href="#Googleアシスタントアプリ開発入門" class="headerlink" title="Googleアシスタントアプリ開発入門"></a>Googleアシスタントアプリ開発入門</h1><div style="text-align:center; margin-bottom: 40px"><br><img src="/img/cover/2019_01_google_assistant_handson.jpg" alt="2019_01_google_assistant_handson" title="2019_01_google_assistant_handson" style="width:980px"><br></div><ul><li><p>目次</p><ul><li><p>●chapter1 GoogleアシスタントとAction</p><ul><li>1.1 AIアシスタント ～対話型のインタフェースで問題を解決～</li><li>1.2 Googleアシスタントとは？</li><li>1.3 Googleアシスタントから呼ばれる機能「Action」を使いこなそう</li></ul></li><li><p>●chapter2 Googleアシスタントのアプリ「Action」の作り方</p><ul><li>2.1 アプリ開発エコシステム「Actions on Google」で快適開発</li><li>2.2 簡単な会話アプリを作ってみる</li><li>2.3 やまびこアプリを作ろう（会話アプリのはじめの一歩）</li></ul></li><li><p>●chapter3 しっかり作るGoogleアシスタントアプリ</p><ul><li>3.1 標準的なアプリ実行環境を知ろう</li><li>3.2 基本的な処理フローをおさえよう</li><li>3.3 アプリのテーマと会話内容を決めよう</li><li>3.4 スピーカー向けアプリを作ろう1（静的会話をDialogflowで実装してみる）</li><li>3.5 スピーカー向けアプリを作ろう2（「じゃんけんアプリ」に動的会話を実装）</li><li>3.6 シミュレータや実機でしっかりテストしよう</li><li>3.7 アプリの会話音声をチューニングしよう（SSMLを使う）</li><li>3.8 UIを視覚的にリッチにしよう（Rich Responses）</li><li>3.9 最終的なプログラムコードを確認しよう</li><li>3.10 column：アプリのアルファリリース、ベータリリース</li></ul></li><li><p>●chapter4 いろいろな機能を活用してアプリを作ってみよう</p><ul><li>4.1 ToDoリストアプリを作ろう（データベースを利用する）</li><li>4.2 位置情報を音声で返すアプリを作ろう（位置情報を利用する）</li><li>4.3 天気予報アプリを作ろう（位置情報を利用して周囲の天気予報を応える）</li><li>4.4 アラームアプリを作ろう（Push APIを使う）</li><li>4.5 column：Actions on Googleのさまざまな機能</li></ul></li><li><p>●chapter5 アプリが世の中に出るまで／出たあと</p><ul><li>5.1 作ったアプリを配信しよう（Google社の審査）</li><li>5.2 Googleアシスタントにアプリをおすすめしてもらおう</li><li>5.3 船出のあと……</li></ul></li></ul></li></ul><h2 id="学んだこと"><a href="#学んだこと" class="headerlink" title="学んだこと"></a>学んだこと</h2><ul><li>Googleアシスタントアプリ開発に必要な用語</li><li>※業務で必要な箇所のみ拾い読み</li><li>あとで再読したい</li></ul><h2 id="手に取った理由"><a href="#手に取った理由" class="headerlink" title="手に取った理由"></a>手に取った理由</h2><ul><li>Googleアシスタントアプリの運用/保守に携わっていく上で必要なスキルを習得するため</li><li>スピーカー開発関連の知識を増やすため</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Googleアシスタントアプリ開発入門&quot;&gt;&lt;a href=&quot;#Googleアシスタントアプリ開発入門&quot; class=&quot;headerlink&quot; title=&quot;Googleアシスタントアプリ開発入門&quot;&gt;&lt;/a&gt;Googleアシスタントアプリ開発入門&lt;/h1&gt;&lt;div 
      
    
    </summary>
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
    
      <category term="教科書" scheme="http://yoursite.com/tags/%E6%95%99%E7%A7%91%E6%9B%B8/"/>
    
      <category term="再読" scheme="http://yoursite.com/tags/%E5%86%8D%E8%AA%AD/"/>
    
  </entry>
  
  <entry>
    <title>AWS認定ソリューションアーキテクトアソシエイト</title>
    <link href="http://yoursite.com/AWS/2018_12_AWS%E8%AA%8D%E5%AE%9A%E3%82%BD%E3%83%AA%E3%83%A5%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%88%E3%82%A2%E3%82%BD%E3%82%B7%E3%82%A8%E3%82%A4%E3%83%88/"/>
    <id>http://yoursite.com/AWS/2018_12_AWS認定ソリューションアーキテクトアソシエイト/</id>
    <published>2018-12-27T16:07:30.000Z</published>
    <updated>2019-07-20T01:37:17.456Z</updated>
    
    <content type="html"><![CDATA[<h1 id="書籍「AWS認定ソリューションアーキテクトアソシエイト」"><a href="#書籍「AWS認定ソリューションアーキテクトアソシエイト」" class="headerlink" title="書籍「AWS認定ソリューションアーキテクトアソシエイト」"></a>書籍「AWS認定ソリューションアーキテクトアソシエイト」</h1><ul><li><p>著者　：大塚 康徳（日立インフォメーションアカデミー）</p></li><li><p>単行本（ソフトカバー）: 168ページ</p></li><li>出版社: リックテレコム (2016/8/17)</li><li>言語: 日本語</li><li>ISBN-10: 486594043X</li><li>ISBN-13: 978-4865940435</li><li>発売日： 2016/8/17</li></ul><div style="text-align:center; margin-bottom: 40px"><br><img src="/img/cover/2018_12_aws_saa_blue.JPG" alt="2018_12_aws_saa_blue" title="2018_12_aws_saa_blue" style="width:980px"><br></div><h1 id="第1章-AWSと認定プログラム-ーAWSクラウドとは何か、そして認定プログラムとは何か？ー"><a href="#第1章-AWSと認定プログラム-ーAWSクラウドとは何か、そして認定プログラムとは何か？ー" class="headerlink" title="第1章 AWSと認定プログラム ーAWSクラウドとは何か、そして認定プログラムとは何か？ー"></a>第1章 AWSと認定プログラム ーAWSクラウドとは何か、そして認定プログラムとは何か？ー</h1><ul><li>割愛<ul><li>試験概要、AWSとはについて説明しているだけ</li></ul></li></ul><h1 id="第2章-リージョン／アベイラビリティーゾーンとAWSサービス-ーリージョンとAZ、そして各種サービスの提供レベルについてー"><a href="#第2章-リージョン／アベイラビリティーゾーンとAWSサービス-ーリージョンとAZ、そして各種サービスの提供レベルについてー" class="headerlink" title="第2章 リージョン／アベイラビリティーゾーンとAWSサービス ーリージョンとAZ、そして各種サービスの提供レベルについてー"></a>第2章 リージョン／アベイラビリティーゾーンとAWSサービス ーリージョンとAZ、そして各種サービスの提供レベルについてー</h1><ul><li><p>試験のポイント！</p><ul><li>サーバやデータはAZ間で冗長的に配置する</li></ul></li><li><p>サービス種別</p><ul><li>リージョンサービス</li><li>AZサービス</li><li>グローバルサービス</li></ul></li></ul><p>※サービスの中のコンテンツ毎に種別が違ったりして掘り下げるとややこしい<br>参考）<a href="https://stay-ko.be/aws/solutionarchitect-pro-aws-global-vs-resion-vs-az-resources" target="_blank" rel="noopener">https://stay-ko.be/aws/solutionarchitect-pro-aws-global-vs-resion-vs-az-resources</a></p><ul><li>章末問題<ul><li>ELBはAZサービスでありリージョンをまたいで負荷分散できない！</li><li>複数のAZにEC2を配置して、ELBで負荷分散するのが鉄則</li></ul></li></ul><h1 id="第3章-責任分担セキュリティモデルとAWSにおける認証（IAM）"><a href="#第3章-責任分担セキュリティモデルとAWSにおける認証（IAM）" class="headerlink" title="第3章 責任分担セキュリティモデルとAWSにおける認証（IAM）"></a>第3章 責任分担セキュリティモデルとAWSにおける認証（IAM）</h1><h1 id="責任分担セキュリティモデル"><a href="#責任分担セキュリティモデル" class="headerlink" title="責任分担セキュリティモデル"></a>責任分担セキュリティモデル</h1><ul><li><p>責任分担セキュリティモデル</p><ul><li>利用者とAWSが協力してセキュリティを高める考え方</li></ul></li><li><p>サービス種別</p><ul><li>インフラストラクチャサービス<ul><li>ハードウェア部分までAWSが管理</li><li>EC2など</li></ul></li><li>コンテナサービス<ul><li>ハードウェア部分からミドルウェア部分までAWSが管理</li><li>RDSなど</li></ul></li><li>アブストラクトサービス<ul><li>ハードウェア部分からソフトウェア部分までAWSが管理</li><li>S3やDynamoDB</li></ul></li></ul></li><li><p>試験のポイント！</p><ul><li>インフラストラクチャサービス、コンテナサービス、アブストラクトサービスの各サービスについて、利用者の責任範囲を明確にする</li></ul></li></ul><h2 id="AWSにおける認証とアクセス制御"><a href="#AWSにおける認証とアクセス制御" class="headerlink" title="AWSにおける認証とアクセス制御"></a>AWSにおける認証とアクセス制御</h2><ul><li><p>試験のポイント！</p><ul><li>日常の操作にはルートアカウントを使用せずに、IAMユーザを使用する</li></ul></li><li><p>試験のポイント！</p><ul><li>各IAMグループ、IAMユーザには、最小権限のアクセス権を与える。</li><li>IAMポリシーは最も厳しいポリシー（拒否）が優先される。<ul><li>アクセス許可と拒否が相反する場合、拒否が優先</li></ul></li></ul></li><li><p>試験のポイント！</p><ul><li>EC2インスタンス上で実行されるプログラムの認証にはIAMロールを割り当てる<ul><li>IAMロールを使用することでアクセスキーとシークレットアクセスキーがなくてもAWSサービスにアクセスできる</li><li>キーを使わないアクセスで、キーの流出を防ぐことが狙い</li></ul></li></ul></li></ul><h2 id="IDフェデレーション"><a href="#IDフェデレーション" class="headerlink" title="IDフェデレーション"></a>IDフェデレーション</h2><ul><li>事例<ul><li>要求<ul><li>自社の従業員に各自の業務レポートを毎月月末にS3にアップロードさせるたい</li></ul></li></ul><ul><li>問題<ul><li>S3バケットへのアクセス権を付与したいが、毎月１回だけのために全従業員分のIAMユーザを作成するのは非効率すぎて現実的ではない。</li></ul></li><li>解決策<ul><li>AWS Security Token Service（STS）という一時的に認証情報を付与するサービスとIDブローカー（IDプロバイダー）を利用して、自社の認証基盤で認証が通ればS3バケットへのアップロードを一時的に許可することができる</li></ul></li></ul></li></ul><p>→これを「IDフェデレーション」という！</p><ul><li><p>他にも以下がある</p><ul><li>Security Assertion Markup Language(SAML)を使用したシングルサインオン</li><li>GoogleやFacebookといったウェブIDプロバイダーを使用したシングルサインオン</li></ul></li><li><p>試験のポイント！</p><ul><li>AWSの使用頻度が低いユーザは、IDフェデレーションで社内の認証基盤とIAMを連携する</li></ul></li><li><p>章末問題</p><ul><li>利用者の責任で実施しなければならないセキュリティ対策は？<ul><li>S3上のデータの暗号化</li><li>EC2インスタンス上のOSのセキュリティパッチの適用</li></ul></li><li>AWSアカウント/認証情報の推奨される運用は？<ul><li>S3バケットへのアップロードをEC2インスタンスで実行する場合は、S3バケットへのファイルアップロードが許可されたIAMロールをEC2インスタンスに割り当てる</li></ul></li></ul></li></ul><h1 id="第4章-AWSにおけるネットワーク（VPC）"><a href="#第4章-AWSにおけるネットワーク（VPC）" class="headerlink" title="第4章 AWSにおけるネットワーク（VPC）"></a>第4章 AWSにおけるネットワーク（VPC）</h1><h2 id="VPCの機能と設定"><a href="#VPCの機能と設定" class="headerlink" title="VPCの機能と設定"></a>VPCの機能と設定</h2><ul><li><p>VPC（Amazon Virtual Private Cloud）</p><ul><li>利用者毎にプライベートなネットワーク空間を提供するサービス</li></ul></li><li><p>１．VPCの作成</p></li><li><p>２．サブネットの作成</p><ul><li>重要！<ul><li>サブネットはAZをまたがることはできない。サブネットを選択することはAZを選択することと同じ</li></ul></li></ul></li><li><p>３．ゲートウェイの作成</p><ul><li>インターネットゲートウェイ（IGW）をVPCにアタッチ</li><li>オンプレと通信するためのゲートウェイはバーチャルプライベートゲートウェイ（VGW）</li></ul></li><li><p>４．ルートテーブルの設定</p><ul><li>重要！<ul><li>インターネットとのアクセスを許可するサブネット：パブリックサブネット</li><li>インターネットとのアクセスを許可しないサブネット：プライベートサブネット</li></ul></li><li>パブリックかプライベートはサブネットに適用されているルートテーブルによってきまる<ul><li>パブリック：デフォルトゲートウェイ（送信先：0.0.0.0/0）のターゲットとしてIGWが設定</li><li>プライベート：上記でない</li></ul></li><li>VPCの内の通信はルートテーブルでは制御できないので、VPC内のサブネットであれば、通信が可能になっている<ul><li>Webサーバ、DBサーバ、その他のサーバ、でサブネットを分けていても、相互通信可能な状態になっている</li></ul></li></ul></li><li><p>５．NATインスタンスの作成</p><ul><li>プライベートサブネット内のパッチ当て等</li><li>NATインスタンスの実態はEC2インスタンス（※注意※最新ではNATゲートウェイというAWSサービスが存在する！）<ul><li>送信元/送信先チェック：宛先が自身のIPアドレスでなければトラフィックを破棄する設定。EC2インスタンスはデフォルトでON</li><li>NATインスタンスはこの機能を無効化している</li></ul></li></ul></li><li><p>試験のポイント！</p><ul><li>プライベートサブネット内のインスタンスがインターネットにアクセスするための設定を押さえる！</li></ul></li></ul><h2 id="EC2インスタンスのIPアドレス"><a href="#EC2インスタンスのIPアドレス" class="headerlink" title="EC2インスタンスのIPアドレス"></a>EC2インスタンスのIPアドレス</h2><ul><li><p>IPアドレスの種類</p><ul><li>Public IP</li><li>Elastic IP</li></ul></li><li><p>EC2インスタンスのプライベートIPアドレスとグローバルIPアドレスの紐付けは、VPCの仮想ネットワークで行われているので、EC2インスタンスのOSにログインし、ipconfigコマンドやifconfigコマンドを実行しても、プライベートIPしか確認できない</p></li></ul><h2 id="セキュリティグループとネットワークACL"><a href="#セキュリティグループとネットワークACL" class="headerlink" title="セキュリティグループとネットワークACL"></a>セキュリティグループとネットワークACL</h2><ul><li>ファイアウォール機能<ul><li>セキュリティグループ</li><li>ネットワークACL</li></ul></li></ul><table><thead><tr><th></th><th style="text-align:left">セキュリティグループ</th><th style="text-align:left">ネットワークACL</th></tr></thead><tbody><tr><td>適用単位</td><td style="text-align:left">EC2やRDS、ELBなどインスタンス毎</td><td style="text-align:left">サブネット単位</td></tr><tr><td>作成可能なルール</td><td style="text-align:left">許可のみ</td><td style="text-align:left">許可/拒否</td></tr><tr><td>デフォルトルール</td><td style="text-align:left">インバウンド：すべて拒否/アウトバウンド：すべて許可（ホワイトリスト方式）</td><td style="text-align:left">インバウンド：すべて許可/アウトバウンド：すべて許可（ブラックリスト方式）</td></tr><tr><td>特徴</td><td style="text-align:left">ステートフル</td><td style="text-align:left">ステートレス</td></tr></tbody></table><ul><li>試験のポイント！<ul><li>セキュリティグループとネットワークACLの違いを抑えて、ファイアウォールによるトラブルシューティングに対応できるようにする</li></ul></li></ul><h2 id="VPCピア接続"><a href="#VPCピア接続" class="headerlink" title="VPCピア接続"></a>VPCピア接続</h2><ul><li><p>使い所</p><ul><li>本番環境と開発環境で異なるVPCを構築したが、２つのVPCを接続して、プライベートIPで通信したい</li></ul></li><li><p>接続が確立されると、PCXというゲートウェイに相当するものが作成される</p></li><li><p>ルートテーブルの設定で送信先のターゲットとして、PCXを設定することで、各VPC内のサブネット間でのプライベートIPでの通信が可能になる</p></li><li><p>ピア接続の制約</p><ul><li>接続するVPCは同じリージョンに存在する必要がある</li><li>接続するVPCのプライベートネットワークアドレス空間は重複していない<ul><li>接続する可能性があるならはじめから分けておく必要性を示唆している</li></ul></li><li>１対１の接続<ul><li>ここはAWS対策講座でも強調して説明されていた</li></ul></li></ul></li><li><p>試験のポイント！</p><ul><li>VPCピア接続の特徴/制約を押さえる</li></ul></li><li><p>章末問題</p><ul><li>VPC内のすべてのサブネット間の通信はデフォルトのルーティングルールで許可されており、変更や削除はできない</li><li>セキュリティグループはステートフルのため戻りのトラフィックを確認する必要ない</li><li>VPCピア接続にあたってVPCが同一のリージョンに存在する必要がある点</li><li>VPCピア接続は１対１</li></ul></li></ul><h1 id="第5章-AWSにおけるコンピューティング（EC2／AMI／EBS／インスタンスストア）"><a href="#第5章-AWSにおけるコンピューティング（EC2／AMI／EBS／インスタンスストア）" class="headerlink" title="第5章 AWSにおけるコンピューティング（EC2／AMI／EBS／インスタンスストア）"></a>第5章 AWSにおけるコンピューティング（EC2／AMI／EBS／インスタンスストア）</h1><h2 id="EC2の初回起動と設定"><a href="#EC2の初回起動と設定" class="headerlink" title="EC2の初回起動と設定"></a>EC2の初回起動と設定</h2><p>【作成ステップについて】</p><ol><li>Amazon Machine Image(AMI)の選択</li><li>インスタンスタイプの選択 <ol start="3"><li>インスタンスファミリー選択</li></ol></li><li>ネットワーク/IAMロール/ユーザデータなどの設定（インスタンスの詳細設定）<ol start="4"><li>ユーザデータ：シェルスクリプト</li><li>メタデータ：インスタンス自身に関するデータ</li></ol></li><li>ストレージの設定<ol start="5"><li>EBS</li><li>インスタンスストア：追加できるのはEC2インスタンスの初回起動時のみ</li></ol></li><li>タグ付け<ol start="6"><li>タグ付けができる。おおよそ、Nameをキーにサーバー名を値に設定したりする</li></ol></li><li>セキュリティグループの設定<ol start="7"><li>EC2には少なくとも１つのセキュリティグループを割り当てる必要がある</li></ol></li><li>個々までの設定の確認</li><li>キーペアの選択</li></ol><ul><li>試験のポイント！<ul><li>ユーザデータおよびメタデータの用途と、メタデータで参照できる主要なデータを押さえる</li></ul></li></ul><h2 id="EC2インスタンスのライフサイクル"><a href="#EC2インスタンスのライフサイクル" class="headerlink" title="EC2インスタンスのライフサイクル"></a>EC2インスタンスのライフサイクル</h2><ul><li><p>ステータスチェック</p><ul><li>System Status Checks:インフラストラクチャ（HW、ハイパーバイザ）のチェック</li><li>Instance Status Checks：OSのチェック</li></ul></li><li><p>EC2のインスタンスがrunningになった時点から料金が発生し、stopped,terminatedになるまで発生</p></li></ul><h2 id="EBSとインスタンスストア"><a href="#EBSとインスタンスストア" class="headerlink" title="EBSとインスタンスストア"></a>EBSとインスタンスストア</h2><ul><li>Amazoon EBS(Elastic Block Store)<ul><li>AZ内に作成されるネットワーク接続型のブロックストレージ</li><li>不揮発性</li></ul></li><li><p>インスタンスストア</p><ul><li>EC2インスタンスの物理ホストの内蔵ストレージで、揮発性（一時的なデータボリューム）</li><li>揮発性：EC2が停止すると保存されていたデータは削除される</li><li>EC2が停止して起動すると、物理ホストが変わるため、揮発性という特徴がある</li></ul></li><li><p>重要！</p><ul><li>ブロックストレージにはEBSとインスタンスストアの２種類があり、不揮発性と揮発性という違いがある！</li></ul></li><li><p>OSがどこにインストールされるかによる違い</p><ul><li>EBS-backedインスタンス<ul><li>EBSにOSがインストールされる</li></ul></li><li>instance store-backedインスタンス<ul><li>インスタンスストアにインストラクターされる</li></ul></li></ul></li><li><p>試験のポイント！</p><ul><li>EBS-backedインスタンスとinstance store-backedインスタンスの特徴を押さえる！</li></ul></li></ul><h2 id="EBSのタイプ"><a href="#EBSのタイプ" class="headerlink" title="EBSのタイプ"></a>EBSのタイプ</h2><ul><li><p>EBSのタイプとして３種類言及しているが、情報として古いので、最新を確認したほうがよい</p></li><li><p>EBS最適化オプション（Black Beltより最新情報を記載）</p><ul><li>ネットワークのIO帯域とEBSのIO帯域を分け、EBS専用帯域を確保するオプション</li></ul></li><li><p>試験のポイント！</p><ul><li>EBSボリュームタイプの性能の違いとEBS最適化インスタンス(今はEBS最適化オプション？)の使い所を押さえる</li></ul></li></ul><h2 id="EBSスナップショット"><a href="#EBSスナップショット" class="headerlink" title="EBSスナップショット"></a>EBSスナップショット</h2><ul><li><p>試験のポイント！</p><ul><li>EBSスナップショットの特徴を押さえる！</li></ul></li><li><p>試験のポイント！</p><ul><li>EBSスナップショットを介したAZ/リージョン間のEBSボリュームの複製の流れを押さえる</li><li>リージョン-a/AZ-a → リージョン-a/S3 にスナップショット取得</li><li>リージョン-a/S3 → リージョン-a/AZ-b にスナップショット復元</li><li>リージョン-a/S3 → リージョン-b/S3 にスナップショットコピー</li><li>リージョン-b/S3 → リージョン-b/AZ-c にスナップショット復元<ul><li>S3間はリージョンをまたいでスナップショットをコピーすることができる点</li></ul></li></ul></li></ul><h2 id="プレイスメントグループ"><a href="#プレイスメントグループ" class="headerlink" title="プレイスメントグループ"></a>プレイスメントグループ</h2><p>初めて聞いた…</p><ul><li>試験のポイント！<ul><li>プレイスメントグループ内にEC2インスタンスを起動することで、EC2インスタンス間のネットワーク接続を高速化できる</li></ul></li></ul><h2 id="Dedicatedインスタンス"><a href="#Dedicatedインスタンス" class="headerlink" title="Dedicatedインスタンス"></a>Dedicatedインスタンス</h2><ul><li>ソフトウェア・ライセンスの、ハードウェア制約を解消するために、EC2インスタンスを起動する物理ホストに、別のEC2インスタンスが起動しないことを保証</li><li><p>Dedicatedホストという、物理ホストをアカウントに割り当てておき、その中にEC2インスタンスを起動していくサービスが利用できるようになった</p></li><li><p>AWS参考<br><a href="https://aws.amazon.com/jp/ec2/purchasing-options/dedicated-instances/" target="_blank" rel="noopener">https://aws.amazon.com/jp/ec2/purchasing-options/dedicated-instances/</a></p></li><li><p>章末問題</p><ul><li>ユーザデータについて</li><li>EC2の停止は「EBS-backedインスタンス」しかできない（instance store-backedインスタンスはできない）</li><li>EC2の再起動は揮発性ボリュームデータを失わない</li><li>スナップショット取得の留意事項（アンマウント＋取得後すぐにIO可能）</li><li>EBSボリュームはAZ間コピーもリージョン間コピーもできない、S3にスナップショットを取得して適応する</li><li>プレイスメントグループについて</li><li>Dedicatedインスタンスについて</li></ul></li></ul><h1 id="第6章-オブジェクトストレージ（S3／Glacier）"><a href="#第6章-オブジェクトストレージ（S3／Glacier）" class="headerlink" title="第6章 オブジェクトストレージ（S3／Glacier）"></a>第6章 オブジェクトストレージ（S3／Glacier）</h1><h2 id="S3バケット／オブジェクトとストレージクラス"><a href="#S3バケット／オブジェクトとストレージクラス" class="headerlink" title="S3バケット／オブジェクトとストレージクラス"></a>S3バケット／オブジェクトとストレージクラス</h2><ul><li><p>S3（Amazon Simple Storage Service）</p><ul><li>スタンダード（標準）クラス</li><li>低冗長化（Reduced Redundancy Storage;RRS）ストレージクラス</li></ul></li><li><p>※この本では言及してないが、Black Beltで最新は以下の４種類</p></li></ul><table><thead><tr><th>ストレージクラス</th><th>特徴</th><th>耐久性</th></tr></thead><tbody><tr><td>スタンダード</td><td>複数箇所にデータを複製。デフォルトのストレージクラス</td><td>99.999999999%(イレブン・ナイン)</td></tr><tr><td>STANDARD-IA（標準低頻度アクセスストレージ）</td><td>スタンダードに比べ格納コストが安価。いつでもアクセス可能だが、データの読み出し容量に対して課金。IA（Infrequent Access）</td><td>99.999999999%(イレブン・ナイン)</td></tr><tr><td>Glacier（アーカイブ）</td><td>最も低コストだが、データの取り出しにコストと時間を要する。ライフサイクルマネジメントにて指定する</td><td>99.999999999%(イレブン・ナイン)</td></tr><tr><td>低冗長化ストレージ（RRS）</td><td>RRSはReduced Redundancy Storageの略。Glacierから取り出したデータの置き場所として利用</td><td>99.99%</td></tr></tbody></table><ul><li>試験のポイント！<ul><li>S3のストレージクラスには、失われることが許されないデータを格納する用途に適したスタンダードクラスと、失われても再作成可能なデータを格納する用途に適した低冗長化クラスがある！</li></ul></li></ul><h2 id="S3の整合性"><a href="#S3の整合性" class="headerlink" title="S3の整合性"></a>S3の整合性</h2><p>S3はオンラインで頻繁に更新されるデータの格納先には向かない</p><p>格納されている静的データを何度も読み取るような用途に向いている</p><p>新規オブジェクトの追加は「完了」と表示されれば、画面上、lsコマンド上で確認できる</p><p>更新、削除は「完了」と表示されても、結果整合性をとるために、画面上、lsコマンド上で前のオブジェクトが表示されたり、削除できていなかったりする</p><ul><li>試験のポイント！<ul><li>S3の各操作とデータ整合性について押さえ、整合性を考慮したS3の利用用途を押さえる！</li></ul></li></ul><h2 id="S3のアクセス制限とセキュリティ"><a href="#S3のアクセス制限とセキュリティ" class="headerlink" title="S3のアクセス制限とセキュリティ"></a>S3のアクセス制限とセキュリティ</h2><ul><li><p>アクセス管理の方法</p><ul><li>アクセスコントロールリスト（ACL）</li><li>バケットポリシー</li><li>IAM(ユーザ)ポリシー</li></ul></li><li><p>その他</p><ul><li>署名（期限）付きURL<ul><li>アクセス許可設定をしていない特定のオブジェクトを指定した期間に限定して公開</li><li>用途）商品購入後、期間限定でURLに署名をつけて購入者に渡してダウンロードしてもらう際などに用いられる</li></ul></li></ul></li></ul><h2 id="オブエジェクトの暗号化とアクセスログ"><a href="#オブエジェクトの暗号化とアクセスログ" class="headerlink" title="オブエジェクトの暗号化とアクセスログ"></a>オブエジェクトの暗号化とアクセスログ</h2><ul><li>試験のポイント！<ul><li>S3の暗号化やアクセスログの取得はデフォルトではなく、ユーザの責任の元に実施する！</li></ul></li></ul><h2 id="S3の静的Webサイトホスティング機能"><a href="#S3の静的Webサイトホスティング機能" class="headerlink" title="S3の静的Webサイトホスティング機能"></a>S3の静的Webサイトホスティング機能</h2><ul><li><p>Webサイトホスティング機能</p><ul><li>エンドポイント<ul><li>バケット名.s3-website-リージョン名.amazonaws.com</li></ul></li></ul></li><li><p>準備</p><ul><li>Route53やDNSドメインサービスで名前解決する必要がある</li></ul></li></ul><h2 id="S3のバージョニング機能"><a href="#S3のバージョニング機能" class="headerlink" title="S3のバージョニング機能"></a>S3のバージョニング機能</h2><ul><li><p>バージョニング機能</p><ul><li>S3バケット単位で有効/無効にできる</li><li>誤って上書き、削除した場合でも、操作前のオブジェクトを復元できる</li><li>有効にした場合、キーの他にバージョンIDが付与される</li></ul></li><li><p>試験のポイント！</p><ul><li>S3のバージョニング機能を利用すれば、誤操作などにより上書きや削除をしてしまっても、元のデータを復元できる！</li></ul></li></ul><h2 id="S3のライフサイクル機能とGlacierへのアーカイブ"><a href="#S3のライフサイクル機能とGlacierへのアーカイブ" class="headerlink" title="S3のライフサイクル機能とGlacierへのアーカイブ"></a>S3のライフサイクル機能とGlacierへのアーカイブ</h2><ul><li>普段アクセスしないものは、より安く運用できる「Glacier」へ移動</li></ul><ul><li><p>格納方法</p><ul><li>ライフサイクル機能<ul><li>指定日数が経過したら、Glacierに格納、削除といった操作ができる機能</li></ul></li><li>SDKを利用して直接格納</li></ul></li><li><p>試験のポイント！</p><ul><li>Glacierは参照する頻度の少ないデータを長期間保管するのに適している</li></ul></li><li><p>章末問題</p><ul><li></li></ul></li></ul><h1 id="第7章-データベース（RDS／ElastiCache／DynamoDB）"><a href="#第7章-データベース（RDS／ElastiCache／DynamoDB）" class="headerlink" title="第7章 データベース（RDS／ElastiCache／DynamoDB）"></a>第7章 データベース（RDS／ElastiCache／DynamoDB）</h1><h2 id="マネージド・サービス"><a href="#マネージド・サービス" class="headerlink" title="マネージド・サービス"></a>マネージド・サービス</h2><ul><li><p>マネージド・サービスとは</p><ul><li>利用者が自身でOSやミドルウェア/ソフトウェアをインストールすることなくサービスを利用でき、サービスの可用性や拡張性、バックアップやパッチ適用といった管理作業の多くをAWSが管理してくれるサービスのこと</li></ul></li><li><p>RDSはマネージド・サービスで、他にもELBやSQSなどが存在する</p></li></ul><h2 id="マネージド型データベースサービス"><a href="#マネージド型データベースサービス" class="headerlink" title="マネージド型データベースサービス"></a>マネージド型データベースサービス</h2><ul><li>AWSが提供するマネージド型データベースサービス<ul><li>Amazon RDS：リレーショナルデータベースサービス</li><li>Amazon DynamoDB：NoSQLデータベースサービス</li><li>Amazon ElastiCache：インメモリキャッシュサービス</li><li>Amazon Redshift：データウェアハウスサービス</li></ul></li></ul><p>※最新では、Amazon Neptuneというサービスも存在する（フルマネージドのグラフデータベースサービス）</p><h2 id="RDS"><a href="#RDS" class="headerlink" title="RDS"></a>RDS</h2><ul><li><p>種類</p><ul><li>Amazon Aurora<ul><li>MySQLとPostgreSQLとの互換性のあるエンジン</li></ul></li><li>MySQL</li><li>MariaDB<ul><li>MySQLから分岐（フォーク）して作成された</li></ul></li><li>PostgreSQL</li><li>Oracle</li><li>Microsoft SQL Server</li></ul></li><li><p>特徴</p><ul><li>１）マルチAZ配置<ul><li>複数のAZにRDSインスタンスを配置して可用性を高める機能（マスタ-スレーブ構成）</li><li>MySQL、MariaDB、PostgreSQL、Oracleでは同期物理レプリケーション、</li><li>SQL Server では同期論理レプリケーションを使用してマスタからスレーブにデータ同期</li><li>スレーブデータは完全にスタンバイ状態で、読み取りもできないので、読み取り性能を上げたい場合は、リードレプリカや、ElastiCacheを利用すること</li><li>マスタに障害や停止が発生した場合、フェイルオーバーが開始される。フェイルオーバーの過程で、RDSインスタンスのCNAMEがマスタースレーブに付け替えられます</li><li>AuroraのマルチAZ配置は、マスタ-スレーブ構成ではなく、３つのAZにまたがるクラスターボリュームが作成され、各AZにクラスターデータのコピーが格納される</li></ul></li><li>試験のポイント！<ul><li>RDSのマルチAZ配置の特徴、フェイルオーバー時の挙動を押さえる！</li></ul></li><li>２）自動バックアップ機能<ul><li>RDS標準機能で、１日１回自動的にデータのバックアップを取得する</li><li>取得中は多少の読み書き遅延が発生する可能性があるので、利用者は、バックアップウィンドウと呼ばれる設定項目でバックアップが取得される時間帯を選択する</li><li>バックアップの保持期間はデフォルトで７日間。０～３５日間の間で指定する（０を選択するとバックアップが取得されない）</li><li>RDSはトランザクションログも自動的に取得しており、１日１回の自動バックアップとトランザクションログを利用して、設定している保存期間の特定時点のデータを持つRDSインスタンスを復元可能</li><li>トランザクションログは５分に１回永続ボリュームに書き込まれている</li></ul></li><li>試験のポイント！<ul><li>RDSの自動バックアップ機能のメリットを押さえる！</li></ul></li><li>３）パッチ適用<ul><li>自動パッチ適用機能を有効にしておくと、メンテナンスウィンドウと呼ばれる設定項目で指定した曜日/時間帯にパッチが適用される。</li><li>パッチ適用時に数分のダウンタイムが生じることがあるが、RDSをマルチAZ配置にすることで、先にスタンバイにパッチがてきようされ、フェイルオーバーした後に旧マスタ-でパッチが適用されるため、その影響を軽減できる</li><li>利用者がパッチ適用を有効/無効に設定できるが、重要なセキュリティ脆弱性が発生した場合は自動的に適用されることがある</li></ul></li><li>４）ストレージ<ul><li>RDSのストレージも、EBSのストレージと同様に、種類がある</li><li>General Purpose SSD</li><li>Provisioned IOPS SSD</li><li>Magnetic（Black Beltに「下位互換のためサポート」と記載あり）</li><li>（具体的な数値についてはBlack Beltを見たほうがよいため割愛）</li></ul></li></ul></li></ul><h2 id="DynamoDB"><a href="#DynamoDB" class="headerlink" title="DynamoDB"></a>DynamoDB</h2><ul><li><p>マネージド型のNoSQLデータベースサービス</p></li><li><p>特徴</p><ul><li>ストレージ容量が必要に応じて自動的に拡張</li><li>秒間あたりのI/O性能を指定できる</li><li>ストレージはSSDのみで安定したI/O性能を提供</li><li>データを３つのデータセンタに複製することで高可用性と高い耐久性を提供</li><li>読み込み整合性の強弱を指定することで、性能と整合性のバランスを選択</li></ul></li><li><p>拡張性</p></li><li>冗長性</li><li><p>整合性（結果整合性）</p></li><li><p>ユースケース</p><ul><li>セッションデータ</li><li>ゲームの点数</li><li>買い物リスト（買い物かご）</li><li>センサーデータ</li></ul></li></ul><p>１つの項目の実データは最大400KBまで</p><p>１つ１つの項目に対応する実データサイズが大きくなる場合は、実データをS3に保管して、DynamoDBにはS3の格納先URLや格納日付といったメタデータを格納するということもできる</p><ul><li><p>試験のポイント！</p><ul><li>DynamoDBのメリットとユースケースを押さえる！</li></ul></li><li><p>DynamoDBはリージョンサービス</p><ul><li>プライベートサブネットからのアクセスはNATインスタンスを経由する</li></ul></li><li><p>試験のポイント！</p><ul><li>DynamoDBのアクセス制御はIAMで行い、EC2インスタンス上で実行されるプログラムの認証には、IAMロールを活用する</li></ul></li></ul><h2 id="ElastiCache"><a href="#ElastiCache" class="headerlink" title="ElastiCache"></a>ElastiCache</h2><ul><li><p>種類</p><ul><li>Memcached<ul><li>Key-Value Store形式</li><li>キャッシュクラスタ構成</li></ul></li><li>Redis<ul><li>Key-Value Store形式</li><li>マスタースレーブ構成</li></ul></li></ul></li><li><p>ElastiCacheはAZサービスでサブネットグループに配置</p></li><li><p>アクセス制御はセキュリティグループとサブネットのルーティングルール</p></li><li><p>試験のポイント！</p><ul><li>ElastiCacheのメリット/ユースケースを押さえる！</li></ul></li><li><p>章末問題</p><ul><li></li></ul></li></ul><h1 id="第8章-AWSにおける監視と通知（CloudWatch／SNS）"><a href="#第8章-AWSにおける監視と通知（CloudWatch／SNS）" class="headerlink" title="第8章 AWSにおける監視と通知（CloudWatch／SNS）"></a>第8章 AWSにおける監視と通知（CloudWatch／SNS）</h1><h2 id="CloudWatchによるモニタリング"><a href="#CloudWatchによるモニタリング" class="headerlink" title="CloudWatchによるモニタリング"></a>CloudWatchによるモニタリング</h2><ul><li><p>CloudWatchとは</p><ul><li>モニタリングサービス</li></ul></li><li><p>メトリックス（監視項目）</p><ul><li>EC2インスタンスのCPU利用料</li><li>EBSのディスクI/O</li><li>S33の格納オブジェクト総数</li><li>RDSインスタンスのCPU利用率</li><li>RDSインスタンスのメモリ空き容量</li><li>RDSインスタンスのストレージ空き容量</li><li>DynamoDBに書き込まれたユニット数</li><li>など。。。</li></ul></li><li><p>CloudWatchは各種AWSリソースから送られてきたモニタリングデータを保存し、メトリックス毎にグラフ化して表示することができる</p></li><li>保持期間は２週間、それ以降のデータは破棄されてしまうため、月次のモニタリングレポート必要な場合は、保持期間内にCloudWatchからモニタリングデータをダウンロードしておく必要があります。</li></ul><h2 id="EC2のモニタリング"><a href="#EC2のモニタリング" class="headerlink" title="EC2のモニタリング"></a>EC2のモニタリング</h2><p>CloudWatchはあくまで、AWSリソースから<strong>送られてきた</strong>データを保存/可視化するサービスであるため、CloudWatchにデータを送る仕組み/機能をEC2インスタンスや、RDSインスタンスなどのAWSリソース側で用意する必要がある</p><p>RDSはマネージドサービスであり、デフォルトで様様なモニタリングデータを収集して、CloudWatchに送信するエージェントがインスタンスに導入されている</p><p>EC2はマネージドサービスではないため、デフォルトではハイパーバイザが収集できるモニタリングデータのみを収集してCloudWatchに送っている</p><ul><li>標準（デフォルト）メトリックス：ハイパーバイザが取得してCloudWatchに送信するメトリックス<ul><li>CPUクレジット利用数（CPUCreditUsage）</li><li>CPUクレジット累積数（CPUCreditBalance）</li><li>CPU利用率（CPUUtilization）</li><li>１秒あたりのDisk読み込み回数（DiskReadOps）</li><li>１秒あたりのDisk書き込み回数（DiskWriteOps）</li><li>インスタンスストレージの読み取りバイト数（DiskReadBytes）</li><li>インスタンスストレージの書き込みバイト数（DiskWriteBytes）</li><li>受信したバイト数（NetworkIn）</li><li>送信したバイト数（NetworkOut）</li><li>OS/インフラストラクチャステータスチェックの成功(0)/失敗(1)（StatusCheckFailed）</li></ul></li><li>カスタムメトリックス：OSにインストールしたエージェントが取得して、CloudWatchに送信するメトリックス</li></ul><blockquote><p>参考）よくある質問「カスタムメトリックスとは」</p><p><a href="https://aws.amazon.com/jp/cloudwatch/faqs/" target="_blank" rel="noopener">https://aws.amazon.com/jp/cloudwatch/faqs/</a></p><blockquote><p>カスタムメトリクスとは、Amazon CloudWatch でモニタリングするためにお客様自身が用意するメトリクスのことです。</p><p>カスタムメトリクスを使用してモニタリングできるものの例としては、ウェブページのロードに要する時間、リクエストエラー率、<br>インスタンス上のプロセスやスレッドの数、アプリケーションで実行された作業の量などがあります。</p><p>カスタムメトリクスを使用するには、PutMetricData API を使用します。Windows および Linux 向けのモニタリングスクリプトのサンプル、CloudWatch プラグイン集が用意されているほか、AWS パ&gt;ートナーからも多数のアプリケーションやツールが提供されています。</p></blockquote></blockquote><ul><li>基本モニタリング<ul><li>３種類のステータスチェックは１分間隔、その他は５分間隔</li></ul></li><li>詳細モニタリング<ul><li>標準メトリックスをすべて１分間隔（ただし、追加料金が必要）</li></ul></li></ul><ul><li>試験のポイント！<ul><li>EC2の標準メトリックスや基本/詳細モニタリングを押さえる！</li></ul></li></ul><h2 id="アラームとアクション"><a href="#アラームとアクション" class="headerlink" title="アラームとアクション"></a>アラームとアクション</h2><ul><li><p>CloudWatchの各メトリックスに対して、アラームを設定することができる</p><ul><li>閾値を超えた時に所定のアクションを呼び出す</li></ul></li><li><p>アクション例</p><ul><li>メールなどの通知（Simple Notification Service）</li><li>Auto Scalingポリシー（EC2インスタンス数の増減）</li><li>EC2アクション（停止/削除/再起動/復旧）</li></ul></li><li><p>アラームの３つの状態</p><ul><li>OK</li><li>アラーム（ALARM）</li><li>不足（INSUFFICIENT_DATA）</li></ul></li><li><p>設定例</p><ul><li>EC2インスタンスの１分間のCPU利用率の平均が閾値の７０％を３期連続（３分間連続）で上回っている場合に、EC2インスタンスを２台増やすAutoScalingポリシーのアクションを呼び出す</li><li>など。。。</li></ul></li><li><p>重要！</p><ul><li>CloudWatchのアラームとアクションについて、特徴と代表的な利用の流れを押さえる</li></ul></li></ul><h2 id="SNS"><a href="#SNS" class="headerlink" title="SNS"></a>SNS</h2><ul><li><p>SNS(Amazon Simple Notification Service)</p><ul><li>ユーザやアプリケーションにメッセージを送信できる</li><li>CloudWatchのアラームアクションとしてメッセージを通知することもできる</li></ul></li><li><p>押さえるべき３つの用語</p><ul><li>メッセージ<ul><li>通知するメッセージ</li></ul></li><li>サブスクライバ<ul><li>受信者を指し、サポートされているプロトコルは次の通り<ul><li>Eメール</li><li>SMS</li><li>HTTP/HTTPS</li><li>SQS（Simple Queue Service）</li><li>Lambda（サーバ無しのプログラムコード実行サービス）</li></ul></li></ul></li><li>トピック<ul><li>単一/複数のサブスクライバをまとめたもの</li></ul></li></ul></li><li><p>利用例</p><ul><li>１．SampleTopicというシステムのアラートが通知されるトピックを作成し、運用管理者のEメールアドレス/メーリングリストをサブスクライバとしてSampleTopicに登録</li><li>２．CloudWatchでシステムのEC2インスタンスをモニタリングし、１分間の平均CPU利用率が８０％を１回超えたというアラームが発生すると、SampleTopicにメッセージを通知するアクションを設定</li><li>３．該当するEC2インスタンスのCPU利用率が８０％を超えてあアラームが発生すると、「CPU利用率が８０％を超えてアラームの状態がOKからALARMに遷移した」というメッセージをSampleTopicに送信</li><li>４．SNSはSampleTopicに登録されている運用管理者のEメールアドレス/メーリングリスト（サブスクライバ）にメッセージを送信</li></ul></li></ul><ul><li>章末問題<ul><li>WEbサーバとして利用しているEC2インスタンスの標準メトリックスとして正しいものは？<ul><li>[誤]メモリ使用率</li><li>[誤]Webページへのロード時間</li><li>[誤]Webサーバのプロセス/スレッド数</li><li>[正]Network I/O</li></ul></li></ul></li></ul><p>※デフォルトは、ハイパーバイザが取得できる値のみ。メモリの使用率は、OSで収集する必要があります。</p><h1 id="第9章-AWSにおける拡張性と分散／並列処理（ELB／Auto-Scaling／SQS／SWF）"><a href="#第9章-AWSにおける拡張性と分散／並列処理（ELB／Auto-Scaling／SQS／SWF）" class="headerlink" title="第9章 AWSにおける拡張性と分散／並列処理（ELB／Auto Scaling／SQS／SWF）"></a>第9章 AWSにおける拡張性と分散／並列処理（ELB／Auto Scaling／SQS／SWF）</h1><h2 id="密結合と疎結合"><a href="#密結合と疎結合" class="headerlink" title="密結合と疎結合"></a>密結合と疎結合</h2><ul><li>通常のオンプレでWeb-AP-DBサーバーの3Tier構成を組むと、サーバー間が密結合担ってしまう。</li><li>AWSではサーバ間を疎結合にするために、負荷分散装置を用いて、WEBサーバ、APサーバのインスタンスが入れ替わっても問題ないように３Tier構成を組む</li><li><p>そのためのサービスをELB（Elastic Load Balancing）という（マネージドサービス）</p></li><li><p>重要！</p><ul><li>コンポーネント間を疎結合にして伸縮自在性を実装し、AWSのメリットを活かすシステム構成にする！</li></ul></li></ul><h2 id="ELB"><a href="#ELB" class="headerlink" title="ELB"></a>ELB</h2><ul><li><p>機能</p><ul><li>複数のAZにまたがる負荷分散</li><li>EC2インスタンスのヘルスチェック</li><li>ELB自体の自動スケーリング</li><li>SSLのオフロード</li><li>Connection Draining</li><li>アクセスログ記録</li><li>スティッキーセクション</li></ul></li><li><p>(1)複数のAZにまたがる負荷分散</p></li><li>(2)EC2インスタンスのヘルスチェック<ul><li>補足）EC2インスタンスを再起動した際、ELBのヘルスチェック間隔によってインスタンス異常と判定され、そのインスタンスのトラフィックが行われなくなり、再起動後もトラフィックの再開をしなかったが、2015/12にEC2インスタンスのELBへの自動再登録が可能になった</li></ul></li><li><p>(3)ELB自体の自動スケーリング</p><ul><li>ELBは、受信するトラフィックの流量に合わせて自動的にその実態を増減させる</li><li>ELBの実態はサブネットの中に作成される</li><li>割り当てられるIPアドレスはサブネットの中から採番されるが、同時にDNS名が付与され、DNS名で通信される</li><li>実態はサブネットの中にあるが、AZ間をまたいで通信されるため、AZの間にELBのアイコンを書くことがおおい</li></ul></li><li><p>(4)SSLのオフロード</p><ul><li>SSL証明書はEC2インスタンスに配置するのではなく、ELBに配置して一元管理する</li></ul></li><li><p>(5)Connection Draining</p><ul><li>ELBが配下のEC2インスタンスの登録解除をするときに、新規のリクエストについてはそのインスタンスへのトラフィックの送信を停止し、登録解除前にそのインスタンスで処理中だったリクエストについては完了まで待つようにする機能です。</li></ul></li><li>(6)アクセスログ記録<ul><li>ELBにはアクセスログ収集機能があり、S3バケットに保存することで、アクセスログを一元管理できる</li></ul></li><li><p>(7)スティッキーセクション</p><ul><li>ELBには、スティッキーセクションという、システムにアクセスしているクライアントを特定のEC2インスタンスに紐付けできる機能がある。</li><li>例）ユーザ認証が必要な会員WebサイトをEC2インスタンス上に構築し、その前段にELBを配置するとする。クラアイアンとは会員Webサイトにアクセスした際に、ELBに割り振られたEC2インスタンスのWebサーバ上でユーザ認証手続きを行います。ユーザ認証に成功すると、Webサーバ側でセッション情報が保持されるため、クライアントが会員Webサイト内で別ページを閲覧して、再度Webサーバに要求が送られても、Webサーバはセッション情報を参照することで、認証済みであることが確認でき、改めてユーザ認証を行わずにすむ</li><li>→ただし、この方法は「伸縮自在性を実装」に影響を及ぼすので、注意が必要。</li><li>「各コンポーネントが特定の状態を持たいない（ステートレス）」であることが重要。スティッキーセクションの代わりに、DynamoDBや、ElastiCacheを利用するほうが懸命</li></ul></li><li><p>試験のポイント！</p><ul><li>ELBの機能/特徴を理解して、ELBによるシステムの可用性向上メリットを押さえる！</li></ul></li></ul><h2 id="分散／並列処理"><a href="#分散／並列処理" class="headerlink" title="分散／並列処理"></a>分散／並列処理</h2><p>ある１台のEC2インスタンスでは性能が不足する場合の対処方法２つ</p><ul><li>(1) スケールアップ：インスタンスタイプを変更し、より高スペックに</li><li><p>(2) スケールアウト：EC2インスタンスの台数を増やして分散処理させる</p></li><li><p>スケールアップの問題点</p><ul><li>EC2インスタンスを一旦停止する必要があり、１台のインスタンスの場合は業務を停止する必要がある</li><li>最終的にはスペックの限界がある</li><li>１台のインスタンスでは「故障に備えた設計で障害を回避」を実践できない構成になる</li><li>システム負荷が減少した際に、スケールアップしたインスタンスタイプではオーバースペックになる。スケールダウンするためには再度EC2インスタンスを一旦停止する必要がある</li></ul></li><li><p>試験のポイント！</p><ul><li>分散/並列処理できる処理は並列化して業務を効率化する！</li></ul></li></ul><h2 id="Auto-Scaling"><a href="#Auto-Scaling" class="headerlink" title="Auto Scaling"></a>Auto Scaling</h2><ul><li><p>Auto Scaling</p><ul><li>EC2のインスタンスでAuto Scalingグループというグループを構成し、設定に従って自動的にEC2インスタンスの台数を増減させる</li><li>負荷が現象した際は、スケールインすることでコストメリットを図れる</li><li>Auto Scalingの利用料金は無料で、起動したEC2インスタンスの利用料金のみ費用が発生する</li></ul></li><li><p>ユースケース</p><ul><li>負荷に基づいた利用</li><li>スケジュールに基づいた利用</li><li>正常なEC2インスタンスの台数を維持するための利用</li></ul></li><li><p>Auto Scalingのコンポーネント</p><ul><li>起動設定（Launch Configration）<ul><li>どんなEC2インスタンスを起動するのか？という設定<ul><li>AMI</li><li>インスタンスタイプ</li><li>IAMロール</li><li>CloudWatch詳細モニタリング</li><li>ユーザデータ</li><li>IPアドレス</li><li>ストレージ（EBS、インスタンスストア）</li><li>セキュリティグループ</li><li>キーペア</li><li>など、、</li></ul></li></ul></li><li>Auto Scaling Group（Auto Scalingグループとは異なり、設定項目）<ul><li>どこに、どんな規模のグループ？という設定です</li><li>EC2インスタンスが起動するサブネットや特定のELB配下など、どこに？の設定</li><li>最小/最大台数などグループの規模を定める設定<ul><li>スタートのグループサイズ（EC2インスタンス数）</li><li>サブネット（AZ）</li><li>ELB（ヘルスチェック設定も含む）</li><li>最小/最大グループサイズ（EC2インスタンス数）</li><li>など、、</li></ul></li></ul></li><li>Auto Scaling ポリシー<ul><li>いつ、何台増減させるか？という設定</li><li>例えば、負荷に基づく設定であれば、CPU利用率のCloudWatchアラームを設定しておき、OKからアラームに状態遷移した際に、アクションとしてAuto Scalingポリシーを呼び出す<ul><li>アラームXが発生した際</li><li>N台追加/削除</li><li>猶予時間（インスタンスの増減後に、次の増減アクションが発生するまでのクールダウン時間）</li></ul></li></ul></li></ul></li><li><p>補足</p><ul><li>2015/7にAuto Scalingポリシーに「Step Scaliing」というタイプが追加され、それまでのポリシーは「Simple Scaling」というタイプになった</li><li>Step Scaling<ul><li>複数ステップでの増減が可能。まずこうなったら１台増やす、さらに何秒後までに、何％だったら、もう１台増やすのような設定</li></ul></li><li>Simple Scaling<ul><li>条件が１つの設定</li></ul></li></ul></li><li><p>試験のポイント！</p><ul><li>Auto Scalingにおける３つの設定項目を押さえる！</li></ul></li><li><p>Auto Scalingの２つの特徴</p><ul><li>正常なEC2インスタンスを希望する台数（Desired Capacity）維持するため、インスタンスのヘルスチェックをかけている</li><li>Auto Scalingグループが複数のAZにまたがるとき、AZ間でEC2インスタンス数を均等にする</li></ul></li><li><p>Auto Scalingのシュミレーションが記載されている項目がある～</p></li><li><p>スケールアウト時のインスタンス削除ルール</p><ul><li>１．起動している台数が最も多いAZのインスタンス（大原則）</li><li>２．起動設定が最も古いインスタンス</li><li>３．次の課金タイミングが最も近いインスタンス</li></ul></li><li><p>試験のポイント！</p><ul><li>Auto Scalingにおける大原則を押さえ、EC2インスタンスの増減がどの様に発生するかを押さえる！</li></ul></li></ul><h2 id="SQS-Amazon-Simple-Queue-Service"><a href="#SQS-Amazon-Simple-Queue-Service" class="headerlink" title="SQS (Amazon Simple Queue Service)"></a>SQS (Amazon Simple Queue Service)</h2><ul><li><p>ELBと並んでコンポーネントを疎結合にする要素で、AWSで分散/並列処理を行う上で重要なサービス</p></li><li><p>特徴</p><ul><li>(1)Pull型（ポーリングされる必要がある）<ul><li>アプリケーションにポーリングされる必要がある</li></ul></li><li>(2)順序性の保証はしない（FirstInFirstOutが保証されない）<ul><li>順序性は保たれない</li></ul></li><li>(3)最低１回配信保証<ul><li>メッセージはあるアプリケーションによって取得されてもキューから削除されることはなく、アプリケーションがバッチ処理の最後で明示的に削除する必要がある</li><li>メッセージを取得したアプリケーションがバッチ処理の最中で停止しても、他のノード上のアプリケーションが再度同じメッセージを取得して処理できる</li></ul></li><li>(4)可視性タイムアウト<ul><li>あるメッセージを取得したアプリケーションがバッチ処理を実行中に、他のノード上のアプリケーションがキューに残っている同じメッセージを取得して島わあないように、可視性タイムアウトという機能が備わっている。デフォルトで３０秒、利用者による設定も可能</li></ul></li><li>(5)メッセージサイズは最大256KB<ul><li>サイズが大きい場合はS3に保存して、SQSにはデータの格納先の情報を格納する</li></ul></li></ul></li><li><p>SQSはリージョンサービスで、プライベートサブネットからキューのポーリングやメッセージの格納といった操作を行うにはNATインスタンスが必要</p></li><li><p>EC2上でSQSへのアクセスがあるアプリケーションを動作させる場合は、IAMポリシーが設定されたIAMロールをEC2インスタンスにアタッチすることで安全に利用できる</p></li><li><p>試験のポイント！</p><ul><li>分散/並列処理におけるSQSのメリット/特徴を理解し、SQSのユースケースを押さえる！</li></ul></li></ul><h2 id="SWF（Amazon-Simple-Workflow）"><a href="#SWF（Amazon-Simple-Workflow）" class="headerlink" title="SWF（Amazon Simple Workflow）"></a>SWF（Amazon Simple Workflow）</h2><ul><li>マネージド型のタスクコーディネータ</li><li><p>重複が許されない、厳密に１回限りで順序性が求められる処理のコーディネータとしての利用に適している</p></li><li><p>構成要素</p><ul><li>ワークフロースターター<ul><li>ワークフローを開始する</li></ul></li><li>ディサイダー<ul><li>ワークフロー中の各処理を調整する</li></ul></li><li>アクティビティ・ワーカー<ul><li>ワークフロー中の各処理を実行する</li></ul></li></ul></li><li><p>試験のポイント！</p><ul><li>分散/並列処理における厳密に１回限りで順序性が求められる処理というSWFのユースケースを押さえる！</li></ul></li><li><p>章末問題</p><ul><li>ELBのIPアドレスを直接指定してはいけない</li><li>予測できない負荷にたいするテストに時間をかけるのではなく、負荷ベースのAuto Scalingを利用することで、負荷に対応する</li><li>１台のインスタンスを４０時間稼働させる利用料金と４０台のインスタンスを１時間可動させる利用料金は同じなので、可能な限り並列処理を実施する</li><li>一時的にAuto Scaling設定がされているEC2インスタンスの台数を増やしたいときに変更するのは？<ul><li>Auto Scaling Group設定</li></ul></li><li>動画トランスコード処理はSQSを利用するべき</li></ul></li></ul><h1 id="第10章-DNSとコンテンツ配信（Route-53／CloudFront）"><a href="#第10章-DNSとコンテンツ配信（Route-53／CloudFront）" class="headerlink" title="第10章 DNSとコンテンツ配信（Route 53／CloudFront）"></a>第10章 DNSとコンテンツ配信（Route 53／CloudFront）</h1><h2 id="エッジロケーション"><a href="#エッジロケーション" class="headerlink" title="エッジロケーション"></a>エッジロケーション</h2><ul><li>AWSにはリージョンとAZ以外に、エッジロケーションというデータセンタが世界に５０箇所以上あります。</li><li>エッジロケーションには、EC2やS3、RDSといったサービスでなく、Amazon Route 53のDNSサーバやAmazon Cloud Frontのキャッシュサーバが動作している</li><li><p>エッジロケーションは数が多いので、<a href="https://aws.amazon.com/jp/about-aws/global-infrastructure/" target="_blank" rel="noopener">AWSインフラストラクチャページ</a>で確認する</p></li><li><p>重要！</p><ul><li>世界５０箇所以上のエッジロケーションを利用して、DNSサービスやコンテンツ配信（CDN）サービスが提供されている！</li></ul></li></ul><h2 id="Route-53"><a href="#Route-53" class="headerlink" title="Route 53"></a>Route 53</h2><ul><li>マネージド型のDNSサービス</li><li><p>DNSサービスが53番ポートを利用することからその名前がついている</p></li><li><p>Route53を使用してゾーン/ドメイン情報を登録すると、４箇所のエッジロケーションのDNSサーバにゾーン/ドメイン情報が格納される</p></li><li>Route53が管理しているドメインに対してクエリが発生すれば、その４箇所のうちエンドユーザに最も近いDNSサーバが応答する</li><li>４箇所のDNSサーバが同時に停止する可能性は限りなく低いため、Route53のSLAは１００％として提供されている</li><li>利用料金は、管理しているホストゾーン（従来のDNSゾーンファイル）の数とクエリ回数などの従量課金制となっており、低額から利用可能</li></ul><ul><li><p>Route53 レコードタイプ</p><ul><li>A</li><li>AAAA(IPv6)</li><li>CNAME</li><li>MX</li><li>NS</li><li>PTR</li><li>SOA（Ｓtart Ｏf Ａuthority）</li><li>SPF</li><li>SRV</li><li>TXT</li><li>ALIAS(エイリアス：AWS独自レコード)</li></ul></li><li><p>Zone Apex（ゾーンエイペックス）：ゾーンの頂点のこと</p></li><li><p>試験のポイント！</p><ul><li>Route53の独自レコードであるALIASレコードは、CNAMEレコードでは対応できないZone Apexの名前解決をサポートする！</li></ul></li><li><p>レコードに行える設定</p><ul><li>荷重ラウンドロビン</li><li>レイテンシーベースルーティング</li><li>位置情報ルーティング</li><li>ヘルスチェックとフェイルオーバー</li></ul></li><li><p>試験のポイント！</p><ul><li>Route53の各種機能による、リージョンレベルのユースケースを押さえる！</li></ul></li></ul><h2 id="CloudFront"><a href="#CloudFront" class="headerlink" title="CloudFront"></a>CloudFront</h2><ul><li>CloudFrontはCDNサービス（Contents Delivery Network）</li><li>全国５０箇所のエッジロケーションの中の地理的に近い場所からコンテンツをダウンロード</li><li>アクセス回数とデータ転送量による従量課金制、長期契約や最低利用料金はない</li><li><p>CloudFrontではエッジロケーションにキャッシュさせる時間を設定できる</p><ul><li>静的なコンテンツについてはキャッシュ時間を長く</li><li>動的なコンテンツについてはキャッシュ時間を短く　といった具合</li></ul></li><li><p>サービス提供側のメリット</p><ul><li>大量のアクセスが各地のエッジロケーションに分散され、オリジンサーバの負荷が大幅に減少</li><li>オリジンサーバのリソース削減</li><li>S3バケットに直接アクセスされるよりもAWSの利用料金を抑えることができる</li></ul></li><li><p>試験のポイント！</p><ul><li>CloudFrontの特徴/メリットを理解し、ユースケースを押さえる！</li></ul></li></ul><ul><li>CloudFrontを利用したコンテンツ配信においても、CloudFrontのSSL証明書、あるいは利用者独自のSSL証明書を利用した暗号化通信が可能</li><li><p>CloudFront経由でエンドユーザに、S3へアクセスさせる際は、バケットポリシーでCloudFrontからのアクセスだけ許可する設定（OAI:Original Accesss Identity）を作成し、OAIからのアクセスだけを許可</p></li><li><p>試験のポイント！</p><ul><li>CloudFrontを利用したコンテンツ配信におけるセキュリティ/アクセス制限を押さえる</li></ul></li><li><p>章末問題</p><ul><li></li></ul></li></ul><h1 id="第11章-AWSサービスのプロビジョニング／デプロイ／構成管理（CloudFormation／Elastic-Beanstalk／OpsWorks）"><a href="#第11章-AWSサービスのプロビジョニング／デプロイ／構成管理（CloudFormation／Elastic-Beanstalk／OpsWorks）" class="headerlink" title="第11章 AWSサービスのプロビジョニング／デプロイ／構成管理（CloudFormation／Elastic Beanstalk／OpsWorks）"></a>第11章 AWSサービスのプロビジョニング／デプロイ／構成管理（CloudFormation／Elastic Beanstalk／OpsWorks）</h1><h2 id="CloudFormation"><a href="#CloudFormation" class="headerlink" title="CloudFormation"></a>CloudFormation</h2><ul><li><p>CloudFormation</p><ul><li>プロビジョニングサービス。利用者が用意した定義にしたがってAWSリソースを自動的にプロビジョニングする</li><li>自動化により、AWSリソースの構築/管理を効率化できる</li><li>インフラストラクチャをコード化して、インフラのバージョン管理が可能</li><li>利用料は無料で、プロビジョニングされたリソースの利用料金のみ発生</li></ul></li><li><p>押さえておく用語</p><ul><li>テンプレート<ul><li>プロビジョニングするリソースを規定するJSON形式のテキストファイル</li></ul></li><li>スタック<ul><li>CloudFormationによってプロビジョニングされるリソースの集合/管理単位</li></ul></li></ul></li><li><p>試験のポイント！</p><ul><li>CloudFormationを利用したインフラストラクチャのバージョン管理イメージを押さえる！</li></ul></li></ul><ul><li><p>テンプレートの作成について</p><ul><li>AWSから提供されるサンプルテンプレートを元に利用者が編集したり、CloudFormerというツールを利用して作成することもできる</li></ul></li><li><p>CloudFormer</p><ul><li>利用者のアカウントで現在作成されているAWSリソースを元にテンプレートを作成することができるツール</li></ul></li></ul><ul><li><p>JSONの書き方について～</p></li><li><p>試験のポイント！</p><ul><li>CloudFormationで設定できる項目や、エラー発生時の動きなどを押さえる！</li></ul></li></ul><h2 id="Elastic-Beanstalk-OpsWorks"><a href="#Elastic-Beanstalk-OpsWorks" class="headerlink" title="Elastic Beanstalk/ OpsWorks"></a>Elastic Beanstalk/ OpsWorks</h2><ul><li>Amazon Elastic Beanstalk<ul><li>アプリケーションのデプロイツール</li><li>アプリケーションのバージョニング管理ができ、既存の環境を以前のバージョンに戻すことができる</li><li>CloudFormation同様、プロビジョニングされたリソースにたいする課金</li></ul></li></ul><ul><li>OpsWorks<ul><li>AWS上のアプリケーションサーバの構成管理ツール</li><li>ELBやEC2インスタンスを作成し、その後にChefのレシピを実行してソフトウェアのインストールや設定などを自動化できる</li></ul></li></ul><ul><li>まとめると<ul><li>CloudFormation<ul><li>VPC以下の構成をプロビジョニング</li><li>Elastic BeanstalkとOpsWorksを呼び出して一気に設定できる</li></ul></li><li>Elastic Beanstalk<ul><li>アプリケーションのデプロイ関連（アプリケーションのバージョン管理）</li></ul></li><li>OpsWorks<ul><li>アプリの設定（chefのレシピを実行してソフトウェアのインストールや設定）</li></ul></li></ul></li></ul><ul><li>章末問題<ul><li></li></ul></li></ul><h1 id="第12章-EC2の料金モデル（オンデマンドインスタンス／リザーブドインスタンス／スポットインスタンス）"><a href="#第12章-EC2の料金モデル（オンデマンドインスタンス／リザーブドインスタンス／スポットインスタンス）" class="headerlink" title="第12章 EC2の料金モデル（オンデマンドインスタンス／リザーブドインスタンス／スポットインスタンス）"></a>第12章 EC2の料金モデル（オンデマンドインスタンス／リザーブドインスタンス／スポットインスタンス）</h1><h2 id="オンデマンドインスタンス"><a href="#オンデマンドインスタンス" class="headerlink" title="オンデマンドインスタンス"></a>オンデマンドインスタンス</h2><ul><li>デフォルトの課金形式</li><li>インスタンスが起動しているときに１時間単位で支払いが発生</li><li><p>料金は次の３要素で決まる</p><ul><li>リージョン</li><li>インスタンスタイプ</li><li>OS(Amazon Linux/RHEL/Windows Serverなど)</li></ul></li><li><p>使用用途</p><ul><li>開発/検証環境のサーバ</li><li>Auto Scalingグループで増減するサーバ</li><li>１年を通して常時稼働することが求められていないサーバ</li></ul></li></ul><h2 id="リザーブドインスタンス"><a href="#リザーブドインスタンス" class="headerlink" title="リザーブドインスタンス"></a>リザーブドインスタンス</h2><ul><li>１年あるいは３年契約を結ぶことにより、オンデマンドインスタンスより割安にEC2インスタンスやRDSインスタンス、ElastiCacheノードやRedshiftノードを利用できる</li><li>RI(Reserved Instance)と略した名称で呼ばれることもある</li><li>DynamoDBやCloudFrontにも同様の割引方式がありますが、こちらはキャパシティを事前に予約するリザーブドキャパシティといいます</li><li>リザーブドインスタンスはEC2インスタンスの起動/停止にかかわらず、利用料金が発生</li><li><p>支払い方式</p><ul><li>前払いなし</li><li>一部前払い</li><li>全額前払い</li></ul></li><li><p>使用用途</p><ul><li>いつでも確実にインスタンスを立ち上げたい</li><li>長期間継続的に利用することが決まっている</li></ul></li></ul><h2 id="スポットインスタンス"><a href="#スポットインスタンス" class="headerlink" title="スポットインスタンス"></a>スポットインスタンス</h2><ul><li>入札形式のEC2インスタンスの利用/支払い方式で、需要と供給のバランスによって決まるスポット価格（市場価格）を入札価格が上回ると、EC2インスタンスが利用できる</li><li><p>スポット価格の設定項目</p><ul><li>アベイラビリティゾーン（AZ）</li><li>インスタンスタイプ</li><li>OS(Amazon Linux/SUSE Linux/ Windows Serverなど)</li><li></li></ul></li><li><p>入札価格をスポット価格が上回った時、インスタンスはターミネートされる</p></li><li>計算クラスタノードの一部や、Auto Scalingの増加部分のインスタンスなど、突然削除されても問題ないところで利用します。</li><li>スポットインスタンス上のデータについては、頻繁にチェックポイントを設けて、S3やEBS、DynamoDBといった不揮発性のストレージに書き出す必要があります。</li><li>EC2インスタンスをターミネートする２分前に通知があるため、その通知をトリガーに外部ストレージに書き出す</li></ul><ul><li><p>重要！</p><ul><li>スポットインスタンスは、単独で使用するのではなく、オンデマンドやリザーブドインスタンスと組み合わせて利用する！</li></ul></li><li><p>試験のポイント！</p><ul><li>業務（提供サービス）の継続とEC2のコスト最適化の業法を考慮して、オンデマンド/リザーブド/スポットインスタンスそれぞれのユースケースを押さえる！</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;書籍「AWS認定ソリューションアーキテクトアソシエイト」&quot;&gt;&lt;a href=&quot;#書籍「AWS認定ソリューションアーキテクトアソシエイト」&quot; class=&quot;headerlink&quot; title=&quot;書籍「AWS認定ソリューションアーキテクトアソシエイト」&quot;&gt;&lt;/a&gt;書籍
      
    
    </summary>
    
      <category term="AWS" scheme="http://yoursite.com/categories/AWS/"/>
    
    
      <category term="教科書" scheme="http://yoursite.com/tags/%E6%95%99%E7%A7%91%E6%9B%B8/"/>
    
  </entry>
  
  <entry>
    <title>HTML5プロフェッショナル認定試験 レベル１ 問題集</title>
    <link href="http://yoursite.com/HTML/2018_06_HTML5/"/>
    <id>http://yoursite.com/HTML/2018_06_HTML5/</id>
    <published>2018-05-31T15:00:00.000Z</published>
    <updated>2019-07-20T01:36:32.691Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LPIC-Level1-教科書"><a href="#LPIC-Level1-教科書" class="headerlink" title="LPIC Level1 教科書"></a>LPIC Level1 教科書</h1><div style="text-align:center; margin-bottom: 40px"><br><img src="/img/cover/2018_06_html5_exercise.jpg" alt="2018_06_html5_exercise" title="2018_06_html5_exercise" style="width:980px"><br></div><ul><li>目次<ul><li>1章　Webの基礎知識</li><li>2章　CSS</li><li>3章　要素</li><li>4章　レスポンシブWebデザイン</li><li>5章　APIの基礎知識</li><li>6章　模擬試験</li></ul></li></ul><h2 id="学んだこと"><a href="#学んだこと" class="headerlink" title="学んだこと"></a>学んだこと</h2><ul><li>教科書で学んだことの復習</li><li>問題傾向の整理</li></ul><h2 id="手に取った理由"><a href="#手に取った理由" class="headerlink" title="手に取った理由"></a>手に取った理由</h2><ul><li>HTML5 Level1資格取得のため</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LPIC-Level1-教科書&quot;&gt;&lt;a href=&quot;#LPIC-Level1-教科書&quot; class=&quot;headerlink&quot; title=&quot;LPIC Level1 教科書&quot;&gt;&lt;/a&gt;LPIC Level1 教科書&lt;/h1&gt;&lt;div style=&quot;text-alig
      
    
    </summary>
    
      <category term="HTML" scheme="http://yoursite.com/categories/HTML/"/>
    
    
      <category term="教科書" scheme="http://yoursite.com/tags/%E6%95%99%E7%A7%91%E6%9B%B8/"/>
    
  </entry>
  
  <entry>
    <title>LPIC Level1 問題集</title>
    <link href="http://yoursite.com/LPIC/2018_04_LPIC_Level1_%E5%95%8F%E9%A1%8C%E9%9B%86/"/>
    <id>http://yoursite.com/LPIC/2018_04_LPIC_Level1_問題集/</id>
    <published>2018-03-31T15:00:00.000Z</published>
    <updated>2019-07-20T01:31:28.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LPIC-Level1-教科書"><a href="#LPIC-Level1-教科書" class="headerlink" title="LPIC Level1 教科書"></a>LPIC Level1 教科書</h1><div style="text-align:center; margin-bottom: 40px"><br><img src="/img/cover/2018_04_lpic_exercise.jpg" alt="2018_04_lpic_exercise" title="2018_04_lpic_exercise" style="width:980px"><br></div><ul><li>目次</li><li>第1部　101試験<ul><li>1章　基本コマンドとファイルの操作<ul><li>2章　正規表現とviエディタ</li><li>3章　プロセス管理</li><li>4章　ファイルシステムの管理</li><li>5章　マウントとクォータ機能</li><li>6章　ファイルの管理</li><li>7章　ソフトウェア管理</li><li>8章　システムアーキテクチャ</li><li>模擬試験</li></ul></li><li>第2部　102試験<ul><li>1章　シェル、スクリプト、SQLの基礎</li><li>2章　X Windows System</li><li>3章　ユーザアカウントの管理</li><li>4章　システムサービスの管理</li><li>5章　ネットワークの基礎</li><li>6章　セキュリティ</li><li>模擬試験</li></ul></li></ul></li></ul><h2 id="学んだこと"><a href="#学んだこと" class="headerlink" title="学んだこと"></a>学んだこと</h2><ul><li>教科書で得た知識の再確認</li><li>問題の出題傾向の把握</li></ul><h2 id="手に取った理由"><a href="#手に取った理由" class="headerlink" title="手に取った理由"></a>手に取った理由</h2><ul><li>LPIC Level1資格取得のため</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LPIC-Level1-教科書&quot;&gt;&lt;a href=&quot;#LPIC-Level1-教科書&quot; class=&quot;headerlink&quot; title=&quot;LPIC Level1 教科書&quot;&gt;&lt;/a&gt;LPIC Level1 教科書&lt;/h1&gt;&lt;div style=&quot;text-alig
      
    
    </summary>
    
      <category term="LPIC" scheme="http://yoursite.com/categories/LPIC/"/>
    
    
      <category term="教科書" scheme="http://yoursite.com/tags/%E6%95%99%E7%A7%91%E6%9B%B8/"/>
    
  </entry>
  
  <entry>
    <title>LPIC Level1 教科書</title>
    <link href="http://yoursite.com/LPIC/2018_04_LPIC_Level1/"/>
    <id>http://yoursite.com/LPIC/2018_04_LPIC_Level1/</id>
    <published>2018-03-31T15:00:00.000Z</published>
    <updated>2019-07-20T01:28:13.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LPIC-Level1-教科書"><a href="#LPIC-Level1-教科書" class="headerlink" title="LPIC Level1 教科書"></a>LPIC Level1 教科書</h1><div style="text-align:center; margin-bottom: 40px"><br><img src="/img/cover/2018_04_lpic.jpg" alt="2018_04_lpic" title="2018_04_lpic" style="width:980px"><br></div><ul><li>目次<ul><li>序章　LPI認定試験の概要</li><li>第1章　システムアーキテクチャ</li><li>第2章　Linuxのインストールとパッケージ管理</li><li>第3章　GNU＆UNIXコマンド</li><li>第4章　ファイルとプロセスの管理</li><li>第5章　デバイスとLinuxファイルシステム</li><li>第6章　101模擬試験</li><li>第7章　シェル、スクリプト、データ管理</li><li>第8章　ユーザーインターフェイスとデスクトップ</li><li>第9章　システム管理（1）</li><li>第10章　システム管理（2）</li><li>第11章　ネットワークの基礎</li><li>第12章　セキュリティ</li><li>第13章　102模擬試験</li></ul></li></ul><h2 id="学んだこと"><a href="#学んだこと" class="headerlink" title="学んだこと"></a>学んだこと</h2><ul><li>LinuxOSのシステムアーキテクチャ</li><li>パッケージ管理システムについて</li><li>OSの種類(Redhat系/Debian系)</li><li>シェルスクリプト（一般的なコマンドのオプション含めた使い方）</li><li>シェル起動時の環境設定ファイル</li></ul><h2 id="手に取った理由"><a href="#手に取った理由" class="headerlink" title="手に取った理由"></a>手に取った理由</h2><ul><li>LinuxOSについて体系的な知識を身に着けるため</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LPIC-Level1-教科書&quot;&gt;&lt;a href=&quot;#LPIC-Level1-教科書&quot; class=&quot;headerlink&quot; title=&quot;LPIC Level1 教科書&quot;&gt;&lt;/a&gt;LPIC Level1 教科書&lt;/h1&gt;&lt;div style=&quot;text-alig
      
    
    </summary>
    
      <category term="LPIC" scheme="http://yoursite.com/categories/LPIC/"/>
    
    
      <category term="教科書" scheme="http://yoursite.com/tags/%E6%95%99%E7%A7%91%E6%9B%B8/"/>
    
  </entry>
  
  <entry>
    <title>データベーススペシャリスト 2017年版 EXAM PRESS</title>
    <link href="http://yoursite.com/DB/2018_01_%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9%E3%82%B9%E3%83%9A%E3%82%B7%E3%83%A3%E3%83%AA%E3%82%B9%E3%83%88/"/>
    <id>http://yoursite.com/DB/2018_01_データベーススペシャリスト/</id>
    <published>2017-12-31T15:00:00.000Z</published>
    <updated>2019-07-20T01:07:01.041Z</updated>
    
    <content type="html"><![CDATA[<h1 id="データベーススペシャリスト-EXAM-PRESS"><a href="#データベーススペシャリスト-EXAM-PRESS" class="headerlink" title="データベーススペシャリスト EXAM PRESS"></a>データベーススペシャリスト EXAM PRESS</h1><div style="text-align:center; margin-bottom: 40px"><br><img src="/img/cover/2018_01_db.jpg" alt="2018_01_db" title="2018_01_db" style="width:980px"><br></div><ul><li>目次<ul><li>序章　試験対策（学習方法と解答テクニック）</li><li>第1章　概念データモデル</li><li>第2章　関係スキーマ</li><li>第3章　SQL</li><li>第4章　重要キーワード</li></ul></li></ul><h2 id="学んだこと"><a href="#学んだこと" class="headerlink" title="学んだこと"></a>学んだこと</h2><ul><li>DBスペシャリストに出題される問題傾向</li><li>今までの業務経験等である程度理解はしていたが、得られるものがあった</li></ul><h2 id="手に取った理由"><a href="#手に取った理由" class="headerlink" title="手に取った理由"></a>手に取った理由</h2><ul><li>DB関連知識の深堀のため</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;データベーススペシャリスト-EXAM-PRESS&quot;&gt;&lt;a href=&quot;#データベーススペシャリスト-EXAM-PRESS&quot; class=&quot;headerlink&quot; title=&quot;データベーススペシャリスト EXAM PRESS&quot;&gt;&lt;/a&gt;データベーススペシャリスト 
      
    
    </summary>
    
      <category term="DB" scheme="http://yoursite.com/categories/DB/"/>
    
    
      <category term="教科書" scheme="http://yoursite.com/tags/%E6%95%99%E7%A7%91%E6%9B%B8/"/>
    
  </entry>
  
  <entry>
    <title>Photoshopレタッチ・加工</title>
    <link href="http://yoursite.com/EX/2017_09_PhotoShop%E3%83%AC%E3%82%BF%E3%83%83%E3%83%81%E3%83%BB%E5%8A%A0%E5%B7%A5/"/>
    <id>http://yoursite.com/EX/2017_09_PhotoShopレタッチ・加工/</id>
    <published>2017-08-31T15:00:00.000Z</published>
    <updated>2019-07-20T01:02:00.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Photoshopレタッチ・加工"><a href="#Photoshopレタッチ・加工" class="headerlink" title="Photoshopレタッチ・加工"></a>Photoshopレタッチ・加工</h1><div style="text-align:center; margin-bottom: 40px"><br><img src="/img/cover/2017_09_photoshop.jpg" alt="2017_09_photoshop" title="2017_09_photoshop" style="width:980px"><br></div><h2 id="学んだこと"><a href="#学んだこと" class="headerlink" title="学んだこと"></a>学んだこと</h2><ul><li>Photoshopの加工テクニックを抜粋して拾い読み</li></ul><h2 id="手に取った理由"><a href="#手に取った理由" class="headerlink" title="手に取った理由"></a>手に取った理由</h2><ul><li>趣味で一眼レフにはまっており、row画像を加工・人の目を引く写真の作成方法を学習したかった</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Photoshopレタッチ・加工&quot;&gt;&lt;a href=&quot;#Photoshopレタッチ・加工&quot; class=&quot;headerlink&quot; title=&quot;Photoshopレタッチ・加工&quot;&gt;&lt;/a&gt;Photoshopレタッチ・加工&lt;/h1&gt;&lt;div style=&quot;text-
      
    
    </summary>
    
      <category term="EX" scheme="http://yoursite.com/categories/EX/"/>
    
    
      <category term="再読" scheme="http://yoursite.com/tags/%E5%86%8D%E8%AA%AD/"/>
    
      <category term="レシピ" scheme="http://yoursite.com/tags/%E3%83%AC%E3%82%B7%E3%83%94/"/>
    
  </entry>
  
</feed>
