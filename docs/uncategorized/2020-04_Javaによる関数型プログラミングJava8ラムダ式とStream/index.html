<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>2020-04_Javaによる関数型プログラミングJava8ラムダ式とStream | OUTPUT*OVER-THERE</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#264A2E">
    
    
    <meta name="keywords" content="">
    <meta name="description" content="Javaによる関数型プログラミングJava8ラムダ式とStream 著者：vankat subramaniam 訳：株式会社プログラミングシステム社 2014年10月 発行 オライリー本  まえがきはじめに対象者 Java5経験者 他の言語で関数型プログラミングを行っていて、Javaで実施したい人 すでにラムダ式に詳しい人は、チームメンバーのトレーニングに使用できる  本書の内容 最初から最後まで">
<meta property="og:type" content="article">
<meta property="og:title" content="2020-04_Javaによる関数型プログラミングJava8ラムダ式とStream">
<meta property="og:url" content="http://yoursite.com/uncategorized/2020-04_Java%E3%81%AB%E3%82%88%E3%82%8B%E9%96%A2%E6%95%B0%E5%9E%8B%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0Java8%E3%83%A9%E3%83%A0%E3%83%80%E5%BC%8F%E3%81%A8Stream/index.html">
<meta property="og:site_name" content="OUTPUT*OVER-THERE">
<meta property="og:description" content="Javaによる関数型プログラミングJava8ラムダ式とStream 著者：vankat subramaniam 訳：株式会社プログラミングシステム社 2014年10月 発行 オライリー本  まえがきはじめに対象者 Java5経験者 他の言語で関数型プログラミングを行っていて、Javaで実施したい人 すでにラムダ式に詳しい人は、チームメンバーのトレーニングに使用できる  本書の内容 最初から最後まで">
<meta property="og:locale" content="ja_JP">
<meta property="article:published_time" content="2023-06-24T05:22:58.003Z">
<meta property="article:modified_time" content="2020-04-29T15:07:44.045Z">
<meta property="article:author" content="t-tsutsui">
<meta name="twitter:card" content="summary">
    
        <link rel="alternate" type="application/atom+xml" title="OUTPUT*OVER-THERE" href="https://tutttuwi.github.io/output-over-there/atom.xml">
    
    <link rel="shortcut icon" href="https://tutttuwi.github.io/output-over-there/favicon.ico">
    <link rel="stylesheet" href="https://tutttuwi.github.io/output-over-there/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(https://tutttuwi.github.io/output-over-there/img/brand.png)">
      <div class="brand">
        <a href="https://tutttuwi.github.io/output-over-there/" class="avatar waves-effect waves-circle waves-light">
          <img src="https://tutttuwi.github.io/output-over-there/img/avatar.png">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">t-tsutsui</h5>
          <a href="mailto:t.tsutsui9117@gmail.com" title="t.tsutsui9117@gmail.com" class="mail">t.tsutsui9117@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="https://tutttuwi.github.io/output-over-there/"  >
                <i class="icon icon-lg icon-home"></i>
                Home
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://tutttuwi.github.io/output-over-there/about"  >
                <i class="icon icon-lg icon-link"></i>
                About
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://tutttuwi.github.io/output-over-there/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://tutttuwi.github.io/output-over-there/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://tutttuwi.github.io/output-over-there/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">2020-04_Javaによる関数型プログラミングJava8ラムダ式とStream</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="検索">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">2020-04_Javaによる関数型プログラミングJava8ラムダ式とStream</h1>
        <h5 class="subtitle">
            
                <time datetime="2023-06-24T05:22:58.003Z" itemprop="datePublished" class="page-time">
  2023-06-24
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Javaによる関数型プログラミングJava8ラムダ式とStream"><span class="post-toc-number">1.</span> <span class="post-toc-text">Javaによる関数型プログラミングJava8ラムダ式とStream</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#まえがき"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">まえがき</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#はじめに"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">はじめに</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#対象者"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">対象者</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#本書の内容"><span class="post-toc-number">1.2.2.</span> <span class="post-toc-text">本書の内容</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用するJavaのバージョン"><span class="post-toc-number">1.2.3.</span> <span class="post-toc-text">使用するJavaのバージョン</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#サンプルコードの読み方"><span class="post-toc-number">1.2.4.</span> <span class="post-toc-text">サンプルコードの読み方</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#オンラインリソース"><span class="post-toc-number">1.2.5.</span> <span class="post-toc-text">オンラインリソース</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1章-Hello、ラムダ式"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">1章　Hello、ラムダ式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-1-考え方を変える"><span class="post-toc-number">1.3.1.</span> <span class="post-toc-text">1.1 考え方を変える</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-2-関数型のコードによる大きな利益"><span class="post-toc-number">1.3.2.</span> <span class="post-toc-text">1.2 関数型のコードによる大きな利益</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-3-なぜ関数型で記述するのか"><span class="post-toc-number">1.3.3.</span> <span class="post-toc-text">1.3 なぜ関数型で記述するのか</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-4-革命ではなく、進化"><span class="post-toc-number">1.3.4.</span> <span class="post-toc-text">1.4 革命ではなく、進化</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-5-簡単にするためのほんの少しの砂糖"><span class="post-toc-number">1.3.5.</span> <span class="post-toc-text">1.5 簡単にするためのほんの少しの砂糖</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-6-まとめ"><span class="post-toc-number">1.3.6.</span> <span class="post-toc-text">1.6 まとめ</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2章-コレクションの使用"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">2章　コレクションの使用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-1-リストをイテレート"><span class="post-toc-number">1.4.1.</span> <span class="post-toc-text">2.1 リストをイテレート</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-2-リストの変換"><span class="post-toc-number">1.4.2.</span> <span class="post-toc-text">2.2 リストの変換</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-2-1-ラムダ式を使う"><span class="post-toc-number">1.4.2.1.</span> <span class="post-toc-text">2.2.1 ラムダ式を使う</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-2-2-メソッド参照を使用"><span class="post-toc-number">1.4.2.2.</span> <span class="post-toc-text">2.2.2 メソッド参照を使用</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-3-要素の検索"><span class="post-toc-number">1.4.3.</span> <span class="post-toc-text">2.3 要素の検索</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-4-ラムダ式の再利用"><span class="post-toc-number">1.4.4.</span> <span class="post-toc-text">2.4 ラムダ式の再利用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-5-静的スコープとクロージャ"><span class="post-toc-number">1.4.5.</span> <span class="post-toc-text">2.5 静的スコープとクロージャ</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-6-要素を-1つ選択"><span class="post-toc-number">1.4.6.</span> <span class="post-toc-text">2.6 要素を 1つ選択</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-7-コレクションを単一の値に集約（reduce）"><span class="post-toc-number">1.4.7.</span> <span class="post-toc-text">2.7 コレクションを単一の値に集約（reduce）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-8-要素の結合"><span class="post-toc-number">1.4.8.</span> <span class="post-toc-text">2.8 要素の結合</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-9-まとめ"><span class="post-toc-number">1.4.9.</span> <span class="post-toc-text">2.9 まとめ</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3章-文字列、コンパレータ、フィルタ"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">3章　文字列、コンパレータ、フィルタ</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-1-文字列のイテレーション"><span class="post-toc-number">1.5.1.</span> <span class="post-toc-text">3.1 文字列のイテレーション</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-2-Comparatorインタフェースを実装"><span class="post-toc-number">1.5.2.</span> <span class="post-toc-text">3.2 Comparatorインタフェースを実装</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-3-複数のプロパティによる流暢な比較"><span class="post-toc-number">1.5.3.</span> <span class="post-toc-text">3.3 複数のプロパティによる流暢な比較</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-4-collectメソッドとCollectorsクラスの使用"><span class="post-toc-number">1.5.4.</span> <span class="post-toc-text">3.4 collectメソッドとCollectorsクラスの使用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-5-ディレクトリの全ファイルをリスト"><span class="post-toc-number">1.5.5.</span> <span class="post-toc-text">3.5 ディレクトリの全ファイルをリスト</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-6-ディレクトリの特定のファイルだけをリスト"><span class="post-toc-number">1.5.6.</span> <span class="post-toc-text">3.6 ディレクトリの特定のファイルだけをリスト</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-7-flatMapで直下のサブディレクトリをリスト"><span class="post-toc-number">1.5.7.</span> <span class="post-toc-text">3.7 flatMapで直下のサブディレクトリをリスト</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-8-ファイルの変更を監視"><span class="post-toc-number">1.5.8.</span> <span class="post-toc-text">3.8 ファイルの変更を監視</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-9-まとめ"><span class="post-toc-number">1.5.9.</span> <span class="post-toc-text">3.9 まとめ</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4章-ラムダ式で設計する"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">4章　ラムダ式で設計する</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-1-ラムダ式を使った関心の分離"><span class="post-toc-number">1.6.1.</span> <span class="post-toc-text">4.1 ラムダ式を使った関心の分離</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-1-1-デザイン問題の探求"><span class="post-toc-number">1.6.1.1.</span> <span class="post-toc-text">4.1.1 デザイン問題の探求</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-1-2-問題でがんじがらめ"><span class="post-toc-number">1.6.1.2.</span> <span class="post-toc-text">4.1.2 問題でがんじがらめ</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-1-3-主要な関心の分離"><span class="post-toc-number">1.6.1.3.</span> <span class="post-toc-text">4.1.3 主要な関心の分離</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-2-ラムダ式を使った委譲"><span class="post-toc-number">1.6.2.</span> <span class="post-toc-text">4.2 ラムダ式を使った委譲</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-3-ラムダ式を使ったデコレーション"><span class="post-toc-number">1.6.3.</span> <span class="post-toc-text">4.3 ラムダ式を使ったデコレーション</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-4-defaultメソッドを覗く"><span class="post-toc-number">1.6.4.</span> <span class="post-toc-text">4.4 defaultメソッドを覗く</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-5-ラムダ式を使った流暢なインタフェース"><span class="post-toc-number">1.6.5.</span> <span class="post-toc-text">4.5 ラムダ式を使った流暢なインタフェース</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-6-例外処理"><span class="post-toc-number">1.6.6.</span> <span class="post-toc-text">4.6 例外処理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-7-まとめ"><span class="post-toc-number">1.6.7.</span> <span class="post-toc-text">4.7 まとめ</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5章-外部リソースを扱う"><span class="post-toc-number">1.7.</span> <span class="post-toc-text">5章　外部リソースを扱う</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-1-リソースの解放"><span class="post-toc-number">1.7.1.</span> <span class="post-toc-text">5.1 リソースの解放</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-2-ラムダ式でリソース解放"><span class="post-toc-number">1.7.2.</span> <span class="post-toc-text">5.2 ラムダ式でリソース解放</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-3-ロックの管理"><span class="post-toc-number">1.7.3.</span> <span class="post-toc-text">5.3 ロックの管理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-4-簡潔な例外テストの生成"><span class="post-toc-number">1.7.4.</span> <span class="post-toc-text">5.4 簡潔な例外テストの生成</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-5-まとめ"><span class="post-toc-number">1.7.5.</span> <span class="post-toc-text">5.5 まとめ</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6章-「遅延させる」ということ"><span class="post-toc-number">1.8.</span> <span class="post-toc-text">6章　「遅延させる」ということ</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-1-初期化の遅延"><span class="post-toc-number">1.8.1.</span> <span class="post-toc-text">6.1 初期化の遅延</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-2-遅延評価"><span class="post-toc-number">1.8.2.</span> <span class="post-toc-text">6.2 遅延評価</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-3-Streamの遅延処理を活用"><span class="post-toc-number">1.8.3.</span> <span class="post-toc-text">6.3 Streamの遅延処理を活用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#6-3-1-中間処理と終端処理"><span class="post-toc-number">1.8.3.1.</span> <span class="post-toc-text">6.3.1 中間処理と終端処理</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-4-無限の「遅い」コレクションを生成"><span class="post-toc-number">1.8.4.</span> <span class="post-toc-text">6.4 無限の「遅い」コレクションを生成</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-5-まとめ"><span class="post-toc-number">1.8.5.</span> <span class="post-toc-text">6.5 まとめ</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#7章-再帰の最適化"><span class="post-toc-number">1.9.</span> <span class="post-toc-text">7章　再帰の最適化</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-1-末尾呼び出し最適化を使う"><span class="post-toc-number">1.9.1.</span> <span class="post-toc-text">7.1 末尾呼び出し最適化を使う</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7-1-2-末尾再帰に変換する"><span class="post-toc-number">1.9.1.1.</span> <span class="post-toc-text">7.1.2 末尾再帰に変換する</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-2-メモ化でスピードアップ"><span class="post-toc-number">1.9.2.</span> <span class="post-toc-text">7.2 メモ化でスピードアップ</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-3-まとめ"><span class="post-toc-number">1.9.3.</span> <span class="post-toc-text">7.3 まとめ</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#8章-ラムダ式で合成"><span class="post-toc-number">1.10.</span> <span class="post-toc-text">8章　ラムダ式で合成</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8-1-関数合成の利用"><span class="post-toc-number">1.10.1.</span> <span class="post-toc-text">8.1 関数合成の利用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8-2-MapReduceの使用"><span class="post-toc-number">1.10.2.</span> <span class="post-toc-text">8.2 MapReduceの使用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8-3-並列化への飛躍"><span class="post-toc-number">1.10.3.</span> <span class="post-toc-text">8.3 並列化への飛躍</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8-4-まとめ"><span class="post-toc-number">1.10.4.</span> <span class="post-toc-text">8.4 まとめ</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#9章-すべてをまとめて"><span class="post-toc-number">1.11.</span> <span class="post-toc-text">9章　すべてをまとめて</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#9-1-関数型スタイルで成功するために実践すべきこと"><span class="post-toc-number">1.11.1.</span> <span class="post-toc-text">9.1 関数型スタイルで成功するために実践すべきこと</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-1-1-宣言的により近く、命令型からより遠く"><span class="post-toc-number">1.11.1.1.</span> <span class="post-toc-text">9.1.1 宣言的により近く、命令型からより遠く</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-1-2-普遍性の尊重"><span class="post-toc-number">1.11.1.2.</span> <span class="post-toc-text">9.1.2 普遍性の尊重</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-1-3-副作用の削減"><span class="post-toc-number">1.11.1.3.</span> <span class="post-toc-text">9.1.3 副作用の削減</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-1-4-文より式を優先"><span class="post-toc-number">1.11.1.4.</span> <span class="post-toc-text">9.1.4 文より式を優先</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-1-5-高階関数を利用して設計"><span class="post-toc-number">1.11.1.5.</span> <span class="post-toc-text">9.1.5 高階関数を利用して設計</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#9-2-パフォーマンスの問題"><span class="post-toc-number">1.11.2.</span> <span class="post-toc-text">9.2 パフォーマンスの問題</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#9-3-関数型スタイルを採用"><span class="post-toc-number">1.11.3.</span> <span class="post-toc-text">9.3 関数型スタイルを採用</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#付録A-基本的な関数型インタフェース"><span class="post-toc-number">1.12.</span> <span class="post-toc-text">付録A 基本的な関数型インタフェース</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#A-1-Consumer"><span class="post-toc-number">1.12.1.</span> <span class="post-toc-text">A.1 Consumer</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#A-2-Supplier"><span class="post-toc-number">1.12.2.</span> <span class="post-toc-text">A.2 Supplier</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#A-3-Predicate"><span class="post-toc-number">1.12.3.</span> <span class="post-toc-text">A.3 Predicate</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#A-4-Function-lt-T-R-gt"><span class="post-toc-number">1.12.4.</span> <span class="post-toc-text">A.4 Function&lt;T, R&gt;</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#付録B-構文の基礎"><span class="post-toc-number">1.13.</span> <span class="post-toc-text">付録B 構文の基礎</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#B-1-関数型インタフェースの定義"><span class="post-toc-number">1.13.1.</span> <span class="post-toc-text">B.1 関数型インタフェースの定義</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#B-2-パラメータを持たないラムダ式の生成"><span class="post-toc-number">1.13.2.</span> <span class="post-toc-text">B.2 パラメータを持たないラムダ式の生成</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#B-3-パラメータ-1つのラムダ式の生成"><span class="post-toc-number">1.13.3.</span> <span class="post-toc-text">B.3 パラメータ 1つのラムダ式の生成</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#B-4-ラムダ式のパラメータ型を推論する"><span class="post-toc-number">1.13.4.</span> <span class="post-toc-text">B.4 ラムダ式のパラメータ型を推論する</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#B-5-パラメータ-1つのラムダ式では括弧を省略可能"><span class="post-toc-number">1.13.5.</span> <span class="post-toc-text">B.5 パラメータ 1つのラムダ式では括弧を省略可能</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#B-6-複数パラメータを持つラムダ式の生成"><span class="post-toc-number">1.13.6.</span> <span class="post-toc-text">B.6 複数パラメータを持つラムダ式の生成</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#B-7-複数の型のパラメータを持つメソッドを呼び出す"><span class="post-toc-number">1.13.7.</span> <span class="post-toc-text">B.7 複数の型のパラメータを持つメソッドを呼び出す</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#B-8-ラムダ式を変数に格納"><span class="post-toc-number">1.13.8.</span> <span class="post-toc-text">B.8 ラムダ式を変数に格納</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#B-9-複数行のラムダ式を生成"><span class="post-toc-number">1.13.9.</span> <span class="post-toc-text">B.9 複数行のラムダ式を生成</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#B-10-ラムダ式を返す"><span class="post-toc-number">1.13.10.</span> <span class="post-toc-text">B.10 ラムダ式を返す</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#B-11-ラムダ式からラムダ式を返す"><span class="post-toc-number">1.13.11.</span> <span class="post-toc-text">B.11 ラムダ式からラムダ式を返す</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#B-12-クロージャにおける静的スコープ"><span class="post-toc-number">1.13.12.</span> <span class="post-toc-text">B.12 クロージャにおける静的スコープ</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#B-13-インスタンスメソッドのメソッド参照を渡す"><span class="post-toc-number">1.13.13.</span> <span class="post-toc-text">B.13 インスタンスメソッドのメソッド参照を渡す</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#B-14-メソッド参照をstaticメソッドに渡す"><span class="post-toc-number">1.13.14.</span> <span class="post-toc-text">B.14 メソッド参照をstaticメソッドに渡す</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#B-15-メソッド参照を他のインスタンスのメソッドに渡す"><span class="post-toc-number">1.13.15.</span> <span class="post-toc-text">B.15 メソッド参照を他のインスタンスのメソッドに渡す</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#B-16-複数の引数を取るメソッドの参照を渡す"><span class="post-toc-number">1.13.16.</span> <span class="post-toc-text">B.16 複数の引数を取るメソッドの参照を渡す</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#B-17-コンストラクタ参照を使う"><span class="post-toc-number">1.13.17.</span> <span class="post-toc-text">B.17 コンストラクタ参照を使う</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#B-18-関数合成"><span class="post-toc-number">1.13.18.</span> <span class="post-toc-text">B.18 関数合成</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#付録C-Web上のリソース"><span class="post-toc-number">1.14.</span> <span class="post-toc-text">付録C Web上のリソース</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#付録D-参考文献"><span class="post-toc-number">1.15.</span> <span class="post-toc-text">付録D 参考文献</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#訳者あとがき"><span class="post-toc-number">1.16.</span> <span class="post-toc-text">訳者あとがき</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#索引"><span class="post-toc-number">1.17.</span> <span class="post-toc-text">索引</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-2020-04_Javaによる関数型プログラミングJava8ラムダ式とStream"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">2020-04_Javaによる関数型プログラミングJava8ラムダ式とStream</h1>
        <div class="post-meta">
            <time class="post-time" title="2023-06-24 14:22:58" datetime="2023-06-24T05:22:58.003Z"  itemprop="datePublished">2023-06-24</time>

            


            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="Javaによる関数型プログラミングJava8ラムダ式とStream"><a href="#Javaによる関数型プログラミングJava8ラムダ式とStream" class="headerlink" title="Javaによる関数型プログラミングJava8ラムダ式とStream"></a>Javaによる関数型プログラミングJava8ラムダ式とStream</h1><ul>
<li>著者：vankat subramaniam</li>
<li>訳：株式会社プログラミングシステム社</li>
<li>2014年10月 発行</li>
<li>オライリー本</li>
</ul>
<h2 id="まえがき"><a href="#まえがき" class="headerlink" title="まえがき"></a>まえがき</h2><h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><h3 id="対象者"><a href="#対象者" class="headerlink" title="対象者"></a>対象者</h3><ul>
<li>Java5経験者</li>
<li>他の言語で関数型プログラミングを行っていて、Javaで実施したい人</li>
<li>すでにラムダ式に詳しい人は、チームメンバーのトレーニングに使用できる</li>
</ul>
<h3 id="本書の内容"><a href="#本書の内容" class="headerlink" title="本書の内容"></a>本書の内容</h3><ul>
<li>最初から最後まで通して読むことをおすすめする（前の章で紹介した内容を後ろの章で使ってる）</li>
</ul>
<h3 id="使用するJavaのバージョン"><a href="#使用するJavaのバージョン" class="headerlink" title="使用するJavaのバージョン"></a>使用するJavaのバージョン</h3><ul>
<li><code>Java8</code>が必要</li>
</ul>
<h3 id="サンプルコードの読み方"><a href="#サンプルコードの読み方" class="headerlink" title="サンプルコードの読み方"></a>サンプルコードの読み方</h3><ul>
<li>サンプル<ul>
<li><a href="https://pragprog.com/titles/vsjava8/source_code">https://pragprog.com/titles/vsjava8/source_code</a></li>
</ul>
</li>
</ul>
<h3 id="オンラインリソース"><a href="#オンラインリソース" class="headerlink" title="オンラインリソース"></a>オンラインリソース</h3><ul>
<li>サンプルコード<ul>
<li><a href="https://pragprog.com/book/vsjava8/functional-programming-in-java">https://pragprog.com/book/vsjava8/functional-programming-in-java</a></li>
</ul>
</li>
</ul>
<h2 id="1章-Hello、ラムダ式"><a href="#1章-Hello、ラムダ式" class="headerlink" title="1章　Hello、ラムダ式"></a>1章　Hello、ラムダ式</h2><h3 id="1-1-考え方を変える"><a href="#1-1-考え方を変える" class="headerlink" title="1.1 考え方を変える"></a>1.1 考え方を変える</h3><ul>
<li>ラムダ式の紹介</li>
</ul>
<h3 id="1-2-関数型のコードによる大きな利益"><a href="#1-2-関数型のコードによる大きな利益" class="headerlink" title="1.2 関数型のコードによる大きな利益"></a>1.2 関数型のコードによる大きな利益</h3><h3 id="1-3-なぜ関数型で記述するのか"><a href="#1-3-なぜ関数型で記述するのか" class="headerlink" title="1.3 なぜ関数型で記述するのか"></a>1.3 なぜ関数型で記述するのか</h3><h3 id="1-4-革命ではなく、進化"><a href="#1-4-革命ではなく、進化" class="headerlink" title="1.4 革命ではなく、進化"></a>1.4 革命ではなく、進化</h3><h3 id="1-5-簡単にするためのほんの少しの砂糖"><a href="#1-5-簡単にするためのほんの少しの砂糖" class="headerlink" title="1.5 簡単にするためのほんの少しの砂糖"></a>1.5 簡単にするためのほんの少しの砂糖</h3><h3 id="1-6-まとめ"><a href="#1-6-まとめ" class="headerlink" title="1.6 まとめ"></a>1.6 まとめ</h3><ul>
<li>第一章はラムダ式の紹介をしていたので流し読み</li>
</ul>
<h2 id="2章-コレクションの使用"><a href="#2章-コレクションの使用" class="headerlink" title="2章　コレクションの使用"></a>2章　コレクションの使用</h2><h3 id="2-1-リストをイテレート"><a href="#2-1-リストをイテレート" class="headerlink" title="2.1 リストをイテレート"></a>2.1 リストをイテレート</h3><ul>
<li>今までの書き方から徐々にエレガントに進化させていく</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自殺点パターンと呼ぶ</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; friends.size(); i++) &#123;</span><br><span class="line">      System.out.println(friends.get(i));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 冗長でエラーが発生しやすいから</span></span><br><span class="line"><span class="comment">// &lt;i だったかな？ &lt;=i だったかな？と悩む</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上記よりは儀式が少なくなっている</span></span><br><span class="line"><span class="comment">// 特定のインデックスに対する操作がなければ、上記より優れているパターン</span></span><br><span class="line">    <span class="keyword">for</span>(String name : friends) &#123;</span><br><span class="line">      System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// これら両方とも命令形のコードであり、モダンなJavaでは捨て去ることができる</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>関数型へ移行を進める理由</p>
<ul>
<li>forループは本質的にシーケンシャルであり、並列化が極めて難しい</li>
<li>このようなループはポリモーフィックではなく、命令した通りのことを実行される。コレクションに対して（ポリモーフィックな処理を行う）メソッドを呼び出すのではなく、forループに渡している</li>
<li>設計レベルで、コードは「伝えろ、聞くな」という原則を破っている。forループではイテレーションの詳細をライブラリに任せるのではなく、特定のイテレーション処理を実行するよう要求している</li>
</ul>
</li>
<li><p>Tell, Don’t Ask <a href="https://www.jabba.cloud/20150912232135/">https://www.jabba.cloud/20150912232135/</a></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"//"</span> + <span class="string">"START:INTERNAL_OUTPUT"</span>);</span><br><span class="line">friends.forEach((<span class="keyword">final</span> String name) -&gt; System.out.println(name));</span><br><span class="line">System.out.println(<span class="string">"//"</span> + <span class="string">"END:INTERNAL_OUTPUT"</span>);</span><br><span class="line"></span><br><span class="line">friends.forEach((name) -&gt; System.out.println(name));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 型推論されたパラメータはfinalが保証されなくなる</span></span><br><span class="line"><span class="comment">// 引数を変更しない習慣を開発者自身が身につける必要がある</span></span><br><span class="line">friends.forEach(name -&gt; System.out.println(name));</span><br><span class="line"></span><br><span class="line">friends.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h3 id="2-2-リストの変換"><a href="#2-2-リストの変換" class="headerlink" title="2.2 リストの変換"></a>2.2 リストの変換</h3><h4 id="2-2-1-ラムダ式を使う"><a href="#2-2-1-ラムダ式を使う" class="headerlink" title="2.2.1 ラムダ式を使う"></a>2.2.1 ラムダ式を使う</h4><ul>
<li>map()メソッドについて：連続した入力を連続した出力に変換します</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// こうじゃなくて</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;String&gt; uppercaseNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    friends.forEach(name -&gt; uppercaseNames.add(name.toUpperCase()));</span><br><span class="line">    System.out.println(uppercaseNames);</span><br><span class="line"></span><br><span class="line"><span class="comment">// こう書く</span></span><br><span class="line">    friends.stream()</span><br><span class="line">           .map(name -&gt; name.toUpperCase())</span><br><span class="line">           .forEach(name -&gt; System.out.print(name + <span class="string">" "</span>));</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-メソッド参照を使用"><a href="#2-2-2-メソッド参照を使用" class="headerlink" title="2.2.2 メソッド参照を使用"></a>2.2.2 メソッド参照を使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">friends.stream()</span><br><span class="line">       .map(String::toUpperCase)</span><br><span class="line">       .forEach(name -&gt; System.out.println(name));</span><br></pre></td></tr></table></figure>

<ul>
<li>メソッド参照の使い所<ul>
<li>ラムダ式が非常に短い場合や、ラムダ式がインスタンスメソッドやstaticメソッドをシンプルで直接的に呼び出している場合における優れた代替手段</li>
<li>映画「Offiece Space」のTom Smykowskiのようなもの…　著者が例えている</li>
<li>→個人的に「Offiece-spaceパターン」とよんでいる</li>
</ul>
</li>
</ul>
<h3 id="2-3-要素の検索"><a href="#2-3-要素の検索" class="headerlink" title="2.3 要素の検索"></a>2.3 要素の検索</h3><ul>
<li>fileter()<ul>
<li>コレクションから要素を抜き出すために用いる</li>
<li>map()メソッドと同様にイテレーターを返すが、同じ要素数返すとは限らない</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;String&gt; startsWithN = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String name : friends) &#123;</span><br><span class="line">      <span class="keyword">if</span>(name.startsWith(<span class="string">"N"</span>)) &#123;</span><br><span class="line">        startsWithN.add(name);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(String.format(<span class="string">"Found %d names"</span>, startsWithN.size()));</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;String&gt; startsWithN =</span><br><span class="line">      friends.stream()</span><br><span class="line">             .filter(name -&gt; name.startsWith(<span class="string">"N"</span>))</span><br><span class="line">             .collect(Collectors.toList());</span><br><span class="line">    System.out.println(String.format(<span class="string">"Found %d names"</span>, startsWithN.size()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-ラムダ式の再利用"><a href="#2-4-ラムダ式の再利用" class="headerlink" title="2.4 ラムダ式の再利用"></a>2.4 ラムダ式の再利用</h3><ul>
<li>ラムダ式を定義しておいて重複をなくそうという説明</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Predicate&lt;String&gt; startsWithN = name -&gt; name.startsWith(<span class="string">"N"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> countFriendsStartN =</span><br><span class="line">  friends.stream()</span><br><span class="line">         .filter(startsWithN)</span><br><span class="line">         .count();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> countEditorsStartN =</span><br><span class="line">  editors.stream()</span><br><span class="line">         .filter(startsWithN)</span><br><span class="line">         .count();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> countComradesStartN =</span><br><span class="line">  comrades.stream()</span><br><span class="line">          .filter(startsWithN)</span><br><span class="line">          .count();</span><br></pre></td></tr></table></figure>

<ul>
<li>DRYの原則</li>
</ul>
<h3 id="2-5-静的スコープとクロージャ"><a href="#2-5-静的スコープとクロージャ" class="headerlink" title="2.5 静的スコープとクロージャ"></a>2.5 静的スコープとクロージャ</h3><ul>
<li><p>ラムダ式内は実質的にfinalな変数しか使えない</p>
</li>
<li><p><code>Predicate&lt;T&gt;</code>は<code>T</code>型を引数に取り、関数が行う検査の結果として<code>boolean</code>を返却。候補値の取捨選択を行う際に利用できる。</p>
</li>
<li><p><code>Function&lt;T,R&gt;</code>は<code>T</code>型の引数を取り、<code>R</code>型の結果を返す関数。常に<code>boolean</code>を返却する<code>Predicate&lt;T&gt;</code>より汎用的。</p>
</li>
<li><p><code>Optional</code>クラスは、結果が存在しない可能性がある場合に便利</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Function&lt;String, Predicate&lt;String&gt;&gt; startsWithLetter =</span><br><span class="line">  letter -&gt; name -&gt; name.startsWith(letter);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> countFriendsStartN =</span><br><span class="line">  friends.stream()</span><br><span class="line">         .filter(startsWithLetter.apply(<span class="string">"N"</span>)).count();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> countFriendsStartB =</span><br><span class="line">  friends.stream()</span><br><span class="line">         .filter(startsWithLetter.apply(<span class="string">"B"</span>)).count();</span><br></pre></td></tr></table></figure>

<ul>
<li>MEMO: Functionで囲うメリットがいまいち理解できていない（2020-04-26 14:52:51）</li>
</ul>
<h3 id="2-6-要素を-1つ選択"><a href="#2-6-要素を-1つ選択" class="headerlink" title="2.6 要素を 1つ選択"></a>2.6 要素を 1つ選択</h3><ul>
<li>Null初期化は、Nullであることを確認する作業が必要になって来る<ul>
<li>これを忘れるとNullpointerExcepiton</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// エレガントな例</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pickName</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> List&lt;String&gt; names, <span class="keyword">final</span> String startingLetter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Optional&lt;String&gt; foundName = </span><br><span class="line">      names.stream()</span><br><span class="line">           .filter(name -&gt;name.startsWith(startingLetter))</span><br><span class="line">           .findFirst();</span><br><span class="line">    System.out.println(String.format(<span class="string">"A name starting with %s: %s"</span>,</span><br><span class="line">      startingLetter, foundName.orElse(<span class="string">"No name found"</span>)));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>OptionalはNull脱臭剤</li>
</ul>
<h3 id="2-7-コレクションを単一の値に集約（reduce）"><a href="#2-7-コレクションを単一の値に集約（reduce）" class="headerlink" title="2.7 コレクションを単一の値に集約（reduce）"></a>2.7 コレクションを単一の値に集約（reduce）</h3><ul>
<li>本節では、要素の比較や計算状態をコレクションに渡って持ち越して使用する方法を学ぶ</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"//"</span> + <span class="string">"START:SUM_OUTPUT"</span>);</span><br><span class="line">      System.out.println(<span class="string">"Total number of characters in all names: "</span> +</span><br><span class="line">        friends.stream()</span><br><span class="line">               .mapToInt(name -&gt; name.length())</span><br><span class="line">               .sum());</span><br><span class="line">    &#125;</span><br><span class="line">System.out.println(<span class="string">"//"</span> + <span class="string">"END:SUM_OUTPUT"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"//"</span> + <span class="string">"END:AVERAGE_OUTPUT"</span>);</span><br><span class="line">System.out.println(<span class="string">"//"</span> + <span class="string">"START:REDUCE_OUTPUT"</span>);</span><br><span class="line">    <span class="keyword">final</span> Optional&lt;String&gt; aLongName =</span><br><span class="line">      friends.stream()</span><br><span class="line">             .reduce((name1, name2) -&gt;</span><br><span class="line">                name1.length() &gt;= name2.length() ? name1 : name2);</span><br><span class="line">    aLongName.ifPresent(name -&gt;</span><br><span class="line">      System.out.println(String.format(<span class="string">"A longest name: %s"</span>, name)));</span><br><span class="line">System.out.println(<span class="string">"//"</span> + <span class="string">"END:REDUCE_OUTPUT"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String steveOrLonger =</span><br><span class="line">      friends.stream()</span><br><span class="line">             .reduce(<span class="string">"Steve"</span>, (name1, name2) -&gt;</span><br><span class="line">                name1.length() &gt;= name2.length() ? name1 : name2);</span><br><span class="line"></span><br><span class="line">    System.out.println(steveOrLonger);</span><br></pre></td></tr></table></figure>

<h3 id="2-8-要素の結合"><a href="#2-8-要素の結合" class="headerlink" title="2.8 要素の結合"></a>2.8 要素の結合</h3><ul>
<li>StringJoinerの説明</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"//"</span> + <span class="string">"START:MAP_JOIN_OUTPUT"</span>);</span><br><span class="line">    System.out.println(</span><br><span class="line">      friends.stream()</span><br><span class="line">             .map(String::toUpperCase)</span><br><span class="line">             .collect(joining(<span class="string">", "</span>)));</span><br><span class="line">System.out.println(<span class="string">"//"</span> + <span class="string">"END:MAP_JOIN_OUTPUT"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-9-まとめ"><a href="#2-9-まとめ" class="headerlink" title="2.9 まとめ"></a>2.9 まとめ</h3><ul>
<li>コレクションはプログラムにおいてはありふれたもので、</li>
<li>ラムダ式によりJavaにおけるコレクションの利用は従来よりも遥かに簡単で単純になりました</li>
<li>記述するコード量が減少し、保守性が高くなる</li>
</ul>
<h2 id="3章-文字列、コンパレータ、フィルタ"><a href="#3章-文字列、コンパレータ、フィルタ" class="headerlink" title="3章　文字列、コンパレータ、フィルタ"></a>3章　文字列、コンパレータ、フィルタ</h2><ul>
<li>ラムダ式とメソッド参照を使用してSringをいてレートし、Comparatorを実装し、ディレクトリのファイルリストを取得し、</li>
<li>そしてファイルやディレクトリを監視します</li>
</ul>
<h3 id="3-1-文字列のイテレーション"><a href="#3-1-文字列のイテレーション" class="headerlink" title="3.1 文字列のイテレーション"></a>3.1 文字列のイテレーション</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"//"</span> + <span class="string">"START:ITERATE_OUTPUT"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> String str = <span class="string">"w00t"</span>;</span><br><span class="line"></span><br><span class="line">str.chars()</span><br><span class="line">   .forEach(ch -&gt; System.out.println(ch));</span><br><span class="line">System.out.println(<span class="string">"//"</span> + <span class="string">"END:ITERATE_OUTPUT"</span>);</span><br><span class="line"></span><br><span class="line">str.chars()</span><br><span class="line">   .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"//"</span> + <span class="string">"START:FIX_OUTPUT"</span>);</span><br><span class="line">str.chars()</span><br><span class="line">   .forEach(IterateString::printChar);</span><br><span class="line">System.out.println(<span class="string">"//"</span> + <span class="string">"END:FIX_OUTPUT"</span>);</span><br><span class="line"></span><br><span class="line">    str.chars()</span><br><span class="line">       .mapToObj(ch -&gt; Character.valueOf((<span class="keyword">char</span>)ch))</span><br><span class="line">       .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"//"</span> + <span class="string">"START:FILTER_OUTPUT"</span>);</span><br><span class="line">str.chars()</span><br><span class="line">   .filter(ch -&gt; Character.isDigit(ch))</span><br><span class="line">   .forEach(ch -&gt; printChar(ch));</span><br><span class="line">System.out.println(<span class="string">""</span>);</span><br><span class="line">System.out.println(<span class="string">"//"</span> + <span class="string">"END:FILTER_OUTPUT"</span>);</span><br><span class="line"></span><br><span class="line">str.chars()</span><br><span class="line">   .filter(ch -&gt; Character.isDigit(ch));</span><br><span class="line"></span><br><span class="line">str.chars()</span><br><span class="line">   .filter(Character::isDigit);</span><br><span class="line"></span><br><span class="line">str.chars()</span><br><span class="line">   .filter(Character::isDigit)</span><br><span class="line">   .forEach(IterateString::printChar);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>インスタンスメソッドのメソッド参照（String::toUppercase）と、staticメソッドのメソッド参照（Character::isDigit）は構造的に同じように見えるが異なる</p>
</li>
<li><p>インスタンスメソッド： <code>引数.toUppercase();</code></p>
</li>
<li><p>staticメソッド： <code>Character.isDigit(引数);</code></p>
</li>
<li><p>インスタンスメソッドとstaticメソッドの定義が衝突すると、</p>
</li>
<li><p>どちらを使用していいかコンパイラが判断できなくなりコンパイルエラーとなる</p>
<ul>
<li>→この場合はラムダ式を使う！</li>
<li>ラムダ式とメソッド参照を自由自在に切り替えられるようになる</li>
</ul>
</li>
</ul>
<h3 id="3-2-Comparatorインタフェースを実装"><a href="#3-2-Comparatorインタフェースを実装" class="headerlink" title="3.2 Comparatorインタフェースを実装"></a>3.2 Comparatorインタフェースを実装</h3><ul>
<li><code>List</code>の<code>sort()メソッド</code>だと戻り値が<code>void</code>なので、リスト本体が変更されてしまう</li>
<li>コピーを取得した上で、変更する必要があったが、面倒</li>
<li>代わりにStreamの力を借りて処理する方法を考える</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">people.sorted((person1,person2) -&gt; person1.ageDifference(person2)).collect(toList());</span><br><span class="line"><span class="comment">// ↓改善</span></span><br><span class="line">people.stream().sorted(Person::ageDifference).collect(toList());</span><br></pre></td></tr></table></figure>

<ul>
<li>逆順にしたい場合</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">people.stream().sorted((person1, person2) -&gt; person2.ageDifference(person1)).collect(toList());</span><br><span class="line"><span class="comment">// パラメータの順番が引数受け渡しの規約に従っていないため、メソッド参照を使うようにリファクタリングすることはできません。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>事前に<code>Comparator</code>を定義しておいて、使用することで簡潔に記載できる</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;Person&gt; people = Arrays.asList(</span><br><span class="line">      <span class="keyword">new</span> Person(<span class="string">"John"</span>, <span class="number">20</span>),</span><br><span class="line">      <span class="keyword">new</span> Person(<span class="string">"Sara"</span>, <span class="number">21</span>),</span><br><span class="line">      <span class="keyword">new</span> Person(<span class="string">"Jane"</span>, <span class="number">21</span>),</span><br><span class="line">      <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">35</span>));</span><br><span class="line"></span><br><span class="line">&#123;  </span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"START:AGE_ASCEND_OUTPUT"</span>);</span><br><span class="line">    List&lt;Person&gt; ascendingAge = </span><br><span class="line">      people.stream()</span><br><span class="line">            .sorted((person1, person2) -&gt; person1.ageDifference(person2))</span><br><span class="line">            .collect(toList());</span><br><span class="line">    printPeople(<span class="string">"Sorted in ascending order by age: "</span>, ascendingAge);</span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"END:AGE_ASCEND_OUTPUT"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;  </span><br><span class="line">  <span class="comment">// メソッド参照（Method Reference）</span></span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"START:AGE_ASCEND_MR_OUTPUT"</span>);</span><br><span class="line">    List&lt;Person&gt; ascendingAge = </span><br><span class="line">      people.stream()</span><br><span class="line">            .sorted(Person::ageDifference)</span><br><span class="line">            .collect(toList());</span><br><span class="line"></span><br><span class="line">    printPeople(<span class="string">"Sorted in ascending order by age: "</span>, ascendingAge);</span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"END:AGE_ASCEND_MR_OUTPUT"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"START:AGE_DESCEND_OUTPUT"</span>);</span><br><span class="line">    printPeople(<span class="string">"Sorted in descending order by age: "</span>,</span><br><span class="line">      people.stream()</span><br><span class="line">            .sorted((person1, person2) -&gt; person2.ageDifference(person1))</span><br><span class="line">            .collect(toList()));</span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"END:AGE_DESCEND_OUTPUT"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"START:REVERSE_ORDER_OUTPUT"</span>);</span><br><span class="line">    Comparator&lt;Person&gt; compareAscending = </span><br><span class="line">      (person1, person2) -&gt; person1.ageDifference(person2);</span><br><span class="line">      <span class="comment">// reversed()を使うことで降順の関数を事前に用意できる</span></span><br><span class="line">    Comparator&lt;Person&gt; compareDescending = compareAscending.reversed();</span><br><span class="line"></span><br><span class="line">    printPeople(<span class="string">"Sorted in ascending order by age: "</span>,</span><br><span class="line">      people.stream()</span><br><span class="line">            .sorted(compareAscending)</span><br><span class="line">            .collect(toList())</span><br><span class="line">    );</span><br><span class="line">    printPeople(<span class="string">"Sorted in descending order by age: "</span>,</span><br><span class="line">      people.stream()</span><br><span class="line">            .sorted(compareDescending)</span><br><span class="line">            .collect(toList())</span><br><span class="line">    );</span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"END:REVERSE_ORDER_OUTPUT"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 名前の昇順に並び替え</span></span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"START:NAME_ASCEND_OUTPUT"</span>);</span><br><span class="line">    printPeople(<span class="string">"Sorted in ascending order by name: "</span>,</span><br><span class="line">      people.stream()</span><br><span class="line">            .sorted((person1, person2) -&gt; </span><br><span class="line">               person1.getName().compareTo(person2.getName()))</span><br><span class="line">            .collect(toList()));</span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"END:NAME_ASCEND_OUTPUT"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// min()メソッドはOptionalを返す！</span></span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"START:YOUNGEST_OUTPUT"</span>);</span><br><span class="line">    people.stream()</span><br><span class="line">          .min(Person::ageDifference)</span><br><span class="line">          .ifPresent(youngest -&gt; System.out.println(<span class="string">"Youngest: "</span> + youngest));</span><br><span class="line">System.out.println(<span class="string">"//"</span> + <span class="string">"END:YOUNGEST_OUTPUT"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"START:ELDEST_OUTPUT"</span>);</span><br><span class="line">    people.stream()</span><br><span class="line">          .max(Person::ageDifference)</span><br><span class="line">          .ifPresent(eldest -&gt; System.out.println(<span class="string">"Eldest: "</span> + eldest));</span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"END:ELDEST_OUTPUT"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-複数のプロパティによる流暢な比較"><a href="#3-3-複数のプロパティによる流暢な比較" class="headerlink" title="3.3 複数のプロパティによる流暢な比較"></a>3.3 複数のプロパティによる流暢な比較</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 名前のアルファベット順にするために以下の関数を用意した</span></span><br><span class="line">    <span class="comment">// 従来の内部クラス構文と比較すると非常に簡潔</span></span><br><span class="line">    people.stream()</span><br><span class="line">          .sorted((person1, person2) -&gt; </span><br><span class="line">             person1.getName().compareTo(person2.getName()));</span><br><span class="line"></span><br><span class="line">    printPeople(<span class="string">"Sorted in ascending order by name: "</span>,</span><br><span class="line">    people.stream()</span><br><span class="line">          .sorted(comparing((Person person) -&gt; person.getName()))</span><br><span class="line">          .collect(toList()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Comparatorインターフェースのコンビニエンス関数を使用することで、より自由にコードの目的を表現できる</span></span><br><span class="line">    <span class="comment">// Comparaotrインターフェースのcomparing()メソッドを静的にインポートしました。comparing()メソッドは与えられた</span></span><br><span class="line">    <span class="comment">// ラムダ式のロジックを使用してComparatorを生成する！</span></span><br><span class="line">    <span class="comment">// つまり、関数（Function）を引数に取り、関数（Comparator）を返す高階関数</span></span><br><span class="line">    <span class="keyword">final</span> Function&lt;Person, String&gt; byName = person -&gt; person.getName();</span><br><span class="line">    people.stream()</span><br><span class="line">          .sorted(comparing(byName));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"START:SORT_NAME_AND_AGE_OUTPUT"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> Function&lt;Person, Integer&gt; byAge = person -&gt; person.getAge();</span><br><span class="line">    <span class="keyword">final</span> Function&lt;Person, String&gt; byTheirName = person -&gt; person.getName();</span><br><span class="line">    </span><br><span class="line">    printPeople(<span class="string">"Sorted in ascending order by age and name: "</span>,</span><br><span class="line">      people.stream()</span><br><span class="line">            .sorted(comparing(byAge).thenComparing(byTheirName))</span><br><span class="line">            .collect(toList()));</span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"END:SORT_NAME_AND_AGE_OUTPUT"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>このように、Comparatorの実装をラムダ式やJDKの新たなユーティリティクラスを使用して簡単に合成できる<ul>
<li>MEMO: 少し納得してないので再度確認</li>
</ul>
</li>
</ul>
<h3 id="3-4-collectメソッドとCollectorsクラスの使用"><a href="#3-4-collectメソッドとCollectorsクラスの使用" class="headerlink" title="3.4 collectメソッドとCollectorsクラスの使用"></a>3.4 collectメソッドとCollectorsクラスの使用</h3><ul>
<li>これまでに、Streamの要素をArrayListに変換する例でcollect()メソッドを数回使用している<ul>
<li>このメソッドは、あるコレクションを可変コレクションなど他のデータ型へ変換する際に便利な集約処理を行います</li>
<li>collect()関数はCollectorsクラスのユーティリティメソッドと組み合わせるととても便利</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 20歳以上の人を抽出してリストを取得する</span></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">// 従来の書き方</span></span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"START:MUTABLE_OUTPUT"</span>);</span><br><span class="line">    List&lt;Person&gt; olderThan20 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      people.stream()</span><br><span class="line">            .filter(person -&gt; person.getAge() &gt; <span class="number">20</span>)</span><br><span class="line">            .forEach(person -&gt; olderThan20.add(person));</span><br><span class="line">    System.out.println(<span class="string">"People older than 20: "</span> + olderThan20);</span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"END:MUTABLE_OUTPUT"</span>);</span><br><span class="line">    <span class="comment">// 問題点：</span></span><br><span class="line">    <span class="comment">// ターゲットとするコレクションに要素を１つずつ追加する保s理はとても低レベルなもので、宣言型ではなく命令形のコード</span></span><br><span class="line">    <span class="comment">// 並列に実行させる場合にはスレッドセーフ問題を適切に処理しなければならない</span></span><br><span class="line">    <span class="comment">// 可変性を持つコードを並列化するのは難しいものです。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// この問題はcollect()を使うことで緩和できる</span></span><br><span class="line"><span class="comment">// collect()メソッドの以下の３つについて知っておく</span></span><br><span class="line"><span class="comment">// サプライヤ　　：結果を収めるコンテナの精製方法（例えば、ArrayList::new）</span></span><br><span class="line"><span class="comment">// アキュムレータ：結果コンテナに単一の要素を追加する方法（例えばArrayList::add）</span></span><br><span class="line"><span class="comment">// コンバイナ　　：結果コンテナを他のコンテナと結合する方法（例えばArrayList::addAll）</span></span><br><span class="line"></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">// 便利な書き方！</span></span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"START:COLLECT_OUTPUT"</span>);</span><br><span class="line">    List&lt;Person&gt; olderThan20 = </span><br><span class="line">      people.stream()</span><br><span class="line">            .filter(person -&gt; person.getAge() &gt; <span class="number">20</span>)</span><br><span class="line">            .collect(ArrayList::<span class="keyword">new</span>, ArrayList::add, ArrayList::addAll);</span><br><span class="line">    System.out.println(<span class="string">"People older than 20: "</span> + olderThan20);</span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"END:COLLECT_OUTPUT"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// メリット：</span></span><br><span class="line"><span class="comment">// より明確で意図を持ったプログラミングを行っている→ArrayListに処理結果を集めることがこのコードの目的</span></span><br><span class="line"><span class="comment">// コード内で状態変更を行っていないため、イテレーションを簡単に並列化できる</span></span><br></pre></td></tr></table></figure>

<ul>
<li>次は基本の<code>collect()</code>メソッドよりも簡潔で便利な、オーバーロードされたcollect()メソッドを見ていく</li>
<li>このメソッドはCollectorを引数に取ります</li>
<li>Collectorはcollect()メソッドに設定された３つの異なるパラメータをカプセル化した、より簡単で再利用可能なインターフェース</li>
<li>様々なCollectorの実装を提供するCollectorsクラスにtoList()というコンビニエンスメソッドがある</li>
<li>このメソッドはArrayListに要素を蓄積するメソッドで、Collectorインターフェースの実装</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"START:COLLECT_TO_LIST_OUTPUT"</span>);</span><br><span class="line">    List&lt;Person&gt; olderThan20 = </span><br><span class="line">      people.stream()</span><br><span class="line">            .filter(person -&gt; person.getAge() &gt; <span class="number">20</span>)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    System.out.println(<span class="string">"People older than 20: "</span> + olderThan20);</span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"END:COLLECT_TO_LIST_OUTPUT"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>他にも色々集計できるよっていう説明!<ul>
<li><a href="https://docs.oracle.com/javase/jp/8/docs/api/java/util/stream/Collectors.html">https://docs.oracle.com/javase/jp/8/docs/api/java/util/stream/Collectors.html</a></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;  </span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"START:GROUP_BY_OUTPUT"</span>);</span><br><span class="line">    Map&lt;Integer, List&lt;Person&gt;&gt; peopleByAge = </span><br><span class="line">      people.stream()</span><br><span class="line">            .collect(Collectors.groupingBy(Person::getAge));</span><br><span class="line">    System.out.println(<span class="string">"Grouped by age: "</span> + peopleByAge);</span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"END:GROUP_BY_OUTPUT"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;  </span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"START:GROUP_BY_AGE_NAME_OUTPUT"</span>);</span><br><span class="line">    Map&lt;Integer, List&lt;String&gt;&gt; nameOfPeopleByAge = </span><br><span class="line">      people.stream()</span><br><span class="line">            .collect(</span><br><span class="line">              groupingBy(Person::getAge, mapping(Person::getName, toList())));</span><br><span class="line">    System.out.println(<span class="string">"People grouped by age: "</span> + nameOfPeopleByAge);</span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"END:GROUP_BY_AGE_NAME_OUTPUT"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;  </span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"START:OLDEST_IN_EACH_LETTER_OUTPUT"</span>);</span><br><span class="line">    Comparator&lt;Person&gt; byAge = Comparator.comparing(Person::getAge);</span><br><span class="line">    Map&lt;Character, Optional&lt;Person&gt;&gt; oldestPersonOfEachLetter = </span><br><span class="line">      people.stream()</span><br><span class="line">            .collect(groupingBy(person -&gt; person.getName().charAt(<span class="number">0</span>),</span><br><span class="line">               reducing(BinaryOperator.maxBy(byAge))));</span><br><span class="line">    System.out.println(<span class="string">"Oldest person of each letter:"</span>);</span><br><span class="line">    System.out.println(oldestPersonOfEachLetter);</span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"END:OLDEST_IN_EACH_LETTER_OUTPUT"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>MEMO: 集計関数を実際に色々使ってみる！！</li>
</ul>
<h3 id="3-5-ディレクトリの全ファイルをリスト"><a href="#3-5-ディレクトリの全ファイルをリスト" class="headerlink" title="3.5 ディレクトリの全ファイルをリスト"></a>3.5 ディレクトリの全ファイルをリスト</h3><ul>
<li><p><code>File</code>クラスの<code>list()</code>メソッドを使うと、ディレクトリにある全ファイル名を簡単にリスト化できる</p>
</li>
<li><p>ファイル名だけでなくすべてのファイルを取得する場合は<code>listFiles()</code>メソッドが使える</p>
</li>
<li><p>ファイルを取得したあとの処理が大変</p>
</li>
<li><p>ここでは、従来のくどい外部イテレータを使用するのではなく、エレガントな関数型スタイルの機能を使ってリストをイテレートしていく</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下の２つとも古いjavaより格段にシンプル</span></span><br><span class="line">Files.list(Paths.get(<span class="string">"."</span>))</span><br><span class="line">     .forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line">Files.list(Paths.get(<span class="string">"."</span>))</span><br><span class="line">     .filter(Files::isDirectory) <span class="comment">// filterはPredicateを期待する</span></span><br><span class="line">     .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-ディレクトリの特定のファイルだけをリスト"><a href="#3-6-ディレクトリの特定のファイルだけをリスト" class="headerlink" title="3.6 ディレクトリの特定のファイルだけをリスト"></a>3.6 ディレクトリの特定のファイルだけをリスト</h3><ul>
<li>特定のファイル名取得のためにオーバーロードされたFileクラスのlist()メソッドを提供してきました</li>
<li>このlist()メソッドはFilenameFilterインターフェースを引数に取ります</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String[] files =</span><br><span class="line">  <span class="keyword">new</span> File(<span class="string">"fpij"</span>).list(<span class="keyword">new</span> java.io.FilenameFilter() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(<span class="keyword">final</span> File dir, <span class="keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name.endsWith(<span class="string">".java"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>これをラムダ式に置き換える！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  Files.newDirectoryStream(</span><br><span class="line">       Paths.get(<span class="string">"fpij"</span>), path -&gt; path.toString().endsWith(<span class="string">".java"</span>))</span><br><span class="line">   .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-7-flatMapで直下のサブディレクトリをリスト"><a href="#3-7-flatMapで直下のサブディレクトリをリスト" class="headerlink" title="3.7 flatMapで直下のサブディレクトリをリスト"></a>3.7 flatMapで直下のサブディレクトリをリスト</h3><ul>
<li>与えられたディレクトリ直下のサブディレクトリを探索する方法を解説する</li>
<li>最初に原始的な方法を説明し、次により便利なflatMap()メソッド（Streamクラス）を使用する</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listTheHardWay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  List&lt;File&gt; files = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  File[] filesInCurrentDir = <span class="keyword">new</span> File(<span class="string">"."</span>).listFiles();</span><br><span class="line">  <span class="keyword">for</span>(File file : filesInCurrentDir) &#123;</span><br><span class="line">    File[] filesInSubDir = file.listFiles();</span><br><span class="line">    <span class="keyword">if</span>(filesInSubDir != <span class="keyword">null</span>) &#123;</span><br><span class="line">      files.addAll(Arrays.asList(filesInSubDir));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      files.add(file);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"Count: "</span> + files.size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">betterWay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  List&lt;File&gt; files =</span><br><span class="line">    Stream.of(<span class="keyword">new</span> File(<span class="string">"."</span>).listFiles())</span><br><span class="line">          .flatMap(file -&gt; file.listFiles() == <span class="keyword">null</span> ? </span><br><span class="line">              Stream.of(file) : Stream.of(file.listFiles()))</span><br><span class="line">          .collect(toList());</span><br><span class="line">  System.out.println(<span class="string">"Count: "</span> + files.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>MEMO: モナド合成という言葉が出てきたが、いまいち意味がわからない</li>
</ul>
<h3 id="3-8-ファイルの変更を監視"><a href="#3-8-ファイルの変更を監視" class="headerlink" title="3.8 ファイルの変更を監視"></a>3.8 ファイルの変更を監視</h3><ul>
<li>ファイルが生成・変更・削除される際のアラートも簡単に実現できる</li>
<li>Java7で追加されたWatchServiceの機能を紹介</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> Thread(() -&gt; watchFileChange()).start();</span><br><span class="line">  <span class="keyword">final</span> File file = <span class="keyword">new</span> File(<span class="string">"sample.txt"</span>);</span><br><span class="line">  file.createNewFile();</span><br><span class="line">  Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">  file.setLastModified(System.currentTimeMillis());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">watchFileChange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Path path = Paths.get(<span class="string">"."</span>);</span><br><span class="line">    <span class="keyword">final</span> WatchService watchService = </span><br><span class="line">      path.getFileSystem()</span><br><span class="line">          .newWatchService();</span><br><span class="line">      </span><br><span class="line">    path.register(watchService, StandardWatchEventKinds.ENTRY_MODIFY);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"Report any file changed within next 1 minute..."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> WatchKey watchKey = watchService.poll(<span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(watchKey != <span class="keyword">null</span>) &#123;</span><br><span class="line">      watchKey.pollEvents()</span><br><span class="line">              .stream()</span><br><span class="line">              .forEach(event -&gt;</span><br><span class="line">                 System.out.println(event.context()));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(InterruptedException | IOException ex) &#123;</span><br><span class="line">    System.out.println(ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-9-まとめ"><a href="#3-9-まとめ" class="headerlink" title="3.9 まとめ"></a>3.9 まとめ</h3><ul>
<li>文字列操作やファイル処理、カスタムコンパレータの生成などの定型タスクはラムダ式とメソッド参照によって非常に楽に、簡潔になりました。</li>
</ul>
<h2 id="4章-ラムダ式で設計する"><a href="#4章-ラムダ式で設計する" class="headerlink" title="4章　ラムダ式で設計する"></a>4章　ラムダ式で設計する</h2><ul>
<li>本章では、ラムダ式が巧妙なデザインアイデアに生命を与える</li>
<li>これまではオブジェクトを使用していた箇所を軽量関数で代用できる</li>
</ul>
<h3 id="4-1-ラムダ式を使った関心の分離"><a href="#4-1-ラムダ式を使った関心の分離" class="headerlink" title="4.1 ラムダ式を使った関心の分離"></a>4.1 ラムダ式を使った関心の分離</h3><ul>
<li>コードの再利用のためにクラスを生成することは良い心がけですが、それが常に正しいとは限らない</li>
<li>クラスの代わりに高階関数を使うことで、クラス階層を必要とせずに同じことが達成できる</li>
</ul>
<h4 id="4-1-1-デザイン問題の探求"><a href="#4-1-1-デザイン問題の探求" class="headerlink" title="4.1.1 デザイン問題の探求"></a>4.1.1 デザイン問題の探求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Asset</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">enum</span> AssetType &#123; BOND, STOCK &#125;; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AssetType type;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Asset</span><span class="params">(<span class="keyword">final</span> AssetType assetType, <span class="keyword">final</span> <span class="keyword">int</span> assetValue)</span> </span>&#123;</span><br><span class="line">    type = assetType;</span><br><span class="line">    value = assetValue;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> AssetType <span class="title">getType</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> type; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Utilクラス</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">totalAssetValues</span><span class="params">(<span class="keyword">final</span> List&lt;Asset&gt; assets)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> assets.stream()</span><br><span class="line">                 .mapToInt(Asset::getValue)</span><br><span class="line">                 .sum();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ラムダ式を使って、totalAssetValues()メソッドを書き、流暢なイテレータと好むべき不変性を使いました</li>
<li>しかし今はメソッド自身の設計に目を向けましょう</li>
<li>このメソッドでは<ul>
<li>どのようにイテレーションを行うか</li>
<li>何を合計するか</li>
<li>どのように合計するか<ul>
<li>といった３つの問題が絡み合っている</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-1-2-問題でがんじがらめ"><a href="#4-1-2-問題でがんじがらめ" class="headerlink" title="4.1.2 問題でがんじがらめ"></a>4.1.2 問題でがんじがらめ</h4><ul>
<li>資産のうち、債券（bond）だけを合計したい場合を考える</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">totalBondValues</span><span class="params">(<span class="keyword">final</span> List&lt;Asset&gt; assets)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> assets.stream()</span><br><span class="line">               .mapToInt(asset -&gt; </span><br><span class="line">                  asset.getType() == AssetType.BOND ? asset.getValue() : <span class="number">0</span>)</span><br><span class="line">               .sum();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">totalStockValues</span><span class="params">(<span class="keyword">final</span> List&lt;Asset&gt; assets)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> assets.stream()</span><br><span class="line">               .mapToInt(asset -&gt; </span><br><span class="line">                  asset.getType() == AssetType.STOCK ? asset.getValue() : <span class="number">0</span>)</span><br><span class="line">               .sum();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>こんなふうにコピペで増やしていって良いでしょうか？</li>
<li>DRYの原則に従ってもう少しましな設計をしましょう</li>
</ul>
<h4 id="4-1-3-主要な関心の分離"><a href="#4-1-3-主要な関心の分離" class="headerlink" title="4.1.3 主要な関心の分離"></a>4.1.3 主要な関心の分離</h4><ul>
<li>イテレーションと合計を求める方法は同じですが、「何を」合計するかが異なります</li>
<li>この「何を合計するか」部分はメソッドから切り離す良い候補</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">totalAssetValues</span><span class="params">(<span class="keyword">final</span> List&lt;Asset&gt; assets,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">final</span> Predicate&lt;Asset&gt; assetSelector)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> assets.stream()</span><br><span class="line">               .filter(assetSelector)</span><br><span class="line">               .mapToInt(Asset::getValue)</span><br><span class="line">               .sum();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</span><br><span class="line">  List&lt;Asset&gt; assets = Arrays.asList(</span><br><span class="line">    <span class="keyword">new</span> Asset(Asset.AssetType.BOND, <span class="number">1000</span>),</span><br><span class="line">    <span class="keyword">new</span> Asset(Asset.AssetType.BOND, <span class="number">2000</span>),</span><br><span class="line">    <span class="keyword">new</span> Asset(Asset.AssetType.STOCK, <span class="number">3000</span>),</span><br><span class="line">    <span class="keyword">new</span> Asset(Asset.AssetType.STOCK, <span class="number">4000</span>)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"Total of all assets: "</span> + </span><br><span class="line">    totalAssetValues(assets, asset -&gt; <span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"Total of bonds: "</span> + </span><br><span class="line">    totalAssetValues(assets, asset -&gt; asset.getType() == AssetType.BOND));</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"Total of stocks: "</span> + </span><br><span class="line">    totalAssetValues(assets, asset -&gt; asset.getType() == AssetType.STOCK));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>個々まではメソッドレベルでの関心の分離を行いましたが、次はクラスレベルで応用します</li>
</ul>
<h3 id="4-2-ラムダ式を使った委譲"><a href="#4-2-ラムダ式を使った委譲" class="headerlink" title="4.2 ラムダ式を使った委譲"></a>4.2 ラムダ式を使った委譲</h3><h3 id="4-3-ラムダ式を使ったデコレーション"><a href="#4-3-ラムダ式を使ったデコレーション" class="headerlink" title="4.3 ラムダ式を使ったデコレーション"></a>4.3 ラムダ式を使ったデコレーション</h3><ul>
<li>Cameraクラスのフィルター設定</li>
</ul>
<h3 id="4-4-defaultメソッドを覗く"><a href="#4-4-defaultメソッドを覗く" class="headerlink" title="4.4 defaultメソッドを覗く"></a>4.4 defaultメソッドを覗く</h3><ul>
<li><p>interfaceがdefaultメソッドを持てる</p>
</li>
<li><p>実装の衝突を防ぐためにルールが存在する</p>
</li>
<li><p>実際にinterfaceにdefaultメソッドが記述できるメリットがあまり浮かばないような気がする</p>
</li>
</ul>
<h3 id="4-5-ラムダ式を使った流暢なインタフェース"><a href="#4-5-ラムダ式を使った流暢なインタフェース" class="headerlink" title="4.5 ラムダ式を使った流暢なインタフェース"></a>4.5 ラムダ式を使った流暢なインタフェース</h3><ul>
<li>MEMO: ここは参考になる実装だと感じた<ul>
<li>用途例：メーラの設定、データベース設定パラメータの設定、インスタンスの連続した状態を管理下におきつつ構築する必要のある場合</li>
<li>ローンパターンと言うらしい</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">FluentMailer</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> FluentMailer <span class="title">from</span><span class="params">(<span class="keyword">final</span> String address)</span> </span>&#123; <span class="comment">/*... */</span>; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> FluentMailer <span class="title">to</span><span class="params">(<span class="keyword">final</span> String address)</span>   </span>&#123; <span class="comment">/*... */</span>; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> FluentMailer <span class="title">subject</span><span class="params">(<span class="keyword">final</span> String line)</span> </span>&#123; <span class="comment">/*... */</span>; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> FluentMailer <span class="title">body</span><span class="params">(<span class="keyword">final</span> String message)</span> </span>&#123; <span class="comment">/*... */</span>; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">final</span> Consumer&lt;FluentMailer&gt; block)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> FluentMailer mailer = <span class="keyword">new</span> FluentMailer();</span><br><span class="line">  block.accept(mailer);</span><br><span class="line">  System.out.println(<span class="string">"sending..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</span><br><span class="line">  FluentMailer.send(mailer -&gt;</span><br><span class="line">    mailer.from(<span class="string">"build@agiledeveloper.com"</span>)</span><br><span class="line">          .to(<span class="string">"venkats@agiledeveloper.com"</span>)</span><br><span class="line">          .subject(<span class="string">"build notification"</span>)</span><br><span class="line">          .body(<span class="string">"...much better..."</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-6-例外処理"><a href="#4-6-例外処理" class="headerlink" title="4.6 例外処理"></a>4.6 例外処理</h3><ul>
<li>ラムダ式の例外処理について<ul>
<li>MEMO: 再読する必要あり</li>
</ul>
</li>
</ul>
<h3 id="4-7-まとめ"><a href="#4-7-まとめ" class="headerlink" title="4.7 まとめ"></a>4.7 まとめ</h3><h2 id="5章-外部リソースを扱う"><a href="#5章-外部リソースを扱う" class="headerlink" title="5章　外部リソースを扱う"></a>5章　外部リソースを扱う</h2><ul>
<li><p>Java仮想マシン（JVM）は、自動的にガベージコレクション（GC）を行っているものだと信じているかもしれません。</p>
</li>
<li><p>内部リソースだけを扱っている場合はJVMにGCを任せられることは事実</p>
</li>
<li><p>しかし、</p>
<ul>
<li>データベース接続</li>
<li>ファイルやソケット</li>
<li>ネイティブリソースといった外部リソースを使用する場合は<ul>
<li>GCは開発者の責任範囲</li>
</ul>
</li>
</ul>
</li>
<li><p>本章では、ラムダ式を使って、<code>execute around method(EAM)</code>を実装します。</p>
</li>
<li><p>連続操作をより効率的に制御できます。そしてこのパターンを使ってロック管理と書き込み例外テストを行います</p>
</li>
</ul>
<h3 id="5-1-リソースの解放"><a href="#5-1-リソースの解放" class="headerlink" title="5.1 リソースの解放"></a>5.1 リソースの解放</h3><ul>
<li>finalize()なんて使ったらGCされずに貯まるでしょ？</li>
<li>close()メソッドで閉じる？→閉じ忘れたらどうするの？→エラー発生したらclose()呼ばれないままになるよね？</li>
<li>try-with-resources構文使う？Java7から追加された便利な構文だけど、開発者が下記忘れたら元も子もない、AutoClosableの実装もしておかないと行けないでしょ？<ul>
<li>→ラムダ式で解決しましょう！という説明</li>
</ul>
</li>
</ul>
<h3 id="5-2-ラムダ式でリソース解放"><a href="#5-2-ラムダ式でリソース解放" class="headerlink" title="5.2 ラムダ式でリソース解放"></a>5.2 ラムダ式でリソース解放</h3><ul>
<li>ラムダ式で設計して、開発者にこれを使うように共有すれば問題なし</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileWriterEAM</span>  </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> FileWriter writer;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">FileWriterEAM</span><span class="params">(<span class="keyword">final</span> String fileName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    writer = <span class="keyword">new</span> FileWriter(fileName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"close called automatically..."</span>);</span><br><span class="line">    writer.close();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeStuff</span><span class="params">(<span class="keyword">final</span> String message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    writer.write(message);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">(<span class="keyword">final</span> String fileName,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> UseInstance&lt;FileWriterEAM, IOException&gt; block)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> FileWriterEAM writerEAM = <span class="keyword">new</span> FileWriterEAM(fileName);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      block.accept(writerEAM);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      writerEAM.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  </span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"START:EAM_USE_OUTPUT"</span>);</span><br><span class="line">    FileWriterEAM.use(<span class="string">"eam.txt"</span>, writerEAM -&gt; writerEAM.writeStuff(<span class="string">"sweet"</span>));</span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"END:EAM_USE_OUTPUT"</span>);</span><br><span class="line"></span><br><span class="line">    FileWriterEAM.use(<span class="string">"eam2.txt"</span>, writerEAM -&gt; &#123;</span><br><span class="line">        writerEAM.writeStuff(<span class="string">"how"</span>);</span><br><span class="line">        writerEAM.writeStuff(<span class="string">"sweet"</span>);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interface</span></span><br><span class="line"><span class="comment">// @FunctionalInterfaceは関数型インターフェースであることの宣言</span></span><br><span class="line"><span class="comment">// 例外を考慮する必要がなければ、Consumerインターフェースを使えばよかったが、ラムダ式は、合成されるabstratメソッドのシグネチャの一部として定義されたチェック例外を投げることができるため実装</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UseInstance</span>&lt;<span class="title">T</span>, <span class="title">X</span> <span class="keyword">extends</span> <span class="title">Throwable</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T instance)</span> <span class="keyword">throws</span> X</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>MEMO: <code>execute around method</code>パターンの構造らしい<ul>
<li>この仕組はファイル読み込みを行う際に見習うべき</li>
<li>そもそも標準のjavaでファイル読み込み時に自動的に開放するような書き方ができないか確認すべき</li>
<li>実際には読み込みファイルと書き込みファイル両方を開いて処理を行う場合が多いのでは？<ul>
<li>そのような場合どうやって書いていく？</li>
</ul>
</li>
<li>Transactionという形でUTIL作成して、複数ファイルをオープンして操作していけば行ける？</li>
</ul>
</li>
</ul>
<h3 id="5-3-ロックの管理"><a href="#5-3-ロックの管理" class="headerlink" title="5.3 ロックの管理"></a>5.3 ロックの管理</h3><ul>
<li>コンカレントなJavaアプリケーションにおいてロックは重要な役割を果たす</li>
<li>ここでは、ラムダ式を使って細かなロックの制御を行い、重要なセクションの適切なロックの単体テストの可能性を開く</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Locker</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runLocked</span><span class="params">(Lock lock, Runnable block)</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      block.run();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>MEMO: Lockの使い方確認 このロジックレベルでロックする使い所がいまいちピンとこない<ul>
<li>使い所があれば、synchronizedを使用するより、こちらの方が単体テストもしやすいメリットがあるみたい</li>
</ul>
</li>
</ul>
<h3 id="5-4-簡潔な例外テストの生成"><a href="#5-4-簡潔な例外テストの生成" class="headerlink" title="5.4 簡潔な例外テストの生成"></a>5.4 簡潔な例外テストの生成</h3><ul>
<li>Junitフレームワークなどでアノテーションを使用した、例外テストを実施する場合は、</li>
<li>ラムダ式で書き換えた方が良いという例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RodCutter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> mustFail;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RodCutter</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> fail)</span> </span>&#123; mustFail = fail; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrices</span><span class="params">(<span class="keyword">final</span> List&lt;Integer&gt; prices)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span>(mustFail) </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RodCutterException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> RodCutterException();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RodCutterTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> RodCutter rodCutter;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Integer&gt; prices;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> RodCutter <span class="title">createCutter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RodCutter(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Before</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rodCutter = createCutter();</span><br><span class="line">    prices = Arrays.asList(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">VerboseExceptionTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rodCutter.setPrices(prices);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      rodCutter.maxProfit(<span class="number">0</span>);</span><br><span class="line">      fail(<span class="string">"Expected exception for zero length"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(RodCutterException ex) &#123;</span><br><span class="line">      assertTrue(<span class="string">"expected"</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span>(expected = RodCutterException.class) </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TerseExceptionTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rodCutter.setPrices(prices);</span><br><span class="line">    rodCutter.maxProfit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Lamda式を利用したテスト方法</span></span><br><span class="line">  <span class="meta">@Test</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConciseExceptionTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rodCutter.setPrices(prices);</span><br><span class="line">    assertThrows(RodCutterException.class, () -&gt; rodCutter.maxProfit(<span class="number">0</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    junit.textui.TestRunner.run(<span class="keyword">new</span> JUnit4TestAdapter(RodCutterTest.class));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// HELPERの実装</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHelper</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;X extends Throwable&gt; <span class="function">Throwable <span class="title">assertThrows</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> Class&lt;X&gt; exceptionClass, <span class="keyword">final</span> Runnable block)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      block.run();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">if</span>(exceptionClass.isInstance(ex))</span><br><span class="line">        <span class="keyword">return</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    fail(<span class="string">"Failed to throw expected exception "</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>MEMO: 現在のフレームワークでラムダ式を利用したメソッドが提供されていないかどうか確認する</li>
</ul>
<h3 id="5-5-まとめ"><a href="#5-5-まとめ" class="headerlink" title="5.5 まとめ"></a>5.5 まとめ</h3><ul>
<li>アプリケーションが外部リソースを使用する場合、全面的に自動ガベージコレクションに頼ることはできません。</li>
<li><code>execute around method</code>パターンは実行フローのきめ細かい制御や外部リソースの開放に役立つ<ul>
<li>オブジェクト生存期間の制御</li>
<li>ロック管理</li>
<li>簡潔な例外テストの記述</li>
</ul>
</li>
</ul>
<h2 id="6章-「遅延させる」ということ"><a href="#6章-「遅延させる」ということ" class="headerlink" title="6章　「遅延させる」ということ"></a>6章　「遅延させる」ということ</h2><h3 id="6-1-初期化の遅延"><a href="#6-1-初期化の遅延" class="headerlink" title="6.1 初期化の遅延"></a>6.1 初期化の遅延</h3><ul>
<li>オブジェクト内部に重いリソースが存在する場合、その生成を後回しにできれば有益</li>
<li>オブジェクトの一部の生成をアトマwしにするという設計上の決断は、オブジェクトを使う開発者にとって重荷になるべきではなく、シームレスであるべき</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Supplier&lt;Heavy&gt; heavy = () -&gt; createAndCacheHeavy();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Holder created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Heavy <span class="title">getHeavy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> heavy.get();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> Heavy <span class="title">createAndCacheHeavy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">HeavyFactory</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Heavy</span>&gt; </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> Heavy heavyInstance = <span class="keyword">new</span> Heavy();</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Heavy <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> heavyInstance; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!HeavyFactory.class.isInstance(heavy)) &#123;</span><br><span class="line">      heavy = <span class="keyword">new</span> HeavyFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> heavy.get();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Holder holder = <span class="keyword">new</span> Holder();</span><br><span class="line">    System.out.println(<span class="string">"deferring heavy creation..."</span>);</span><br><span class="line">    System.out.println(holder.getHeavy());</span><br><span class="line">    System.out.println(holder.getHeavy());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>virtual poroxyパターン</li>
<li>オブジェクトの生成に１レベル挟む<br>次はラムダ式で実現する</li>
</ul>
<h3 id="6-2-遅延評価"><a href="#6-2-遅延評価" class="headerlink" title="6.2 遅延評価"></a>6.2 遅延評価</h3><ul>
<li><p>短絡評価： <code>fn1() || fn2()</code></p>
</li>
<li><p>メソッドの引数の場合は渡されたものすべてが評価される</p>
<ul>
<li>すべての引数を使用しない場合はその評価に費やした時間とリソースが無駄になる</li>
<li>ここでもラムダ式を使って任意の引数の評価を遅らせることができる</li>
</ul>
</li>
<li><p>メソッド実行時にある引数が使用されない可能性があることがわかっていれば、いくつかの引数、またはすべての引数を遅延実行するようにメソッドのインターフェースを変更できる</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Evaluation</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">evaluate</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"evaluating ..."</span> + value);</span><br><span class="line">    simulateTimeConsumingOp(<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">return</span> value &gt; <span class="number">100</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">simulateTimeConsumingOp</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> millseconds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">      Thread.sleep(<span class="number">2000</span>); </span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">eagerEvaluator</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">boolean</span> input1, <span class="keyword">final</span> <span class="keyword">boolean</span> input2)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"eagerEvaluator called..."</span>);</span><br><span class="line">    System.out.println(<span class="string">"accept?: "</span> + (input1 &amp;&amp; input2));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 遅延評価のためのメソッド</span></span><br><span class="line"><span class="comment">  * ラムダ式を引数に取り、実行自体はこのメソッドの中で行う</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lazyEvaluator</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> Supplier&lt;Boolean&gt; input1, <span class="keyword">final</span> Supplier&lt;Boolean&gt; input2)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"lazyEvaluator called..."</span>);</span><br><span class="line">    System.out.println(<span class="string">"accept?: "</span> + (input1.get() &amp;&amp; input2.get()));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"START:EAGER_OUTPUT"</span>);</span><br><span class="line">    eagerEvaluator(evaluate(<span class="number">1</span>), evaluate(<span class="number">2</span>));</span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"END:EAGER_OUTPUT"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ４秒かかっていた処理が２秒でfalseを返却するようになる</span></span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"START:LAZY_OUTPUT"</span>);</span><br><span class="line">    lazyEvaluator(() -&gt; evaluate(<span class="number">1</span>), () -&gt; evaluate(<span class="number">2</span>));</span><br><span class="line">    System.out.println(<span class="string">"//"</span> + <span class="string">"END:LAZY_OUTPUT"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>デメリット</p>
<ul>
<li>ラムダ式をわざわざ書かないと行けないので面倒（場合によってはメソッド参照を利用できる）</li>
<li>コード量は多くなる</li>
</ul>
</li>
<li><p>MEMO: フレームワークで遅延処理を行うためにはどのようにするべきか</p>
</li>
</ul>
<h3 id="6-3-Streamの遅延処理を活用"><a href="#6-3-Streamの遅延処理を活用" class="headerlink" title="6.3 Streamの遅延処理を活用"></a>6.3 Streamの遅延処理を活用</h3><ul>
<li>Streamの遅延評価について説明</li>
</ul>
<h4 id="6-3-1-中間処理と終端処理"><a href="#6-3-1-中間処理と終端処理" class="headerlink" title="6.3.1 中間処理と終端処理"></a>6.3.1 中間処理と終端処理</h4><ul>
<li><p>Streamには２種類のメソッドがある</p>
<ul>
<li>中間処理</li>
<li>終端処理</li>
</ul>
</li>
<li><p>Streamの遅さは複数の中間処理をチェーンし、最後に終端処理を行うことで実現している</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">"Brad"</span>, <span class="string">"Kate"</span>, <span class="string">"Kim"</span>, <span class="string">"Jack"</span>, <span class="string">"Joe"</span>,</span><br><span class="line">  <span class="string">"Mike"</span>, <span class="string">"Susan"</span>, <span class="string">"George"</span>, <span class="string">"Robert"</span>, <span class="string">"Julia"</span>, <span class="string">"Parker"</span>, <span class="string">"Benson"</span>);</span><br><span class="line">System.out.println(<span class="string">"//"</span> + <span class="string">"START:CHAIN_OUTPUT"</span>);</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ここの処理はコレクションの変換に多くの作業を費やしている働き者に見えますが、実は見かけによらず怠け者です。</span></span><br><span class="line"><span class="keyword">final</span> String firstNameWith3Letters = </span><br><span class="line">  names.stream()</span><br><span class="line">        .filter(name -&gt; length(name) == <span class="number">3</span>)</span><br><span class="line">        .map(name -&gt; toUpper(name))</span><br><span class="line">        .findFirst()</span><br><span class="line">        .get();</span><br><span class="line"></span><br><span class="line">System.out.println(firstNameWith3Letters);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"//"</span> + <span class="string">"END:CHAIN_OUTPUT"</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>本当に必要な処理以外は実施していないらしい</p>
</li>
<li><p>その詳細を次で！述べる</p>
</li>
<li><p>中間処理、終端処理まで考慮された上で、初めて処理が実行される</p>
<ul>
<li>filter 12処理<ul>
<li>map 2処理<ul>
<li>findFirst 1処理</li>
</ul>
</li>
</ul>
</li>
<li>ではなく！</li>
<li>filter 3 処理！！<ul>
<li>map 1処理<ul>
<li>findFirst 1処理</li>
</ul>
</li>
</ul>
</li>
<li>という形で評価される</li>
</ul>
</li>
<li><p>JDKが裏で結合（fusing）処理を行うことで実現している</p>
</li>
<li><p>データの通り道は１本ということ</p>
</li>
<li><p>要素の抽出、マッピング、選択が１度に行われる</p>
</li>
</ul>
<h3 id="6-4-無限の「遅い」コレクションを生成"><a href="#6-4-無限の「遅い」コレクションを生成" class="headerlink" title="6.4 無限の「遅い」コレクションを生成"></a>6.4 無限の「遅い」コレクションを生成</h3><ul>
<li>MEMO: スキップ</li>
</ul>
<h3 id="6-5-まとめ"><a href="#6-5-まとめ" class="headerlink" title="6.5 まとめ"></a>6.5 まとめ</h3><h2 id="7章-再帰の最適化"><a href="#7章-再帰の最適化" class="headerlink" title="7章　再帰の最適化"></a>7章　再帰の最適化</h2><ul>
<li><p>再帰は魅力的で強力な問題解決方法</p>
</li>
<li><p>再帰はとても表現力に富んでいます</p>
</li>
<li><p>大きな問題の再帰処理を可能とする末尾呼び出し最適化（tail-call optimization TCO）を説明</p>
</li>
</ul>
<h3 id="7-1-末尾呼び出し最適化を使う"><a href="#7-1-末尾呼び出し最適化を使う" class="headerlink" title="7.1 末尾呼び出し最適化を使う"></a>7.1 末尾呼び出し最適化を使う</h3><ul>
<li><p>再帰を使う上で最も高いハードルは、巨大な入力値によるスタックオーバーフローのリスク</p>
</li>
<li><p>しかし、末尾呼び出し最適化（TCO）という優れたテクニックがこの心配のタネを取り除く</p>
</li>
<li><p>末尾呼び出しとは</p>
<ul>
<li>最後の処理が自身の呼び出しとなるような再帰呼び出しのことを言います</li>
</ul>
</li>
<li><p>JavaはTCOをコンパイラレベルで直接サポートしていませんが、ラムダ式を使って数行で実装できる</p>
</li>
<li><p>このソリューションはトランポリンとも呼ばれrます。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通常の実装</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">factorialRec</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(number == <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span> number;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> number * factorialRec(number - <span class="number">1</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 大きい数を渡すとStackOverflowErrorが発生</span></span><br></pre></td></tr></table></figure>

<ul>
<li>この再帰関数は大きな入力値を扱えず、落ちてしまう</li>
<li>再帰が強力で表現力豊かであっても使えません。</li>
<li>この問題は再帰そのものにあるわけではない</li>
<li>再帰の完了を待つ間、部分的な計算結果をすべて保存しているためです。</li>
<li>スタックに積み上げずに再帰を行う方法が必要</li>
</ul>
<h4 id="7-1-2-末尾再帰に変換する"><a href="#7-1-2-末尾再帰に変換する" class="headerlink" title="7.1.2 末尾再帰に変換する"></a>7.1.2 末尾再帰に変換する</h4><ul>
<li>遅延評価させるために<ul>
<li>TailCall関数型インターフェース</li>
<li>TailCallsクラスを設計する</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TailCall&lt;Integer&gt; <span class="title">factorialTailRec</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">final</span> <span class="keyword">int</span> factorial, <span class="keyword">final</span> <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (number == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> done(factorial);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> call(() -&gt; factorialTailRec(factorial * number, number - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>MEMO: TCOについて理解できていない… 再帰処理設計が必要になったら読み返す</li>
</ul>
<h3 id="7-2-メモ化でスピードアップ"><a href="#7-2-メモ化でスピードアップ" class="headerlink" title="7.2 メモ化でスピードアップ"></a>7.2 メモ化でスピードアップ</h3><h3 id="7-3-まとめ"><a href="#7-3-まとめ" class="headerlink" title="7.3 まとめ"></a>7.3 まとめ</h3><h2 id="8章-ラムダ式で合成"><a href="#8章-ラムダ式で合成" class="headerlink" title="8章　ラムダ式で合成"></a>8章　ラムダ式で合成</h2><ul>
<li><p>Java8には、オブジェクト志向アプローチと関数型スタイルという２つの強力なツールがある</p>
</li>
<li><p>組み合わせて使っていこう！</p>
</li>
<li><p>本章では、</p>
<ul>
<li>関数合成を詳しく説明し、実践的なMapReduceパターンを例として実装</li>
<li>MapReduceパターンでは、独立した計算処理を分散し、それらの処理結果を集約して最終的な結果を計算します</li>
<li>最後はJDKの力を借りて、この計算処理を簡単に並列化します。</li>
</ul>
</li>
</ul>
<h3 id="8-1-関数合成の利用"><a href="#8-1-関数合成の利用" class="headerlink" title="8.1 関数合成の利用"></a>8.1 関数合成の利用</h3><ul>
<li><p>オブジェクト指向＋関数型スタイル複合アプローチでは、状態が変化するのではなく、軽量なオブジェクトが別のオブジェクトに変換される</p>
</li>
<li><p>可変性がないことで、エラー発生の可能性を減らし、並列実行家より簡単</p>
</li>
<li><p>リストからStreamを作成し、オリジナルのリストは変更されず、新しくオブジェクトを生成するということが言いたいだけ</p>
</li>
</ul>
<h3 id="8-2-MapReduceの使用"><a href="#8-2-MapReduceの使用" class="headerlink" title="8.2 MapReduceの使用"></a>8.2 MapReduceの使用</h3><ul>
<li><p>MapReduceパターンは２つの操作がある</p>
<ul>
<li>コレクションの各要素で実行する操作</li>
<li>これらの実行結果を組み合わせて最終結果を導き出す</li>
</ul>
</li>
<li><p>このパターンでマルチコアプロセッサを有効活用可能であることから注目をされつつある</p>
</li>
<li><p><code>Tickers.symbols.parallelStream()</code>は裏側に隠れているスレッドプールで管理された複数のスレッドで、</p>
</li>
<li><p>map()やfilter()のようなメソッドを並列処理します。</p>
</li>
<li><p>stream()とparallelStream()のどちらを使用するかを決める際には、いくつかの問題を考えなければいけません</p>
<ul>
<li>本当にラムダ式を同時に実行したいのか？</li>
<li>対象コードは副作用や競合状態が発生しない、独立した動作を行える？</li>
<li>実行順序に影響を与えることはないか？</li>
</ul>
</li>
<li><p>map()やfilter()のように、計算を行って、その結果を次の処理に回すようなメソッドは並列化に向いている</p>
</li>
<li><p>MEMO: 闇雲に並列化はしないほうがよい！！</p>
</li>
<li><p>並列ストリームを選択すべきか？</p>
<ul>
<li>ライブラリは簡単に並列化を行ってくれるが、並列化が常に正しい選択であるとは限らない</li>
<li>データと、実行する計算内容によっては、並列計算はシーケンシャルな計算より遅くなることもあり得る</li>
<li>並列化実行処理のためのコストもかかる</li>
<li>コレクションが小さいのであれば、シーケンシャル実行のほうが早くなるかも</li>
<li>速度を計測して実装していくべき</li>
</ul>
</li>
</ul>
<h3 id="8-3-並列化への飛躍"><a href="#8-3-並列化への飛躍" class="headerlink" title="8.3 並列化への飛躍"></a>8.3 並列化への飛躍</h3><h3 id="8-4-まとめ"><a href="#8-4-まとめ" class="headerlink" title="8.4 まとめ"></a>8.4 まとめ</h3><h2 id="9章-すべてをまとめて"><a href="#9章-すべてをまとめて" class="headerlink" title="9章　すべてをまとめて"></a>9章　すべてをまとめて</h2><ul>
<li>本書を通してJava8のラムダ式を紹介しました</li>
<li>コレクションのイテレーションを行い</li>
<li>軽量でよりよい設計を実現し、コードを簡単に合成、そして並列化しました。</li>
<li>この最終章ではまとめとして、関数型スタイルのプログラミングを使って、最大の効果を上げるために</li>
<li>磨いておくべきことを説明し、関数型スタイルを採用して成功するための推奨事項を最後に取り上げる</li>
</ul>
<h3 id="9-1-関数型スタイルで成功するために実践すべきこと"><a href="#9-1-関数型スタイルで成功するために実践すべきこと" class="headerlink" title="9.1 関数型スタイルで成功するために実践すべきこと"></a>9.1 関数型スタイルで成功するために実践すべきこと</h3><p>新機能のメリットを十分に活かし、簡潔で軽量なアプリケーションを生成するには、設計、コーディング、そして考え方まで変えなければいけません。</p>
<p>これまでのJavaを使ってきた命令形や、オブジェクト指向のパラダイムとは違うもの</p>
<p>ここでは根本的に変えるべきアプリケーション開発手法や、その変更によって得られる利点について説明</p>
<h4 id="9-1-1-宣言的により近く、命令型からより遠く"><a href="#9-1-1-宣言的により近く、命令型からより遠く" class="headerlink" title="9.1.1 宣言的により近く、命令型からより遠く"></a>9.1.1 宣言的により近く、命令型からより遠く</h4><ul>
<li>価格リストを与えられていて、その中から最大値を選ぶようにと依頼されたとしたときに、</li>
<li>命令型のfor文で最大値を探すのではなく、ラムダ式を使ってstream経由で取得する</li>
</ul>
<h4 id="9-1-2-普遍性の尊重"><a href="#9-1-2-普遍性の尊重" class="headerlink" title="9.1.2 普遍性の尊重"></a>9.1.2 普遍性の尊重</h4><ul>
<li>状態変更が可能な(mutable)変数はあまり上品とは言えません。</li>
<li>そしてそのような変数の共有は単なる害悪</li>
<li>開発者は変数の状態変更によって混乱させられてしまい、時には変更を見逃してしまいます。</li>
<li>したがって、変更可能な変数が多いほど、より多くのエラーが発生する可能性があるということ</li>
<li>正確な並列化が非常に難しくなるということもデメリット</li>
<li>関数型スタイルの導入がそれを簡単にしてくれる</li>
<li>純粋な関数型言語は値しか持っていません。つまり１回しか書き込みができない、初期化後は全く変更を受け付けない変数です。</li>
<li>しかしJavaはそのような言語とはことなり、不変性(immutability)を強制しないため、不変性を尊重する責任は開発者にある</li>
</ul>
<h4 id="9-1-3-副作用の削減"><a href="#9-1-3-副作用の削減" class="headerlink" title="9.1.3 副作用の削減"></a>9.1.3 副作用の削減</h4><ul>
<li>副作用を減らそう</li>
<li>所感：時間や状態などの外部要員によって関数の処理結果が異なることが無いように作成すること</li>
</ul>
<h4 id="9-1-4-文より式を優先"><a href="#9-1-4-文より式を優先" class="headerlink" title="9.1.4 文より式を優先"></a>9.1.4 文より式を優先</h4><ul>
<li><p>文：アクションを実行するが何も返さない</p>
</li>
<li><p>式：アクションを実行して結果を返す</p>
</li>
<li><p>文は何も返さないため、目的を遂行するためには副作用を起こしメモリを書き換える必要がある</p>
</li>
<li><p>一方式は、参照透明性を保つように設計できるため、これまでに述べたメリットを得られる</p>
</li>
<li><p>式を使うメリット</p>
<ul>
<li>関数合成ができるということが挙げられる</li>
<li>チェーンでコードを記述することで、文章を読むように簡単にコードを読めるようになる</li>
</ul>
</li>
</ul>
<h4 id="9-1-5-高階関数を利用して設計"><a href="#9-1-5-高階関数を利用して設計" class="headerlink" title="9.1.5 高階関数を利用して設計"></a>9.1.5 高階関数を利用して設計</h4><ul>
<li><p>これまでは匿名内部クラスを単一メソッドのインターフェースに渡していたような場所で、</p>
</li>
<li><p>ラムダ式やメソッド参照を渡すことができる様になり、コードがより簡潔になります。</p>
</li>
<li><p>メーラーを関数で設計することでローンパターンを適用する例</p>
</li>
<li><p>Colorフィルターを関数で表現する例</p>
</li>
<li><p>関数を引数に渡してDRYな設計をしよう</p>
</li>
</ul>
<h3 id="9-2-パフォーマンスの問題"><a href="#9-2-パフォーマンスの問題" class="headerlink" title="9.2 パフォーマンスの問題"></a>9.2 パフォーマンスの問題</h3><ul>
<li><p>命令型のコードと比較してもパフォーマンスは劣らない</p>
<ul>
<li>メリット<ul>
<li>直感的に見やすい</li>
<li>並列化も容易</li>
</ul>
</li>
</ul>
</li>
<li><p>関数型を採用しましょう</p>
</li>
<li><p>MEMO: 処理時間の違いはむやみに信頼できるものではないのでやめましょうと書かれている…</p>
</li>
</ul>
<h3 id="9-3-関数型スタイルを採用"><a href="#9-3-関数型スタイルを採用" class="headerlink" title="9.3 関数型スタイルを採用"></a>9.3 関数型スタイルを採用</h3><ul>
<li>実際に使ってみて、試して、より良い設計を考えていこう！</li>
</ul>
<h2 id="付録A-基本的な関数型インタフェース"><a href="#付録A-基本的な関数型インタフェース" class="headerlink" title="付録A 基本的な関数型インタフェース"></a>付録A 基本的な関数型インタフェース</h2><ul>
<li>JDK8には様々な関数型インターフェースを持っている</li>
<li>ここでは頻繁に出現する基本的なインターフェースをいくつか紹介</li>
</ul>
<h3 id="A-1-Consumer"><a href="#A-1-Consumer" class="headerlink" title="A.1 Consumer"></a>A.1 Consumer<T></h3><ul>
<li><p>入力を受け入れ、戻り値を返さない操作を表すインターフェース</p>
</li>
<li><p>有効活用するためには副作用を伴う必要がある</p>
</li>
<li><p>抽象メソッド</p>
<ul>
<li>accept()</li>
</ul>
</li>
<li><p>defaultメソッド</p>
<ul>
<li>andThen()</li>
</ul>
</li>
<li><p>主な利用方法</p>
<ul>
<li>forEach()メソッドの引数</li>
</ul>
</li>
<li><p>特注なプリミティブ</p>
<ul>
<li>IntConsumer, LongConsumer, DoubleConsumerなど</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java8sample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8Sample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Consumer&lt;String&gt; hoge = string -&gt; System.out.println(<span class="string">"hoge : "</span> + string);</span><br><span class="line">        Consumer&lt;String&gt; fuga = string -&gt; System.out.println(<span class="string">"fuga : "</span> + string);</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; piyo = hoge.andThen(fuga);</span><br><span class="line"></span><br><span class="line">        piyo.accept(<span class="string">"piyo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="A-2-Supplier"><a href="#A-2-Supplier" class="headerlink" title="A.2 Supplier"></a>A.2 Supplier<T></h3><ul>
<li><p>新しいインスタンス、またはあらかじめ生成しておいたインスタンスを返すファクトリ。</p>
</li>
<li><p>抽象メソッド</p>
<ul>
<li>get()</li>
</ul>
</li>
<li><p>defaultメソッド</p>
<ul>
<li>なし</li>
</ul>
</li>
<li><p>主な利用方法</p>
<ul>
<li>遅延実行を行う無限Streamの生成</li>
<li>OptionalクラスのorElseGet()メソッドの引数</li>
</ul>
</li>
<li><p>特殊なプリミティブ</p>
<ul>
<li>IntSupplier, LongSupplier, DoubleSupplierなど</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java8sample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8Sample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Supplier&lt;String&gt; supplier = () -&gt; <span class="string">"hoge"</span>;</span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>遅延初期化で少し出てきた程度</li>
</ul>
<h3 id="A-3-Predicate"><a href="#A-3-Predicate" class="headerlink" title="A.3 Predicate"></a>A.3 Predicate<T></h3><ul>
<li><p>入力値が何らかの条件に該当するかを確認するために有効。</p>
</li>
<li><p>抽象メソッド</p>
<ul>
<li>test()</li>
</ul>
</li>
<li><p>defaultメソッド</p>
<ul>
<li>and(), nagate(), or()</li>
</ul>
</li>
<li><p>主な利用方法</p>
<ul>
<li>Streamのfilter()やanyMatch()メソッドなどの引数</li>
</ul>
</li>
<li><p>特殊なプリミティブ</p>
<ul>
<li>IntPredicate, LongPredicate, DoublePredicateなど</li>
</ul>
</li>
<li><p>anyMatchはリストのStreamのうちどれか１つでも一致する条件であればtrueを返却する動きになるみたい</p>
<ul>
<li>→終端操作</li>
</ul>
</li>
<li><p>filterは中間操作</p>
</li>
</ul>
<h3 id="A-4-Function-lt-T-R-gt"><a href="#A-4-Function-lt-T-R-gt" class="headerlink" title="A.4 Function&lt;T, R&gt;"></a>A.4 Function&lt;T, R&gt;</h3><ul>
<li><p>引数をとって適切な結果値を返す操作を表す変換インターフェース</p>
</li>
<li><p>抽象メソッド</p>
<ul>
<li>apply()</li>
</ul>
</li>
<li><p>defaultメソッド</p>
<ul>
<li>andThen(), compose()</li>
</ul>
</li>
<li><p>主な利用方法</p>
<ul>
<li>Streamのmap()メソッドの引数</li>
</ul>
</li>
<li><p>特殊なプリミティブ</p>
<ul>
<li>IntFunction、LongFunction, DoubleFunction, IntToDoubleFunction, DoubleToIntFunction</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java8sample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8Sample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Function&lt;String, String&gt; wrapDoubleQuotation = str -&gt; <span class="string">"\""</span> + str + <span class="string">"\""</span>;</span><br><span class="line">        Function&lt;String, String&gt; wrapSingleQuotation = str -&gt; <span class="string">"'"</span> + str + <span class="string">"'"</span>;</span><br><span class="line"></span><br><span class="line">        Function&lt;String, String&gt; wrapDoubleAndSingleQuotation = wrapDoubleQuotation.compose(wrapSingleQuotation);</span><br><span class="line">        String result = wrapDoubleAndSingleQuotation.apply(<span class="string">"hoge"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="付録B-構文の基礎"><a href="#付録B-構文の基礎" class="headerlink" title="付録B 構文の基礎"></a>付録B 構文の基礎</h2><ul>
<li>関数型インターフェスのクイック・リファレンス</li>
</ul>
<h3 id="B-1-関数型インタフェースの定義"><a href="#B-1-関数型インタフェースの定義" class="headerlink" title="B.1 関数型インタフェースの定義"></a>B.1 関数型インタフェースの定義</h3><ul>
<li>関数型インターフェース<ul>
<li>interface実装して、<code>@FunctionalInterface</code>を付与する</li>
<li>実装されていないabstractメソッドを必ず１つ持つ</li>
<li>必要に応じて実装されたdefaultメソッドを持つ</li>
<li>staticメソッドも持つことができる</li>
</ul>
</li>
</ul>
<h3 id="B-2-パラメータを持たないラムダ式の生成"><a href="#B-2-パラメータを持たないラムダ式の生成" class="headerlink" title="B.2 パラメータを持たないラムダ式の生成"></a>B.2 パラメータを持たないラムダ式の生成</h3><h3 id="B-3-パラメータ-1つのラムダ式の生成"><a href="#B-3-パラメータ-1つのラムダ式の生成" class="headerlink" title="B.3 パラメータ 1つのラムダ式の生成"></a>B.3 パラメータ 1つのラムダ式の生成</h3><p>型推論は効くが、明示した場合は <code>(final String str) -&gt; System.out.println(str);</code>などとする</p>
<h3 id="B-4-ラムダ式のパラメータ型を推論する"><a href="#B-4-ラムダ式のパラメータ型を推論する" class="headerlink" title="B.4 ラムダ式のパラメータ型を推論する"></a>B.4 ラムダ式のパラメータ型を推論する</h3><ul>
<li>通常、型推論されるが、１つでも型を明示的に記載する必要がある場合、</li>
<li>すべて引数の型を記載する必要がある</li>
</ul>
<h3 id="B-5-パラメータ-1つのラムダ式では括弧を省略可能"><a href="#B-5-パラメータ-1つのラムダ式では括弧を省略可能" class="headerlink" title="B.5 パラメータ 1つのラムダ式では括弧を省略可能"></a>B.5 パラメータ 1つのラムダ式では括弧を省略可能</h3><ul>
<li><code>(name) -&gt; ;</code>とかいても <code>name -&gt; ;</code>とかいてもよい</li>
</ul>
<h3 id="B-6-複数パラメータを持つラムダ式の生成"><a href="#B-6-複数パラメータを持つラムダ式の生成" class="headerlink" title="B.6 複数パラメータを持つラムダ式の生成"></a>B.6 複数パラメータを持つラムダ式の生成</h3><ul>
<li>複数のパラメータを持つ場合はカッコが必須 <code>frinends.stream().reduce((name1,name2) -&gt; name1.length() &gt;= name2.length() ? name1 : name2);</code></li>
</ul>
<h3 id="B-7-複数の型のパラメータを持つメソッドを呼び出す"><a href="#B-7-複数の型のパラメータを持つメソッドを呼び出す" class="headerlink" title="B.7 複数の型のパラメータを持つメソッドを呼び出す"></a>B.7 複数の型のパラメータを持つメソッドを呼び出す</h3><ul>
<li>ラムダ式やメソッド参照を引数に渡せる</li>
</ul>
<h3 id="B-8-ラムダ式を変数に格納"><a href="#B-8-ラムダ式を変数に格納" class="headerlink" title="B.8 ラムダ式を変数に格納"></a>B.8 ラムダ式を変数に格納</h3><ul>
<li>再利用するためにラムダ式を変数に格納できる</li>
</ul>
<h3 id="B-9-複数行のラムダ式を生成"><a href="#B-9-複数行のラムダ式を生成" class="headerlink" title="B.9 複数行のラムダ式を生成"></a>B.9 複数行のラムダ式を生成</h3><ul>
<li>ラムダ式は複数行に渡って記載できる</li>
<li>必要に応じて、return文を記載しないといけない</li>
</ul>
<h3 id="B-10-ラムダ式を返す"><a href="#B-10-ラムダ式を返す" class="headerlink" title="B.10 ラムダ式を返す"></a>B.10 ラムダ式を返す</h3><ul>
<li>メソッドの戻り値型として関数型インタフェースを指定できる</li>
</ul>
<h3 id="B-11-ラムダ式からラムダ式を返す"><a href="#B-11-ラムダ式からラムダ式を返す" class="headerlink" title="B.11 ラムダ式からラムダ式を返す"></a>B.11 ラムダ式からラムダ式を返す</h3><ul>
<li>ラムダ式を返すラムダ式をかける</li>
</ul>
<h3 id="B-12-クロージャにおける静的スコープ"><a href="#B-12-クロージャにおける静的スコープ" class="headerlink" title="B.12 クロージャにおける静的スコープ"></a>B.12 クロージャにおける静的スコープ</h3><h3 id="B-13-インスタンスメソッドのメソッド参照を渡す"><a href="#B-13-インスタンスメソッドのメソッド参照を渡す" class="headerlink" title="B.13 インスタンスメソッドのメソッド参照を渡す"></a>B.13 インスタンスメソッドのメソッド参照を渡す</h3><h3 id="B-14-メソッド参照をstaticメソッドに渡す"><a href="#B-14-メソッド参照をstaticメソッドに渡す" class="headerlink" title="B.14 メソッド参照をstaticメソッドに渡す"></a>B.14 メソッド参照をstaticメソッドに渡す</h3><h3 id="B-15-メソッド参照を他のインスタンスのメソッドに渡す"><a href="#B-15-メソッド参照を他のインスタンスのメソッドに渡す" class="headerlink" title="B.15 メソッド参照を他のインスタンスのメソッドに渡す"></a>B.15 メソッド参照を他のインスタンスのメソッドに渡す</h3><h3 id="B-16-複数の引数を取るメソッドの参照を渡す"><a href="#B-16-複数の引数を取るメソッドの参照を渡す" class="headerlink" title="B.16 複数の引数を取るメソッドの参照を渡す"></a>B.16 複数の引数を取るメソッドの参照を渡す</h3><h3 id="B-17-コンストラクタ参照を使う"><a href="#B-17-コンストラクタ参照を使う" class="headerlink" title="B.17 コンストラクタ参照を使う"></a>B.17 コンストラクタ参照を使う</h3><h3 id="B-18-関数合成"><a href="#B-18-関数合成" class="headerlink" title="B.18 関数合成"></a>B.18 関数合成</h3><h2 id="付録C-Web上のリソース"><a href="#付録C-Web上のリソース" class="headerlink" title="付録C Web上のリソース"></a>付録C Web上のリソース</h2><ul>
<li><p>Cutting Stock問題</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Cutting_stock_problem">https://en.wikipedia.org/wiki/Cutting_stock_problem</a></li>
<li>メモ化テクニックを使って解決できる最適化問題</li>
</ul>
</li>
<li><p>依存関係逆転の原則</p>
<ul>
<li>クラスの実装で拡張するのではなく、抽象（インタフェース）とカップリングすることによる拡張方法を説明している</li>
</ul>
</li>
<li><p>DRY原則</p>
<ul>
<li><a href="https://ja.wikipedia.org/wiki/Don%27t_repeat_yourself">https://ja.wikipedia.org/wiki/Don%27t_repeat_yourself</a></li>
</ul>
</li>
<li><p>本質と儀式について（Essence vs. Ceremony）</p>
<ul>
<li>→古いからやめようと思う</li>
</ul>
</li>
<li><p>Execute Around Methodパターン</p>
</li>
<li><p>ローンパターン(Loan Pattern)</p>
<ul>
<li>Scalaにおけるローンパターンの紹介</li>
<li>記事がなかった<ul>
<li><a href="https://docs.scala-lang.org/">https://docs.scala-lang.org/</a></li>
</ul>
</li>
</ul>
</li>
<li><p>伝えろ。聞くな。</p>
<ul>
<li><a href="https://pragprog.com/articles/tell-dont-asks">https://pragprog.com/articles/tell-dont-asks</a></li>
<li>伝えろ、聞くなという原則を説明するコラム</li>
</ul>
</li>
<li><p>書籍サイト</p>
<ul>
<li><a href="https://pragprog.com/">https://pragprog.com/</a></li>
</ul>
</li>
</ul>
<h2 id="付録D-参考文献"><a href="#付録D-参考文献" class="headerlink" title="付録D 参考文献"></a>付録D 参考文献</h2><h2 id="訳者あとがき"><a href="#訳者あとがき" class="headerlink" title="訳者あとがき"></a>訳者あとがき</h2><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2>
        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最終更新：<time datetime="2020-04-29T15:07:44.045Z" itemprop="dateUpdated">2020-04-30 00:07:44</time>
</span><br>


        
        thank you for your reading my article!!
        
    </div>
    
    <footer>
        <a href="http://yoursite.com">
            <img src="https://tutttuwi.github.io/output-over-there/img/avatar.png" alt="t-tsutsui">
            t-tsutsui
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            

            


        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between flex-row-reverse">
  

  
    <div class="waves-block waves-effect next">
      <a href="https://tutttuwi.github.io/output-over-there/AWS/Cloud/%E8%B3%87%E6%A0%BC/2023-06_AWS_SolutionArchitectSpecialist_%E5%8F%97%E9%A8%93%E5%AF%BE%E7%AD%96%E3%83%A1%E3%83%A2/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">AWS_SolutionArchitectSpecialist_受験対策まとめ</h4>
      </a>
    </div>
  
</nav>



    

















</article>



</div>

        <footer class="footer">
    <div class="top">
<!--        

        <p>
            
                <span><a href="https://tutttuwi.github.io/output-over-there/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>このブログの内容物は<a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.ja">クリエイティブ・コモンズ 表示 - 非営利 - 継承 4.0 国際ライセンスの下に提供されています</a></span>
        </p> -->
    </div>
    <div class="bottom">
        <p><span>t-tsutsui &copy; 2015 - 2023</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>


    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: 'https://tutttuwi.github.io/output-over-there/', SHARE: false, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>










</body>
</html>
